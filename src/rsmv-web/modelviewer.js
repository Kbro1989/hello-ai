var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// node_modules/sharp/lib/is.js
var require_is = __commonJS({
  "node_modules/sharp/lib/is.js"(exports, module) {
    "use strict";
    var defined = function(val) {
      return typeof val !== "undefined" && val !== null;
    };
    var object = function(val) {
      return typeof val === "object";
    };
    var plainObject = function(val) {
      return Object.prototype.toString.call(val) === "[object Object]";
    };
    var fn = function(val) {
      return typeof val === "function";
    };
    var bool = function(val) {
      return typeof val === "boolean";
    };
    var buffer = function(val) {
      return val instanceof Buffer;
    };
    var typedArray = function(val) {
      if (defined(val)) {
        switch (val.constructor) {
          case Uint8Array:
          case Uint8ClampedArray:
          case Int8Array:
          case Uint16Array:
          case Int16Array:
          case Uint32Array:
          case Int32Array:
          case Float32Array:
          case Float64Array:
            return true;
        }
      }
      return false;
    };
    var arrayBuffer = function(val) {
      return val instanceof ArrayBuffer;
    };
    var string3 = function(val) {
      return typeof val === "string" && val.length > 0;
    };
    var number3 = function(val) {
      return typeof val === "number" && !Number.isNaN(val);
    };
    var integer = function(val) {
      return Number.isInteger(val);
    };
    var inRange = function(val, min, max) {
      return val >= min && val <= max;
    };
    var inArray = function(val, list) {
      return list.includes(val);
    };
    var invalidParameterError = function(name, expected, actual) {
      return new Error(
        `Expected ${expected} for ${name} but received ${actual} of type ${typeof actual}`
      );
    };
    var nativeError = function(native, context) {
      context.message = native.message;
      return context;
    };
    module.exports = {
      defined,
      object,
      plainObject,
      fn,
      bool,
      buffer,
      typedArray,
      arrayBuffer,
      string: string3,
      number: number3,
      integer,
      inRange,
      inArray,
      invalidParameterError,
      nativeError
    };
  }
});

// node_modules/detect-libc/lib/process.js
var require_process = __commonJS({
  "node_modules/detect-libc/lib/process.js"(exports, module) {
    "use strict";
    var isLinux = () => process.platform === "linux";
    var report = null;
    var getReport = () => {
      if (!report) {
        if (isLinux() && process.report) {
          const orig = process.report.excludeNetwork;
          process.report.excludeNetwork = true;
          report = process.report.getReport();
          process.report.excludeNetwork = orig;
        } else {
          report = {};
        }
      }
      return report;
    };
    module.exports = { isLinux, getReport };
  }
});

// node_modules/detect-libc/lib/filesystem.js
var require_filesystem = __commonJS({
  "node_modules/detect-libc/lib/filesystem.js"(exports, module) {
    "use strict";
    var fs7 = __require("fs");
    var LDD_PATH = "/usr/bin/ldd";
    var SELF_PATH = "/proc/self/exe";
    var MAX_LENGTH = 2048;
    var readFileSync = (path7) => {
      const fd = fs7.openSync(path7, "r");
      const buffer = Buffer.alloc(MAX_LENGTH);
      const bytesRead = fs7.readSync(fd, buffer, 0, MAX_LENGTH, 0);
      fs7.close(fd, () => {
      });
      return buffer.subarray(0, bytesRead);
    };
    var readFile2 = (path7) => new Promise((resolve3, reject) => {
      fs7.open(path7, "r", (err, fd) => {
        if (err) {
          reject(err);
        } else {
          const buffer = Buffer.alloc(MAX_LENGTH);
          fs7.read(fd, buffer, 0, MAX_LENGTH, 0, (_, bytesRead) => {
            resolve3(buffer.subarray(0, bytesRead));
            fs7.close(fd, () => {
            });
          });
        }
      });
    });
    module.exports = {
      LDD_PATH,
      SELF_PATH,
      readFileSync,
      readFile: readFile2
    };
  }
});

// node_modules/detect-libc/lib/elf.js
var require_elf = __commonJS({
  "node_modules/detect-libc/lib/elf.js"(exports, module) {
    "use strict";
    var interpreterPath = (elf) => {
      if (elf.length < 64) {
        return null;
      }
      if (elf.readUInt32BE(0) !== 2135247942) {
        return null;
      }
      if (elf.readUInt8(4) !== 2) {
        return null;
      }
      if (elf.readUInt8(5) !== 1) {
        return null;
      }
      const offset = elf.readUInt32LE(32);
      const size = elf.readUInt16LE(54);
      const count = elf.readUInt16LE(56);
      for (let i = 0; i < count; i++) {
        const headerOffset = offset + i * size;
        const type = elf.readUInt32LE(headerOffset);
        if (type === 3) {
          const fileOffset = elf.readUInt32LE(headerOffset + 8);
          const fileSize = elf.readUInt32LE(headerOffset + 32);
          return elf.subarray(fileOffset, fileOffset + fileSize).toString().replace(/\0.*$/g, "");
        }
      }
      return null;
    };
    module.exports = {
      interpreterPath
    };
  }
});

// node_modules/detect-libc/lib/detect-libc.js
var require_detect_libc = __commonJS({
  "node_modules/detect-libc/lib/detect-libc.js"(exports, module) {
    "use strict";
    var childProcess = __require("child_process");
    var { isLinux, getReport } = require_process();
    var { LDD_PATH, SELF_PATH, readFile: readFile2, readFileSync } = require_filesystem();
    var { interpreterPath } = require_elf();
    var cachedFamilyInterpreter;
    var cachedFamilyFilesystem;
    var cachedVersionFilesystem;
    var command2 = "getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true";
    var commandOut = "";
    var safeCommand = () => {
      if (!commandOut) {
        return new Promise((resolve3) => {
          childProcess.exec(command2, (err, out) => {
            commandOut = err ? " " : out;
            resolve3(commandOut);
          });
        });
      }
      return commandOut;
    };
    var safeCommandSync = () => {
      if (!commandOut) {
        try {
          commandOut = childProcess.execSync(command2, { encoding: "utf8" });
        } catch (_err) {
          commandOut = " ";
        }
      }
      return commandOut;
    };
    var GLIBC = "glibc";
    var RE_GLIBC_VERSION = /LIBC[a-z0-9 \-).]*?(\d+\.\d+)/i;
    var MUSL = "musl";
    var isFileMusl = (f) => f.includes("libc.musl-") || f.includes("ld-musl-");
    var familyFromReport = () => {
      const report = getReport();
      if (report.header && report.header.glibcVersionRuntime) {
        return GLIBC;
      }
      if (Array.isArray(report.sharedObjects)) {
        if (report.sharedObjects.some(isFileMusl)) {
          return MUSL;
        }
      }
      return null;
    };
    var familyFromCommand = (out) => {
      const [getconf, ldd1] = out.split(/[\r\n]+/);
      if (getconf && getconf.includes(GLIBC)) {
        return GLIBC;
      }
      if (ldd1 && ldd1.includes(MUSL)) {
        return MUSL;
      }
      return null;
    };
    var familyFromInterpreterPath = (path7) => {
      if (path7) {
        if (path7.includes("/ld-musl-")) {
          return MUSL;
        } else if (path7.includes("/ld-linux-")) {
          return GLIBC;
        }
      }
      return null;
    };
    var getFamilyFromLddContent = (content) => {
      content = content.toString();
      if (content.includes("musl")) {
        return MUSL;
      }
      if (content.includes("GNU C Library")) {
        return GLIBC;
      }
      return null;
    };
    var familyFromFilesystem = async () => {
      if (cachedFamilyFilesystem !== void 0) {
        return cachedFamilyFilesystem;
      }
      cachedFamilyFilesystem = null;
      try {
        const lddContent = await readFile2(LDD_PATH);
        cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);
      } catch (e) {
      }
      return cachedFamilyFilesystem;
    };
    var familyFromFilesystemSync = () => {
      if (cachedFamilyFilesystem !== void 0) {
        return cachedFamilyFilesystem;
      }
      cachedFamilyFilesystem = null;
      try {
        const lddContent = readFileSync(LDD_PATH);
        cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);
      } catch (e) {
      }
      return cachedFamilyFilesystem;
    };
    var familyFromInterpreter = async () => {
      if (cachedFamilyInterpreter !== void 0) {
        return cachedFamilyInterpreter;
      }
      cachedFamilyInterpreter = null;
      try {
        const selfContent = await readFile2(SELF_PATH);
        const path7 = interpreterPath(selfContent);
        cachedFamilyInterpreter = familyFromInterpreterPath(path7);
      } catch (e) {
      }
      return cachedFamilyInterpreter;
    };
    var familyFromInterpreterSync = () => {
      if (cachedFamilyInterpreter !== void 0) {
        return cachedFamilyInterpreter;
      }
      cachedFamilyInterpreter = null;
      try {
        const selfContent = readFileSync(SELF_PATH);
        const path7 = interpreterPath(selfContent);
        cachedFamilyInterpreter = familyFromInterpreterPath(path7);
      } catch (e) {
      }
      return cachedFamilyInterpreter;
    };
    var family = async () => {
      let family2 = null;
      if (isLinux()) {
        family2 = await familyFromInterpreter();
        if (!family2) {
          family2 = await familyFromFilesystem();
          if (!family2) {
            family2 = familyFromReport();
          }
          if (!family2) {
            const out = await safeCommand();
            family2 = familyFromCommand(out);
          }
        }
      }
      return family2;
    };
    var familySync = () => {
      let family2 = null;
      if (isLinux()) {
        family2 = familyFromInterpreterSync();
        if (!family2) {
          family2 = familyFromFilesystemSync();
          if (!family2) {
            family2 = familyFromReport();
          }
          if (!family2) {
            const out = safeCommandSync();
            family2 = familyFromCommand(out);
          }
        }
      }
      return family2;
    };
    var isNonGlibcLinux = async () => isLinux() && await family() !== GLIBC;
    var isNonGlibcLinuxSync = () => isLinux() && familySync() !== GLIBC;
    var versionFromFilesystem = async () => {
      if (cachedVersionFilesystem !== void 0) {
        return cachedVersionFilesystem;
      }
      cachedVersionFilesystem = null;
      try {
        const lddContent = await readFile2(LDD_PATH);
        const versionMatch = lddContent.match(RE_GLIBC_VERSION);
        if (versionMatch) {
          cachedVersionFilesystem = versionMatch[1];
        }
      } catch (e) {
      }
      return cachedVersionFilesystem;
    };
    var versionFromFilesystemSync = () => {
      if (cachedVersionFilesystem !== void 0) {
        return cachedVersionFilesystem;
      }
      cachedVersionFilesystem = null;
      try {
        const lddContent = readFileSync(LDD_PATH);
        const versionMatch = lddContent.match(RE_GLIBC_VERSION);
        if (versionMatch) {
          cachedVersionFilesystem = versionMatch[1];
        }
      } catch (e) {
      }
      return cachedVersionFilesystem;
    };
    var versionFromReport = () => {
      const report = getReport();
      if (report.header && report.header.glibcVersionRuntime) {
        return report.header.glibcVersionRuntime;
      }
      return null;
    };
    var versionSuffix = (s) => s.trim().split(/\s+/)[1];
    var versionFromCommand = (out) => {
      const [getconf, ldd1, ldd2] = out.split(/[\r\n]+/);
      if (getconf && getconf.includes(GLIBC)) {
        return versionSuffix(getconf);
      }
      if (ldd1 && ldd2 && ldd1.includes(MUSL)) {
        return versionSuffix(ldd2);
      }
      return null;
    };
    var version = async () => {
      let version2 = null;
      if (isLinux()) {
        version2 = await versionFromFilesystem();
        if (!version2) {
          version2 = versionFromReport();
        }
        if (!version2) {
          const out = await safeCommand();
          version2 = versionFromCommand(out);
        }
      }
      return version2;
    };
    var versionSync = () => {
      let version2 = null;
      if (isLinux()) {
        version2 = versionFromFilesystemSync();
        if (!version2) {
          version2 = versionFromReport();
        }
        if (!version2) {
          const out = safeCommandSync();
          version2 = versionFromCommand(out);
        }
      }
      return version2;
    };
    module.exports = {
      GLIBC,
      MUSL,
      family,
      familySync,
      isNonGlibcLinux,
      isNonGlibcLinuxSync,
      version,
      versionSync
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports, module) {
    "use strict";
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug;
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports, module) {
    "use strict";
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports, module) {
    "use strict";
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports = module.exports = {};
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var safeSrc = exports.safeSrc = [];
    var t = exports.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports, module) {
    "use strict";
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports, module) {
    "use strict";
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      if (typeof a === "number" && typeof b === "number") {
        return a === b ? 0 : a < b ? -1 : 1;
      }
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports, module) {
    "use strict";
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof _SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.major < other.major) {
          return -1;
        }
        if (this.major > other.major) {
          return 1;
        }
        if (this.minor < other.minor) {
          return -1;
        }
        if (this.minor > other.minor) {
          return 1;
        }
        if (this.patch < other.patch) {
          return -1;
        }
        if (this.patch > other.patch) {
          return 1;
        }
        return 0;
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var parse4 = (version, options, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module.exports = parse4;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var parse4 = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse4(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module.exports = coerce;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module.exports = compare;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module.exports = gte;
  }
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/semver/internal/lrucache.js"(exports, module) {
    "use strict";
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey2 = this.map.keys().next().value;
            this.delete(firstKey2);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module.exports = LRUCache;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module.exports = neq;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module.exports = lt;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports, module) {
    "use strict";
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module.exports = cmp;
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports, module) {
    "use strict";
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports, module) {
    "use strict";
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      comp = comp.replace(re[t.BUILD], "");
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set3, version, options) => {
      for (let i = 0; i < set3.length; i++) {
        if (!set3[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set3.length; i++) {
          debug(set3[i].semver);
          if (set3[i].semver === Comparator.ANY) {
            continue;
          }
          if (set3[i].semver.prerelease.length > 0) {
            const allowed = set3[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module.exports = satisfies;
  }
});

// node_modules/sharp/package.json
var require_package = __commonJS({
  "node_modules/sharp/package.json"(exports, module) {
    module.exports = {
      name: "sharp",
      description: "High performance Node.js image processing, the fastest module to resize JPEG, PNG, WebP, GIF, AVIF and TIFF images",
      version: "0.33.5",
      author: "Lovell Fuller <npm@lovell.info>",
      homepage: "https://sharp.pixelplumbing.com",
      contributors: [
        "Pierre Inglebert <pierre.inglebert@gmail.com>",
        "Jonathan Ong <jonathanrichardong@gmail.com>",
        "Chanon Sajjamanochai <chanon.s@gmail.com>",
        "Juliano Julio <julianojulio@gmail.com>",
        "Daniel Gasienica <daniel@gasienica.ch>",
        "Julian Walker <julian@fiftythree.com>",
        "Amit Pitaru <pitaru.amit@gmail.com>",
        "Brandon Aaron <hello.brandon@aaron.sh>",
        "Andreas Lind <andreas@one.com>",
        "Maurus Cuelenaere <mcuelenaere@gmail.com>",
        "Linus Unneb\xE4ck <linus@folkdatorn.se>",
        "Victor Mateevitsi <mvictoras@gmail.com>",
        "Alaric Holloway <alaric.holloway@gmail.com>",
        "Bernhard K. Weisshuhn <bkw@codingforce.com>",
        "Chris Riley <criley@primedia.com>",
        "David Carley <dacarley@gmail.com>",
        "John Tobin <john@limelightmobileinc.com>",
        "Kenton Gray <kentongray@gmail.com>",
        "Felix B\xFCnemann <Felix.Buenemann@gmail.com>",
        "Samy Al Zahrani <samyalzahrany@gmail.com>",
        "Chintan Thakkar <lemnisk8@gmail.com>",
        "F. Orlando Galashan <frulo@gmx.de>",
        "Kleis Auke Wolthuizen <info@kleisauke.nl>",
        "Matt Hirsch <mhirsch@media.mit.edu>",
        "Matthias Thoemmes <thoemmes@gmail.com>",
        "Patrick Paskaris <patrick@paskaris.gr>",
        "J\xE9r\xE9my Lal <kapouer@melix.org>",
        "Rahul Nanwani <r.nanwani@gmail.com>",
        "Alice Monday <alice0meta@gmail.com>",
        "Kristo Jorgenson <kristo.jorgenson@gmail.com>",
        "YvesBos <yves_bos@outlook.com>",
        "Guy Maliar <guy@tailorbrands.com>",
        "Nicolas Coden <nicolas@ncoden.fr>",
        "Matt Parrish <matt.r.parrish@gmail.com>",
        "Marcel Bretschneider <marcel.bretschneider@gmail.com>",
        "Matthew McEachen <matthew+github@mceachen.org>",
        "Jarda Kot\u011B\u0161ovec <jarda.kotesovec@gmail.com>",
        "Kenric D'Souza <kenric.dsouza@gmail.com>",
        "Oleh Aleinyk <oleg.aleynik@gmail.com>",
        "Marcel Bretschneider <marcel.bretschneider@gmail.com>",
        "Andrea Bianco <andrea.bianco@unibas.ch>",
        "Rik Heywood <rik@rik.org>",
        "Thomas Parisot <hi@oncletom.io>",
        "Nathan Graves <nathanrgraves+github@gmail.com>",
        "Tom Lokhorst <tom@lokhorst.eu>",
        "Espen Hovlandsdal <espen@hovlandsdal.com>",
        "Sylvain Dumont <sylvain.dumont35@gmail.com>",
        "Alun Davies <alun.owain.davies@googlemail.com>",
        "Aidan Hoolachan <ajhoolachan21@gmail.com>",
        "Axel Eirola <axel.eirola@iki.fi>",
        "Freezy <freezy@xbmc.org>",
        "Daiz <taneli.vatanen@gmail.com>",
        "Julian Aubourg <j@ubourg.net>",
        "Keith Belovay <keith@picthrive.com>",
        "Michael B. Klein <mbklein@gmail.com>",
        "Jordan Prudhomme <jordan@raboland.fr>",
        "Ilya Ovdin <iovdin@gmail.com>",
        "Andargor <andargor@yahoo.com>",
        "Paul Neave <paul.neave@gmail.com>",
        "Brendan Kennedy <brenwken@gmail.com>",
        "Brychan Bennett-Odlum <git@brychan.io>",
        "Edward Silverton <e.silverton@gmail.com>",
        "Roman Malieiev <aromaleev@gmail.com>",
        "Tomas Szabo <tomas.szabo@deftomat.com>",
        "Robert O'Rourke <robert@o-rourke.org>",
        "Guillermo Alfonso Varela Chouci\xF1o <guillevch@gmail.com>",
        "Christian Flintrup <chr@gigahost.dk>",
        "Manan Jadhav <manan@motionden.com>",
        "Leon Radley <leon@radley.se>",
        "alza54 <alza54@thiocod.in>",
        "Jacob Smith <jacob@frende.me>",
        "Michael Nutt <michael@nutt.im>",
        "Brad Parham <baparham@gmail.com>",
        "Taneli Vatanen <taneli.vatanen@gmail.com>",
        "Joris Dugu\xE9 <zaruike10@gmail.com>",
        "Chris Banks <christopher.bradley.banks@gmail.com>",
        "Ompal Singh <ompal.hitm09@gmail.com>",
        "Brodan <christopher.hranj@gmail.com>",
        "Ankur Parihar <ankur.github@gmail.com>",
        "Brahim Ait elhaj <brahima@gmail.com>",
        "Mart Jansink <m.jansink@gmail.com>",
        "Lachlan Newman <lachnewman007@gmail.com>",
        "Dennis Beatty <dennis@dcbeatty.com>",
        "Ingvar Stepanyan <me@rreverser.com>",
        "Don Denton <don@happycollision.com>"
      ],
      scripts: {
        install: "node install/check",
        clean: "rm -rf src/build/ .nyc_output/ coverage/ test/fixtures/output.*",
        test: "npm run test-lint && npm run test-unit && npm run test-licensing && npm run test-types",
        "test-lint": "semistandard && cpplint",
        "test-unit": "nyc --reporter=lcov --reporter=text --check-coverage --branches=100 mocha",
        "test-licensing": 'license-checker --production --summary --onlyAllow="Apache-2.0;BSD;ISC;LGPL-3.0-or-later;MIT"',
        "test-leak": "./test/leak/leak.sh",
        "test-types": "tsd",
        "package-from-local-build": "node npm/from-local-build",
        "package-from-github-release": "node npm/from-github-release",
        "docs-build": "node docs/build && node docs/search-index/build",
        "docs-serve": "cd docs && npx serve",
        "docs-publish": "cd docs && npx firebase-tools deploy --project pixelplumbing --only hosting:pixelplumbing-sharp"
      },
      type: "commonjs",
      main: "lib/index.js",
      types: "lib/index.d.ts",
      files: [
        "install",
        "lib",
        "src/*.{cc,h,gyp}"
      ],
      repository: {
        type: "git",
        url: "git://github.com/lovell/sharp.git"
      },
      keywords: [
        "jpeg",
        "png",
        "webp",
        "avif",
        "tiff",
        "gif",
        "svg",
        "jp2",
        "dzi",
        "image",
        "resize",
        "thumbnail",
        "crop",
        "embed",
        "libvips",
        "vips"
      ],
      dependencies: {
        color: "^4.2.3",
        "detect-libc": "^2.0.3",
        semver: "^7.6.3"
      },
      optionalDependencies: {
        "@img/sharp-darwin-arm64": "0.33.5",
        "@img/sharp-darwin-x64": "0.33.5",
        "@img/sharp-libvips-darwin-arm64": "1.0.4",
        "@img/sharp-libvips-darwin-x64": "1.0.4",
        "@img/sharp-libvips-linux-arm": "1.0.5",
        "@img/sharp-libvips-linux-arm64": "1.0.4",
        "@img/sharp-libvips-linux-s390x": "1.0.4",
        "@img/sharp-libvips-linux-x64": "1.0.4",
        "@img/sharp-libvips-linuxmusl-arm64": "1.0.4",
        "@img/sharp-libvips-linuxmusl-x64": "1.0.4",
        "@img/sharp-linux-arm": "0.33.5",
        "@img/sharp-linux-arm64": "0.33.5",
        "@img/sharp-linux-s390x": "0.33.5",
        "@img/sharp-linux-x64": "0.33.5",
        "@img/sharp-linuxmusl-arm64": "0.33.5",
        "@img/sharp-linuxmusl-x64": "0.33.5",
        "@img/sharp-wasm32": "0.33.5",
        "@img/sharp-win32-ia32": "0.33.5",
        "@img/sharp-win32-x64": "0.33.5"
      },
      devDependencies: {
        "@emnapi/runtime": "^1.2.0",
        "@img/sharp-libvips-dev": "1.0.4",
        "@img/sharp-libvips-dev-wasm32": "1.0.5",
        "@img/sharp-libvips-win32-ia32": "1.0.4",
        "@img/sharp-libvips-win32-x64": "1.0.4",
        "@types/node": "*",
        async: "^3.2.5",
        cc: "^3.0.1",
        emnapi: "^1.2.0",
        "exif-reader": "^2.0.1",
        "extract-zip": "^2.0.1",
        icc: "^3.0.0",
        "jsdoc-to-markdown": "^8.0.3",
        "license-checker": "^25.0.1",
        mocha: "^10.7.3",
        "node-addon-api": "^8.1.0",
        nyc: "^17.0.0",
        prebuild: "^13.0.1",
        semistandard: "^17.0.0",
        "tar-fs": "^3.0.6",
        tsd: "^0.31.1"
      },
      license: "Apache-2.0",
      engines: {
        node: "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      config: {
        libvips: ">=8.15.3"
      },
      funding: {
        url: "https://opencollective.com/libvips"
      },
      binary: {
        napi_versions: [
          9
        ]
      },
      semistandard: {
        env: [
          "mocha"
        ]
      },
      cc: {
        linelength: "120",
        filter: [
          "build/include"
        ]
      },
      nyc: {
        include: [
          "lib"
        ]
      },
      tsd: {
        directory: "test/types/"
      }
    };
  }
});

// node_modules/sharp/lib/libvips.js
var require_libvips = __commonJS({
  "node_modules/sharp/lib/libvips.js"(exports, module) {
    "use strict";
    var { spawnSync } = __require("node:child_process");
    var { createHash } = __require("node:crypto");
    var semverCoerce = require_coerce();
    var semverGreaterThanOrEqualTo = require_gte();
    var semverSatisfies = require_satisfies();
    var detectLibc = require_detect_libc();
    var { config, engines, optionalDependencies } = require_package();
    var minimumLibvipsVersionLabelled = process.env.npm_package_config_libvips || /* istanbul ignore next */
    config.libvips;
    var minimumLibvipsVersion = semverCoerce(minimumLibvipsVersionLabelled).version;
    var prebuiltPlatforms = [
      "darwin-arm64",
      "darwin-x64",
      "linux-arm",
      "linux-arm64",
      "linux-s390x",
      "linux-x64",
      "linuxmusl-arm64",
      "linuxmusl-x64",
      "win32-ia32",
      "win32-x64"
    ];
    var spawnSyncOptions = {
      encoding: "utf8",
      shell: true
    };
    var log = (item) => {
      if (item instanceof Error) {
        console.error(`sharp: Installation error: ${item.message}`);
      } else {
        console.log(`sharp: ${item}`);
      }
    };
    var runtimeLibc = () => detectLibc.isNonGlibcLinuxSync() ? detectLibc.familySync() : "";
    var runtimePlatformArch = () => `${process.platform}${runtimeLibc()}-${process.arch}`;
    var buildPlatformArch = () => {
      if (isEmscripten()) {
        return "wasm32";
      }
      const { npm_config_arch, npm_config_platform, npm_config_libc } = process.env;
      const libc = typeof npm_config_libc === "string" ? npm_config_libc : runtimeLibc();
      return `${npm_config_platform || process.platform}${libc}-${npm_config_arch || process.arch}`;
    };
    var buildSharpLibvipsIncludeDir = () => {
      try {
        return __require(`@img/sharp-libvips-dev-${buildPlatformArch()}/include`);
      } catch {
        try {
          return __require("@img/sharp-libvips-dev/include");
        } catch {
        }
      }
      return "";
    };
    var buildSharpLibvipsCPlusPlusDir = () => {
      try {
        return __require("@img/sharp-libvips-dev/cplusplus");
      } catch {
      }
      return "";
    };
    var buildSharpLibvipsLibDir = () => {
      try {
        return __require(`@img/sharp-libvips-dev-${buildPlatformArch()}/lib`);
      } catch {
        try {
          return __require(`@img/sharp-libvips-${buildPlatformArch()}/lib`);
        } catch {
        }
      }
      return "";
    };
    var isUnsupportedNodeRuntime = () => {
      if (process.release?.name === "node" && process.versions) {
        if (!semverSatisfies(process.versions.node, engines.node)) {
          return { found: process.versions.node, expected: engines.node };
        }
      }
    };
    var isEmscripten = () => {
      const { CC } = process.env;
      return Boolean(CC && CC.endsWith("/emcc"));
    };
    var isRosetta = () => {
      if (process.platform === "darwin" && process.arch === "x64") {
        const translated = spawnSync("sysctl sysctl.proc_translated", spawnSyncOptions).stdout;
        return (translated || "").trim() === "sysctl.proc_translated: 1";
      }
      return false;
    };
    var sha512 = (s) => createHash("sha512").update(s).digest("hex");
    var yarnLocator = () => {
      try {
        const identHash = sha512(`imgsharp-libvips-${buildPlatformArch()}`);
        const npmVersion = semverCoerce(optionalDependencies[`@img/sharp-libvips-${buildPlatformArch()}`]).version;
        return sha512(`${identHash}npm:${npmVersion}`).slice(0, 10);
      } catch {
      }
      return "";
    };
    var spawnRebuild = () => spawnSync(`node-gyp rebuild --directory=src ${isEmscripten() ? "--nodedir=emscripten" : ""}`, {
      ...spawnSyncOptions,
      stdio: "inherit"
    }).status;
    var globalLibvipsVersion = () => {
      if (process.platform !== "win32") {
        const globalLibvipsVersion2 = spawnSync("pkg-config --modversion vips-cpp", {
          ...spawnSyncOptions,
          env: {
            ...process.env,
            PKG_CONFIG_PATH: pkgConfigPath()
          }
        }).stdout;
        return (globalLibvipsVersion2 || "").trim();
      } else {
        return "";
      }
    };
    var pkgConfigPath = () => {
      if (process.platform !== "win32") {
        const brewPkgConfigPath = spawnSync(
          'which brew >/dev/null 2>&1 && brew environment --plain | grep PKG_CONFIG_LIBDIR | cut -d" " -f2',
          spawnSyncOptions
        ).stdout || "";
        return [
          brewPkgConfigPath.trim(),
          process.env.PKG_CONFIG_PATH,
          "/usr/local/lib/pkgconfig",
          "/usr/lib/pkgconfig",
          "/usr/local/libdata/pkgconfig",
          "/usr/libdata/pkgconfig"
        ].filter(Boolean).join(":");
      } else {
        return "";
      }
    };
    var skipSearch = (status, reason, logger) => {
      if (logger) {
        logger(`Detected ${reason}, skipping search for globally-installed libvips`);
      }
      return status;
    };
    var useGlobalLibvips = (logger) => {
      if (Boolean(process.env.SHARP_IGNORE_GLOBAL_LIBVIPS) === true) {
        return skipSearch(false, "SHARP_IGNORE_GLOBAL_LIBVIPS", logger);
      }
      if (Boolean(process.env.SHARP_FORCE_GLOBAL_LIBVIPS) === true) {
        return skipSearch(true, "SHARP_FORCE_GLOBAL_LIBVIPS", logger);
      }
      if (isRosetta()) {
        return skipSearch(false, "Rosetta", logger);
      }
      const globalVipsVersion = globalLibvipsVersion();
      return !!globalVipsVersion && /* istanbul ignore next */
      semverGreaterThanOrEqualTo(globalVipsVersion, minimumLibvipsVersion);
    };
    module.exports = {
      minimumLibvipsVersion,
      prebuiltPlatforms,
      buildPlatformArch,
      buildSharpLibvipsIncludeDir,
      buildSharpLibvipsCPlusPlusDir,
      buildSharpLibvipsLibDir,
      isUnsupportedNodeRuntime,
      runtimePlatformArch,
      log,
      yarnLocator,
      spawnRebuild,
      globalLibvipsVersion,
      pkgConfigPath,
      useGlobalLibvips
    };
  }
});

// node_modules/sharp/lib/sharp.js
var require_sharp = __commonJS({
  "node_modules/sharp/lib/sharp.js"(exports, module) {
    "use strict";
    var { familySync, versionSync } = require_detect_libc();
    var { runtimePlatformArch, isUnsupportedNodeRuntime, prebuiltPlatforms, minimumLibvipsVersion } = require_libvips();
    var runtimePlatform = runtimePlatformArch();
    var paths = [
      `../src/build/Release/sharp-${runtimePlatform}.node`,
      "../src/build/Release/sharp-wasm32.node",
      `@img/sharp-${runtimePlatform}/sharp.node`,
      "@img/sharp-wasm32/sharp.node"
    ];
    var sharp;
    var errors = [];
    for (const path7 of paths) {
      try {
        sharp = __require(path7);
        break;
      } catch (err) {
        errors.push(err);
      }
    }
    if (sharp) {
      module.exports = sharp;
    } else {
      const [isLinux, isMacOs, isWindows] = ["linux", "darwin", "win32"].map((os) => runtimePlatform.startsWith(os));
      const help = [`Could not load the "sharp" module using the ${runtimePlatform} runtime`];
      errors.forEach((err) => {
        if (err.code !== "MODULE_NOT_FOUND") {
          help.push(`${err.code}: ${err.message}`);
        }
      });
      const messages = errors.map((err) => err.message).join(" ");
      help.push("Possible solutions:");
      if (isUnsupportedNodeRuntime()) {
        const { found, expected } = isUnsupportedNodeRuntime();
        help.push(
          "- Please upgrade Node.js:",
          `    Found ${found}`,
          `    Requires ${expected}`
        );
      } else if (prebuiltPlatforms.includes(runtimePlatform)) {
        const [os, cpu] = runtimePlatform.split("-");
        const libc = os.endsWith("musl") ? " --libc=musl" : "";
        help.push(
          "- Ensure optional dependencies can be installed:",
          "    npm install --include=optional sharp",
          "- Ensure your package manager supports multi-platform installation:",
          "    See https://sharp.pixelplumbing.com/install#cross-platform",
          "- Add platform-specific dependencies:",
          `    npm install --os=${os.replace("musl", "")}${libc} --cpu=${cpu} sharp`
        );
      } else {
        help.push(
          `- Manually install libvips >= ${minimumLibvipsVersion}`,
          "- Add experimental WebAssembly-based dependencies:",
          "    npm install --cpu=wasm32 sharp",
          "    npm install @img/sharp-wasm32"
        );
      }
      if (isLinux && /(symbol not found|CXXABI_)/i.test(messages)) {
        try {
          const { config } = __require(`@img/sharp-libvips-${runtimePlatform}/package`);
          const libcFound = `${familySync()} ${versionSync()}`;
          const libcRequires = `${config.musl ? "musl" : "glibc"} ${config.musl || config.glibc}`;
          help.push(
            "- Update your OS:",
            `    Found ${libcFound}`,
            `    Requires ${libcRequires}`
          );
        } catch (errEngines) {
        }
      }
      if (isLinux && /\/snap\/core[0-9]{2}/.test(messages)) {
        help.push(
          "- Remove the Node.js Snap, which does not support native modules",
          "    snap remove node"
        );
      }
      if (isMacOs && /Incompatible library version/.test(messages)) {
        help.push(
          "- Update Homebrew:",
          "    brew update && brew upgrade vips"
        );
      }
      if (errors.some((err) => err.code === "ERR_DLOPEN_DISABLED")) {
        help.push("- Run Node.js without using the --no-addons flag");
      }
      if (isWindows && /The specified procedure could not be found/.test(messages)) {
        help.push(
          "- Using the canvas package on Windows?",
          "    See https://sharp.pixelplumbing.com/install#canvas-and-windows",
          "- Check for outdated versions of sharp in the dependency tree:",
          "    npm ls sharp"
        );
      }
      help.push(
        "- Consult the installation documentation:",
        "    See https://sharp.pixelplumbing.com/install"
      );
      throw new Error(help.join("\n"));
    }
  }
});

// node_modules/sharp/lib/constructor.js
var require_constructor = __commonJS({
  "node_modules/sharp/lib/constructor.js"(exports, module) {
    "use strict";
    var util = __require("node:util");
    var stream = __require("node:stream");
    var is = require_is();
    require_sharp();
    var debuglog = util.debuglog("sharp");
    var Sharp = function(input, options) {
      if (arguments.length === 1 && !is.defined(input)) {
        throw new Error("Invalid input");
      }
      if (!(this instanceof Sharp)) {
        return new Sharp(input, options);
      }
      stream.Duplex.call(this);
      this.options = {
        // resize options
        topOffsetPre: -1,
        leftOffsetPre: -1,
        widthPre: -1,
        heightPre: -1,
        topOffsetPost: -1,
        leftOffsetPost: -1,
        widthPost: -1,
        heightPost: -1,
        width: -1,
        height: -1,
        canvas: "crop",
        position: 0,
        resizeBackground: [0, 0, 0, 255],
        useExifOrientation: false,
        angle: 0,
        rotationAngle: 0,
        rotationBackground: [0, 0, 0, 255],
        rotateBeforePreExtract: false,
        flip: false,
        flop: false,
        extendTop: 0,
        extendBottom: 0,
        extendLeft: 0,
        extendRight: 0,
        extendBackground: [0, 0, 0, 255],
        extendWith: "background",
        withoutEnlargement: false,
        withoutReduction: false,
        affineMatrix: [],
        affineBackground: [0, 0, 0, 255],
        affineIdx: 0,
        affineIdy: 0,
        affineOdx: 0,
        affineOdy: 0,
        affineInterpolator: this.constructor.interpolators.bilinear,
        kernel: "lanczos3",
        fastShrinkOnLoad: true,
        // operations
        tint: [-1, 0, 0, 0],
        flatten: false,
        flattenBackground: [0, 0, 0],
        unflatten: false,
        negate: false,
        negateAlpha: true,
        medianSize: 0,
        blurSigma: 0,
        precision: "integer",
        minAmpl: 0.2,
        sharpenSigma: 0,
        sharpenM1: 1,
        sharpenM2: 2,
        sharpenX1: 2,
        sharpenY2: 10,
        sharpenY3: 20,
        threshold: 0,
        thresholdGrayscale: true,
        trimBackground: [],
        trimThreshold: -1,
        trimLineArt: false,
        gamma: 0,
        gammaOut: 0,
        greyscale: false,
        normalise: false,
        normaliseLower: 1,
        normaliseUpper: 99,
        claheWidth: 0,
        claheHeight: 0,
        claheMaxSlope: 3,
        brightness: 1,
        saturation: 1,
        hue: 0,
        lightness: 0,
        booleanBufferIn: null,
        booleanFileIn: "",
        joinChannelIn: [],
        extractChannel: -1,
        removeAlpha: false,
        ensureAlpha: -1,
        colourspace: "srgb",
        colourspacePipeline: "last",
        composite: [],
        // output
        fileOut: "",
        formatOut: "input",
        streamOut: false,
        keepMetadata: 0,
        withMetadataOrientation: -1,
        withMetadataDensity: 0,
        withIccProfile: "",
        withExif: {},
        withExifMerge: true,
        resolveWithObject: false,
        // output format
        jpegQuality: 80,
        jpegProgressive: false,
        jpegChromaSubsampling: "4:2:0",
        jpegTrellisQuantisation: false,
        jpegOvershootDeringing: false,
        jpegOptimiseScans: false,
        jpegOptimiseCoding: true,
        jpegQuantisationTable: 0,
        pngProgressive: false,
        pngCompressionLevel: 6,
        pngAdaptiveFiltering: false,
        pngPalette: false,
        pngQuality: 100,
        pngEffort: 7,
        pngBitdepth: 8,
        pngDither: 1,
        jp2Quality: 80,
        jp2TileHeight: 512,
        jp2TileWidth: 512,
        jp2Lossless: false,
        jp2ChromaSubsampling: "4:4:4",
        webpQuality: 80,
        webpAlphaQuality: 100,
        webpLossless: false,
        webpNearLossless: false,
        webpSmartSubsample: false,
        webpPreset: "default",
        webpEffort: 4,
        webpMinSize: false,
        webpMixed: false,
        gifBitdepth: 8,
        gifEffort: 7,
        gifDither: 1,
        gifInterFrameMaxError: 0,
        gifInterPaletteMaxError: 3,
        gifReuse: true,
        gifProgressive: false,
        tiffQuality: 80,
        tiffCompression: "jpeg",
        tiffPredictor: "horizontal",
        tiffPyramid: false,
        tiffMiniswhite: false,
        tiffBitdepth: 8,
        tiffTile: false,
        tiffTileHeight: 256,
        tiffTileWidth: 256,
        tiffXres: 1,
        tiffYres: 1,
        tiffResolutionUnit: "inch",
        heifQuality: 50,
        heifLossless: false,
        heifCompression: "av1",
        heifEffort: 4,
        heifChromaSubsampling: "4:4:4",
        heifBitdepth: 8,
        jxlDistance: 1,
        jxlDecodingTier: 0,
        jxlEffort: 7,
        jxlLossless: false,
        rawDepth: "uchar",
        tileSize: 256,
        tileOverlap: 0,
        tileContainer: "fs",
        tileLayout: "dz",
        tileFormat: "last",
        tileDepth: "last",
        tileAngle: 0,
        tileSkipBlanks: -1,
        tileBackground: [255, 255, 255, 255],
        tileCentre: false,
        tileId: "https://example.com/iiif",
        tileBasename: "",
        timeoutSeconds: 0,
        linearA: [],
        linearB: [],
        // Function to notify of libvips warnings
        debuglog: (warning) => {
          this.emit("warning", warning);
          debuglog(warning);
        },
        // Function to notify of queue length changes
        queueListener: function(queueLength) {
          Sharp.queue.emit("change", queueLength);
        }
      };
      this.options.input = this._createInputDescriptor(input, options, { allowStream: true });
      return this;
    };
    Object.setPrototypeOf(Sharp.prototype, stream.Duplex.prototype);
    Object.setPrototypeOf(Sharp, stream.Duplex);
    function clone() {
      const clone2 = this.constructor.call();
      const { debuglog: debuglog2, queueListener, ...options } = this.options;
      clone2.options = structuredClone(options);
      clone2.options.debuglog = debuglog2;
      clone2.options.queueListener = queueListener;
      if (this._isStreamInput()) {
        this.on("finish", () => {
          this._flattenBufferIn();
          clone2.options.input.buffer = this.options.input.buffer;
          clone2.emit("finish");
        });
      }
      return clone2;
    }
    Object.assign(Sharp.prototype, { clone });
    module.exports = Sharp;
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "node_modules/is-arrayish/index.js"(exports, module) {
    module.exports = function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
  }
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "node_modules/simple-swizzle/index.js"(exports, module) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat = Array.prototype.concat;
    var slice = Array.prototype.slice;
    var swizzle = module.exports = function swizzle2(args) {
      var results = [];
      for (var i = 0, len = args.length; i < len; i++) {
        var arg = args[i];
        if (isArrayish(arg)) {
          results = concat.call(results, slice.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    };
    swizzle.wrap = function(fn) {
      return function() {
        return fn(swizzle(arguments));
      };
    };
  }
});

// node_modules/color-string/index.js
var require_color_string = __commonJS({
  "node_modules/color-string/index.js"(exports, module) {
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (name in colorNames) {
      if (hasOwnProperty.call(colorNames, name)) {
        reverseNames[colorNames[name]] = name;
      }
    }
    var name;
    var cs = module.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string3) {
      var prefix = string3.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix) {
        case "hsl":
          val = cs.get.hsl(string3);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string3);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string3);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string3) {
      if (!string3) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb = [0, 0, 0, 1];
      var match;
      var i;
      var hexAlpha;
      if (match = string3.match(hex)) {
        hexAlpha = match[2];
        match = match[1];
        for (i = 0; i < 3; i++) {
          var i2 = i * 2;
          rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match = string3.match(abbr)) {
        match = match[1];
        hexAlpha = match[3];
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i] + match[i], 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match = string3.match(rgba)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i + 1], 0);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string3.match(per)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string3.match(keyword)) {
        if (match[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty.call(colorNames, match[1])) {
          return null;
        }
        rgb = colorNames[match[1]];
        rgb[3] = 1;
        return rgb;
      } else {
        return null;
      }
      for (i = 0; i < 3; i++) {
        rgb[i] = clamp3(rgb[i], 0, 255);
      }
      rgb[3] = clamp3(rgb[3], 0, 1);
      return rgb;
    };
    cs.get.hsl = function(string3) {
      if (!string3) {
        return null;
      }
      var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string3.match(hsl);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var s = clamp3(parseFloat(match[2]), 0, 100);
        var l = clamp3(parseFloat(match[3]), 0, 100);
        var a = clamp3(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, s, l, a];
      }
      return null;
    };
    cs.get.hwb = function(string3) {
      if (!string3) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string3.match(hwb);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var w = clamp3(parseFloat(match[2]), 0, 100);
        var b = clamp3(parseFloat(match[3]), 0, 100);
        var a = clamp3(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, w, b, a];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba = swizzle(arguments);
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba = swizzle(arguments);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba = swizzle(arguments);
      var r = Math.round(rgba[0] / 255 * 100);
      var g = Math.round(rgba[1] / 255 * 100);
      var b = Math.round(rgba[2] / 255 * 100);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla = swizzle(arguments);
      return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
    };
    cs.to.keyword = function(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    };
    function clamp3(num, min, max) {
      return Math.min(Math.max(min, num), max);
    }
    function hexDouble(num) {
      var str = Math.round(num).toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    }
  }
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color-convert/conversions.js"(exports, module) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string3 = integer.toString(16).toUpperCase();
      return "000000".substring(string3.length) + string3;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string3 = integer.toString(16).toUpperCase();
      return "000000".substring(string3.length) + string3;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color-convert/route.js"(exports, module) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path7 = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path7.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path7;
      return fn;
    }
    module.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color-convert/index.js"(exports, module) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module.exports = convert;
  }
});

// node_modules/color/index.js
var require_color = __commonJS({
  "node_modules/color/index.js"(exports, module) {
    var colorString = require_color_string();
    var convert = require_color_convert();
    var skippedModels = [
      // To be honest, I don't really feel like keyword belongs in color convert, but eh.
      "keyword",
      // Gray conflicts with some method names, and has its own method defined.
      "gray",
      // Shouldn't really be in color-convert either...
      "hex"
    ];
    var hashedModelKeys = {};
    for (const model of Object.keys(convert)) {
      hashedModelKeys[[...convert[model].labels].sort().join("")] = model;
    }
    var limiters = {};
    function Color3(object, model) {
      if (!(this instanceof Color3)) {
        return new Color3(object, model);
      }
      if (model && model in skippedModels) {
        model = null;
      }
      if (model && !(model in convert)) {
        throw new Error("Unknown model: " + model);
      }
      let i;
      let channels;
      if (object == null) {
        this.model = "rgb";
        this.color = [0, 0, 0];
        this.valpha = 1;
      } else if (object instanceof Color3) {
        this.model = object.model;
        this.color = [...object.color];
        this.valpha = object.valpha;
      } else if (typeof object === "string") {
        const result = colorString.get(object);
        if (result === null) {
          throw new Error("Unable to parse color from string: " + object);
        }
        this.model = result.model;
        channels = convert[this.model].channels;
        this.color = result.value.slice(0, channels);
        this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
      } else if (object.length > 0) {
        this.model = model || "rgb";
        channels = convert[this.model].channels;
        const newArray = Array.prototype.slice.call(object, 0, channels);
        this.color = zeroArray(newArray, channels);
        this.valpha = typeof object[channels] === "number" ? object[channels] : 1;
      } else if (typeof object === "number") {
        this.model = "rgb";
        this.color = [
          object >> 16 & 255,
          object >> 8 & 255,
          object & 255
        ];
        this.valpha = 1;
      } else {
        this.valpha = 1;
        const keys = Object.keys(object);
        if ("alpha" in object) {
          keys.splice(keys.indexOf("alpha"), 1);
          this.valpha = typeof object.alpha === "number" ? object.alpha : 0;
        }
        const hashedKeys = keys.sort().join("");
        if (!(hashedKeys in hashedModelKeys)) {
          throw new Error("Unable to parse color from object: " + JSON.stringify(object));
        }
        this.model = hashedModelKeys[hashedKeys];
        const { labels } = convert[this.model];
        const color = [];
        for (i = 0; i < labels.length; i++) {
          color.push(object[labels[i]]);
        }
        this.color = zeroArray(color);
      }
      if (limiters[this.model]) {
        channels = convert[this.model].channels;
        for (i = 0; i < channels; i++) {
          const limit = limiters[this.model][i];
          if (limit) {
            this.color[i] = limit(this.color[i]);
          }
        }
      }
      this.valpha = Math.max(0, Math.min(1, this.valpha));
      if (Object.freeze) {
        Object.freeze(this);
      }
    }
    Color3.prototype = {
      toString() {
        return this.string();
      },
      toJSON() {
        return this[this.model]();
      },
      string(places) {
        let self = this.model in colorString.to ? this : this.rgb();
        self = self.round(typeof places === "number" ? places : 1);
        const args = self.valpha === 1 ? self.color : [...self.color, this.valpha];
        return colorString.to[self.model](args);
      },
      percentString(places) {
        const self = this.rgb().round(typeof places === "number" ? places : 1);
        const args = self.valpha === 1 ? self.color : [...self.color, this.valpha];
        return colorString.to.rgb.percent(args);
      },
      array() {
        return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
      },
      object() {
        const result = {};
        const { channels } = convert[this.model];
        const { labels } = convert[this.model];
        for (let i = 0; i < channels; i++) {
          result[labels[i]] = this.color[i];
        }
        if (this.valpha !== 1) {
          result.alpha = this.valpha;
        }
        return result;
      },
      unitArray() {
        const rgb = this.rgb().color;
        rgb[0] /= 255;
        rgb[1] /= 255;
        rgb[2] /= 255;
        if (this.valpha !== 1) {
          rgb.push(this.valpha);
        }
        return rgb;
      },
      unitObject() {
        const rgb = this.rgb().object();
        rgb.r /= 255;
        rgb.g /= 255;
        rgb.b /= 255;
        if (this.valpha !== 1) {
          rgb.alpha = this.valpha;
        }
        return rgb;
      },
      round(places) {
        places = Math.max(places || 0, 0);
        return new Color3([...this.color.map(roundToPlace(places)), this.valpha], this.model);
      },
      alpha(value) {
        if (value !== void 0) {
          return new Color3([...this.color, Math.max(0, Math.min(1, value))], this.model);
        }
        return this.valpha;
      },
      // Rgb
      red: getset("rgb", 0, maxfn(255)),
      green: getset("rgb", 1, maxfn(255)),
      blue: getset("rgb", 2, maxfn(255)),
      hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, (value) => (value % 360 + 360) % 360),
      saturationl: getset("hsl", 1, maxfn(100)),
      lightness: getset("hsl", 2, maxfn(100)),
      saturationv: getset("hsv", 1, maxfn(100)),
      value: getset("hsv", 2, maxfn(100)),
      chroma: getset("hcg", 1, maxfn(100)),
      gray: getset("hcg", 2, maxfn(100)),
      white: getset("hwb", 1, maxfn(100)),
      wblack: getset("hwb", 2, maxfn(100)),
      cyan: getset("cmyk", 0, maxfn(100)),
      magenta: getset("cmyk", 1, maxfn(100)),
      yellow: getset("cmyk", 2, maxfn(100)),
      black: getset("cmyk", 3, maxfn(100)),
      x: getset("xyz", 0, maxfn(95.047)),
      y: getset("xyz", 1, maxfn(100)),
      z: getset("xyz", 2, maxfn(108.833)),
      l: getset("lab", 0, maxfn(100)),
      a: getset("lab", 1),
      b: getset("lab", 2),
      keyword(value) {
        if (value !== void 0) {
          return new Color3(value);
        }
        return convert[this.model].keyword(this.color);
      },
      hex(value) {
        if (value !== void 0) {
          return new Color3(value);
        }
        return colorString.to.hex(this.rgb().round().color);
      },
      hexa(value) {
        if (value !== void 0) {
          return new Color3(value);
        }
        const rgbArray = this.rgb().round().color;
        let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
        if (alphaHex.length === 1) {
          alphaHex = "0" + alphaHex;
        }
        return colorString.to.hex(rgbArray) + alphaHex;
      },
      rgbNumber() {
        const rgb = this.rgb().color;
        return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
      },
      luminosity() {
        const rgb = this.rgb().color;
        const lum = [];
        for (const [i, element] of rgb.entries()) {
          const chan = element / 255;
          lum[i] = chan <= 0.04045 ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;
        }
        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast(color2) {
        const lum1 = this.luminosity();
        const lum2 = color2.luminosity();
        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }
        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level(color2) {
        const contrastRatio = this.contrast(color2);
        if (contrastRatio >= 7) {
          return "AAA";
        }
        return contrastRatio >= 4.5 ? "AA" : "";
      },
      isDark() {
        const rgb = this.rgb().color;
        const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 1e4;
        return yiq < 128;
      },
      isLight() {
        return !this.isDark();
      },
      negate() {
        const rgb = this.rgb();
        for (let i = 0; i < 3; i++) {
          rgb.color[i] = 255 - rgb.color[i];
        }
        return rgb;
      },
      lighten(ratio) {
        const hsl = this.hsl();
        hsl.color[2] += hsl.color[2] * ratio;
        return hsl;
      },
      darken(ratio) {
        const hsl = this.hsl();
        hsl.color[2] -= hsl.color[2] * ratio;
        return hsl;
      },
      saturate(ratio) {
        const hsl = this.hsl();
        hsl.color[1] += hsl.color[1] * ratio;
        return hsl;
      },
      desaturate(ratio) {
        const hsl = this.hsl();
        hsl.color[1] -= hsl.color[1] * ratio;
        return hsl;
      },
      whiten(ratio) {
        const hwb = this.hwb();
        hwb.color[1] += hwb.color[1] * ratio;
        return hwb;
      },
      blacken(ratio) {
        const hwb = this.hwb();
        hwb.color[2] += hwb.color[2] * ratio;
        return hwb;
      },
      grayscale() {
        const rgb = this.rgb().color;
        const value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        return Color3.rgb(value, value, value);
      },
      fade(ratio) {
        return this.alpha(this.valpha - this.valpha * ratio);
      },
      opaquer(ratio) {
        return this.alpha(this.valpha + this.valpha * ratio);
      },
      rotate(degrees) {
        const hsl = this.hsl();
        let hue = hsl.color[0];
        hue = (hue + degrees) % 360;
        hue = hue < 0 ? 360 + hue : hue;
        hsl.color[0] = hue;
        return hsl;
      },
      mix(mixinColor, weight) {
        if (!mixinColor || !mixinColor.rgb) {
          throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
        }
        const color1 = mixinColor.rgb();
        const color2 = this.rgb();
        const p = weight === void 0 ? 0.5 : weight;
        const w = 2 * p - 1;
        const a = color1.alpha() - color2.alpha();
        const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
        const w2 = 1 - w1;
        return Color3.rgb(
          w1 * color1.red() + w2 * color2.red(),
          w1 * color1.green() + w2 * color2.green(),
          w1 * color1.blue() + w2 * color2.blue(),
          color1.alpha() * p + color2.alpha() * (1 - p)
        );
      }
    };
    for (const model of Object.keys(convert)) {
      if (skippedModels.includes(model)) {
        continue;
      }
      const { channels } = convert[model];
      Color3.prototype[model] = function(...args) {
        if (this.model === model) {
          return new Color3(this);
        }
        if (args.length > 0) {
          return new Color3(args, model);
        }
        return new Color3([...assertArray(convert[this.model][model].raw(this.color)), this.valpha], model);
      };
      Color3[model] = function(...args) {
        let color = args[0];
        if (typeof color === "number") {
          color = zeroArray(args, channels);
        }
        return new Color3(color, model);
      };
    }
    function roundTo(number3, places) {
      return Number(number3.toFixed(places));
    }
    function roundToPlace(places) {
      return function(number3) {
        return roundTo(number3, places);
      };
    }
    function getset(model, channel, modifier) {
      model = Array.isArray(model) ? model : [model];
      for (const m of model) {
        (limiters[m] || (limiters[m] = []))[channel] = modifier;
      }
      model = model[0];
      return function(value) {
        let result;
        if (value !== void 0) {
          if (modifier) {
            value = modifier(value);
          }
          result = this[model]();
          result.color[channel] = value;
          return result;
        }
        result = this[model]().color[channel];
        if (modifier) {
          result = modifier(result);
        }
        return result;
      };
    }
    function maxfn(max) {
      return function(v) {
        return Math.max(0, Math.min(max, v));
      };
    }
    function assertArray(value) {
      return Array.isArray(value) ? value : [value];
    }
    function zeroArray(array2, length) {
      for (let i = 0; i < length; i++) {
        if (typeof array2[i] !== "number") {
          array2[i] = 0;
        }
      }
      return array2;
    }
    module.exports = Color3;
  }
});

// node_modules/sharp/lib/input.js
var require_input = __commonJS({
  "node_modules/sharp/lib/input.js"(exports, module) {
    "use strict";
    var color = require_color();
    var is = require_is();
    var sharp = require_sharp();
    var align = {
      left: "low",
      center: "centre",
      centre: "centre",
      right: "high"
    };
    function _inputOptionsFromObject(obj) {
      const { raw, density, limitInputPixels, ignoreIcc, unlimited, sequentialRead, failOn, failOnError, animated, page, pages, subifd } = obj;
      return [raw, density, limitInputPixels, ignoreIcc, unlimited, sequentialRead, failOn, failOnError, animated, page, pages, subifd].some(is.defined) ? { raw, density, limitInputPixels, ignoreIcc, unlimited, sequentialRead, failOn, failOnError, animated, page, pages, subifd } : void 0;
    }
    function _createInputDescriptor(input, inputOptions, containerOptions) {
      const inputDescriptor = {
        failOn: "warning",
        limitInputPixels: Math.pow(16383, 2),
        ignoreIcc: false,
        unlimited: false,
        sequentialRead: true
      };
      if (is.string(input)) {
        inputDescriptor.file = input;
      } else if (is.buffer(input)) {
        if (input.length === 0) {
          throw Error("Input Buffer is empty");
        }
        inputDescriptor.buffer = input;
      } else if (is.arrayBuffer(input)) {
        if (input.byteLength === 0) {
          throw Error("Input bit Array is empty");
        }
        inputDescriptor.buffer = Buffer.from(input, 0, input.byteLength);
      } else if (is.typedArray(input)) {
        if (input.length === 0) {
          throw Error("Input Bit Array is empty");
        }
        inputDescriptor.buffer = Buffer.from(input.buffer, input.byteOffset, input.byteLength);
      } else if (is.plainObject(input) && !is.defined(inputOptions)) {
        inputOptions = input;
        if (_inputOptionsFromObject(inputOptions)) {
          inputDescriptor.buffer = [];
        }
      } else if (!is.defined(input) && !is.defined(inputOptions) && is.object(containerOptions) && containerOptions.allowStream) {
        inputDescriptor.buffer = [];
      } else {
        throw new Error(`Unsupported input '${input}' of type ${typeof input}${is.defined(inputOptions) ? ` when also providing options of type ${typeof inputOptions}` : ""}`);
      }
      if (is.object(inputOptions)) {
        if (is.defined(inputOptions.failOnError)) {
          if (is.bool(inputOptions.failOnError)) {
            inputDescriptor.failOn = inputOptions.failOnError ? "warning" : "none";
          } else {
            throw is.invalidParameterError("failOnError", "boolean", inputOptions.failOnError);
          }
        }
        if (is.defined(inputOptions.failOn)) {
          if (is.string(inputOptions.failOn) && is.inArray(inputOptions.failOn, ["none", "truncated", "error", "warning"])) {
            inputDescriptor.failOn = inputOptions.failOn;
          } else {
            throw is.invalidParameterError("failOn", "one of: none, truncated, error, warning", inputOptions.failOn);
          }
        }
        if (is.defined(inputOptions.density)) {
          if (is.inRange(inputOptions.density, 1, 1e5)) {
            inputDescriptor.density = inputOptions.density;
          } else {
            throw is.invalidParameterError("density", "number between 1 and 100000", inputOptions.density);
          }
        }
        if (is.defined(inputOptions.ignoreIcc)) {
          if (is.bool(inputOptions.ignoreIcc)) {
            inputDescriptor.ignoreIcc = inputOptions.ignoreIcc;
          } else {
            throw is.invalidParameterError("ignoreIcc", "boolean", inputOptions.ignoreIcc);
          }
        }
        if (is.defined(inputOptions.limitInputPixels)) {
          if (is.bool(inputOptions.limitInputPixels)) {
            inputDescriptor.limitInputPixels = inputOptions.limitInputPixels ? Math.pow(16383, 2) : 0;
          } else if (is.integer(inputOptions.limitInputPixels) && is.inRange(inputOptions.limitInputPixels, 0, Number.MAX_SAFE_INTEGER)) {
            inputDescriptor.limitInputPixels = inputOptions.limitInputPixels;
          } else {
            throw is.invalidParameterError("limitInputPixels", "positive integer", inputOptions.limitInputPixels);
          }
        }
        if (is.defined(inputOptions.unlimited)) {
          if (is.bool(inputOptions.unlimited)) {
            inputDescriptor.unlimited = inputOptions.unlimited;
          } else {
            throw is.invalidParameterError("unlimited", "boolean", inputOptions.unlimited);
          }
        }
        if (is.defined(inputOptions.sequentialRead)) {
          if (is.bool(inputOptions.sequentialRead)) {
            inputDescriptor.sequentialRead = inputOptions.sequentialRead;
          } else {
            throw is.invalidParameterError("sequentialRead", "boolean", inputOptions.sequentialRead);
          }
        }
        if (is.defined(inputOptions.raw)) {
          if (is.object(inputOptions.raw) && is.integer(inputOptions.raw.width) && inputOptions.raw.width > 0 && is.integer(inputOptions.raw.height) && inputOptions.raw.height > 0 && is.integer(inputOptions.raw.channels) && is.inRange(inputOptions.raw.channels, 1, 4)) {
            inputDescriptor.rawWidth = inputOptions.raw.width;
            inputDescriptor.rawHeight = inputOptions.raw.height;
            inputDescriptor.rawChannels = inputOptions.raw.channels;
            inputDescriptor.rawPremultiplied = !!inputOptions.raw.premultiplied;
            switch (input.constructor) {
              case Uint8Array:
              case Uint8ClampedArray:
                inputDescriptor.rawDepth = "uchar";
                break;
              case Int8Array:
                inputDescriptor.rawDepth = "char";
                break;
              case Uint16Array:
                inputDescriptor.rawDepth = "ushort";
                break;
              case Int16Array:
                inputDescriptor.rawDepth = "short";
                break;
              case Uint32Array:
                inputDescriptor.rawDepth = "uint";
                break;
              case Int32Array:
                inputDescriptor.rawDepth = "int";
                break;
              case Float32Array:
                inputDescriptor.rawDepth = "float";
                break;
              case Float64Array:
                inputDescriptor.rawDepth = "double";
                break;
              default:
                inputDescriptor.rawDepth = "uchar";
                break;
            }
          } else {
            throw new Error("Expected width, height and channels for raw pixel input");
          }
        }
        if (is.defined(inputOptions.animated)) {
          if (is.bool(inputOptions.animated)) {
            inputDescriptor.pages = inputOptions.animated ? -1 : 1;
          } else {
            throw is.invalidParameterError("animated", "boolean", inputOptions.animated);
          }
        }
        if (is.defined(inputOptions.pages)) {
          if (is.integer(inputOptions.pages) && is.inRange(inputOptions.pages, -1, 1e5)) {
            inputDescriptor.pages = inputOptions.pages;
          } else {
            throw is.invalidParameterError("pages", "integer between -1 and 100000", inputOptions.pages);
          }
        }
        if (is.defined(inputOptions.page)) {
          if (is.integer(inputOptions.page) && is.inRange(inputOptions.page, 0, 1e5)) {
            inputDescriptor.page = inputOptions.page;
          } else {
            throw is.invalidParameterError("page", "integer between 0 and 100000", inputOptions.page);
          }
        }
        if (is.defined(inputOptions.level)) {
          if (is.integer(inputOptions.level) && is.inRange(inputOptions.level, 0, 256)) {
            inputDescriptor.level = inputOptions.level;
          } else {
            throw is.invalidParameterError("level", "integer between 0 and 256", inputOptions.level);
          }
        }
        if (is.defined(inputOptions.subifd)) {
          if (is.integer(inputOptions.subifd) && is.inRange(inputOptions.subifd, -1, 1e5)) {
            inputDescriptor.subifd = inputOptions.subifd;
          } else {
            throw is.invalidParameterError("subifd", "integer between -1 and 100000", inputOptions.subifd);
          }
        }
        if (is.defined(inputOptions.create)) {
          if (is.object(inputOptions.create) && is.integer(inputOptions.create.width) && inputOptions.create.width > 0 && is.integer(inputOptions.create.height) && inputOptions.create.height > 0 && is.integer(inputOptions.create.channels)) {
            inputDescriptor.createWidth = inputOptions.create.width;
            inputDescriptor.createHeight = inputOptions.create.height;
            inputDescriptor.createChannels = inputOptions.create.channels;
            if (is.defined(inputOptions.create.noise)) {
              if (!is.object(inputOptions.create.noise)) {
                throw new Error("Expected noise to be an object");
              }
              if (!is.inArray(inputOptions.create.noise.type, ["gaussian"])) {
                throw new Error("Only gaussian noise is supported at the moment");
              }
              if (!is.inRange(inputOptions.create.channels, 1, 4)) {
                throw is.invalidParameterError("create.channels", "number between 1 and 4", inputOptions.create.channels);
              }
              inputDescriptor.createNoiseType = inputOptions.create.noise.type;
              if (is.number(inputOptions.create.noise.mean) && is.inRange(inputOptions.create.noise.mean, 0, 1e4)) {
                inputDescriptor.createNoiseMean = inputOptions.create.noise.mean;
              } else {
                throw is.invalidParameterError("create.noise.mean", "number between 0 and 10000", inputOptions.create.noise.mean);
              }
              if (is.number(inputOptions.create.noise.sigma) && is.inRange(inputOptions.create.noise.sigma, 0, 1e4)) {
                inputDescriptor.createNoiseSigma = inputOptions.create.noise.sigma;
              } else {
                throw is.invalidParameterError("create.noise.sigma", "number between 0 and 10000", inputOptions.create.noise.sigma);
              }
            } else if (is.defined(inputOptions.create.background)) {
              if (!is.inRange(inputOptions.create.channels, 3, 4)) {
                throw is.invalidParameterError("create.channels", "number between 3 and 4", inputOptions.create.channels);
              }
              const background = color(inputOptions.create.background);
              inputDescriptor.createBackground = [
                background.red(),
                background.green(),
                background.blue(),
                Math.round(background.alpha() * 255)
              ];
            } else {
              throw new Error("Expected valid noise or background to create a new input image");
            }
            delete inputDescriptor.buffer;
          } else {
            throw new Error("Expected valid width, height and channels to create a new input image");
          }
        }
        if (is.defined(inputOptions.text)) {
          if (is.object(inputOptions.text) && is.string(inputOptions.text.text)) {
            inputDescriptor.textValue = inputOptions.text.text;
            if (is.defined(inputOptions.text.height) && is.defined(inputOptions.text.dpi)) {
              throw new Error("Expected only one of dpi or height");
            }
            if (is.defined(inputOptions.text.font)) {
              if (is.string(inputOptions.text.font)) {
                inputDescriptor.textFont = inputOptions.text.font;
              } else {
                throw is.invalidParameterError("text.font", "string", inputOptions.text.font);
              }
            }
            if (is.defined(inputOptions.text.fontfile)) {
              if (is.string(inputOptions.text.fontfile)) {
                inputDescriptor.textFontfile = inputOptions.text.fontfile;
              } else {
                throw is.invalidParameterError("text.fontfile", "string", inputOptions.text.fontfile);
              }
            }
            if (is.defined(inputOptions.text.width)) {
              if (is.integer(inputOptions.text.width) && inputOptions.text.width > 0) {
                inputDescriptor.textWidth = inputOptions.text.width;
              } else {
                throw is.invalidParameterError("text.width", "positive integer", inputOptions.text.width);
              }
            }
            if (is.defined(inputOptions.text.height)) {
              if (is.integer(inputOptions.text.height) && inputOptions.text.height > 0) {
                inputDescriptor.textHeight = inputOptions.text.height;
              } else {
                throw is.invalidParameterError("text.height", "positive integer", inputOptions.text.height);
              }
            }
            if (is.defined(inputOptions.text.align)) {
              if (is.string(inputOptions.text.align) && is.string(this.constructor.align[inputOptions.text.align])) {
                inputDescriptor.textAlign = this.constructor.align[inputOptions.text.align];
              } else {
                throw is.invalidParameterError("text.align", "valid alignment", inputOptions.text.align);
              }
            }
            if (is.defined(inputOptions.text.justify)) {
              if (is.bool(inputOptions.text.justify)) {
                inputDescriptor.textJustify = inputOptions.text.justify;
              } else {
                throw is.invalidParameterError("text.justify", "boolean", inputOptions.text.justify);
              }
            }
            if (is.defined(inputOptions.text.dpi)) {
              if (is.integer(inputOptions.text.dpi) && is.inRange(inputOptions.text.dpi, 1, 1e6)) {
                inputDescriptor.textDpi = inputOptions.text.dpi;
              } else {
                throw is.invalidParameterError("text.dpi", "integer between 1 and 1000000", inputOptions.text.dpi);
              }
            }
            if (is.defined(inputOptions.text.rgba)) {
              if (is.bool(inputOptions.text.rgba)) {
                inputDescriptor.textRgba = inputOptions.text.rgba;
              } else {
                throw is.invalidParameterError("text.rgba", "bool", inputOptions.text.rgba);
              }
            }
            if (is.defined(inputOptions.text.spacing)) {
              if (is.integer(inputOptions.text.spacing) && is.inRange(inputOptions.text.spacing, -1e6, 1e6)) {
                inputDescriptor.textSpacing = inputOptions.text.spacing;
              } else {
                throw is.invalidParameterError("text.spacing", "integer between -1000000 and 1000000", inputOptions.text.spacing);
              }
            }
            if (is.defined(inputOptions.text.wrap)) {
              if (is.string(inputOptions.text.wrap) && is.inArray(inputOptions.text.wrap, ["word", "char", "word-char", "none"])) {
                inputDescriptor.textWrap = inputOptions.text.wrap;
              } else {
                throw is.invalidParameterError("text.wrap", "one of: word, char, word-char, none", inputOptions.text.wrap);
              }
            }
            delete inputDescriptor.buffer;
          } else {
            throw new Error("Expected a valid string to create an image with text.");
          }
        }
      } else if (is.defined(inputOptions)) {
        throw new Error("Invalid input options " + inputOptions);
      }
      return inputDescriptor;
    }
    function _write(chunk, encoding, callback) {
      if (Array.isArray(this.options.input.buffer)) {
        if (is.buffer(chunk)) {
          if (this.options.input.buffer.length === 0) {
            this.on("finish", () => {
              this.streamInFinished = true;
            });
          }
          this.options.input.buffer.push(chunk);
          callback();
        } else {
          callback(new Error("Non-Buffer data on Writable Stream"));
        }
      } else {
        callback(new Error("Unexpected data on Writable Stream"));
      }
    }
    function _flattenBufferIn() {
      if (this._isStreamInput()) {
        this.options.input.buffer = Buffer.concat(this.options.input.buffer);
      }
    }
    function _isStreamInput() {
      return Array.isArray(this.options.input.buffer);
    }
    function metadata(callback) {
      const stack = Error();
      if (is.fn(callback)) {
        if (this._isStreamInput()) {
          this.on("finish", () => {
            this._flattenBufferIn();
            sharp.metadata(this.options, (err, metadata2) => {
              if (err) {
                callback(is.nativeError(err, stack));
              } else {
                callback(null, metadata2);
              }
            });
          });
        } else {
          sharp.metadata(this.options, (err, metadata2) => {
            if (err) {
              callback(is.nativeError(err, stack));
            } else {
              callback(null, metadata2);
            }
          });
        }
        return this;
      } else {
        if (this._isStreamInput()) {
          return new Promise((resolve3, reject) => {
            const finished = () => {
              this._flattenBufferIn();
              sharp.metadata(this.options, (err, metadata2) => {
                if (err) {
                  reject(is.nativeError(err, stack));
                } else {
                  resolve3(metadata2);
                }
              });
            };
            if (this.writableFinished) {
              finished();
            } else {
              this.once("finish", finished);
            }
          });
        } else {
          return new Promise((resolve3, reject) => {
            sharp.metadata(this.options, (err, metadata2) => {
              if (err) {
                reject(is.nativeError(err, stack));
              } else {
                resolve3(metadata2);
              }
            });
          });
        }
      }
    }
    function stats(callback) {
      const stack = Error();
      if (is.fn(callback)) {
        if (this._isStreamInput()) {
          this.on("finish", () => {
            this._flattenBufferIn();
            sharp.stats(this.options, (err, stats2) => {
              if (err) {
                callback(is.nativeError(err, stack));
              } else {
                callback(null, stats2);
              }
            });
          });
        } else {
          sharp.stats(this.options, (err, stats2) => {
            if (err) {
              callback(is.nativeError(err, stack));
            } else {
              callback(null, stats2);
            }
          });
        }
        return this;
      } else {
        if (this._isStreamInput()) {
          return new Promise((resolve3, reject) => {
            this.on("finish", function() {
              this._flattenBufferIn();
              sharp.stats(this.options, (err, stats2) => {
                if (err) {
                  reject(is.nativeError(err, stack));
                } else {
                  resolve3(stats2);
                }
              });
            });
          });
        } else {
          return new Promise((resolve3, reject) => {
            sharp.stats(this.options, (err, stats2) => {
              if (err) {
                reject(is.nativeError(err, stack));
              } else {
                resolve3(stats2);
              }
            });
          });
        }
      }
    }
    module.exports = function(Sharp) {
      Object.assign(Sharp.prototype, {
        // Private
        _inputOptionsFromObject,
        _createInputDescriptor,
        _write,
        _flattenBufferIn,
        _isStreamInput,
        // Public
        metadata,
        stats
      });
      Sharp.align = align;
    };
  }
});

// node_modules/sharp/lib/resize.js
var require_resize = __commonJS({
  "node_modules/sharp/lib/resize.js"(exports, module) {
    "use strict";
    var is = require_is();
    var gravity = {
      center: 0,
      centre: 0,
      north: 1,
      east: 2,
      south: 3,
      west: 4,
      northeast: 5,
      southeast: 6,
      southwest: 7,
      northwest: 8
    };
    var position = {
      top: 1,
      right: 2,
      bottom: 3,
      left: 4,
      "right top": 5,
      "right bottom": 6,
      "left bottom": 7,
      "left top": 8
    };
    var extendWith = {
      background: "background",
      copy: "copy",
      repeat: "repeat",
      mirror: "mirror"
    };
    var strategy = {
      entropy: 16,
      attention: 17
    };
    var kernel = {
      nearest: "nearest",
      linear: "linear",
      cubic: "cubic",
      mitchell: "mitchell",
      lanczos2: "lanczos2",
      lanczos3: "lanczos3"
    };
    var fit = {
      contain: "contain",
      cover: "cover",
      fill: "fill",
      inside: "inside",
      outside: "outside"
    };
    var mapFitToCanvas = {
      contain: "embed",
      cover: "crop",
      fill: "ignore_aspect",
      inside: "max",
      outside: "min"
    };
    function isRotationExpected(options) {
      return options.angle % 360 !== 0 || options.useExifOrientation === true || options.rotationAngle !== 0;
    }
    function isResizeExpected(options) {
      return options.width !== -1 || options.height !== -1;
    }
    function resize(widthOrOptions, height, options) {
      if (isResizeExpected(this.options)) {
        this.options.debuglog("ignoring previous resize options");
      }
      if (this.options.widthPost !== -1) {
        this.options.debuglog("operation order will be: extract, resize, extract");
      }
      if (is.defined(widthOrOptions)) {
        if (is.object(widthOrOptions) && !is.defined(options)) {
          options = widthOrOptions;
        } else if (is.integer(widthOrOptions) && widthOrOptions > 0) {
          this.options.width = widthOrOptions;
        } else {
          throw is.invalidParameterError("width", "positive integer", widthOrOptions);
        }
      } else {
        this.options.width = -1;
      }
      if (is.defined(height)) {
        if (is.integer(height) && height > 0) {
          this.options.height = height;
        } else {
          throw is.invalidParameterError("height", "positive integer", height);
        }
      } else {
        this.options.height = -1;
      }
      if (is.object(options)) {
        if (is.defined(options.width)) {
          if (is.integer(options.width) && options.width > 0) {
            this.options.width = options.width;
          } else {
            throw is.invalidParameterError("width", "positive integer", options.width);
          }
        }
        if (is.defined(options.height)) {
          if (is.integer(options.height) && options.height > 0) {
            this.options.height = options.height;
          } else {
            throw is.invalidParameterError("height", "positive integer", options.height);
          }
        }
        if (is.defined(options.fit)) {
          const canvas = mapFitToCanvas[options.fit];
          if (is.string(canvas)) {
            this.options.canvas = canvas;
          } else {
            throw is.invalidParameterError("fit", "valid fit", options.fit);
          }
        }
        if (is.defined(options.position)) {
          const pos = is.integer(options.position) ? options.position : strategy[options.position] || position[options.position] || gravity[options.position];
          if (is.integer(pos) && (is.inRange(pos, 0, 8) || is.inRange(pos, 16, 17))) {
            this.options.position = pos;
          } else {
            throw is.invalidParameterError("position", "valid position/gravity/strategy", options.position);
          }
        }
        this._setBackgroundColourOption("resizeBackground", options.background);
        if (is.defined(options.kernel)) {
          if (is.string(kernel[options.kernel])) {
            this.options.kernel = kernel[options.kernel];
          } else {
            throw is.invalidParameterError("kernel", "valid kernel name", options.kernel);
          }
        }
        if (is.defined(options.withoutEnlargement)) {
          this._setBooleanOption("withoutEnlargement", options.withoutEnlargement);
        }
        if (is.defined(options.withoutReduction)) {
          this._setBooleanOption("withoutReduction", options.withoutReduction);
        }
        if (is.defined(options.fastShrinkOnLoad)) {
          this._setBooleanOption("fastShrinkOnLoad", options.fastShrinkOnLoad);
        }
      }
      if (isRotationExpected(this.options) && isResizeExpected(this.options)) {
        this.options.rotateBeforePreExtract = true;
      }
      return this;
    }
    function extend(extend2) {
      if (is.integer(extend2) && extend2 > 0) {
        this.options.extendTop = extend2;
        this.options.extendBottom = extend2;
        this.options.extendLeft = extend2;
        this.options.extendRight = extend2;
      } else if (is.object(extend2)) {
        if (is.defined(extend2.top)) {
          if (is.integer(extend2.top) && extend2.top >= 0) {
            this.options.extendTop = extend2.top;
          } else {
            throw is.invalidParameterError("top", "positive integer", extend2.top);
          }
        }
        if (is.defined(extend2.bottom)) {
          if (is.integer(extend2.bottom) && extend2.bottom >= 0) {
            this.options.extendBottom = extend2.bottom;
          } else {
            throw is.invalidParameterError("bottom", "positive integer", extend2.bottom);
          }
        }
        if (is.defined(extend2.left)) {
          if (is.integer(extend2.left) && extend2.left >= 0) {
            this.options.extendLeft = extend2.left;
          } else {
            throw is.invalidParameterError("left", "positive integer", extend2.left);
          }
        }
        if (is.defined(extend2.right)) {
          if (is.integer(extend2.right) && extend2.right >= 0) {
            this.options.extendRight = extend2.right;
          } else {
            throw is.invalidParameterError("right", "positive integer", extend2.right);
          }
        }
        this._setBackgroundColourOption("extendBackground", extend2.background);
        if (is.defined(extend2.extendWith)) {
          if (is.string(extendWith[extend2.extendWith])) {
            this.options.extendWith = extendWith[extend2.extendWith];
          } else {
            throw is.invalidParameterError("extendWith", "one of: background, copy, repeat, mirror", extend2.extendWith);
          }
        }
      } else {
        throw is.invalidParameterError("extend", "integer or object", extend2);
      }
      return this;
    }
    function extract(options) {
      const suffix = isResizeExpected(this.options) || this.options.widthPre !== -1 ? "Post" : "Pre";
      if (this.options[`width${suffix}`] !== -1) {
        this.options.debuglog("ignoring previous extract options");
      }
      ["left", "top", "width", "height"].forEach(function(name) {
        const value = options[name];
        if (is.integer(value) && value >= 0) {
          this.options[name + (name === "left" || name === "top" ? "Offset" : "") + suffix] = value;
        } else {
          throw is.invalidParameterError(name, "integer", value);
        }
      }, this);
      if (isRotationExpected(this.options) && !isResizeExpected(this.options)) {
        if (this.options.widthPre === -1 || this.options.widthPost === -1) {
          this.options.rotateBeforePreExtract = true;
        }
      }
      return this;
    }
    function trim(options) {
      this.options.trimThreshold = 10;
      if (is.defined(options)) {
        if (is.object(options)) {
          if (is.defined(options.background)) {
            this._setBackgroundColourOption("trimBackground", options.background);
          }
          if (is.defined(options.threshold)) {
            if (is.number(options.threshold) && options.threshold >= 0) {
              this.options.trimThreshold = options.threshold;
            } else {
              throw is.invalidParameterError("threshold", "positive number", options.threshold);
            }
          }
          if (is.defined(options.lineArt)) {
            this._setBooleanOption("trimLineArt", options.lineArt);
          }
        } else {
          throw is.invalidParameterError("trim", "object", options);
        }
      }
      if (isRotationExpected(this.options)) {
        this.options.rotateBeforePreExtract = true;
      }
      return this;
    }
    module.exports = function(Sharp) {
      Object.assign(Sharp.prototype, {
        resize,
        extend,
        extract,
        trim
      });
      Sharp.gravity = gravity;
      Sharp.strategy = strategy;
      Sharp.kernel = kernel;
      Sharp.fit = fit;
      Sharp.position = position;
    };
  }
});

// node_modules/sharp/lib/composite.js
var require_composite = __commonJS({
  "node_modules/sharp/lib/composite.js"(exports, module) {
    "use strict";
    var is = require_is();
    var blend = {
      clear: "clear",
      source: "source",
      over: "over",
      in: "in",
      out: "out",
      atop: "atop",
      dest: "dest",
      "dest-over": "dest-over",
      "dest-in": "dest-in",
      "dest-out": "dest-out",
      "dest-atop": "dest-atop",
      xor: "xor",
      add: "add",
      saturate: "saturate",
      multiply: "multiply",
      screen: "screen",
      overlay: "overlay",
      darken: "darken",
      lighten: "lighten",
      "colour-dodge": "colour-dodge",
      "color-dodge": "colour-dodge",
      "colour-burn": "colour-burn",
      "color-burn": "colour-burn",
      "hard-light": "hard-light",
      "soft-light": "soft-light",
      difference: "difference",
      exclusion: "exclusion"
    };
    function composite(images) {
      if (!Array.isArray(images)) {
        throw is.invalidParameterError("images to composite", "array", images);
      }
      this.options.composite = images.map((image) => {
        if (!is.object(image)) {
          throw is.invalidParameterError("image to composite", "object", image);
        }
        const inputOptions = this._inputOptionsFromObject(image);
        const composite2 = {
          input: this._createInputDescriptor(image.input, inputOptions, { allowStream: false }),
          blend: "over",
          tile: false,
          left: 0,
          top: 0,
          hasOffset: false,
          gravity: 0,
          premultiplied: false
        };
        if (is.defined(image.blend)) {
          if (is.string(blend[image.blend])) {
            composite2.blend = blend[image.blend];
          } else {
            throw is.invalidParameterError("blend", "valid blend name", image.blend);
          }
        }
        if (is.defined(image.tile)) {
          if (is.bool(image.tile)) {
            composite2.tile = image.tile;
          } else {
            throw is.invalidParameterError("tile", "boolean", image.tile);
          }
        }
        if (is.defined(image.left)) {
          if (is.integer(image.left)) {
            composite2.left = image.left;
          } else {
            throw is.invalidParameterError("left", "integer", image.left);
          }
        }
        if (is.defined(image.top)) {
          if (is.integer(image.top)) {
            composite2.top = image.top;
          } else {
            throw is.invalidParameterError("top", "integer", image.top);
          }
        }
        if (is.defined(image.top) !== is.defined(image.left)) {
          throw new Error("Expected both left and top to be set");
        } else {
          composite2.hasOffset = is.integer(image.top) && is.integer(image.left);
        }
        if (is.defined(image.gravity)) {
          if (is.integer(image.gravity) && is.inRange(image.gravity, 0, 8)) {
            composite2.gravity = image.gravity;
          } else if (is.string(image.gravity) && is.integer(this.constructor.gravity[image.gravity])) {
            composite2.gravity = this.constructor.gravity[image.gravity];
          } else {
            throw is.invalidParameterError("gravity", "valid gravity", image.gravity);
          }
        }
        if (is.defined(image.premultiplied)) {
          if (is.bool(image.premultiplied)) {
            composite2.premultiplied = image.premultiplied;
          } else {
            throw is.invalidParameterError("premultiplied", "boolean", image.premultiplied);
          }
        }
        return composite2;
      });
      return this;
    }
    module.exports = function(Sharp) {
      Sharp.prototype.composite = composite;
      Sharp.blend = blend;
    };
  }
});

// node_modules/sharp/lib/operation.js
var require_operation = __commonJS({
  "node_modules/sharp/lib/operation.js"(exports, module) {
    "use strict";
    var color = require_color();
    var is = require_is();
    var vipsPrecision = {
      integer: "integer",
      float: "float",
      approximate: "approximate"
    };
    function rotate(angle, options) {
      if (this.options.useExifOrientation || this.options.angle || this.options.rotationAngle) {
        this.options.debuglog("ignoring previous rotate options");
      }
      if (!is.defined(angle)) {
        this.options.useExifOrientation = true;
      } else if (is.integer(angle) && !(angle % 90)) {
        this.options.angle = angle;
      } else if (is.number(angle)) {
        this.options.rotationAngle = angle;
        if (is.object(options) && options.background) {
          const backgroundColour = color(options.background);
          this.options.rotationBackground = [
            backgroundColour.red(),
            backgroundColour.green(),
            backgroundColour.blue(),
            Math.round(backgroundColour.alpha() * 255)
          ];
        }
      } else {
        throw is.invalidParameterError("angle", "numeric", angle);
      }
      return this;
    }
    function flip(flip2) {
      this.options.flip = is.bool(flip2) ? flip2 : true;
      return this;
    }
    function flop(flop2) {
      this.options.flop = is.bool(flop2) ? flop2 : true;
      return this;
    }
    function affine(matrix, options) {
      const flatMatrix = [].concat(...matrix);
      if (flatMatrix.length === 4 && flatMatrix.every(is.number)) {
        this.options.affineMatrix = flatMatrix;
      } else {
        throw is.invalidParameterError("matrix", "1x4 or 2x2 array", matrix);
      }
      if (is.defined(options)) {
        if (is.object(options)) {
          this._setBackgroundColourOption("affineBackground", options.background);
          if (is.defined(options.idx)) {
            if (is.number(options.idx)) {
              this.options.affineIdx = options.idx;
            } else {
              throw is.invalidParameterError("options.idx", "number", options.idx);
            }
          }
          if (is.defined(options.idy)) {
            if (is.number(options.idy)) {
              this.options.affineIdy = options.idy;
            } else {
              throw is.invalidParameterError("options.idy", "number", options.idy);
            }
          }
          if (is.defined(options.odx)) {
            if (is.number(options.odx)) {
              this.options.affineOdx = options.odx;
            } else {
              throw is.invalidParameterError("options.odx", "number", options.odx);
            }
          }
          if (is.defined(options.ody)) {
            if (is.number(options.ody)) {
              this.options.affineOdy = options.ody;
            } else {
              throw is.invalidParameterError("options.ody", "number", options.ody);
            }
          }
          if (is.defined(options.interpolator)) {
            if (is.inArray(options.interpolator, Object.values(this.constructor.interpolators))) {
              this.options.affineInterpolator = options.interpolator;
            } else {
              throw is.invalidParameterError("options.interpolator", "valid interpolator name", options.interpolator);
            }
          }
        } else {
          throw is.invalidParameterError("options", "object", options);
        }
      }
      return this;
    }
    function sharpen(options, flat, jagged) {
      if (!is.defined(options)) {
        this.options.sharpenSigma = -1;
      } else if (is.bool(options)) {
        this.options.sharpenSigma = options ? -1 : 0;
      } else if (is.number(options) && is.inRange(options, 0.01, 1e4)) {
        this.options.sharpenSigma = options;
        if (is.defined(flat)) {
          if (is.number(flat) && is.inRange(flat, 0, 1e4)) {
            this.options.sharpenM1 = flat;
          } else {
            throw is.invalidParameterError("flat", "number between 0 and 10000", flat);
          }
        }
        if (is.defined(jagged)) {
          if (is.number(jagged) && is.inRange(jagged, 0, 1e4)) {
            this.options.sharpenM2 = jagged;
          } else {
            throw is.invalidParameterError("jagged", "number between 0 and 10000", jagged);
          }
        }
      } else if (is.plainObject(options)) {
        if (is.number(options.sigma) && is.inRange(options.sigma, 1e-6, 10)) {
          this.options.sharpenSigma = options.sigma;
        } else {
          throw is.invalidParameterError("options.sigma", "number between 0.000001 and 10", options.sigma);
        }
        if (is.defined(options.m1)) {
          if (is.number(options.m1) && is.inRange(options.m1, 0, 1e6)) {
            this.options.sharpenM1 = options.m1;
          } else {
            throw is.invalidParameterError("options.m1", "number between 0 and 1000000", options.m1);
          }
        }
        if (is.defined(options.m2)) {
          if (is.number(options.m2) && is.inRange(options.m2, 0, 1e6)) {
            this.options.sharpenM2 = options.m2;
          } else {
            throw is.invalidParameterError("options.m2", "number between 0 and 1000000", options.m2);
          }
        }
        if (is.defined(options.x1)) {
          if (is.number(options.x1) && is.inRange(options.x1, 0, 1e6)) {
            this.options.sharpenX1 = options.x1;
          } else {
            throw is.invalidParameterError("options.x1", "number between 0 and 1000000", options.x1);
          }
        }
        if (is.defined(options.y2)) {
          if (is.number(options.y2) && is.inRange(options.y2, 0, 1e6)) {
            this.options.sharpenY2 = options.y2;
          } else {
            throw is.invalidParameterError("options.y2", "number between 0 and 1000000", options.y2);
          }
        }
        if (is.defined(options.y3)) {
          if (is.number(options.y3) && is.inRange(options.y3, 0, 1e6)) {
            this.options.sharpenY3 = options.y3;
          } else {
            throw is.invalidParameterError("options.y3", "number between 0 and 1000000", options.y3);
          }
        }
      } else {
        throw is.invalidParameterError("sigma", "number between 0.01 and 10000", options);
      }
      return this;
    }
    function median(size) {
      if (!is.defined(size)) {
        this.options.medianSize = 3;
      } else if (is.integer(size) && is.inRange(size, 1, 1e3)) {
        this.options.medianSize = size;
      } else {
        throw is.invalidParameterError("size", "integer between 1 and 1000", size);
      }
      return this;
    }
    function blur(options) {
      let sigma;
      if (is.number(options)) {
        sigma = options;
      } else if (is.plainObject(options)) {
        if (!is.number(options.sigma)) {
          throw is.invalidParameterError("options.sigma", "number between 0.3 and 1000", sigma);
        }
        sigma = options.sigma;
        if ("precision" in options) {
          if (is.string(vipsPrecision[options.precision])) {
            this.options.precision = vipsPrecision[options.precision];
          } else {
            throw is.invalidParameterError("precision", "one of: integer, float, approximate", options.precision);
          }
        }
        if ("minAmplitude" in options) {
          if (is.number(options.minAmplitude) && is.inRange(options.minAmplitude, 1e-3, 1)) {
            this.options.minAmpl = options.minAmplitude;
          } else {
            throw is.invalidParameterError("minAmplitude", "number between 0.001 and 1", options.minAmplitude);
          }
        }
      }
      if (!is.defined(options)) {
        this.options.blurSigma = -1;
      } else if (is.bool(options)) {
        this.options.blurSigma = options ? -1 : 0;
      } else if (is.number(sigma) && is.inRange(sigma, 0.3, 1e3)) {
        this.options.blurSigma = sigma;
      } else {
        throw is.invalidParameterError("sigma", "number between 0.3 and 1000", sigma);
      }
      return this;
    }
    function flatten(options) {
      this.options.flatten = is.bool(options) ? options : true;
      if (is.object(options)) {
        this._setBackgroundColourOption("flattenBackground", options.background);
      }
      return this;
    }
    function unflatten() {
      this.options.unflatten = true;
      return this;
    }
    function gamma(gamma2, gammaOut) {
      if (!is.defined(gamma2)) {
        this.options.gamma = 2.2;
      } else if (is.number(gamma2) && is.inRange(gamma2, 1, 3)) {
        this.options.gamma = gamma2;
      } else {
        throw is.invalidParameterError("gamma", "number between 1.0 and 3.0", gamma2);
      }
      if (!is.defined(gammaOut)) {
        this.options.gammaOut = this.options.gamma;
      } else if (is.number(gammaOut) && is.inRange(gammaOut, 1, 3)) {
        this.options.gammaOut = gammaOut;
      } else {
        throw is.invalidParameterError("gammaOut", "number between 1.0 and 3.0", gammaOut);
      }
      return this;
    }
    function negate(options) {
      this.options.negate = is.bool(options) ? options : true;
      if (is.plainObject(options) && "alpha" in options) {
        if (!is.bool(options.alpha)) {
          throw is.invalidParameterError("alpha", "should be boolean value", options.alpha);
        } else {
          this.options.negateAlpha = options.alpha;
        }
      }
      return this;
    }
    function normalise(options) {
      if (is.plainObject(options)) {
        if (is.defined(options.lower)) {
          if (is.number(options.lower) && is.inRange(options.lower, 0, 99)) {
            this.options.normaliseLower = options.lower;
          } else {
            throw is.invalidParameterError("lower", "number between 0 and 99", options.lower);
          }
        }
        if (is.defined(options.upper)) {
          if (is.number(options.upper) && is.inRange(options.upper, 1, 100)) {
            this.options.normaliseUpper = options.upper;
          } else {
            throw is.invalidParameterError("upper", "number between 1 and 100", options.upper);
          }
        }
      }
      if (this.options.normaliseLower >= this.options.normaliseUpper) {
        throw is.invalidParameterError(
          "range",
          "lower to be less than upper",
          `${this.options.normaliseLower} >= ${this.options.normaliseUpper}`
        );
      }
      this.options.normalise = true;
      return this;
    }
    function normalize(options) {
      return this.normalise(options);
    }
    function clahe(options) {
      if (is.plainObject(options)) {
        if (is.integer(options.width) && options.width > 0) {
          this.options.claheWidth = options.width;
        } else {
          throw is.invalidParameterError("width", "integer greater than zero", options.width);
        }
        if (is.integer(options.height) && options.height > 0) {
          this.options.claheHeight = options.height;
        } else {
          throw is.invalidParameterError("height", "integer greater than zero", options.height);
        }
        if (is.defined(options.maxSlope)) {
          if (is.integer(options.maxSlope) && is.inRange(options.maxSlope, 0, 100)) {
            this.options.claheMaxSlope = options.maxSlope;
          } else {
            throw is.invalidParameterError("maxSlope", "integer between 0 and 100", options.maxSlope);
          }
        }
      } else {
        throw is.invalidParameterError("options", "plain object", options);
      }
      return this;
    }
    function convolve(kernel) {
      if (!is.object(kernel) || !Array.isArray(kernel.kernel) || !is.integer(kernel.width) || !is.integer(kernel.height) || !is.inRange(kernel.width, 3, 1001) || !is.inRange(kernel.height, 3, 1001) || kernel.height * kernel.width !== kernel.kernel.length) {
        throw new Error("Invalid convolution kernel");
      }
      if (!is.integer(kernel.scale)) {
        kernel.scale = kernel.kernel.reduce(function(a, b) {
          return a + b;
        }, 0);
      }
      if (kernel.scale < 1) {
        kernel.scale = 1;
      }
      if (!is.integer(kernel.offset)) {
        kernel.offset = 0;
      }
      this.options.convKernel = kernel;
      return this;
    }
    function threshold(threshold2, options) {
      if (!is.defined(threshold2)) {
        this.options.threshold = 128;
      } else if (is.bool(threshold2)) {
        this.options.threshold = threshold2 ? 128 : 0;
      } else if (is.integer(threshold2) && is.inRange(threshold2, 0, 255)) {
        this.options.threshold = threshold2;
      } else {
        throw is.invalidParameterError("threshold", "integer between 0 and 255", threshold2);
      }
      if (!is.object(options) || options.greyscale === true || options.grayscale === true) {
        this.options.thresholdGrayscale = true;
      } else {
        this.options.thresholdGrayscale = false;
      }
      return this;
    }
    function boolean2(operand, operator, options) {
      this.options.boolean = this._createInputDescriptor(operand, options);
      if (is.string(operator) && is.inArray(operator, ["and", "or", "eor"])) {
        this.options.booleanOp = operator;
      } else {
        throw is.invalidParameterError("operator", "one of: and, or, eor", operator);
      }
      return this;
    }
    function linear(a, b) {
      if (!is.defined(a) && is.number(b)) {
        a = 1;
      } else if (is.number(a) && !is.defined(b)) {
        b = 0;
      }
      if (!is.defined(a)) {
        this.options.linearA = [];
      } else if (is.number(a)) {
        this.options.linearA = [a];
      } else if (Array.isArray(a) && a.length && a.every(is.number)) {
        this.options.linearA = a;
      } else {
        throw is.invalidParameterError("a", "number or array of numbers", a);
      }
      if (!is.defined(b)) {
        this.options.linearB = [];
      } else if (is.number(b)) {
        this.options.linearB = [b];
      } else if (Array.isArray(b) && b.length && b.every(is.number)) {
        this.options.linearB = b;
      } else {
        throw is.invalidParameterError("b", "number or array of numbers", b);
      }
      if (this.options.linearA.length !== this.options.linearB.length) {
        throw new Error("Expected a and b to be arrays of the same length");
      }
      return this;
    }
    function recomb(inputMatrix) {
      if (!Array.isArray(inputMatrix)) {
        throw is.invalidParameterError("inputMatrix", "array", inputMatrix);
      }
      if (inputMatrix.length !== 3 && inputMatrix.length !== 4) {
        throw is.invalidParameterError("inputMatrix", "3x3 or 4x4 array", inputMatrix.length);
      }
      const recombMatrix = inputMatrix.flat().map(Number);
      if (recombMatrix.length !== 9 && recombMatrix.length !== 16) {
        throw is.invalidParameterError("inputMatrix", "cardinality of 9 or 16", recombMatrix.length);
      }
      this.options.recombMatrix = recombMatrix;
      return this;
    }
    function modulate(options) {
      if (!is.plainObject(options)) {
        throw is.invalidParameterError("options", "plain object", options);
      }
      if ("brightness" in options) {
        if (is.number(options.brightness) && options.brightness >= 0) {
          this.options.brightness = options.brightness;
        } else {
          throw is.invalidParameterError("brightness", "number above zero", options.brightness);
        }
      }
      if ("saturation" in options) {
        if (is.number(options.saturation) && options.saturation >= 0) {
          this.options.saturation = options.saturation;
        } else {
          throw is.invalidParameterError("saturation", "number above zero", options.saturation);
        }
      }
      if ("hue" in options) {
        if (is.integer(options.hue)) {
          this.options.hue = options.hue % 360;
        } else {
          throw is.invalidParameterError("hue", "number", options.hue);
        }
      }
      if ("lightness" in options) {
        if (is.number(options.lightness)) {
          this.options.lightness = options.lightness;
        } else {
          throw is.invalidParameterError("lightness", "number", options.lightness);
        }
      }
      return this;
    }
    module.exports = function(Sharp) {
      Object.assign(Sharp.prototype, {
        rotate,
        flip,
        flop,
        affine,
        sharpen,
        median,
        blur,
        flatten,
        unflatten,
        gamma,
        negate,
        normalise,
        normalize,
        clahe,
        convolve,
        threshold,
        boolean: boolean2,
        linear,
        recomb,
        modulate
      });
    };
  }
});

// node_modules/sharp/lib/colour.js
var require_colour = __commonJS({
  "node_modules/sharp/lib/colour.js"(exports, module) {
    "use strict";
    var color = require_color();
    var is = require_is();
    var colourspace = {
      multiband: "multiband",
      "b-w": "b-w",
      bw: "b-w",
      cmyk: "cmyk",
      srgb: "srgb"
    };
    function tint(tint2) {
      this._setBackgroundColourOption("tint", tint2);
      return this;
    }
    function greyscale(greyscale2) {
      this.options.greyscale = is.bool(greyscale2) ? greyscale2 : true;
      return this;
    }
    function grayscale(grayscale2) {
      return this.greyscale(grayscale2);
    }
    function pipelineColourspace(colourspace2) {
      if (!is.string(colourspace2)) {
        throw is.invalidParameterError("colourspace", "string", colourspace2);
      }
      this.options.colourspacePipeline = colourspace2;
      return this;
    }
    function pipelineColorspace(colorspace) {
      return this.pipelineColourspace(colorspace);
    }
    function toColourspace(colourspace2) {
      if (!is.string(colourspace2)) {
        throw is.invalidParameterError("colourspace", "string", colourspace2);
      }
      this.options.colourspace = colourspace2;
      return this;
    }
    function toColorspace(colorspace) {
      return this.toColourspace(colorspace);
    }
    function _setBackgroundColourOption(key, value) {
      if (is.defined(value)) {
        if (is.object(value) || is.string(value)) {
          const colour = color(value);
          this.options[key] = [
            colour.red(),
            colour.green(),
            colour.blue(),
            Math.round(colour.alpha() * 255)
          ];
        } else {
          throw is.invalidParameterError("background", "object or string", value);
        }
      }
    }
    module.exports = function(Sharp) {
      Object.assign(Sharp.prototype, {
        // Public
        tint,
        greyscale,
        grayscale,
        pipelineColourspace,
        pipelineColorspace,
        toColourspace,
        toColorspace,
        // Private
        _setBackgroundColourOption
      });
      Sharp.colourspace = colourspace;
      Sharp.colorspace = colourspace;
    };
  }
});

// node_modules/sharp/lib/channel.js
var require_channel = __commonJS({
  "node_modules/sharp/lib/channel.js"(exports, module) {
    "use strict";
    var is = require_is();
    var bool = {
      and: "and",
      or: "or",
      eor: "eor"
    };
    function removeAlpha() {
      this.options.removeAlpha = true;
      return this;
    }
    function ensureAlpha(alpha) {
      if (is.defined(alpha)) {
        if (is.number(alpha) && is.inRange(alpha, 0, 1)) {
          this.options.ensureAlpha = alpha;
        } else {
          throw is.invalidParameterError("alpha", "number between 0 and 1", alpha);
        }
      } else {
        this.options.ensureAlpha = 1;
      }
      return this;
    }
    function extractChannel(channel) {
      const channelMap = { red: 0, green: 1, blue: 2, alpha: 3 };
      if (Object.keys(channelMap).includes(channel)) {
        channel = channelMap[channel];
      }
      if (is.integer(channel) && is.inRange(channel, 0, 4)) {
        this.options.extractChannel = channel;
      } else {
        throw is.invalidParameterError("channel", "integer or one of: red, green, blue, alpha", channel);
      }
      return this;
    }
    function joinChannel(images, options) {
      if (Array.isArray(images)) {
        images.forEach(function(image) {
          this.options.joinChannelIn.push(this._createInputDescriptor(image, options));
        }, this);
      } else {
        this.options.joinChannelIn.push(this._createInputDescriptor(images, options));
      }
      return this;
    }
    function bandbool(boolOp) {
      if (is.string(boolOp) && is.inArray(boolOp, ["and", "or", "eor"])) {
        this.options.bandBoolOp = boolOp;
      } else {
        throw is.invalidParameterError("boolOp", "one of: and, or, eor", boolOp);
      }
      return this;
    }
    module.exports = function(Sharp) {
      Object.assign(Sharp.prototype, {
        // Public instance functions
        removeAlpha,
        ensureAlpha,
        extractChannel,
        joinChannel,
        bandbool
      });
      Sharp.bool = bool;
    };
  }
});

// node_modules/sharp/lib/output.js
var require_output = __commonJS({
  "node_modules/sharp/lib/output.js"(exports, module) {
    "use strict";
    var path7 = __require("node:path");
    var is = require_is();
    var sharp = require_sharp();
    var formats = /* @__PURE__ */ new Map([
      ["heic", "heif"],
      ["heif", "heif"],
      ["avif", "avif"],
      ["jpeg", "jpeg"],
      ["jpg", "jpeg"],
      ["jpe", "jpeg"],
      ["tile", "tile"],
      ["dz", "tile"],
      ["png", "png"],
      ["raw", "raw"],
      ["tiff", "tiff"],
      ["tif", "tiff"],
      ["webp", "webp"],
      ["gif", "gif"],
      ["jp2", "jp2"],
      ["jpx", "jp2"],
      ["j2k", "jp2"],
      ["j2c", "jp2"],
      ["jxl", "jxl"]
    ]);
    var jp2Regex = /\.(jp[2x]|j2[kc])$/i;
    var errJp2Save = () => new Error("JP2 output requires libvips with support for OpenJPEG");
    var bitdepthFromColourCount = (colours) => 1 << 31 - Math.clz32(Math.ceil(Math.log2(colours)));
    function toFile(fileOut, callback) {
      let err;
      if (!is.string(fileOut)) {
        err = new Error("Missing output file path");
      } else if (is.string(this.options.input.file) && path7.resolve(this.options.input.file) === path7.resolve(fileOut)) {
        err = new Error("Cannot use same file for input and output");
      } else if (jp2Regex.test(path7.extname(fileOut)) && !this.constructor.format.jp2k.output.file) {
        err = errJp2Save();
      }
      if (err) {
        if (is.fn(callback)) {
          callback(err);
        } else {
          return Promise.reject(err);
        }
      } else {
        this.options.fileOut = fileOut;
        const stack = Error();
        return this._pipeline(callback, stack);
      }
      return this;
    }
    function toBuffer(options, callback) {
      if (is.object(options)) {
        this._setBooleanOption("resolveWithObject", options.resolveWithObject);
      } else if (this.options.resolveWithObject) {
        this.options.resolveWithObject = false;
      }
      this.options.fileOut = "";
      const stack = Error();
      return this._pipeline(is.fn(options) ? options : callback, stack);
    }
    function keepExif() {
      this.options.keepMetadata |= 1;
      return this;
    }
    function withExif(exif) {
      if (is.object(exif)) {
        for (const [ifd, entries] of Object.entries(exif)) {
          if (is.object(entries)) {
            for (const [k, v] of Object.entries(entries)) {
              if (is.string(v)) {
                this.options.withExif[`exif-${ifd.toLowerCase()}-${k}`] = v;
              } else {
                throw is.invalidParameterError(`${ifd}.${k}`, "string", v);
              }
            }
          } else {
            throw is.invalidParameterError(ifd, "object", entries);
          }
        }
      } else {
        throw is.invalidParameterError("exif", "object", exif);
      }
      this.options.withExifMerge = false;
      return this.keepExif();
    }
    function withExifMerge(exif) {
      this.withExif(exif);
      this.options.withExifMerge = true;
      return this;
    }
    function keepIccProfile() {
      this.options.keepMetadata |= 8;
      return this;
    }
    function withIccProfile(icc, options) {
      if (is.string(icc)) {
        this.options.withIccProfile = icc;
      } else {
        throw is.invalidParameterError("icc", "string", icc);
      }
      this.keepIccProfile();
      if (is.object(options)) {
        if (is.defined(options.attach)) {
          if (is.bool(options.attach)) {
            if (!options.attach) {
              this.options.keepMetadata &= ~8;
            }
          } else {
            throw is.invalidParameterError("attach", "boolean", options.attach);
          }
        }
      }
      return this;
    }
    function keepMetadata() {
      this.options.keepMetadata = 31;
      return this;
    }
    function withMetadata(options) {
      this.keepMetadata();
      this.withIccProfile("srgb");
      if (is.object(options)) {
        if (is.defined(options.orientation)) {
          if (is.integer(options.orientation) && is.inRange(options.orientation, 1, 8)) {
            this.options.withMetadataOrientation = options.orientation;
          } else {
            throw is.invalidParameterError("orientation", "integer between 1 and 8", options.orientation);
          }
        }
        if (is.defined(options.density)) {
          if (is.number(options.density) && options.density > 0) {
            this.options.withMetadataDensity = options.density;
          } else {
            throw is.invalidParameterError("density", "positive number", options.density);
          }
        }
        if (is.defined(options.icc)) {
          this.withIccProfile(options.icc);
        }
        if (is.defined(options.exif)) {
          this.withExifMerge(options.exif);
        }
      }
      return this;
    }
    function toFormat(format, options) {
      const actualFormat = formats.get((is.object(format) && is.string(format.id) ? format.id : format).toLowerCase());
      if (!actualFormat) {
        throw is.invalidParameterError("format", `one of: ${[...formats.keys()].join(", ")}`, format);
      }
      return this[actualFormat](options);
    }
    function jpeg(options) {
      if (is.object(options)) {
        if (is.defined(options.quality)) {
          if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {
            this.options.jpegQuality = options.quality;
          } else {
            throw is.invalidParameterError("quality", "integer between 1 and 100", options.quality);
          }
        }
        if (is.defined(options.progressive)) {
          this._setBooleanOption("jpegProgressive", options.progressive);
        }
        if (is.defined(options.chromaSubsampling)) {
          if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ["4:2:0", "4:4:4"])) {
            this.options.jpegChromaSubsampling = options.chromaSubsampling;
          } else {
            throw is.invalidParameterError("chromaSubsampling", "one of: 4:2:0, 4:4:4", options.chromaSubsampling);
          }
        }
        const optimiseCoding = is.bool(options.optimizeCoding) ? options.optimizeCoding : options.optimiseCoding;
        if (is.defined(optimiseCoding)) {
          this._setBooleanOption("jpegOptimiseCoding", optimiseCoding);
        }
        if (is.defined(options.mozjpeg)) {
          if (is.bool(options.mozjpeg)) {
            if (options.mozjpeg) {
              this.options.jpegTrellisQuantisation = true;
              this.options.jpegOvershootDeringing = true;
              this.options.jpegOptimiseScans = true;
              this.options.jpegProgressive = true;
              this.options.jpegQuantisationTable = 3;
            }
          } else {
            throw is.invalidParameterError("mozjpeg", "boolean", options.mozjpeg);
          }
        }
        const trellisQuantisation = is.bool(options.trellisQuantization) ? options.trellisQuantization : options.trellisQuantisation;
        if (is.defined(trellisQuantisation)) {
          this._setBooleanOption("jpegTrellisQuantisation", trellisQuantisation);
        }
        if (is.defined(options.overshootDeringing)) {
          this._setBooleanOption("jpegOvershootDeringing", options.overshootDeringing);
        }
        const optimiseScans = is.bool(options.optimizeScans) ? options.optimizeScans : options.optimiseScans;
        if (is.defined(optimiseScans)) {
          this._setBooleanOption("jpegOptimiseScans", optimiseScans);
          if (optimiseScans) {
            this.options.jpegProgressive = true;
          }
        }
        const quantisationTable = is.number(options.quantizationTable) ? options.quantizationTable : options.quantisationTable;
        if (is.defined(quantisationTable)) {
          if (is.integer(quantisationTable) && is.inRange(quantisationTable, 0, 8)) {
            this.options.jpegQuantisationTable = quantisationTable;
          } else {
            throw is.invalidParameterError("quantisationTable", "integer between 0 and 8", quantisationTable);
          }
        }
      }
      return this._updateFormatOut("jpeg", options);
    }
    function png(options) {
      if (is.object(options)) {
        if (is.defined(options.progressive)) {
          this._setBooleanOption("pngProgressive", options.progressive);
        }
        if (is.defined(options.compressionLevel)) {
          if (is.integer(options.compressionLevel) && is.inRange(options.compressionLevel, 0, 9)) {
            this.options.pngCompressionLevel = options.compressionLevel;
          } else {
            throw is.invalidParameterError("compressionLevel", "integer between 0 and 9", options.compressionLevel);
          }
        }
        if (is.defined(options.adaptiveFiltering)) {
          this._setBooleanOption("pngAdaptiveFiltering", options.adaptiveFiltering);
        }
        const colours = options.colours || options.colors;
        if (is.defined(colours)) {
          if (is.integer(colours) && is.inRange(colours, 2, 256)) {
            this.options.pngBitdepth = bitdepthFromColourCount(colours);
          } else {
            throw is.invalidParameterError("colours", "integer between 2 and 256", colours);
          }
        }
        if (is.defined(options.palette)) {
          this._setBooleanOption("pngPalette", options.palette);
        } else if ([options.quality, options.effort, options.colours, options.colors, options.dither].some(is.defined)) {
          this._setBooleanOption("pngPalette", true);
        }
        if (this.options.pngPalette) {
          if (is.defined(options.quality)) {
            if (is.integer(options.quality) && is.inRange(options.quality, 0, 100)) {
              this.options.pngQuality = options.quality;
            } else {
              throw is.invalidParameterError("quality", "integer between 0 and 100", options.quality);
            }
          }
          if (is.defined(options.effort)) {
            if (is.integer(options.effort) && is.inRange(options.effort, 1, 10)) {
              this.options.pngEffort = options.effort;
            } else {
              throw is.invalidParameterError("effort", "integer between 1 and 10", options.effort);
            }
          }
          if (is.defined(options.dither)) {
            if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {
              this.options.pngDither = options.dither;
            } else {
              throw is.invalidParameterError("dither", "number between 0.0 and 1.0", options.dither);
            }
          }
        }
      }
      return this._updateFormatOut("png", options);
    }
    function webp(options) {
      if (is.object(options)) {
        if (is.defined(options.quality)) {
          if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {
            this.options.webpQuality = options.quality;
          } else {
            throw is.invalidParameterError("quality", "integer between 1 and 100", options.quality);
          }
        }
        if (is.defined(options.alphaQuality)) {
          if (is.integer(options.alphaQuality) && is.inRange(options.alphaQuality, 0, 100)) {
            this.options.webpAlphaQuality = options.alphaQuality;
          } else {
            throw is.invalidParameterError("alphaQuality", "integer between 0 and 100", options.alphaQuality);
          }
        }
        if (is.defined(options.lossless)) {
          this._setBooleanOption("webpLossless", options.lossless);
        }
        if (is.defined(options.nearLossless)) {
          this._setBooleanOption("webpNearLossless", options.nearLossless);
        }
        if (is.defined(options.smartSubsample)) {
          this._setBooleanOption("webpSmartSubsample", options.smartSubsample);
        }
        if (is.defined(options.preset)) {
          if (is.string(options.preset) && is.inArray(options.preset, ["default", "photo", "picture", "drawing", "icon", "text"])) {
            this.options.webpPreset = options.preset;
          } else {
            throw is.invalidParameterError("preset", "one of: default, photo, picture, drawing, icon, text", options.preset);
          }
        }
        if (is.defined(options.effort)) {
          if (is.integer(options.effort) && is.inRange(options.effort, 0, 6)) {
            this.options.webpEffort = options.effort;
          } else {
            throw is.invalidParameterError("effort", "integer between 0 and 6", options.effort);
          }
        }
        if (is.defined(options.minSize)) {
          this._setBooleanOption("webpMinSize", options.minSize);
        }
        if (is.defined(options.mixed)) {
          this._setBooleanOption("webpMixed", options.mixed);
        }
      }
      trySetAnimationOptions(options, this.options);
      return this._updateFormatOut("webp", options);
    }
    function gif(options) {
      if (is.object(options)) {
        if (is.defined(options.reuse)) {
          this._setBooleanOption("gifReuse", options.reuse);
        }
        if (is.defined(options.progressive)) {
          this._setBooleanOption("gifProgressive", options.progressive);
        }
        const colours = options.colours || options.colors;
        if (is.defined(colours)) {
          if (is.integer(colours) && is.inRange(colours, 2, 256)) {
            this.options.gifBitdepth = bitdepthFromColourCount(colours);
          } else {
            throw is.invalidParameterError("colours", "integer between 2 and 256", colours);
          }
        }
        if (is.defined(options.effort)) {
          if (is.number(options.effort) && is.inRange(options.effort, 1, 10)) {
            this.options.gifEffort = options.effort;
          } else {
            throw is.invalidParameterError("effort", "integer between 1 and 10", options.effort);
          }
        }
        if (is.defined(options.dither)) {
          if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {
            this.options.gifDither = options.dither;
          } else {
            throw is.invalidParameterError("dither", "number between 0.0 and 1.0", options.dither);
          }
        }
        if (is.defined(options.interFrameMaxError)) {
          if (is.number(options.interFrameMaxError) && is.inRange(options.interFrameMaxError, 0, 32)) {
            this.options.gifInterFrameMaxError = options.interFrameMaxError;
          } else {
            throw is.invalidParameterError("interFrameMaxError", "number between 0.0 and 32.0", options.interFrameMaxError);
          }
        }
        if (is.defined(options.interPaletteMaxError)) {
          if (is.number(options.interPaletteMaxError) && is.inRange(options.interPaletteMaxError, 0, 256)) {
            this.options.gifInterPaletteMaxError = options.interPaletteMaxError;
          } else {
            throw is.invalidParameterError("interPaletteMaxError", "number between 0.0 and 256.0", options.interPaletteMaxError);
          }
        }
      }
      trySetAnimationOptions(options, this.options);
      return this._updateFormatOut("gif", options);
    }
    function jp2(options) {
      if (!this.constructor.format.jp2k.output.buffer) {
        throw errJp2Save();
      }
      if (is.object(options)) {
        if (is.defined(options.quality)) {
          if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {
            this.options.jp2Quality = options.quality;
          } else {
            throw is.invalidParameterError("quality", "integer between 1 and 100", options.quality);
          }
        }
        if (is.defined(options.lossless)) {
          if (is.bool(options.lossless)) {
            this.options.jp2Lossless = options.lossless;
          } else {
            throw is.invalidParameterError("lossless", "boolean", options.lossless);
          }
        }
        if (is.defined(options.tileWidth)) {
          if (is.integer(options.tileWidth) && is.inRange(options.tileWidth, 1, 32768)) {
            this.options.jp2TileWidth = options.tileWidth;
          } else {
            throw is.invalidParameterError("tileWidth", "integer between 1 and 32768", options.tileWidth);
          }
        }
        if (is.defined(options.tileHeight)) {
          if (is.integer(options.tileHeight) && is.inRange(options.tileHeight, 1, 32768)) {
            this.options.jp2TileHeight = options.tileHeight;
          } else {
            throw is.invalidParameterError("tileHeight", "integer between 1 and 32768", options.tileHeight);
          }
        }
        if (is.defined(options.chromaSubsampling)) {
          if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ["4:2:0", "4:4:4"])) {
            this.options.jp2ChromaSubsampling = options.chromaSubsampling;
          } else {
            throw is.invalidParameterError("chromaSubsampling", "one of: 4:2:0, 4:4:4", options.chromaSubsampling);
          }
        }
      }
      return this._updateFormatOut("jp2", options);
    }
    function trySetAnimationOptions(source, target) {
      if (is.object(source) && is.defined(source.loop)) {
        if (is.integer(source.loop) && is.inRange(source.loop, 0, 65535)) {
          target.loop = source.loop;
        } else {
          throw is.invalidParameterError("loop", "integer between 0 and 65535", source.loop);
        }
      }
      if (is.object(source) && is.defined(source.delay)) {
        if (is.integer(source.delay) && is.inRange(source.delay, 0, 65535)) {
          target.delay = [source.delay];
        } else if (Array.isArray(source.delay) && source.delay.every(is.integer) && source.delay.every((v) => is.inRange(v, 0, 65535))) {
          target.delay = source.delay;
        } else {
          throw is.invalidParameterError("delay", "integer or an array of integers between 0 and 65535", source.delay);
        }
      }
    }
    function tiff(options) {
      if (is.object(options)) {
        if (is.defined(options.quality)) {
          if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {
            this.options.tiffQuality = options.quality;
          } else {
            throw is.invalidParameterError("quality", "integer between 1 and 100", options.quality);
          }
        }
        if (is.defined(options.bitdepth)) {
          if (is.integer(options.bitdepth) && is.inArray(options.bitdepth, [1, 2, 4, 8])) {
            this.options.tiffBitdepth = options.bitdepth;
          } else {
            throw is.invalidParameterError("bitdepth", "1, 2, 4 or 8", options.bitdepth);
          }
        }
        if (is.defined(options.tile)) {
          this._setBooleanOption("tiffTile", options.tile);
        }
        if (is.defined(options.tileWidth)) {
          if (is.integer(options.tileWidth) && options.tileWidth > 0) {
            this.options.tiffTileWidth = options.tileWidth;
          } else {
            throw is.invalidParameterError("tileWidth", "integer greater than zero", options.tileWidth);
          }
        }
        if (is.defined(options.tileHeight)) {
          if (is.integer(options.tileHeight) && options.tileHeight > 0) {
            this.options.tiffTileHeight = options.tileHeight;
          } else {
            throw is.invalidParameterError("tileHeight", "integer greater than zero", options.tileHeight);
          }
        }
        if (is.defined(options.miniswhite)) {
          this._setBooleanOption("tiffMiniswhite", options.miniswhite);
        }
        if (is.defined(options.pyramid)) {
          this._setBooleanOption("tiffPyramid", options.pyramid);
        }
        if (is.defined(options.xres)) {
          if (is.number(options.xres) && options.xres > 0) {
            this.options.tiffXres = options.xres;
          } else {
            throw is.invalidParameterError("xres", "number greater than zero", options.xres);
          }
        }
        if (is.defined(options.yres)) {
          if (is.number(options.yres) && options.yres > 0) {
            this.options.tiffYres = options.yres;
          } else {
            throw is.invalidParameterError("yres", "number greater than zero", options.yres);
          }
        }
        if (is.defined(options.compression)) {
          if (is.string(options.compression) && is.inArray(options.compression, ["none", "jpeg", "deflate", "packbits", "ccittfax4", "lzw", "webp", "zstd", "jp2k"])) {
            this.options.tiffCompression = options.compression;
          } else {
            throw is.invalidParameterError("compression", "one of: none, jpeg, deflate, packbits, ccittfax4, lzw, webp, zstd, jp2k", options.compression);
          }
        }
        if (is.defined(options.predictor)) {
          if (is.string(options.predictor) && is.inArray(options.predictor, ["none", "horizontal", "float"])) {
            this.options.tiffPredictor = options.predictor;
          } else {
            throw is.invalidParameterError("predictor", "one of: none, horizontal, float", options.predictor);
          }
        }
        if (is.defined(options.resolutionUnit)) {
          if (is.string(options.resolutionUnit) && is.inArray(options.resolutionUnit, ["inch", "cm"])) {
            this.options.tiffResolutionUnit = options.resolutionUnit;
          } else {
            throw is.invalidParameterError("resolutionUnit", "one of: inch, cm", options.resolutionUnit);
          }
        }
      }
      return this._updateFormatOut("tiff", options);
    }
    function avif(options) {
      return this.heif({ ...options, compression: "av1" });
    }
    function heif(options) {
      if (is.object(options)) {
        if (is.string(options.compression) && is.inArray(options.compression, ["av1", "hevc"])) {
          this.options.heifCompression = options.compression;
        } else {
          throw is.invalidParameterError("compression", "one of: av1, hevc", options.compression);
        }
        if (is.defined(options.quality)) {
          if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {
            this.options.heifQuality = options.quality;
          } else {
            throw is.invalidParameterError("quality", "integer between 1 and 100", options.quality);
          }
        }
        if (is.defined(options.lossless)) {
          if (is.bool(options.lossless)) {
            this.options.heifLossless = options.lossless;
          } else {
            throw is.invalidParameterError("lossless", "boolean", options.lossless);
          }
        }
        if (is.defined(options.effort)) {
          if (is.integer(options.effort) && is.inRange(options.effort, 0, 9)) {
            this.options.heifEffort = options.effort;
          } else {
            throw is.invalidParameterError("effort", "integer between 0 and 9", options.effort);
          }
        }
        if (is.defined(options.chromaSubsampling)) {
          if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ["4:2:0", "4:4:4"])) {
            this.options.heifChromaSubsampling = options.chromaSubsampling;
          } else {
            throw is.invalidParameterError("chromaSubsampling", "one of: 4:2:0, 4:4:4", options.chromaSubsampling);
          }
        }
        if (is.defined(options.bitdepth)) {
          if (is.integer(options.bitdepth) && is.inArray(options.bitdepth, [8, 10, 12])) {
            if (options.bitdepth !== 8 && this.constructor.versions.heif) {
              throw is.invalidParameterError("bitdepth when using prebuilt binaries", 8, options.bitdepth);
            }
            this.options.heifBitdepth = options.bitdepth;
          } else {
            throw is.invalidParameterError("bitdepth", "8, 10 or 12", options.bitdepth);
          }
        }
      } else {
        throw is.invalidParameterError("options", "Object", options);
      }
      return this._updateFormatOut("heif", options);
    }
    function jxl(options) {
      if (is.object(options)) {
        if (is.defined(options.quality)) {
          if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {
            this.options.jxlDistance = options.quality >= 30 ? 0.1 + (100 - options.quality) * 0.09 : 53 / 3e3 * options.quality * options.quality - 23 / 20 * options.quality + 25;
          } else {
            throw is.invalidParameterError("quality", "integer between 1 and 100", options.quality);
          }
        } else if (is.defined(options.distance)) {
          if (is.number(options.distance) && is.inRange(options.distance, 0, 15)) {
            this.options.jxlDistance = options.distance;
          } else {
            throw is.invalidParameterError("distance", "number between 0.0 and 15.0", options.distance);
          }
        }
        if (is.defined(options.decodingTier)) {
          if (is.integer(options.decodingTier) && is.inRange(options.decodingTier, 0, 4)) {
            this.options.jxlDecodingTier = options.decodingTier;
          } else {
            throw is.invalidParameterError("decodingTier", "integer between 0 and 4", options.decodingTier);
          }
        }
        if (is.defined(options.lossless)) {
          if (is.bool(options.lossless)) {
            this.options.jxlLossless = options.lossless;
          } else {
            throw is.invalidParameterError("lossless", "boolean", options.lossless);
          }
        }
        if (is.defined(options.effort)) {
          if (is.integer(options.effort) && is.inRange(options.effort, 3, 9)) {
            this.options.jxlEffort = options.effort;
          } else {
            throw is.invalidParameterError("effort", "integer between 3 and 9", options.effort);
          }
        }
      }
      return this._updateFormatOut("jxl", options);
    }
    function raw(options) {
      if (is.object(options)) {
        if (is.defined(options.depth)) {
          if (is.string(options.depth) && is.inArray(
            options.depth,
            ["char", "uchar", "short", "ushort", "int", "uint", "float", "complex", "double", "dpcomplex"]
          )) {
            this.options.rawDepth = options.depth;
          } else {
            throw is.invalidParameterError("depth", "one of: char, uchar, short, ushort, int, uint, float, complex, double, dpcomplex", options.depth);
          }
        }
      }
      return this._updateFormatOut("raw");
    }
    function tile2(options) {
      if (is.object(options)) {
        if (is.defined(options.size)) {
          if (is.integer(options.size) && is.inRange(options.size, 1, 8192)) {
            this.options.tileSize = options.size;
          } else {
            throw is.invalidParameterError("size", "integer between 1 and 8192", options.size);
          }
        }
        if (is.defined(options.overlap)) {
          if (is.integer(options.overlap) && is.inRange(options.overlap, 0, 8192)) {
            if (options.overlap > this.options.tileSize) {
              throw is.invalidParameterError("overlap", `<= size (${this.options.tileSize})`, options.overlap);
            }
            this.options.tileOverlap = options.overlap;
          } else {
            throw is.invalidParameterError("overlap", "integer between 0 and 8192", options.overlap);
          }
        }
        if (is.defined(options.container)) {
          if (is.string(options.container) && is.inArray(options.container, ["fs", "zip"])) {
            this.options.tileContainer = options.container;
          } else {
            throw is.invalidParameterError("container", "one of: fs, zip", options.container);
          }
        }
        if (is.defined(options.layout)) {
          if (is.string(options.layout) && is.inArray(options.layout, ["dz", "google", "iiif", "iiif3", "zoomify"])) {
            this.options.tileLayout = options.layout;
          } else {
            throw is.invalidParameterError("layout", "one of: dz, google, iiif, iiif3, zoomify", options.layout);
          }
        }
        if (is.defined(options.angle)) {
          if (is.integer(options.angle) && !(options.angle % 90)) {
            this.options.tileAngle = options.angle;
          } else {
            throw is.invalidParameterError("angle", "positive/negative multiple of 90", options.angle);
          }
        }
        this._setBackgroundColourOption("tileBackground", options.background);
        if (is.defined(options.depth)) {
          if (is.string(options.depth) && is.inArray(options.depth, ["onepixel", "onetile", "one"])) {
            this.options.tileDepth = options.depth;
          } else {
            throw is.invalidParameterError("depth", "one of: onepixel, onetile, one", options.depth);
          }
        }
        if (is.defined(options.skipBlanks)) {
          if (is.integer(options.skipBlanks) && is.inRange(options.skipBlanks, -1, 65535)) {
            this.options.tileSkipBlanks = options.skipBlanks;
          } else {
            throw is.invalidParameterError("skipBlanks", "integer between -1 and 255/65535", options.skipBlanks);
          }
        } else if (is.defined(options.layout) && options.layout === "google") {
          this.options.tileSkipBlanks = 5;
        }
        const centre = is.bool(options.center) ? options.center : options.centre;
        if (is.defined(centre)) {
          this._setBooleanOption("tileCentre", centre);
        }
        if (is.defined(options.id)) {
          if (is.string(options.id)) {
            this.options.tileId = options.id;
          } else {
            throw is.invalidParameterError("id", "string", options.id);
          }
        }
        if (is.defined(options.basename)) {
          if (is.string(options.basename)) {
            this.options.tileBasename = options.basename;
          } else {
            throw is.invalidParameterError("basename", "string", options.basename);
          }
        }
      }
      if (is.inArray(this.options.formatOut, ["jpeg", "png", "webp"])) {
        this.options.tileFormat = this.options.formatOut;
      } else if (this.options.formatOut !== "input") {
        throw is.invalidParameterError("format", "one of: jpeg, png, webp", this.options.formatOut);
      }
      return this._updateFormatOut("dz");
    }
    function timeout(options) {
      if (!is.plainObject(options)) {
        throw is.invalidParameterError("options", "object", options);
      }
      if (is.integer(options.seconds) && is.inRange(options.seconds, 0, 3600)) {
        this.options.timeoutSeconds = options.seconds;
      } else {
        throw is.invalidParameterError("seconds", "integer between 0 and 3600", options.seconds);
      }
      return this;
    }
    function _updateFormatOut(formatOut, options) {
      if (!(is.object(options) && options.force === false)) {
        this.options.formatOut = formatOut;
      }
      return this;
    }
    function _setBooleanOption(key, val) {
      if (is.bool(val)) {
        this.options[key] = val;
      } else {
        throw is.invalidParameterError(key, "boolean", val);
      }
    }
    function _read() {
      if (!this.options.streamOut) {
        this.options.streamOut = true;
        const stack = Error();
        this._pipeline(void 0, stack);
      }
    }
    function _pipeline(callback, stack) {
      if (typeof callback === "function") {
        if (this._isStreamInput()) {
          this.on("finish", () => {
            this._flattenBufferIn();
            sharp.pipeline(this.options, (err, data, info) => {
              if (err) {
                callback(is.nativeError(err, stack));
              } else {
                callback(null, data, info);
              }
            });
          });
        } else {
          sharp.pipeline(this.options, (err, data, info) => {
            if (err) {
              callback(is.nativeError(err, stack));
            } else {
              callback(null, data, info);
            }
          });
        }
        return this;
      } else if (this.options.streamOut) {
        if (this._isStreamInput()) {
          this.once("finish", () => {
            this._flattenBufferIn();
            sharp.pipeline(this.options, (err, data, info) => {
              if (err) {
                this.emit("error", is.nativeError(err, stack));
              } else {
                this.emit("info", info);
                this.push(data);
              }
              this.push(null);
              this.on("end", () => this.emit("close"));
            });
          });
          if (this.streamInFinished) {
            this.emit("finish");
          }
        } else {
          sharp.pipeline(this.options, (err, data, info) => {
            if (err) {
              this.emit("error", is.nativeError(err, stack));
            } else {
              this.emit("info", info);
              this.push(data);
            }
            this.push(null);
            this.on("end", () => this.emit("close"));
          });
        }
        return this;
      } else {
        if (this._isStreamInput()) {
          return new Promise((resolve3, reject) => {
            this.once("finish", () => {
              this._flattenBufferIn();
              sharp.pipeline(this.options, (err, data, info) => {
                if (err) {
                  reject(is.nativeError(err, stack));
                } else {
                  if (this.options.resolveWithObject) {
                    resolve3({ data, info });
                  } else {
                    resolve3(data);
                  }
                }
              });
            });
          });
        } else {
          return new Promise((resolve3, reject) => {
            sharp.pipeline(this.options, (err, data, info) => {
              if (err) {
                reject(is.nativeError(err, stack));
              } else {
                if (this.options.resolveWithObject) {
                  resolve3({ data, info });
                } else {
                  resolve3(data);
                }
              }
            });
          });
        }
      }
    }
    module.exports = function(Sharp) {
      Object.assign(Sharp.prototype, {
        // Public
        toFile,
        toBuffer,
        keepExif,
        withExif,
        withExifMerge,
        keepIccProfile,
        withIccProfile,
        keepMetadata,
        withMetadata,
        toFormat,
        jpeg,
        jp2,
        png,
        webp,
        tiff,
        avif,
        heif,
        jxl,
        gif,
        raw,
        tile: tile2,
        timeout,
        // Private
        _updateFormatOut,
        _setBooleanOption,
        _read,
        _pipeline
      });
    };
  }
});

// node_modules/sharp/lib/utility.js
var require_utility = __commonJS({
  "node_modules/sharp/lib/utility.js"(exports, module) {
    "use strict";
    var events = __require("node:events");
    var detectLibc = require_detect_libc();
    var is = require_is();
    var { runtimePlatformArch } = require_libvips();
    var sharp = require_sharp();
    var runtimePlatform = runtimePlatformArch();
    var libvipsVersion = sharp.libvipsVersion();
    var format = sharp.format();
    format.heif.output.alias = ["avif", "heic"];
    format.jpeg.output.alias = ["jpe", "jpg"];
    format.tiff.output.alias = ["tif"];
    format.jp2k.output.alias = ["j2c", "j2k", "jp2", "jpx"];
    var interpolators = {
      /** [Nearest neighbour interpolation](http://en.wikipedia.org/wiki/Nearest-neighbor_interpolation). Suitable for image enlargement only. */
      nearest: "nearest",
      /** [Bilinear interpolation](http://en.wikipedia.org/wiki/Bilinear_interpolation). Faster than bicubic but with less smooth results. */
      bilinear: "bilinear",
      /** [Bicubic interpolation](http://en.wikipedia.org/wiki/Bicubic_interpolation) (the default). */
      bicubic: "bicubic",
      /** [LBB interpolation](https://github.com/libvips/libvips/blob/master/libvips/resample/lbb.cpp#L100). Prevents some "[acutance](http://en.wikipedia.org/wiki/Acutance)" but typically reduces performance by a factor of 2. */
      locallyBoundedBicubic: "lbb",
      /** [Nohalo interpolation](http://eprints.soton.ac.uk/268086/). Prevents acutance but typically reduces performance by a factor of 3. */
      nohalo: "nohalo",
      /** [VSQBS interpolation](https://github.com/libvips/libvips/blob/master/libvips/resample/vsqbs.cpp#L48). Prevents "staircasing" when enlarging. */
      vertexSplitQuadraticBasisSpline: "vsqbs"
    };
    var versions = {
      vips: libvipsVersion.semver
    };
    if (!libvipsVersion.isGlobal) {
      if (!libvipsVersion.isWasm) {
        try {
          versions = __require(`@img/sharp-${runtimePlatform}/versions`);
        } catch (_) {
          try {
            versions = __require(`@img/sharp-libvips-${runtimePlatform}/versions`);
          } catch (_2) {
          }
        }
      } else {
        try {
          versions = __require("@img/sharp-wasm32/versions");
        } catch (_) {
        }
      }
    }
    versions.sharp = require_package().version;
    if (versions.heif && format.heif) {
      format.heif.input.fileSuffix = [".avif"];
      format.heif.output.alias = ["avif"];
    }
    function cache(options) {
      if (is.bool(options)) {
        if (options) {
          return sharp.cache(50, 20, 100);
        } else {
          return sharp.cache(0, 0, 0);
        }
      } else if (is.object(options)) {
        return sharp.cache(options.memory, options.files, options.items);
      } else {
        return sharp.cache();
      }
    }
    cache(true);
    function concurrency(concurrency2) {
      return sharp.concurrency(is.integer(concurrency2) ? concurrency2 : null);
    }
    if (detectLibc.familySync() === detectLibc.GLIBC && !sharp._isUsingJemalloc()) {
      sharp.concurrency(1);
    } else if (detectLibc.familySync() === detectLibc.MUSL && sharp.concurrency() === 1024) {
      sharp.concurrency(__require("node:os").availableParallelism());
    }
    var queue = new events.EventEmitter();
    function counters() {
      return sharp.counters();
    }
    function simd(simd2) {
      return sharp.simd(is.bool(simd2) ? simd2 : null);
    }
    function block(options) {
      if (is.object(options)) {
        if (Array.isArray(options.operation) && options.operation.every(is.string)) {
          sharp.block(options.operation, true);
        } else {
          throw is.invalidParameterError("operation", "Array<string>", options.operation);
        }
      } else {
        throw is.invalidParameterError("options", "object", options);
      }
    }
    function unblock(options) {
      if (is.object(options)) {
        if (Array.isArray(options.operation) && options.operation.every(is.string)) {
          sharp.block(options.operation, false);
        } else {
          throw is.invalidParameterError("operation", "Array<string>", options.operation);
        }
      } else {
        throw is.invalidParameterError("options", "object", options);
      }
    }
    module.exports = function(Sharp) {
      Sharp.cache = cache;
      Sharp.concurrency = concurrency;
      Sharp.counters = counters;
      Sharp.simd = simd;
      Sharp.format = format;
      Sharp.interpolators = interpolators;
      Sharp.versions = versions;
      Sharp.queue = queue;
      Sharp.block = block;
      Sharp.unblock = unblock;
    };
  }
});

// node_modules/sharp/lib/index.js
var require_lib = __commonJS({
  "node_modules/sharp/lib/index.js"(exports, module) {
    "use strict";
    var Sharp = require_constructor();
    require_input()(Sharp);
    require_resize()(Sharp);
    require_composite()(Sharp);
    require_operation()(Sharp);
    require_colour()(Sharp);
    require_channel()(Sharp);
    require_output()(Sharp);
    require_utility()(Sharp);
    module.exports = Sharp;
  }
});

// rsmv/src/opcodes/typedef.jsonc
var require_typedef = __commonJS({
  "rsmv/src/opcodes/typedef.jsonc"(exports, module) {
    module.exports = {
      "variable unsigned long": "varuint",
      "variable unsigned int": "varuint",
      "variable unsigned short": "varushort",
      "unsigned variable long": "varuint",
      "unsigned variable int": "varuint",
      "unsigned variable short": "varushort",
      "variable long": "varint",
      "variable int": "varint",
      "variable short": "varshort",
      "unsigned long": "uint",
      "unsigned int": "uint",
      "unsigned short": "ushort",
      "unsigned byte": "ubyte",
      long: "int",
      "ushort le": "ushort_le",
      "uint le": "uint_le",
      playeritem: ["playeritem"],
      playeritemedit: [
        "struct",
        ["$type", "ubyte"],
        ["model", ["opt", ["$type", 0, "bitflag"], ["array", ["itemvar", "modelcount"], "varuint"]]],
        ["flag2", ["opt", ["$type", 1, "bitflag"], "true"]],
        ["color", ["opt", ["$type", 2, "bitflag"], [
          "struct",
          ["$coltype", "ushort"],
          ["col2", ["opt", ["$coltype", 12816], ["array", ["itemvar", "colorcount"], "ushort"]]],
          ["col4", ["opt", ["$coltype", 8719], ["array", 4, ["tuple", "ushort", "ushort"]]]]
        ]]],
        ["material", ["opt", ["$type", 3, "bitflag"], [
          "struct",
          ["header", "ubyte"],
          ["materials", ["array", ["itemvar", "matcount"], "ushort"]]
        ]]]
      ],
      ubyte: "unsigned byte",
      ushort: "unsigned short",
      uint: "unsigned int",
      varushort: "variable unsigned short",
      varuint: "variable unsigned int",
      varshort: "variable short",
      varint: "variable int",
      "unsigned tribyte": "utribyte",
      "tailed unsigned short": ["tailed varushort"],
      boolean: "bool",
      true: true,
      false: false,
      "0": 0,
      "1": 1,
      "-1": -1,
      null: null,
      extrasmap: ["array", "ubyte", [
        "struct",
        ["$type", "unsigned byte"],
        ["prop", "unsigned tribyte"],
        ["intvalue", ["opt", ["$type", 0], "int"]],
        ["stringvalue", ["opt", ["$type", 1], "string"]]
      ]],
      buildnr: ["buildnr"],
      item_modelid: ["match", "buildnr", { ">=670": "varuint", ">=0": "ushort" }],
      animid: ["match", "buildnr", { ">=670": "varnullint", ">=0": "ushort" }],
      uivalues: ["array", "ubyte", ["match", "ubyte", { "0": "int", "1": "string" }]],
      uivaluesint: ["array", "ubyte", "int"]
    };
  }
});

// rsmv/src/opcodes/cacheindex.json
var require_cacheindex = __commonJS({
  "rsmv/src/opcodes/cacheindex.json"(exports, module) {
    module.exports = [
      "struct",
      ["format", "unsigned byte"],
      ["timestamp", ["match", ["ref", "format"], { ">=6": "uint", other: 0 }]],
      ["flags", "unsigned byte"],
      ["$minorindex", "0"],
      ["indices", [
        "chunkedarray",
        ["match", ["ref", "format"], { ">=7": "varuint", other: "ushort" }],
        [
          ["minor", ["accum", "$minorindex", "unsigned short"]]
        ],
        [
          ["name", ["opt", ["flags", 0, "bitflag"], "unsigned int"]]
        ],
        [
          ["crc", "unsigned int"]
        ],
        [
          ["uncompressed_crc", ["opt", ["flags", 2, "bitflag"], "unsigned int"]]
        ],
        [
          ["size", ["opt", ["flags", 2, "bitflag"], "unsigned int"]],
          ["uncompressed_size", ["opt", ["flags", 2, "bitflag"], "unsigned int"]]
        ],
        [
          ["encryption_or_hash", ["opt", ["flags", 1, "bitflag"], ["buffer", 64, "hex"]]]
        ],
        [
          ["version", "unsigned int"]
        ],
        [
          ["subindexcount", "variable unsigned int"]
        ],
        [
          ["$subindex", "0"],
          ["subindices", ["array", ["ref", "subindexcount"], ["accum", "$subindex", "unsigned short"]]]
        ],
        [
          ["subnames", ["opt", ["flags", 0, "bitflag"], ["array", ["ref", "subindexcount"], "uint"]]]
        ]
      ]]
    ];
  }
});

// rsmv/src/opcodes/npcs.jsonc
var require_npcs = __commonJS({
  "rsmv/src/opcodes/npcs.jsonc"(exports, module) {
    module.exports = {
      "0x01": { name: "models", read: ["array", ["match", "buildnr", { ">=669": "varuint", ">=0": "ushort" }]] },
      "0x02": { name: "name", read: "string" },
      "0x03": { name: "examine", read: "string" },
      "0x08": { name: "unknown_08", read: "unsigned byte" },
      "0x0B": { name: "unknown_0B", read: "unsigned byte" },
      "0x0C": { name: "boundSize", read: "unsigned byte" },
      "0x0D": { name: "unk_0D", read: "ushort" },
      "0x0E": { name: "unk_0E", read: "ushort" },
      "0x11": { name: "unk_11", read: ["array", 4, "ushort"] },
      "0x1E": { name: "actions_0", read: "string" },
      "0x1F": { name: "actions_1", read: "string" },
      "0x20": { name: "actions_2", read: "string" },
      "0x21": { name: "actions_3", read: "string" },
      "0x22": { name: "actions_4", read: "string" },
      "0x28": { name: "color_replacements", read: ["array", ["tuple", "unsigned short", "unsigned short"]] },
      "0x29": { name: "material_replacements", read: ["array", ["tuple", "unsigned short", "unsigned short"]] },
      "0x2A": { name: "recolourPalette", read: ["array", "byte"] },
      "0x2C": { name: "recolor_indices", read: "unsigned short" },
      "0x2D": { name: "retexture_indices", read: "unsigned short" },
      "0x3C": { name: "headModels", read: ["array", ["match", "buildnr", { ">=669": "varuint", ">=0": "ushort" }]] },
      "0x5D": { name: "drawMapDot", read: "false" },
      "0x5F": { name: "combat", read: "unsigned short" },
      "0x61": { name: "scaleXZ", read: "unsigned short" },
      "0x62": { name: "scaleY", read: "unsigned short" },
      "0x63": { name: "unknown_63", read: "true" },
      "0x64": { name: "ambience", read: "byte" },
      "0x65": { name: "modelContract", read: "byte" },
      "0x66": { name: "head_icon_data", read: "unsigned short" },
      "0x67": { name: "unknown_67", read: "unsigned short" },
      "0x6A": { name: "morphs_1", read: [
        "struct",
        ["unk1", "unsigned int"],
        ["unk2", ["array", ["match", "buildnr", { ">=910": "varushort", ">=0": "ubyte" }], "unsigned short"]],
        ["unk3", ["match", "buildnr", { ">=525": "uint", ">=0": "ushort" }]]
      ] },
      "0x6B": { name: "unknown_6B", read: "false" },
      "0x6D": { name: "slowWalk", read: "false" },
      "0x6F": { name: "animateIdle", read: "false" },
      "0x71": { name: "shadow", read: ["struct", ["SrcColor", "unsigned short"], ["DstColor", "unsigned short"]] },
      "0x72": { name: "shadowAlphaIntensity", read: ["struct", ["Src", "byte"], ["Dst", "byte"]] },
      "0x73": { name: "unknown_73", read: ["tuple", "ubyte", "ubyte"] },
      "0x76": { name: "morphs_2", read: [
        "struct",
        ["unk1", "unsigned int"],
        ["unk2", "unsigned short"],
        ["unk3", ["array", ["match", "buildnr", { ">=910": "varushort", ">=0": "ubyte" }], "unsigned short"]],
        ["unk4", "unsigned int"]
      ] },
      "0x77": { name: "movementCapabilities", read: "byte" },
      "0x78": { name: "unknown_78", read: ["tuple", "ushort", "ushort", "ushort", "ubyte"] },
      "0x79": { name: "translations", read: ["array", ["buffer", 4, "hex"]] },
      "0x7A": { name: "unk_7A", read: "unsigned short" },
      "0x7B": { name: "iconHeight", read: "unsigned short" },
      "0x7D": { name: "respawnDirection", read: "byte" },
      "0x7F": { name: "animation_group", read: "unsigned short" },
      "0x80": { name: "movementType", read: "byte" },
      "0x86": { name: "ambient_sound", read: ["struct", ["unk1", "unsigned short"], ["unk2", "unsigned short"], ["unk3", "unsigned short"], ["unk4", "unsigned short"], ["unk45", "unsigned byte"]] },
      "0x87": { name: "oldCursor", read: ["struct", ["Op", "unsigned byte"], ["Cursor", "unsigned short"]] },
      "0x88": { name: "oldCursor2", read: ["struct", ["Op", "unsigned byte"], ["Cursor", "unsigned short"]] },
      "0x89": { name: "attackCursor", read: "unsigned short" },
      "0x8A": { name: "armyIcon", read: "variable int" },
      "0x8C": { name: "unknown_8C", read: "unsigned byte" },
      "0x8D": { name: "unknown_8D", read: "true" },
      "0x8E": { name: "mapFunction", read: "unsigned short" },
      "0x8F": { name: "unknown_8F", read: "true" },
      "0x96": { name: "members_actions_0", read: "string" },
      "0x97": { name: "members_actions_1", read: "string" },
      "0x98": { name: "members_actions_2", read: "string" },
      "0x99": { name: "members_actions_3", read: "string" },
      "0x9A": { name: "members_actions_4", read: "string" },
      "0x9B": { name: "unknown_9B", read: ["struct", ["unknown_1", "byte"], ["unknown_2", "byte"], ["unknown_3", "byte"], ["unknown_4", "byte"]] },
      "0x9E": { name: "aByte3076_set_1", read: "true" },
      "0x9F": { name: "aByte3076_set_0", read: "false" },
      "0xA0": { name: "quests", read: ["array", "unsigned short"] },
      "0xA2": { name: "dummy_1", read: "true" },
      "0xA3": { name: "unknown_A3", read: "unsigned byte" },
      "0xA4": { name: "unknown_A4", read: ["struct", ["unknown_1", "unsigned short"], ["unknown_2", "unsigned short"]] },
      "0xA5": { name: "unknown_A5", read: "unsigned byte" },
      "0xA8": { name: "unknown_A8", read: "unsigned byte" },
      "0xA9": { name: "unknown_A9", read: "false" },
      "0xAA": { name: "action_cursors_0", read: "unsigned short" },
      "0xAB": { name: "action_cursors_1", read: "unsigned short" },
      "0xAC": { name: "action_cursors_2", read: "unsigned short" },
      "0xAD": { name: "action_cursors_3", read: "unsigned short" },
      "0xAE": { name: "action_cursors_4", read: "unsigned short" },
      "0xAF": { name: "action_cursors_5", read: "unsigned short" },
      "0xB2": { name: "dummy_2", read: "true" },
      "0xB3": { name: "unknown_B3", read: ["struct", ["unknown_1", "variable short"], ["unknown_2", "variable short"], ["unknown_3", "variable short"], ["unknown_4", "variable short"], ["unknown_5", "variable short"], ["unknown_6", "variable short"]] },
      "0xB4": { name: "unknown_B4", read: "unsigned byte" },
      "0xB5": { name: "unknown_B5", read: ["struct", ["unknown_1", "unsigned short"], ["unknown_2", "unsigned byte"]] },
      "0xB6": { name: "unknown_B6", read: "true" },
      "0xB7": { name: "unknown_B7", read: "unsigned byte" },
      "0xB8": { name: "unknown_B8", read: "unsigned byte" },
      "0xB9": { name: "unknown_B9", read: "true" },
      "0xDB": { name: "unknown_DB", read: "ubyte" },
      "0xF9": { name: "extra", read: "extrasmap" },
      "0xFD": { name: "unknown_FD", read: "ubyte" }
    };
  }
});

// rsmv/src/opcodes/items.jsonc
var require_items = __commonJS({
  "rsmv/src/opcodes/items.jsonc"(exports, module) {
    module.exports = {
      "0x00": { name: "nullopt", read: "true" },
      "0x01": { name: "baseModel", read: "item_modelid" },
      "0x02": { name: "name", read: "string" },
      "0x03": { name: "buff_effect", read: "string" },
      "0x04": { name: "model_zoom", read: "unsigned short" },
      "0x05": { name: "rotation_0", read: "unsigned short" },
      "0x06": { name: "rotation_1", read: "unsigned short" },
      "0x07": { name: "modelTranslate_0", read: "short" },
      "0x08": { name: "modelTranslate_1", read: "short" },
      "0x0A": { name: "unknown_0A", read: "ushort" },
      "0x0B": { name: "stackable_1", read: "true" },
      "0x0C": { name: "value", read: "int" },
      "0x0D": { name: "equipSlotId", read: "unsigned byte" },
      "0x0E": { name: "equipId", read: "unsigned byte" },
      "0x0F": { name: "unknown_0F", read: "true" },
      "0x10": { name: "members", read: "true" },
      "0x12": { name: "multiStackSize", read: "unsigned short" },
      "0x17": { name: "maleModels_0", read: ["struct", ["id", "item_modelid"], ["type", ["match", "buildnr", { ">=502": 0, other: "ubyte" }]]] },
      "0x18": { name: "maleModels_1", read: "item_modelid" },
      "0x19": { name: "femaleModels_0", read: ["struct", ["id", "item_modelid"], ["type", ["match", "buildnr", { ">=502": 0, other: "ubyte" }]]] },
      "0x1A": { name: "femaleModels_1", read: "item_modelid" },
      "0x1B": { name: "unknown_1B", read: "unsigned byte" },
      "0x1E": { name: "ground_actions_0", read: "string" },
      "0x1F": { name: "ground_actions_1", read: "string" },
      "0x20": { name: "ground_actions_2", read: "string" },
      "0x21": { name: "ground_actions_3", read: "string" },
      "0x22": { name: "ground_actions_4", read: "string" },
      "0x23": { name: "widget_actions_0", read: "string" },
      "0x24": { name: "widget_actions_1", read: "string" },
      "0x25": { name: "widget_actions_2", read: "string" },
      "0x26": { name: "widget_actions_3", read: "string" },
      "0x27": { name: "widget_actions_4", read: "string" },
      "0x28": { name: "color_replacements", read: ["array", ["tuple", "unsigned short", "unsigned short"]] },
      "0x29": { name: "material_replacements", read: ["array", ["tuple", "unsigned short", "unsigned short"]] },
      "0x2A": { name: "recolourPalette", read: ["array", ["tuple", "unsigned byte", "byte"]] },
      "0x2B": { name: "nameColor", read: "int" },
      "0x2C": { name: "recolorDstIndices", read: "unsigned short" },
      "0x2D": { name: "retextureDstIndices", read: "unsigned short" },
      "0x41": { name: "tradeable", read: "true" },
      "0x45": { name: "buy_limit", read: "int" },
      "0x4E": { name: "maleModels_2", read: "item_modelid" },
      "0x4F": { name: "femaleModels_2", read: "item_modelid" },
      "0x5A": { name: "maleHeads_0", read: "item_modelid" },
      "0x5B": { name: "femaleHeads_0", read: "item_modelid" },
      "0x5C": { name: "maleHeads_1", read: "item_modelid" },
      "0x5D": { name: "femaleHeads_1", read: "item_modelid" },
      "0x5E": { name: "category", read: "unsigned short" },
      "0x5F": { name: "rotation_2", read: "unsigned short" },
      "0x60": { name: "dummyItem", read: "unsigned byte" },
      "0x61": { name: "noteData", read: "unsigned short" },
      "0x62": { name: "noteTemplate", read: "unsigned short" },
      "0x64": { name: "stack_info_0", read: ["tuple", "unsigned short", "unsigned short"] },
      "0x65": { name: "stack_info_1", read: ["tuple", "unsigned short", "unsigned short"] },
      "0x66": { name: "stack_info_2", read: ["tuple", "unsigned short", "unsigned short"] },
      "0x67": { name: "stack_info_3", read: ["tuple", "unsigned short", "unsigned short"] },
      "0x68": { name: "stack_info_4", read: ["tuple", "unsigned short", "unsigned short"] },
      "0x69": { name: "stack_info_5", read: ["tuple", "unsigned short", "unsigned short"] },
      "0x6A": { name: "stack_info_6", read: ["tuple", "unsigned short", "unsigned short"] },
      "0x6B": { name: "stack_info_7", read: ["tuple", "unsigned short", "unsigned short"] },
      "0x6C": { name: "stack_info_8", read: ["tuple", "unsigned short", "unsigned short"] },
      "0x6D": { name: "stack_info_9", read: ["tuple", "unsigned short", "unsigned short"] },
      "0x6E": { name: "scale_0", read: "unsigned short" },
      "0x6F": { name: "scale_1", read: "unsigned short" },
      "0x70": { name: "scale_2", read: "unsigned short" },
      "0x71": { name: "ambiance", read: "byte" },
      "0x72": { name: "contrast", read: "byte" },
      "0x73": { name: "team", read: "unsigned byte" },
      "0x79": { name: "loanId", read: "unsigned short" },
      "0x7A": { name: "loanTemplate", read: "unsigned short" },
      "0x7D": { name: "male_translate", read: ["tuple", "unsigned byte", "unsigned byte", "unsigned byte"] },
      "0x7E": { name: "female_translate", read: ["tuple", "unsigned byte", "unsigned byte", "unsigned byte"] },
      "0x7F": { name: "unknown_7F", read: ["tuple", "unsigned byte", "unsigned short"] },
      "0x80": { name: "unknown_80", read: ["tuple", "unsigned byte", "unsigned short"] },
      "0x81": { name: "unknown_81", read: ["tuple", "unsigned byte", "unsigned short"] },
      "0x82": { name: "unknown_82", read: ["tuple", "unsigned byte", "unsigned short"] },
      "0x84": { name: "quests", read: ["array", ["tuple", "unsigned byte", "unsigned short"]] },
      "0x86": { name: "pickSizeShift", read: "unsigned byte" },
      "0x8B": { name: "bindLink", read: "unsigned short" },
      "0x8C": { name: "bindTemplate", read: "unsigned short" },
      "0x8E": { name: "ground_actions_cursor_0", read: "unsigned short" },
      "0x8F": { name: "ground_actions_cursor_1", read: "unsigned short" },
      "0x90": { name: "ground_actions_cursor_2", read: "unsigned short" },
      "0x91": { name: "ground_actions_cursor_3", read: "unsigned short" },
      "0x92": { name: "ground_actions_cursor_4", read: "unsigned short" },
      "0x96": { name: "widget_actions_cursor_0", read: "unsigned short" },
      "0x97": { name: "widget_actions_cursor_1", read: "unsigned short" },
      "0x98": { name: "widget_actions_cursor_2", read: "unsigned short" },
      "0x99": { name: "widget_actions_cursor_3", read: "unsigned short" },
      "0x9A": { name: "widget_actions_cursor_4", read: "unsigned short" },
      "0x9C": { name: "dummy", read: "true" },
      "0x9D": { name: "randomizeGroundPos", read: "true" },
      "0xA1": { name: "combine_info", read: "unsigned short" },
      "0xA2": { name: "combine_template", read: "unsigned short" },
      "0xA3": { name: "combine_num_required", read: "unsigned short" },
      "0xA4": { name: "combine_shard_name", read: "string" },
      "0xA5": { name: "neverStackable", read: "true" },
      "0xA7": { name: "unknown_A7", read: "true" },
      "0xA8": { name: "unknown_A8", read: "true" },
      "0xB2": { name: "unknown_B2", read: "true" },
      "0xB5": { name: "big_value", read: ["tuple", "int", "int"] },
      "0xF9": { name: "extra", read: "extrasmap" }
    };
  }
});

// rsmv/src/opcodes/objects.jsonc
var require_objects = __commonJS({
  "rsmv/src/opcodes/objects.jsonc"(exports, module) {
    module.exports = {
      "0x01": { name: "models", read: ["match", "buildnr", {
        ">=582": ["array", "ubyte", [
          "struct",
          ["type", "ubyte"],
          ["values", ["array", "ubyte", "item_modelid"]]
        ]],
        other: ["array", "ubyte", [
          "struct",
          ["values", ["array", 1, "item_modelid"]],
          ["type", "ubyte"]
        ]]
      }] },
      "0x02": { name: "name", read: "string" },
      "0x03": { name: "examine", read: "string" },
      "0x05": { name: "models_05", read: ["match", "buildnr", {
        ">=582": [
          "struct",
          ["models", ["array", "ubyte", [
            "struct",
            ["type", "ubyte"],
            ["values", ["array", "ubyte", "item_modelid"]]
          ]]],
          ["unktail", ["array", "ubyte", ["tuple", "item_modelid", "item_modelid"]]]
        ],
        other: [
          "struct",
          ["models", ["array", 1, [
            "struct",
            ["type", 10],
            ["values", ["array", "ubyte", "item_modelid"]],
            ["unktail", ["array", 0, ["tuple", "item_modelid", "item_modelid"]]]
          ]]]
        ]
      }] },
      "0x0E": { name: "width", read: "unsigned byte" },
      "0x0F": { name: "length", read: "unsigned byte" },
      "0x11": { name: "probably_nocollision", read: "true" },
      "0x12": { name: "maybe_allows_lineofsight", read: "true" },
      "0x13": { name: "deletable", read: "boolean" },
      "0x15": { name: "probably_morphFloor", read: "true" },
      "0x16": { name: "unknown_16", read: "true" },
      "0x17": { name: "occludes_1", read: "false" },
      "0x18": { name: "probably_animation", read: "variable unsigned int" },
      "0x1B": { name: "maybe_blocks_movement", read: "true" },
      "0x1C": { name: "wallkit_related_1C", read: "unsigned byte" },
      "0x1D": { name: "ambient", read: "ubyte" },
      "0x1E": { name: "actions_0", read: "string" },
      "0x1F": { name: "actions_1", read: "string" },
      "0x20": { name: "actions_2", read: "string" },
      "0x21": { name: "actions_3", read: "string" },
      "0x22": { name: "actions_4", read: "string" },
      "0x27": { name: "contrast", read: "byte" },
      "0x28": { name: "color_replacements", read: ["array", ["tuple", "unsigned short", "unsigned short"]] },
      "0x29": { name: "material_replacements", read: ["array", ["tuple", "unsigned short", "unsigned short"]] },
      "0x2A": { name: "recolourPalette", read: ["array", "byte"] },
      "0x2C": { name: "unknown_2C", read: "unsigned short" },
      "0x2D": { name: "unknown_2D", read: "unsigned short" },
      "0x36": { name: "unknown_36", read: "true" },
      "0x37": { name: "unknown_37", read: "true" },
      "0x38": { name: "unknown_38", read: "true" },
      "0x39": { name: "unknown_39", read: "true" },
      "0x3C": { name: "unknown_3c", read: "ushort" },
      "0x3E": { name: "mirror", read: "true" },
      "0x40": { name: "unknown_40", read: "true" },
      "0x41": { name: "scaleX", read: "short" },
      "0x42": { name: "scaleY", read: "short" },
      "0x43": { name: "scaleZ", read: "short" },
      "0x44": { name: "mapscene_old", read: "unsigned short" },
      "0x45": { name: "dummy_45", read: "unsigned byte" },
      "0x46": { name: "translateX", read: "short" },
      "0x47": { name: "translateY", read: "short" },
      "0x48": { name: "translateZ", read: "short" },
      "0x49": { name: "unknown_49", read: "true" },
      "0x4A": { name: "unknown_4A", read: "true" },
      "0x4B": { name: "unknown_4B", read: "unsigned byte" },
      "0x4D": { name: "morphs_1", read: [
        "struct",
        ["unk1", "unsigned int"],
        ["unk2", ["array", ["match", "buildnr", { ">=910": "varushort", ">=0": "ubyte" }], "item_modelid"]],
        ["unk3", "item_modelid"]
      ] },
      "0x4E": { name: "light_source_related_4E", read: ["struct", ["maybe_color", "unsigned short"], ["maybe_radius", "unsigned byte"]] },
      "0x4F": { name: "unknown_4F", read: ["struct", ["unknown_1", "unsigned short"], ["unknown_2", "unsigned short"], ["unknown_3", "unsigned byte"], ["unknown_4", ["array", "unsigned short"]]] },
      "0x51": { name: "unknown_51", read: "unsigned byte" },
      "0x52": { name: "unknown_52", read: "true" },
      "0x58": { name: "is_members", read: "true" },
      "0x59": { name: "unknown_59", read: "true" },
      "0x5A": { name: "unknown_5A", read: "true" },
      "0x5B": { name: "isMembers", read: "true" },
      "0x5C": { name: "morphs_2", read: [
        "struct",
        ["unk1", "unsigned int"],
        ["unk2", "item_modelid"],
        ["unk3", ["array", ["match", "buildnr", { ">=910": "varushort", ">=0": "ubyte" }], "item_modelid"]],
        ["unk4", "item_modelid"]
      ] },
      "0x5D": { name: "tilt_xz", read: ["tuple", "byte", "byte"] },
      "0x5E": { name: "under_water", read: "true" },
      "0x5F": { name: "probably_morphCeilingOffset", read: ["match", "buildnr", { ">=596": "short", other: 0 }] },
      "0x60": { name: "unknown_60", read: "true" },
      "0x61": { name: "ground_decoration_related_61", read: "true" },
      "0x62": { name: "has_animated_texture", read: "true" },
      "0x63": { name: "dummy_63", read: ["struct", ["unknown_2", "unsigned byte"], ["unknown_1", "unsigned short"]] },
      "0x64": { name: "dummy_64", read: ["struct", ["unknown_2", "unsigned byte"], ["unknown_1", "unsigned short"]] },
      "0x65": { name: "unused_65", read: "unsigned byte" },
      "0x66": { name: "mapscene", read: "unsigned short" },
      "0x67": { name: "occludes_2", read: "false" },
      "0x68": { name: "interactable_related_68", read: "unsigned byte" },
      "0x69": { name: "invertMapScene", read: "true" },
      "0x6A": { name: "headModels", read: ["array", ["struct", ["model", "varuint"], ["unknown_2", "unsigned byte"]]] },
      "0x6B": { name: "mapFunction", read: "unsigned short" },
      "0x71": { name: "unknown_71", read: "unsigned byte" },
      "0x96": { name: "members_action_1", read: "string" },
      "0x97": { name: "members_action_2", read: "string" },
      "0x98": { name: "members_action_3", read: "string" },
      "0x99": { name: "members_action_4", read: "string" },
      "0x9A": { name: "members_action_5", read: "string" },
      "0xA0": { name: "unknown_A0", read: ["array", "unsigned short"] },
      "0xA2": { name: "singleuse_A2", read: "int" },
      "0xA3": { name: "unknown_A3", read: ["struct", ["unknown_1", "byte"], ["unknown_2", "byte"], ["unknown_3", "byte"], ["unknown_4", "byte"]] },
      "0xA4": { name: "singleuse_A4", read: "short" },
      "0xA5": { name: "singleuse_A5", read: "short" },
      "0xA6": { name: "singleuse_A6", read: "unsigned short" },
      "0xA7": { name: "floor_thickness", read: "unsigned short" },
      "0xA8": { name: "unused_a8", read: "true" },
      "0xA9": { name: "unused_a9", read: "true" },
      "0xAA": { name: "wallkit_related_AA", read: "variable unsigned short" },
      "0xAB": { name: "possibly_wallkit_skew_AB", read: "variable unsigned short" },
      "0xAD": { name: "lightsource_related_AD", read: ["struct", ["unknown_1", "unsigned short"], ["unknown_2", "unsigned short"]] },
      "0xB1": { name: "can_change_color", read: "true" },
      "0xB2": { name: "unknown_B2", read: "unsigned byte" },
      "0xBA": { name: "unknown_BA", read: "unsigned byte" },
      "0xBC": { name: "dummy_bc", read: "true" },
      "0xBD": { name: "treerockordoor_BD", read: "true" },
      "0xBE": { name: "action_cursors_0", read: "unsigned short" },
      "0xBF": { name: "action_cursors_1", read: "unsigned short" },
      "0xC0": { name: "action_cursors_2", read: "unsigned short" },
      "0xC1": { name: "action_cursors_3", read: "unsigned short" },
      "0xC2": { name: "action_cursors_4", read: "unsigned short" },
      "0xC3": { name: "action_cursors_5", read: "unsigned short" },
      "0xC4": { name: "tileplacement_related_c4", read: "unsigned byte" },
      "0xC5": { name: "clan_citadel_C5", read: "unsigned byte" },
      "0xC6": { name: "invisible_c6", read: "true" },
      "0xC7": { name: "flooroverlay_c7", read: "true" },
      "0xC8": { name: "singleuse_C8", read: "true" },
      "0xC9": { name: "unknown_C9", read: ["struct", ["unknown_1", "variable short"], ["unknown_2", "variable short"], ["unknown_3", "variable short"], ["unknown_4", "variable short"], ["unknown_5", "variable short"], ["unknown_6", "variable short"]] },
      "0xCA": { name: "singleuse_CA", read: "unsigned byte" },
      "0xCB": { name: "unknown_CB", read: "true" },
      "0xCC": { name: "unknown_CC", read: ["array", "ubyte", ["buffer", 27, "hex"]] },
      "0xF9": { name: "extra", read: "extrasmap" }
    };
  }
});

// rsmv/src/opcodes/achievements.jsonc
var require_achievements = __commonJS({
  "rsmv/src/opcodes/achievements.jsonc"(exports, module) {
    module.exports = {
      "0x01": { name: "name", read: "paddedstring" },
      "0x02": { name: "description", read: [
        "struct",
        ["hasironman", "unsigned byte"],
        ["unk0", "unsigned byte"],
        ["descr", "paddedstring"],
        ["unk1", ["opt", ["hasironman", 2], "unsigned byte"]],
        ["descr_ironman", ["opt", ["hasironman", 2], "paddedstring"]]
      ] },
      "0x03": { name: "category", read: "unsigned short" },
      "0x04": { name: "spriteId", read: "variable unsigned int" },
      "0x05": { name: "runescore", read: "unsigned byte" },
      "0x06": { name: "unknown_0x06", read: "unsigned short" },
      "0x07": { name: "rewardtext", read: "paddedstring" },
      "0x08": { name: "subach_skills", read: ["array", "variable unsigned short", [
        "struct",
        ["ironman", "unsigned byte"],
        ["level", "unsigned byte"],
        ["text", "paddedstring"],
        ["unk_0", "unsigned byte"],
        ["unk_1", "unsigned byte"],
        ["skill", "unsigned byte"]
      ]] },
      "0x09": { name: "subach_varbits", read: ["array", [
        "struct",
        ["type", "unsigned byte"],
        ["value", "variable unsigned int"],
        ["name", "paddedstring"],
        ["stepsize", "unsigned byte"],
        ["varbit", "unsigned short"]
      ]] },
      "0x0A": { name: "varbit_partial_state", read: ["array", [
        "struct",
        ["type", "unsigned byte"],
        ["value", "variable unsigned int"],
        ["name", "paddedstring"],
        ["stepsize", "unsigned byte"],
        ["varbit", "unsigned short"]
      ]] },
      "0x0B": { name: "previous_achievements", read: ["array", "unsigned tribyte"] },
      "0x0C": { name: "skill_reqs_2", read: ["array", "variable unsigned short", [
        "struct",
        ["unk0", "unsigned byte"],
        ["level", "unsigned byte"],
        ["name", "paddedstring"],
        ["unk1", "unsigned byte"],
        ["skill", "unsigned short"]
      ]] },
      "0x0E": { name: "progress_states", read: ["array", "variable unsigned short", [
        "struct",
        ["unk0", "unsigned byte"],
        ["value", "variable unsigned int"],
        ["name", "paddedstring"],
        ["varbits", ["array", "unsigned short"]]
      ]] },
      "0x0D": { name: "subreqs", read: ["array", "variable unsigned short", [
        "struct",
        ["unk0", "unsigned byte"],
        ["value", "variable unsigned int"],
        ["name", "paddedstring"],
        ["varbits", ["array", "unsigned short"]]
      ]] },
      "0x0F": { name: "sub_achievements", read: ["array", "variable unsigned short", [
        "struct",
        ["unk0", "unsigned byte"],
        ["achievement", "unsigned short"]
      ]] },
      "0x10": { name: "subcategory", read: "unsigned short" },
      "0x11": { name: "unk0x11", read: "true" },
      "0x12": { name: "hidden", read: "unsigned byte" },
      "0x13": { name: "f2p", read: "true" },
      "0x14": { name: "quest_req_for_miniquests", read: ["array", "unsigned tribyte"] },
      "0x15": { name: "quest_ids", read: ["array", "unsigned tribyte"] },
      "0x17": { name: "reqs23", read: ["array", "variable unsigned short", [
        "struct",
        ["type", "unsigned byte"],
        ["varbit", "unsigned short"],
        ["stepsize", "unsigned byte"],
        ["name", ["opt", ["type", 0], "paddedstring"]],
        ["requirement", ["opt", ["type", 1], "unsigned short"]],
        ["subbit", "unsigned byte"]
      ]] },
      "0x19": { name: "reqs25", read: ["array", "variable unsigned short", [
        "struct",
        ["type", "unsigned byte"],
        ["varbit", "unsigned short"],
        ["value", "unsigned byte"],
        ["name", ["opt", ["type", 0], "paddedstring"]],
        ["requirement", ["opt", ["type", 1], "unsigned short"]],
        ["subbit", "unsigned byte"]
      ]] },
      "0x1B": { name: "unknown_0x13", read: "true" },
      "0x1C": { name: "skill_req_count", read: ["array", "unsigned byte"] },
      "0x1D": { name: "unknown_0x1D", read: "unsigned byte" },
      "0x1E": { name: "subreq_count", read: ["array", "variable unsigned short"] },
      "0x1F": { name: "unknown_0x1F", read: "unsigned byte" },
      "0x20": { name: "unknown_0x20", read: "unsigned tribyte" },
      "0x23": { name: "unknown_0x23", read: "true" },
      "0x25": { name: "unknown_0x25", read: "unsigned byte" },
      "0x26": { name: "unknown_0x26", read: "true" }
    };
  }
});

// rsmv/src/opcodes/mapsquare_tiles.jsonc
var require_mapsquare_tiles = __commonJS({
  "rsmv/src/opcodes/mapsquare_tiles.jsonc"(exports, module) {
    module.exports = [
      "struct",
      ["magic", ["match", "buildnr", { ">=936": ["tuple", "uint", "ubyte"], other: null }]],
      ["tiles", [
        "array",
        16384,
        ["match", "buildnr", {
          ">=750": [
            "struct",
            ["flags", "unsigned byte"],
            ["shape", ["opt", ["flags", 0, "bitflag"], "unsigned byte"]],
            ["overlay", ["opt", ["flags", 0, "bitflag"], "variable unsigned short"]],
            ["settings", ["opt", ["flags", 1, "bitflag"], "unsigned byte"]],
            ["underlay", ["opt", ["flags", 2, "bitflag"], "variable unsigned short"]],
            ["height", ["opt", ["flags", 3, "bitflag"], ["match", "buildnr", { ">=936": "ushort", other: "ubyte" }]]]
          ],
          other: ["legacy_maptile"]
        }]
      ]],
      ["olddata", ["match", "buildnr", { ">=498": null, other: ["buffer", ["bytesleft"], "hex"] }]],
      ["nonmembarea", ["match", "buildnr", { ">=765": ["buffer", 8, "hex"], other: null }]],
      ["extra", {
        "0x00": { name: "unk00", read: [
          "struct",
          ["flags", "ubyte"],
          ["unk01", ["opt", ["flags", 0, "bitflag"], ["array", 4, "ubyte"]]],
          ["unk02", ["opt", ["flags", 1, "bitflag"], "ushort"]],
          ["unk04", ["opt", ["flags", 2, "bitflag"], "ushort"]],
          ["unk08", ["opt", ["flags", 3, "bitflag"], "ushort"]],
          ["unk10", ["opt", ["flags", 4, "bitflag"], ["tuple", "ushort", "ushort", "ushort"]]],
          ["unk20", ["opt", ["flags", 5, "bitflag"], ["array", 4, "ubyte"]]],
          ["unk40", ["opt", ["flags", 6, "bitflag"], "ushort"]],
          ["unk80", ["opt", ["flags", 7, "bitflag"], ["match", "buildnr", { ">=759": "ushort", other: ["array", 6, "ushort"] }]]]
        ] },
        "0x01": { name: "unk01", read: ["array", "ubyte", [
          "struct",
          ["byte2", "ubyte"],
          ["short0", "ushort"],
          ["short1", "ushort"],
          ["short2", "ushort"],
          ["array5", ["array", "ubyte", ["array", 4, "ubyte"]]],
          ["short3", "ushort"],
          ["short4", "ushort"],
          ["extraflags", "ubyte"],
          ["extra08", ["match", "buildnr", { ">=804": "ushort", other: 0 }]],
          ["extra1f", ["opt", ["extraflags", 31, "bitand"], "ushort"]]
        ]] },
        "0x02": { name: "unk02", read: ["array", 3, ["match", "buildnr", { ">=780": "float", other: "byte" }]] },
        "0x03": { name: "unk03", read: ["tuple", "short", "float"] },
        "0x80": { name: "unk80", read: [
          "struct",
          ["environment", "ushort"],
          ["always00", ["buffer", 8, "hex"]]
        ] },
        "0x81": { name: "unk81", read: ["array", 4, [
          "struct",
          ["flag", "ubyte"],
          ["data", ["opt", ["flag", 0, "bitflag"], ["buffer", 256, "hex"]]]
        ]] },
        "0x82": { name: "unk82", read: "true" }
      }]
    ];
  }
});

// rsmv/src/opcodes/mapsquare_tiles_nxt.jsonc
var require_mapsquare_tiles_nxt = __commonJS({
  "rsmv/src/opcodes/mapsquare_tiles_nxt.jsonc"(exports, module) {
    module.exports = {
      "0x6a": { name: "magic", read: "uint" },
      "0x00": { name: "level0", read: ["array", 4356, [
        "struct",
        ["flags", "ubyte"],
        ["height", ["match", "buildnr", { ">=936": "ushort", other: "ubyte" }]],
        ["rest", ["opt", ["flags", 0, "bitflag"], [
          "struct",
          ["waterheight", ["opt", "flags&16", ["match", "buildnr", { ">=936": "ushort", other: "ubyte" }]]],
          ["underlay", "varushort"],
          ["underlaycolor", ["opt", "underlay!=0", "ushort"]],
          ["overlay", "varushort"],
          ["overlay_under", ["opt", "flags&16", "varushort"]],
          ["shape", ["opt", "overlay!=0", "ubyte"]],
          ["underlay_under", ["opt", "overlay!=0 && flags&16", "varushort"]]
        ]]]
      ]] },
      "0x01": { name: "level1", read: ["array", 4356, [
        "struct",
        ["flags", "ubyte"],
        ["height", ["match", "buildnr", { ">=936": "ushort", other: "ubyte" }]],
        ["rest", ["opt", ["flags", 0, "bitflag"], [
          "struct",
          ["waterheight", ["opt", "flags&16", ["match", "buildnr", { ">=936": "ushort", other: "ubyte" }]]],
          ["underlay", "varushort"],
          ["underlaycolor", ["opt", "underlay!=0", "ushort"]],
          ["overlay", "varushort"],
          ["overlay_under", ["opt", "flags&16", "varushort"]],
          ["shape", ["opt", "overlay!=0", "ubyte"]],
          ["underlay_under", ["opt", "overlay!=0 && flags&16", "varushort"]]
        ]]]
      ]] },
      "0x02": { name: "level2", read: ["array", 4356, [
        "struct",
        ["flags", "ubyte"],
        ["height", ["match", "buildnr", { ">=936": "ushort", other: "ubyte" }]],
        ["rest", ["opt", ["flags", 0, "bitflag"], [
          "struct",
          ["waterheight", ["opt", "flags&16", ["match", "buildnr", { ">=936": "ushort", other: "ubyte" }]]],
          ["underlay", "varushort"],
          ["underlaycolor", ["opt", "underlay!=0", "ushort"]],
          ["overlay", "varushort"],
          ["overlay_under", ["opt", "flags&16", "varushort"]],
          ["shape", ["opt", "overlay!=0", "ubyte"]],
          ["underlay_under", ["opt", "overlay!=0 && flags&16", "varushort"]]
        ]]]
      ]] },
      "0x03": { name: "level3", read: ["array", 4356, [
        "struct",
        ["flags", "ubyte"],
        ["height", ["match", "buildnr", { ">=936": "ushort", other: "ubyte" }]],
        ["rest", ["opt", ["flags", 0, "bitflag"], [
          "struct",
          ["waterheight", ["opt", "flags&16", ["match", "buildnr", { ">=936": "ushort", other: "ubyte" }]]],
          ["underlay", "varushort"],
          ["underlaycolor", ["opt", "underlay!=0", "ushort"]],
          ["overlay", "varushort"],
          ["overlay_under", ["opt", "flags&16", "varushort"]],
          ["shape", ["opt", "overlay!=0", "ubyte"]],
          ["underlay_under", ["opt", "overlay!=0 && flags&16", "varushort"]]
        ]]]
      ]] }
    };
  }
});

// rsmv/src/opcodes/mapsquare_watertiles.json
var require_mapsquare_watertiles = __commonJS({
  "rsmv/src/opcodes/mapsquare_watertiles.json"(exports, module) {
    module.exports = ["array", 4096, [
      "struct",
      ["flags", "unsigned byte"],
      ["shape", ["opt", ["flags", 0, "bitflag"], "unsigned byte"]],
      ["overlay", ["opt", ["flags", 0, "bitflag"], "variable unsigned short"]],
      ["settings", ["opt", ["flags", 1, "bitflag"], "unsigned byte"]],
      ["underlay", ["opt", ["flags", 2, "bitflag"], "variable unsigned short"]],
      ["height", ["opt", ["flags", 3, "bitflag"], "unsigned byte"]]
    ]];
  }
});

// rsmv/src/opcodes/mapsquare_underlays.jsonc
var require_mapsquare_underlays = __commonJS({
  "rsmv/src/opcodes/mapsquare_underlays.jsonc"(exports, module) {
    module.exports = {
      "0x01": { name: "color", read: ["array", 3, "unsigned byte"] },
      "0x02": { name: "material", read: "unsigned short" },
      "0x03": { name: "material_tiling", read: "unsigned short" },
      "0x04": { name: "unknown_0x04", read: "true" },
      "0x05": { name: "unknown_0x05", read: "true" }
    };
  }
});

// rsmv/src/opcodes/mapsquare_overlays.jsonc
var require_mapsquare_overlays = __commonJS({
  "rsmv/src/opcodes/mapsquare_overlays.jsonc"(exports, module) {
    module.exports = {
      "0x01": { name: "color", read: ["array", 3, "unsigned byte"] },
      "0x02": { name: "materialbyte", read: "unsigned byte" },
      "0x03": { name: "material", read: ["match", "buildnr", { ">377": "unsigned short", other: 0 }] },
      "0x05": { name: "unknown_0x05", read: "true" },
      "0x06": { name: "name", read: "string" },
      "0x07": { name: "secondary_colour", read: ["array", 3, "unsigned byte"] },
      "0x08": { name: "unknown_0x08", read: "true" },
      "0x09": { name: "material_tiling", read: "unsigned short" },
      "0x0A": { name: "unknown_0x0A", read: "true" },
      "0x0B": { name: "bleedpriority", read: "unsigned byte" },
      "0x0C": { name: "bleedToUnderlay", read: "true" },
      "0x0D": { name: "tertiary_colour", read: ["array", 3, "unsigned byte"] },
      "0x0E": { name: "unknown_0x0E", read: "unsigned byte" },
      "0x0F": { name: "unknown_0x0F", read: "unsigned short" },
      "0x10": { name: "unknown_0x10", read: "unsigned byte" }
    };
  }
});

// rsmv/src/opcodes/mapsquare_locations.json
var require_mapsquare_locations = __commonJS({
  "rsmv/src/opcodes/mapsquare_locations.json"(exports, module) {
    module.exports = [
      "struct",
      ["$idcounter", "-1"],
      ["locations", ["nullarray", "tailed unsigned short", [
        "struct",
        ["id", ["accum", "$idcounter", ["ref", "$opcode"]]],
        ["$location", "0"],
        ["uses", ["nullarray", "variable unsigned short", [
          "struct",
          ["$loc", ["accum", "$location", ["ref", "$opcode"], "add-1"]],
          ["y", ["ref", "$loc", [0, 6]]],
          ["x", ["ref", "$loc", [6, 6]]],
          ["plane", ["ref", "$loc", [12, 2]]],
          ["$data", "unsigned byte"],
          ["rotation", ["ref", "$data", [0, 2]]],
          ["type", ["ref", "$data", [2, 5]]],
          ["extra", ["opt", ["$data", 7, "bitflag"], [
            "struct",
            ["flags", "unsigned byte"],
            ["rotation", ["opt", ["flags", 0, "bitflag"], ["array", 4, "short"]]],
            ["translateX", ["opt", ["flags", 1, "bitflag"], "short"]],
            ["translateY", ["opt", ["flags", 2, "bitflag"], "short"]],
            ["translateZ", ["opt", ["flags", 3, "bitflag"], "short"]],
            ["scale", ["opt", ["flags", 4, "bitflag"], "unsigned short"]],
            ["scaleX", ["opt", ["flags", 5, "bitflag"], "unsigned short"]],
            ["scaleY", ["opt", ["flags", 6, "bitflag"], "unsigned short"]],
            ["scaleZ", ["opt", ["flags", 7, "bitflag"], "unsigned short"]]
          ]]]
        ]]]
      ]]]
    ];
  }
});

// rsmv/src/opcodes/mapsquare_envs.jsonc
var require_mapsquare_envs = __commonJS({
  "rsmv/src/opcodes/mapsquare_envs.jsonc"(exports, module) {
    module.exports = [
      "struct",
      ["unk", "ubyte"]
    ];
  }
});

// rsmv/src/opcodes/mapzones.json
var require_mapzones = __commonJS({
  "rsmv/src/opcodes/mapzones.json"(exports, module) {
    module.exports = [
      "struct",
      ["internal_name", "string"],
      ["name", "string"],
      ["center", "unsigned int"],
      ["unknown_1", "unsigned int"],
      ["show", "boolean"],
      ["default_zoom", "unsigned byte"],
      ["unknown_2", "unsigned byte"],
      ["bounds", [
        "array",
        [
          "struct",
          ["plane", "unsigned byte"],
          ["src", [
            "struct",
            ["xstart", "unsigned short"],
            ["zstart", "unsigned short"],
            ["xend", "unsigned short"],
            ["zend", "unsigned short"]
          ]],
          ["dst", [
            "struct",
            ["xstart", "unsigned short"],
            ["zstart", "unsigned short"],
            ["xend", "unsigned short"],
            ["zend", "unsigned short"]
          ]]
        ]
      ]]
    ];
  }
});

// rsmv/src/opcodes/enums.json
var require_enums = __commonJS({
  "rsmv/src/opcodes/enums.json"(exports, module) {
    module.exports = {
      "0x01": { name: "key_type1", read: "unsigned byte" },
      "0x02": { name: "value_type1", read: "unsigned byte" },
      "0x65": { name: "key_type2", read: "unsigned byte" },
      "0x66": { name: "value_type2", read: "unsigned byte" },
      "0x03": { name: "stringValue", read: "string" },
      "0x04": { name: "intValue", read: "int" },
      "0x05": { name: "stringArrayValue1", read: ["array", "unsigned short", ["tuple", "int", "string"]] },
      "0x06": { name: "intArrayValue1", read: ["array", "unsigned short", ["tuple", "int", "int"]] },
      "0x07": { name: "stringArrayValue2", read: ["struct", ["max", "unsigned short"], ["values", ["array", "unsigned short", ["tuple", "unsigned short", "string"]]]] },
      "0x08": { name: "intArrayValue2", read: ["struct", ["max", "unsigned short"], ["values", ["array", "unsigned short", ["tuple", "unsigned short", "int"]]]] },
      "0x83": { name: "unknown_83", read: "true" },
      "0xd1": { name: "unknown_d1", read: "true" }
    };
  }
});

// rsmv/src/opcodes/mapscenes.json
var require_mapscenes = __commonJS({
  "rsmv/src/opcodes/mapscenes.json"(exports, module) {
    module.exports = {
      "0x01": { name: "sprite_id", read: "variable unsigned int" },
      "0x02": { name: "unknown_2", read: "unsigned int" },
      "0x03": { name: "unknown_3", read: "true" },
      "0x04": { name: "unknown_4", read: "true" },
      "0x05": { name: "unknown_5", read: "true" }
    };
  }
});

// rsmv/src/opcodes/sequences.json
var require_sequences = __commonJS({
  "rsmv/src/opcodes/sequences.json"(exports, module) {
    module.exports = {
      "0x01": { name: "frames", read: [
        "chunkedarray",
        "unsigned short",
        [["framelength", "unsigned short"]],
        [["frameidlow", "unsigned short"]],
        [["frameidhi", "unsigned short"]]
      ] },
      "0x02": { name: "unknown_02", read: "ushort" },
      "0x03": { name: "unknown_03", read: ["array", "ubyte", "ubyte"] },
      "0x04": { name: "unknown_04", read: "true" },
      "0x05": { name: "unknown_05", read: "ubyte" },
      "0x06": { name: "unknown_06", read: "ushort" },
      "0x07": { name: "unknown_07", read: "ushort" },
      "0x08": { name: "unknown_08", read: "ubyte" },
      "0x09": { name: "unknown_09", read: "ubyte" },
      "0x0A": { name: "unknown_0A", read: "ubyte" },
      "0x0B": { name: "unknown_0B", read: "ubyte" },
      "0x0C": { name: "unknown_0C", read: [
        "chunkedarray",
        "ubyte",
        [["framelength", "unsigned short"]],
        [["frameidlow", "unsigned short"]]
      ] },
      "0x0D": { name: "unknown_0D", read: ["array", "unsigned short", [
        "struct",
        ["$keys", "unsigned byte"],
        ["default", ["opt", ["$keys", 0, "eqnot"], "unsigned short"]],
        ["weirdbyte", ["opt", ["$keys", 0, "eqnot"], "unsigned byte"]],
        ["extras", ["array", ["ref", "$keys", null, -1], "unsigned short"]]
      ]] },
      "0x0E": { name: "unknown_0E", read: "true" },
      "0x0F": { name: "unknown_0F", read: "true" },
      "0x10": { name: "unknown_10", read: "true" },
      "0x11": { name: "unknown_11", read: "ubyte" },
      "0x12": { name: "unknown_12", read: "true" },
      "0x13": { name: "unknown_13", read: "unsigned short" },
      "0x14": { name: "unknown_14", read: ["buffer", 5, "hex"] },
      "0x16": { name: "unknown_16", read: "unsigned byte" },
      "0x18": { name: "unknown_18", read: "unsigned short" },
      "0x19": { name: "skeletal_animation", read: "unsigned short" },
      "0x1a": { name: "skeletal_range", read: ["tuple", "ushort", "ushort"] },
      "0x1b": { name: "unknown_1B", read: "ubyte" },
      "0x70": { name: "unknown_70", read: [
        "chunkedarray",
        "unsigned short",
        [["intlow", "unsigned short"]],
        [["maybe_file", "unsigned short"]]
      ] },
      "0x77": { name: "unknown_77", read: ["tuple", "unsigned short", "unsigned byte"] },
      "0x78": { name: "unknown_78", read: ["tuple", "unsigned short", "unsigned short", "unsigned short"] },
      "0xF9": { name: "extra", read: "extrasmap" }
    };
  }
});

// rsmv/src/opcodes/framemaps.jsonc
var require_framemaps = __commonJS({
  "rsmv/src/opcodes/framemaps.jsonc"(exports, module) {
    module.exports = [
      "struct",
      ["data", [
        "chunkedarray",
        "ushort",
        [["type", "ubyte"]],
        [["unknown", "bool"]],
        [["unknown_always_FFFF", "ushort"]],
        [["length", "varushort"]],
        [["data", ["array", ["ref", "length"], "varushort"]]]
      ]],
      ["skeleton", [
        "chunkedarray",
        "ushort",
        [
          ["parentbone", "ubyte"],
          ["nonskinboneid", "ushort"],
          ["bonematrix", ["array", 16, "float"]],
          ["dataq", ["buffer", 11, "hex"]]
        ]
      ]],
      ["activebones", ["buffer", ["bytesleft"], "hex"]]
    ];
  }
});

// rsmv/src/opcodes/frames.json
var require_frames = __commonJS({
  "rsmv/src/opcodes/frames.json"(exports, module) {
    module.exports = [
      "struct",
      ["header_always_2", "ubyte"],
      ["probably_framemap_id", "ushort"],
      ["flags", ["array", "ushort", "ubyte"]],
      ["animdata", ["buffer", ["bytesleft"], "ubyte"]]
    ];
  }
});

// rsmv/src/opcodes/animgroupconfigs.jsonc
var require_animgroupconfigs = __commonJS({
  "rsmv/src/opcodes/animgroupconfigs.jsonc"(exports, module) {
    module.exports = {
      "0x01": { name: "baseAnims", read: ["struct", ["idle", "animid"], ["walk", "animid"]] },
      "0x02": { name: "unknown_02", read: "animid" },
      "0x03": { name: "unknown_03", read: "animid" },
      "0x05": { name: "unknown_05", read: "animid" },
      "0x04": { name: "unknown_04", read: "animid" },
      "0x06": { name: "run", read: "animid" },
      "0x07": { name: "unknown_07", read: "animid" },
      "0x08": { name: "unknown_08", read: "animid" },
      "0x09": { name: "unknown_09", read: "animid" },
      "0x1a": { name: "unknown_1a", read: ["tuple", "ubyte", "ubyte"] },
      "0x1b": { name: "unknown_1b", read: "animid" },
      "0x26": { name: "unknown_26", read: "animid" },
      "0x27": { name: "unknown_27", read: "animid" },
      "0x28": { name: "unknown_28", read: "animid" },
      "0x29": { name: "unknown_29", read: "animid" },
      "0x2a": { name: "unknown_2a", read: "animid" },
      "0x2b": { name: "unknown_2b", read: "animid" },
      "0x2c": { name: "unknown_2c", read: "animid" },
      "0x2d": { name: "unknown_2d", read: "animid" },
      "0x2e": { name: "unknown_2e", read: "animid" },
      "0x2f": { name: "unknown_2f", read: "animid" },
      "0x30": { name: "unknown_30", read: "animid" },
      "0x31": { name: "unknown_31", read: "animid" },
      "0x32": { name: "unknown_32", read: "animid" },
      "0x33": { name: "unknown_33", read: "animid" },
      "0x34": { name: "idleVariations", read: ["array", "ubyte", [
        "struct",
        ["animid", "animid"],
        ["probably_chance", "ubyte"],
        ["always0", ["match", "buildnr", { ">=916": "ubyte", other: 0 }]]
      ]] },
      "0x35": { name: "unknown_35", read: "true" },
      "0x36": { name: "unknown_36", read: ["tuple", "ubyte", "ubyte"] }
    };
  }
});

// rsmv/src/opcodes/models.jsonc
var require_models = __commonJS({
  "rsmv/src/opcodes/models.jsonc"(exports, module) {
    module.exports = [
      "struct",
      ["format", "ubyte"],
      ["version", "ubyte"],
      ["always_0f", "ubyte"],
      ["meshCount", "ubyte"],
      ["unkCount0", "ubyte"],
      ["unkCount1", "ubyte"],
      ["unkCount2", "ubyte"],
      ["unkCount3", "ubyte"],
      ["unkCount4", ["match", { "version>=5": "ubyte", other: 0 }]],
      ["meshes", ["opt", "version<=3", ["array", ["ref", "meshCount"], [
        "struct",
        ["$groupFlags", "ubyte"],
        ["unkint", "uint"],
        ["materialArgument", "ushort le"],
        ["faceCount", "ushort le"],
        ["hasVertices", ["ref", "$groupFlags", [0, 1]]],
        ["hasVertexAlpha", ["ref", "$groupFlags", [1, 1]]],
        ["hasFaceBones", ["ref", "$groupFlags", [2, 1]]],
        ["hasBoneIds", ["ref", "$groupFlags", [3, 1]]],
        ["isHidden", ["ref", "$groupFlags", [4, 1]]],
        ["hasSkin", ["ref", "$groupFlags", [5, 1]]],
        ["colourBuffer", ["opt", ["hasVertices", 1], ["buffer", ["ref", "faceCount"], "ushort"]]],
        ["alphaBuffer", ["opt", ["hasVertexAlpha", 1], ["buffer", ["ref", "faceCount"], "ubyte"]]],
        ["faceboneidBuffer", ["opt", ["hasFaceBones", 1], ["buffer", ["ref", "faceCount"], "ushort"]]],
        ["indexBuffers", ["array", "ubyte", ["buffer", "ushort le", "ushort"]]],
        ["vertexCount", ["match", ["ref", "hasVertices"], { "=1": "ushort le", "=0": 0 }]],
        ["positionBuffer", ["opt", ["hasVertices", 1], ["buffer", ["ref", "vertexCount"], "short", 3]]],
        ["normalBuffer", ["opt", ["hasVertices", 1], ["match", "buildnr", {
          ">=887": ["buffer", ["ref", "vertexCount"], "byte", 3],
          ">=0": ["buffer", ["ref", "vertexCount"], "short", 3]
        }]]],
        ["tagentBuffer", ["opt", ["hasVertices", 1], ["match", "buildnr", {
          ">=906": ["buffer", ["ref", "vertexCount"], "short", 2],
          ">=0": "null"
        }]]],
        ["uvBuffer", ["opt", ["hasVertices", 1], ["match", "buildnr", {
          ">=887": ["buffer", ["ref", "vertexCount"], "ushort", 2],
          ">=0": ["buffer", ["ref", "vertexCount"], "float", 2]
        }]]],
        ["boneidBuffer", ["opt", ["hasBoneIds", 1], ["buffer", ["ref", "vertexCount"], "ushort"]]],
        ["skin", ["opt", ["hasSkin", 1], [
          "struct",
          ["skinWeightCount", "uint le"],
          ["skinBoneBuffer", ["buffer", ["ref", "skinWeightCount"], "ushort", 1]],
          ["skinWeightBuffer", ["buffer", ["ref", "skinWeightCount"], "ubyte", 1]]
        ]]]
      ]]]],
      ["meshdata", ["opt", "version>3", [
        "struct",
        ["$groupFlags", "ubyte"],
        ["unkint", "ubyte"],
        ["faceCount", "ushort le"],
        ["hasVertices", ["ref", "$groupFlags", [0, 1]]],
        ["hasVertexAlpha", ["ref", "$groupFlags", [1, 1]]],
        ["hasFaceBones", ["ref", "$groupFlags", [2, 1]]],
        ["hasBoneIds", ["ref", "$groupFlags", [3, 1]]],
        ["isHidden", ["ref", "$groupFlags", [4, 1]]],
        ["hasSkin", ["ref", "$groupFlags", [5, 1]]],
        ["vertexCount", "uint le"],
        ["positionBuffer", ["opt", ["hasVertices", 1], ["buffer", ["ref", "vertexCount"], "short", 3]]],
        ["normalBuffer", ["opt", ["hasVertices", 1], ["buffer", ["ref", "vertexCount"], "byte", 3]]],
        ["tagentBuffer", ["opt", ["hasVertices", 1], ["buffer", ["ref", "vertexCount"], "short", 2]]],
        ["uvBuffer", ["opt", ["hasVertices", 1], ["buffer", ["ref", "vertexCount"], "ushort", 2]]],
        ["boneidBuffer", ["opt", ["hasBoneIds", 1], ["buffer", ["ref", "vertexCount"], "ushort"]]],
        ["skin", ["opt", "hasSkin==1", ["array", ["ref", "vertexCount"], [
          "struct",
          ["ids", ["array", "ushort le", "ushort le"]],
          ["weights", ["array", "ushort le", "ubyte"]]
        ]]]],
        ["vertexColours", ["opt", "hasVertices==1", ["buffer", ["ref", "vertexCount"], "ushort"]]],
        ["vertexAlpha", ["opt", "hasVertices==1", ["buffer", ["ref", "vertexCount"], "ubyte"]]],
        ["vertexFacebones", ["opt", "hasFaceBones==1", ["buffer", ["ref", "vertexCount"], "ushort"]]],
        ["renders", ["array", ["ref", "meshCount"], [
          "struct",
          ["$groupFlags", "ubyte"],
          ["hasVertices", ["ref", "$groupFlags", [0, 1]]],
          ["hasVertexAlpha", ["ref", "$groupFlags", [1, 1]]],
          ["hasFaceBones", ["ref", "$groupFlags", [2, 1]]],
          ["hasBoneIds", ["ref", "$groupFlags", [3, 1]]],
          ["isHidden", ["ref", "$groupFlags", [4, 1]]],
          ["hasSkin", ["ref", "$groupFlags", [5, 1]]],
          ["unkint", "uint"],
          ["materialArgument", "ushort le"],
          ["unkbyte2", "ubyte"],
          ["buf", ["match", {
            "vertexCount<=0xffff": ["buffer", "ushort le", "ushort"],
            other: ["buffer", "ushort le", "uint"]
          }]]
        ]]]
      ]]],
      ["unk1Buffer", ["array", ["ref", "unkCount1"], ["buffer", ["match", "buildnr", { ">=923": 39, ">=0": 37 }], "hex"]]],
      ["unk2Buffer", ["array", ["ref", "unkCount2"], ["buffer", ["match", "buildnr", { ">=923": 50, ">=0": 44 }], "hex"]]],
      ["unk3Buffer", ["array", ["ref", "unkCount3"], ["buffer", ["match", "buildnr", { ">=923": 18, ">=0": 16 }], "hex"]]],
      ["unk4Buffer", ["array", ["ref", "unkCount4"], ["buffer", 0]]]
    ];
  }
});

// rsmv/src/opcodes/oldmodels.jsonc
var require_oldmodels = __commonJS({
  "rsmv/src/opcodes/oldmodels.jsonc"(exports, module) {
    module.exports = [
      "struct",
      ["footbytes", ["match", "buildnr", { ">=764": 65535, ">=0": ["footer", 2, "ushort"] }]],
      ["colanimcount", ["match", "buildnr", { ">=764": ["footer", 2, "ushort"], ">=0": 0 }]],
      ["unkcount0", ["match", "buildnr", { ">=764": ["footer", 2, "ushort"], ">=0": 0 }]],
      ["uvcount", ["match", ["ref", "footbytes"], {
        "0xffff": ["footer", 2, "ushort"],
        other: 0
      }]],
      ["indexbufsize", ["match", ["ref", "footbytes"], {
        "0xffff": ["footer", 2, "ushort"],
        other: ["ref", "footbytes"]
      }]],
      ["zsize", ["footer", 2, "ushort"]],
      ["ysize", ["footer", 2, "ushort"]],
      ["xsize", ["footer", 2, "ushort"]],
      ["hasbones", ["footer", 1, "bool"]],
      ["hasmaterials", ["match", ["ref", "footbytes"], {
        "0xffff": ["footer", 1, "bool"],
        other: false
      }]],
      ["flag3", ["footer", 1, "bool"]],
      ["hasalpha", ["footer", 1, "bool"]],
      ["priority", ["footer", 1, "ubyte"]],
      ["extraflags", ["footer", 1, "ubyte"]],
      ["texmapcount", ["match", "buildnr", { ">=764": ["footer", 2, "ushort"], ">=0": ["footer", 1, "ubyte"] }]],
      ["facecount", ["footer", 2, "ushort"]],
      ["vertcount", ["footer", 2, "ushort"]],
      ["header1", ["match", "buildnr", { ">=754": "ubyte", ">=0": 0 }]],
      ["header2", ["match", "buildnr", { ">=764": "ubyte", ">=0": 0 }]],
      ["modelversion", ["match", "buildnr", {
        ">=764": "ubyte",
        other: ["match", ["ref", "extraflags"], {
          "&8": ["footer", 1, "ubyte"],
          other: 0
        }]
      }]],
      ["vertdatasize", ["match", "buildnr", {
        ">=764": ["ref", "unkcount0"],
        other: ["match", ["ref", "extraflags"], {
          "&0x10": ["footer", 2, "ushort"],
          other: ["ref", "vertcount"]
        }]
      }]],
      ["texmap_vertcount", 0],
      ["texmap_projectioncount", 0],
      ["texmap_transsize", 0],
      [
        "texflags",
        [
          "array",
          ["ref", "texmapcount"],
          ["match", ["match", ["ref", "footbytes"], { "65535": "ubyte", other: 0 }], {
            "0": [
              "struct",
              ["type", 0],
              ["vertindex", ["accum", "texmap_vertcount", 1, "postadd"]]
            ],
            "1": [
              "struct",
              ["type", 1],
              ["projection", ["accum", "texmap_projectioncount", 1, "postadd"]],
              ["speed", ["accum", "texmap_transsize", 1, "postadd"]]
            ],
            "2": [
              "struct",
              ["type", 2],
              ["projection", ["accum", "texmap_projectioncount", 1, "postadd"]],
              ["speed", ["accum", "texmap_transsize", 3, "postadd"]]
            ],
            "3": [
              "struct",
              ["type", 3],
              ["projection", ["accum", "texmap_projectioncount", 1, "postadd"]],
              ["speed", ["accum", "texmap_transsize", 1, "postadd"]]
            ]
          }]
        ]
      ],
      ["vertflags", ["buffer", ["ref", "vertcount"], "ubyte"]],
      ["mode_1", ["match", ["ref", "footbytes"], {
        "0xffff": ["opt", ["extraflags", 0, "bitflag"], ["buffer", ["ref", "facecount"], "ubyte"]],
        other: null
      }]],
      ["tritype", ["buffer", ["ref", "facecount"], "ubyte"]],
      ["facepriority", ["opt", ["priority", 255], ["buffer", ["ref", "facecount"], "ubyte"]]],
      ["unk1", ["opt", ["flag3", 1], ["buffer", ["match", "buildnr", { ">=764": ["ref", "colanimcount"], ">=0": ["ref", "facecount"] }]]]],
      ["mode_2", ["match", ["ref", "footbytes"], {
        "0xffff": null,
        other: ["opt", ["extraflags", 0, "bitflag"], ["buffer", ["ref", "facecount"], "ubyte"]]
      }]],
      ["boneids", ["opt", ["hasbones", 1], ["buffer", ["ref", "vertdatasize"]]]],
      ["alpha", ["opt", ["hasalpha", 1], ["buffer", ["ref", "facecount"]]]],
      ["indexbuffer", ["buffer", ["ref", "indexbufsize"]]],
      ["material", ["match", ["ref", "footbytes"], {
        "0xffff": ["opt", ["hasmaterials", 1], ["buffer", ["ref", "facecount"], "ushort"]],
        other: null
      }]],
      ["uvs", ["buffer", ["ref", "uvcount"]]],
      ["colors", ["buffer", ["ref", "facecount"], "ushort"]],
      ["texmap_verts_1", ["match", ["ref", "footbytes"], {
        "0xffff": null,
        other: ["array", ["ref", "texmap_vertcount"], ["tuple", "ushort", "ushort", "ushort"]]
      }]],
      ["posx", ["buffer", ["ref", "xsize"]]],
      ["posy", ["buffer", ["ref", "ysize"]]],
      ["posz", ["buffer", ["ref", "zsize"]]],
      ["texmap_verts_2", ["match", ["ref", "footbytes"], {
        "0xffff": ["array", ["ref", "texmap_vertcount"], ["tuple", "ushort", "ushort", "ushort"]],
        other: null
      }]],
      ["texmap_projections", ["chunkedarray", ["ref", "texmap_projectioncount"], [
        ["normal", ["tuple", "short", "short", "short"]]
      ], [
        ["scale", [
          "tuple",
          ["match", ["ref", "modelversion"], { ">=15": "unsigned tribyte", ">=0": "ushort" }],
          ["match", ["ref", "modelversion"], { ">=14": "unsigned tribyte", ">=0": "ushort" }],
          ["match", ["ref", "modelversion"], { ">=15": "unsigned tribyte", ">=0": "ushort" }]
        ]]
      ], [
        ["rotation", "ubyte"]
      ], [
        ["direction", "ubyte"]
      ]]],
      ["texmap_translates", ["array", ["ref", "texmap_transsize"], "ubyte"]],
      ["particles", ["opt", ["extraflags", 1, "bitflag"], ["array", "ubyte", [
        "struct",
        ["texture", "ushort"],
        ["faceid", "ushort"]
      ]]]],
      ["effectors", ["opt", ["extraflags", 1, "bitflag"], ["array", "ubyte", [
        "struct",
        ["effector", "ushort"],
        ["vertex", "ushort"]
      ]]]],
      ["billboards", ["opt", ["extraflags", 2, "bitflag"], ["array", "ubyte", [
        "struct",
        ["unk1", "ushort"],
        ["unk2", "ushort"],
        ["unk3", "ubyte"],
        ["unk4", "ubyte"]
      ]]]],
      ["texuvs", ["opt", ["extraflags", 7, "bitflag"], [
        "struct",
        ["headoffset", ["footer", 1, "ubyte"]],
        ["indexsize", ["footer", 2, "ushort"]],
        ["datasize", ["footer", 2, "ushort"]],
        ["coordcount", ["footer", 2, "ushort"]],
        ["index", ["buffer", ["ref", "indexsize"], "ubyte"]],
        ["vertex", ["buffer", ["ref", "vertcount"], "ubyte"]],
        ["udata", ["array", ["ref", "coordcount"], "short"]],
        ["vdata", ["array", ["ref", "coordcount"], "short"]]
      ]]],
      ["unusedendbytes", ["match", ["ref", "footbytes"], {
        "0xffff": ["match", "buildnr", {
          ">=526": null,
          other: ["array", "ubyte", ["tuple", "ushort", "ushort", "ushort", "int"]]
        }],
        other: null
      }]]
    ];
  }
});

// rsmv/src/opcodes/classicmodels.jsonc
var require_classicmodels = __commonJS({
  "rsmv/src/opcodes/classicmodels.jsonc"(exports, module) {
    module.exports = [
      "struct",
      ["vertexcount", "ushort"],
      ["facecount", "ushort"],
      ["xpos", ["array", ["ref", "vertexcount"], "short"]],
      ["ypos", ["array", ["ref", "vertexcount"], "short"]],
      ["zpos", ["array", ["ref", "vertexcount"], "short"]],
      ["faces", ["chunkedarray", ["ref", "facecount"], [
        ["$nverts", "ubyte"]
      ], [
        ["color", "ushort"]
      ], [
        ["backcolor", "ushort"]
      ], [
        ["intensity", "ubyte"]
      ], [
        ["verts", ["array", ["ref", "$nverts"], ["match", ["ref", "vertexcount"], {
          "<256": "ubyte",
          other: "ushort"
        }]]]
      ]]]
    ];
  }
});

// rsmv/src/opcodes/spotanims.json
var require_spotanims = __commonJS({
  "rsmv/src/opcodes/spotanims.json"(exports, module) {
    module.exports = {
      "0x01": { name: "model", read: "varuint" },
      "0x02": { name: "sequence", read: "varuint" },
      "0x04": { name: "scaleX", read: "ushort" },
      "0x05": { name: "scaleYorZ", read: "ushort" },
      "0x06": { name: "rotation", read: "ushort" },
      "0x07": { name: "ambient", read: "ubyte" },
      "0x08": { name: "contrast", read: "ubyte" },
      "0x0a": { name: "unk0a", read: "true" },
      "0x28": { name: "replace_colors", read: ["array", "ubyte", ["tuple", "ushort", "ushort"]] },
      "0x29": { name: "replace_materials", read: ["array", "ubyte", ["tuple", "ushort", "ushort"]] },
      "0x2c": { name: "unk2c", read: "ushort" },
      "0x2e": { name: "unk2e", read: "true" }
    };
  }
});

// rsmv/src/opcodes/rootcacheindex.jsonc
var require_rootcacheindex = __commonJS({
  "rsmv/src/opcodes/rootcacheindex.jsonc"(exports, module) {
    module.exports = [
      "struct",
      ["$minorindex", "-1"],
      ["cachemajors", ["match", "buildnr", {
        ">=605": ["array", "ubyte", [
          "struct",
          ["minor", ["accum", "$minorindex", "1"]],
          ["crc", "uint"],
          ["version", "uint"],
          ["subindexcount", ["match", "buildnr", { ">=816": "uint", other: 0 }]],
          ["integer_10", ["match", "buildnr", { ">=816": "uint", other: 0 }]],
          ["maybe_checksum1", ["buffer", 64, "hex"]]
        ]],
        other: ["nullarray", ["bytesleft"], [
          "struct",
          ["minor", ["accum", "$minorindex", "1"]],
          ["crc", "uint"],
          ["version", ["match", "buildnr", { ">=457": "uint", other: 0 }]],
          ["subindexcount", 0]
        ]]
      }]],
      ["maybe_proper_checksum", ["buffer", ["bytesleft"], "hex"]]
    ];
  }
});

// rsmv/src/opcodes/skeletalanim.jsonc
var require_skeletalanim = __commonJS({
  "rsmv/src/opcodes/skeletalanim.jsonc"(exports, module) {
    module.exports = [
      "struct",
      ["header", "ubyte"],
      ["framebase", "ushort"],
      ["endtime", "uint"],
      ["unk_always0", "ubyte"],
      ["tracks", ["array", "ushort", [
        "struct",
        ["unk_1to4", "ubyte"],
        ["boneid", "varushort"],
        ["type_0to9", "ubyte"],
        ["$packetlength", "ushort"],
        ["bonetype_01or3", "ubyte"],
        ["always0", "ushort"],
        ["flag2", "bool"],
        ["chunks", ["array", ["ref", "$packetlength"], [
          "struct",
          ["time", "ushort"],
          ["value", ["array", 5, "float"]]
        ]]]
      ]]]
    ];
  }
});

// rsmv/src/opcodes/materials.jsonc
var require_materials = __commonJS({
  "rsmv/src/opcodes/materials.jsonc"(exports, module) {
    module.exports = [
      "struct",
      ["version", ["match", "buildnr", { ">=887": "ubyte", ">=0": 0 }]],
      ["v0", ["opt", ["version", 0], [
        "struct",
        ["unk0", "ubyte"],
        ["texsize", "ushort"],
        ["opt0", "ubyte"],
        ["opt0data", ["opt", ["opt0", 16], ["tuple", "ubyte", "ushort"]]],
        ["arr", ["nullarray", "ubyte", [
          "struct",
          ["op", ["ref", "$opcode"]],
          ["value", "ushort"]
        ]]],
        ["textureflags", "ubyte"],
        ["diffuse", ["opt", ["textureflags", 17, "bitor"], ["match", "buildnr", { ">=887": "uint", ">=0": 0 }]]],
        ["normal", ["opt", ["textureflags", 10, "bitor"], ["match", "buildnr", { ">=887": "uint", ">=0": 0 }]]],
        ["texrepeatflags", ["match", "buildnr", { ">=876": "ubyte", ">=0": 0 }]],
        ["unk3_skybox", ["match", "buildnr", { ">=876": ["buffer", 3, "hex"], ">=0": "null" }]],
        ["flags2", "ubyte"],
        ["unkfloats", ["opt", ["flags2", 4, "bitflag"], ["tuple", "float", "float"]]],
        ["unk7", "ubyte"],
        ["weirdshit", ["opt", ["unk7", 255], ["buffer", 19, "hex"]]],
        ["diffuse_related1", ["match", "buildnr", { ">=887": ["opt", ["textureflags", 4, "bitflag"], "ubyte"], ">=0": "ubyte" }]],
        ["normal_related", ["opt", ["textureflags", 1, "bitflag"], ["buffer", 4, "hex"]]],
        ["diffuse_related2", ["match", "buildnr", { ">=887": ["opt", ["textureflags", 0, "bitflag"], "ubyte"], ">=0": "ubyte" }]],
        ["diffuse_ralated2_data", ["opt", ["diffuse_related2", 2], "ubyte"]],
        ["alphamode", "ubyte"],
        ["alphacutoff", ["opt", ["alphamode", 1], "ubyte"]],
        ["animtex", "ubyte"],
        ["animtexU", ["opt", ["animtex", 0, "bitflag"], ["match", "buildnr", { ">=897": "short", ">=0": "byte" }]]],
        ["animtexV", ["opt", ["animtex", 1, "bitflag"], ["match", "buildnr", { ">=897": "short", ">=0": "byte" }]]],
        ["flagextra", "bool"],
        ["extra", ["opt", ["flagextra", 1], [
          "struct",
          ["unk00_flags", "ubyte"],
          ["unk01_flagsornumber", "ubyte"],
          ["unk02", "ubyte"],
          ["unknown", ["buffer", 4, "hex"]],
          ["unk07_bool", "bool"],
          ["unk08_flags", "ubyte"],
          ["unk09_bool", "bool"],
          ["unk0a_bool", "bool"],
          ["specular", "ubyte"],
          ["baseColorFraction", "ubyte"],
          ["baseColor", "ushort"]
        ]]]
      ]]],
      ["v1", ["opt", ["version", 1], [
        "struct",
        ["flags", "uint"],
        ["opaque_2", ["ref", "flags", [2, 1]]],
        ["flag3", ["ref", "flags", [3, 1]]],
        ["hasDiffuse", ["ref", "flags", [5, 1]]],
        ["hasNormal", ["ref", "flags", [6, 1]]],
        ["hasCompound", ["ref", "flags", [7, 1]]],
        ["hasUVanimU", ["ref", "flags", [8, 1]]],
        ["hasUVanimV", ["ref", "flags", [9, 1]]],
        ["flag10", ["ref", "flags", [10, 1]]],
        ["flag11", ["ref", "flags", [11, 1]]],
        ["flag12", ["ref", "flags", [12, 1]]],
        ["flag13", ["ref", "flags", [13, 1]]],
        ["flag14", ["ref", "flags", [14, 1]]],
        ["flag15", ["ref", "flags", [15, 1]]],
        ["flag16", ["ref", "flags", [16, 1]]],
        ["ignore_vertexcol_17", ["ref", "flags", [17, 1]]],
        ["flag18", ["ref", "flags", [18, 1]]],
        ["flag19", ["ref", "flags", [19, 1]]],
        ["flag20", ["ref", "flags", [20, 1]]],
        ["flag21", ["ref", "flags", [21, 1]]],
        ["diffuse", ["opt", ["hasDiffuse", 1], [
          "struct",
          ["size", "ubyte"],
          ["texture", "uint"]
        ]]],
        ["normal", ["opt", ["hasNormal", 1], [
          "struct",
          ["size", "ubyte"],
          ["texture", "uint"]
        ]]],
        ["compound", ["opt", ["hasCompound", 1], [
          "struct",
          ["size", "ubyte"],
          ["texture", "uint"]
        ]]],
        ["flag13value", ["opt", ["flag13", 1], "float"]],
        ["flag14value", ["opt", ["flag14", 1], ["tuple", "ushort", "ushort"]]],
        ["flag15value", ["opt", ["flag15", 1], "float"]],
        ["flag18value", ["opt", ["flag18", 1], "float"]],
        ["flag16value", ["opt", ["flag16", 1], "float"]],
        ["flag12value", ["opt", ["flag12", 1], "float"]],
        ["flag11value", ["opt", ["flag11", 1], ["tuple", "float", "float", "float"]]],
        ["flag19value", ["opt", ["flag19", 1], ["tuple", "float", "float", "float", "float", "float"]]],
        ["normalScale", ["opt", ["hasNormal", 1], "float"]],
        ["flag17value", ["opt", ["ignore_vertexcol_17", 1], "float"]],
        ["uvanim_u", ["opt", ["hasUVanimU", 1], "short"]],
        ["uvanim_v", ["opt", ["hasUVanimV", 1], "short"]],
        ["always_0x0901", ["buffer", 2, "hex"]],
        ["unknownbyte0", "ubyte"],
        ["alphamode", "ubyte"],
        ["alphacutoff", ["opt", ["alphamode", 1], "ubyte"]],
        ["unkFFFF", ["buffer", 2, "hex"]],
        ["endbyte", "ubyte"]
      ]]]
    ];
  }
});

// rsmv/src/opcodes/oldmaterials.jsonc
var require_oldmaterials = __commonJS({
  "rsmv/src/opcodes/oldmaterials.jsonc"(exports, module) {
    module.exports = [
      "struct",
      ["$idcount", 0],
      ["mats", [
        "chunkedarray",
        "ushort",
        [["id", ["accum", "$idcount", 1, "postadd"]]],
        [["hasprops", "ubyte"]],
        [["unk1", ["opt", ["hasprops", 0, "eqnot"], "ubyte"]]],
        [["unk2", ["opt", ["hasprops", 0, "eqnot"], "ubyte"]]],
        [["unk3", ["match", "buildnr", { ">627": null, other: ["opt", ["hasprops", 0, "eqnot"], "ubyte"] }]]],
        [["unk4", ["opt", ["hasprops", 0, "eqnot"], "ushort"]]],
        [["basecolorfraction", ["opt", ["hasprops", 0, "eqnot"], "ubyte"]]],
        [["unk6", ["opt", ["hasprops", 0, "eqnot"], "ubyte"]]],
        [["unk7", ["opt", ["hasprops", 0, "eqnot"], "ubyte"]]],
        [["basecolor", ["opt", ["hasprops", 0, "eqnot"], "ushort"]]],
        [["unk10", ["match", "buildnr", { ">554": ["opt", ["hasprops", 0, "eqnot"], "ubyte"], other: null }]]],
        [["unk11", ["match", "buildnr", { ">554": ["opt", ["hasprops", 0, "eqnot"], "ubyte"], other: null }]]],
        [["unk20", ["match", "buildnr", { ">554": ["opt", ["hasprops", 0, "eqnot"], "ubyte"], other: null }]]],
        [["unk21", ["match", "buildnr", { ">554": ["opt", ["hasprops", 0, "eqnot"], "ubyte"], other: null }]]],
        [["unk30", ["match", "buildnr", { ">554": ["opt", ["hasprops", 0, "eqnot"], "ubyte"], other: null }]]],
        [["unk31", ["match", "buildnr", { ">554": ["opt", ["hasprops", 0, "eqnot"], "ubyte"], other: null }]]],
        [["unk32", ["match", "buildnr", { ">554": ["opt", ["hasprops", 0, "eqnot"], "ubyte"], other: null }]]],
        [["unk33", ["match", "buildnr", { ">554": ["opt", ["hasprops", 0, "eqnot"], "ubyte"], other: null }]]],
        [["unk40", ["match", "buildnr", { ">578": ["opt", ["hasprops", 0, "eqnot"], ["buffer", 5, "hex"]], other: null }]]],
        [["unk41", ["match", "buildnr", { ">597": ["opt", ["hasprops", 0, "eqnot"], "ubyte"], other: null }]]]
      ]]
    ];
  }
});

// rsmv/src/opcodes/quickchatcategories.jsonc
var require_quickchatcategories = __commonJS({
  "rsmv/src/opcodes/quickchatcategories.jsonc"(exports, module) {
    module.exports = {
      "0x01": { name: "text", read: "string" },
      "0x02": { name: "subcategories", read: ["array", "ubyte", ["struct", ["id", "ushort"], ["hotkey", "ubyte"]]] },
      "0x03": { name: "lines", read: ["array", "ubyte", ["struct", ["id", "ushort"], ["hotkey", "ubyte"]]] },
      "0x04": { name: "nonsearchable", read: "true" }
    };
  }
});

// rsmv/src/opcodes/quickchatlines.jsonc
var require_quickchatlines = __commonJS({
  "rsmv/src/opcodes/quickchatlines.jsonc"(exports, module) {
    module.exports = {
      "0x01": { name: "text", read: "string" },
      "0x02": { name: "replies", read: ["array", "ubyte", "ushort"] },
      "0x03": { name: "inserts", read: ["array", "ubyte", [
        "struct",
        ["type", "ushort"],
        ["pickEnum", ["opt", ["type", 0], "ushort"]],
        ["pickTtem", ["opt", ["type", 1], "true"]],
        ["skillLevel", ["opt", ["type", 4], "ushort"]],
        ["varplayerEnum", ["opt", ["type", 6], ["struct", ["enum", "ushort"], ["varbit", "ushort"]]]],
        ["varplayer", ["opt", ["type", 8], "ushort"]],
        ["varbit", ["opt", ["type", 9], "ushort"]],
        ["pickTradeableItem", ["opt", ["type", 10], "true"]],
        ["skillLevelEnum", ["opt", ["type", 11], ["struct", ["enum", "ushort"], ["skill", "ushort"]]]],
        ["friendsChatCount", ["opt", ["type", 12], "true"]],
        ["varWorld", ["opt", ["type", 14], "ushort"]],
        ["combatlevel", ["opt", ["type", 15], "true"]],
        ["varbitEnumstring", ["opt", ["type", 16], ["struct", ["enum", "ushort"], ["varbit", "ushort"]]]]
      ]] },
      "0x04": { name: "nonsearchable", read: "true" }
    };
  }
});

// rsmv/src/opcodes/environments.jsonc
var require_environments = __commonJS({
  "rsmv/src/opcodes/environments.jsonc"(exports, module) {
    module.exports = {
      "0x01": { name: "unk01", read: "ushort" },
      "0x04": { name: "unk04", read: "bool" },
      "0x05": { name: "model", read: "varuint" },
      "0x06": { name: "unk06", read: "ushort" }
    };
  }
});

// rsmv/src/opcodes/avatars.jsonc
var require_avatars = __commonJS({
  "rsmv/src/opcodes/avatars.jsonc"(exports, module) {
    module.exports = [
      "struct",
      ["gender", "ubyte"],
      ["$avatype", "playeritem"],
      ["player", ["opt", ["$avatype", -1, "eqnot"], [
        "struct",
        ["slots", [
          "tuple",
          ["ref", "$avatype"],
          "playeritem",
          "playeritem",
          "playeritem",
          "playeritem",
          "playeritem",
          "playeritem",
          "playeritem",
          "playeritem",
          "playeritem",
          "playeritem",
          "playeritem",
          "playeritem",
          "playeritem",
          "playeritem",
          "playeritem"
        ]],
        ["rest", ["buffer", ["bytesleft"], "hex"]]
      ]]],
      ["npc", ["opt", ["$avatype", -1], [
        "struct",
        ["id", "ushort"],
        ["buf", ["buffer", 21, "hex"]],
        ["unkff", "ushort"]
      ]]]
    ];
  }
});

// rsmv/src/opcodes/avataroverrides.jsonc
var require_avataroverrides = __commonJS({
  "rsmv/src/opcodes/avataroverrides.jsonc"(exports, module) {
    module.exports = [
      "struct",
      ["$flags", "ushort"],
      ["slots", [
        "tuple",
        [
          "struct",
          ["slot", ["itemvar", "ref"]],
          ["cust", ["opt", ["$flags", 0, "bitflag"], "playeritemedit"]]
        ],
        [
          "struct",
          ["slot", ["itemvar", "ref"]],
          ["cust", ["opt", ["$flags", 1, "bitflag"], "playeritemedit"]]
        ],
        [
          "struct",
          ["slot", ["itemvar", "ref"]],
          ["cust", ["opt", ["$flags", 2, "bitflag"], "playeritemedit"]]
        ],
        [
          "struct",
          ["slot", ["itemvar", "ref"]],
          ["cust", ["opt", ["$flags", 3, "bitflag"], "playeritemedit"]]
        ],
        [
          "struct",
          ["slot", ["itemvar", "ref"]],
          ["cust", ["opt", ["$flags", 4, "bitflag"], "playeritemedit"]]
        ],
        [
          "struct",
          ["slot", ["itemvar", "ref"]],
          ["cust", ["opt", ["$flags", 5, "bitflag"], "playeritemedit"]]
        ],
        [
          "struct",
          ["slot", ["itemvar", "ref"]],
          ["cust", ["opt", ["$flags", 6, "bitflag"], "playeritemedit"]]
        ],
        [
          "struct",
          ["slot", ["itemvar", "ref"]],
          ["cust", ["opt", ["$flags", 7, "bitflag"], "playeritemedit"]]
        ],
        [
          "struct",
          ["slot", ["itemvar", "ref"]],
          ["cust", ["opt", ["$flags", 8, "bitflag"], "playeritemedit"]]
        ],
        [
          "struct",
          ["slot", ["itemvar", "ref"]],
          ["cust", ["opt", ["$flags", 9, "bitflag"], "playeritemedit"]]
        ],
        [
          "struct",
          ["slot", ["itemvar", "ref"]],
          ["cust", ["opt", ["$flags", 10, "bitflag"], "playeritemedit"]]
        ],
        [
          "struct",
          ["slot", ["itemvar", "ref"]],
          ["cust", ["opt", ["$flags", 11, "bitflag"], "playeritemedit"]]
        ],
        [
          "struct",
          ["slot", ["itemvar", "ref"]],
          ["cust", ["opt", ["$flags", 12, "bitflag"], "playeritemedit"]]
        ],
        [
          "struct",
          ["slot", ["itemvar", "ref"]],
          ["cust", ["opt", ["$flags", 13, "bitflag"], "playeritemedit"]]
        ],
        [
          "struct",
          ["slot", ["itemvar", "ref"]],
          ["cust", ["opt", ["$flags", 14, "bitflag"], "playeritemedit"]]
        ],
        [
          "struct",
          ["slot", ["itemvar", "ref"]],
          ["cust", ["opt", ["$flags", 15, "bitflag"], "playeritemedit"]]
        ]
      ]],
      ["haircol0", "ubyte"],
      ["bodycol", "ubyte"],
      ["legscol", "ubyte"],
      ["bootscol", "ubyte"],
      ["skincol0", "ubyte"],
      ["skincol1", "ubyte"],
      ["haircol1", "ubyte"],
      ["unkbuf", ["buffer", 13, "hex"]],
      ["stance", "ushort"]
    ];
  }
});

// rsmv/src/opcodes/identitykit.jsonc
var require_identitykit = __commonJS({
  "rsmv/src/opcodes/identitykit.jsonc"(exports, module) {
    module.exports = {
      "0x01": { name: "bodypart", read: "ubyte" },
      "0x02": { name: "models", read: ["array", "ubyte", "varuint"] },
      "0x03": { name: "iscopy", read: "true" },
      "0x28": { name: "recolor", read: ["array", "ubyte", ["tuple", "ushort", "ushort"]] },
      "0x3c": { name: "headmodel", read: "varuint" }
    };
  }
});

// rsmv/src/opcodes/structs.jsonc
var require_structs = __commonJS({
  "rsmv/src/opcodes/structs.jsonc"(exports, module) {
    module.exports = {
      "0xF9": { name: "extra", read: "extrasmap" }
    };
  }
});

// rsmv/src/opcodes/params.jsonc
var require_params = __commonJS({
  "rsmv/src/opcodes/params.jsonc"(exports, module) {
    module.exports = {
      "0x04": { name: "unk04", read: "true" },
      "0x65": { name: "type", read: [
        "struct",
        ["vartype", "varushort"],
        ["$primitive", "ubyte"],
        ["defaultint", ["opt", ["$primitive", 2], "int"]],
        ["defaultstring", ["opt", ["$primitive", 5], "string"]]
      ] }
    };
  }
});

// rsmv/src/opcodes/particles_0.jsonc
var require_particles_0 = __commonJS({
  "rsmv/src/opcodes/particles_0.jsonc"(exports, module) {
    module.exports = {
      "0x01": { name: "unk01", read: ["array", 4, "ushort"] },
      "0x02": { name: "unk02", read: ["array", 1, "ushort"] },
      "0x03": { name: "unk03", read: ["array", 4, "ushort"] },
      "0x04": { name: "unk04", read: ["array", 1, "ushort"] },
      "0x05": { name: "unk05", read: ["array", 1, "ushort"] },
      "0x06": { name: "unk06", read: ["buffer", 8, "hex"] },
      "0x07": { name: "unk07", read: ["array", 2, "ushort"] },
      "0x08": { name: "unk08", read: ["array", 2, "ushort"] },
      "0x09": { name: "unk09", read: ["array", "ubyte", "ushort"] },
      "0x0A": { name: "unk0A", read: ["array", "ubyte", "ushort"] },
      "0x0C": { name: "unk0C", read: "ubyte" },
      "0x0D": { name: "unk0D", read: "ubyte" },
      "0x0E": { name: "unk0E", read: "ushort" },
      "0x0F": { name: "unk0F", read: "ushort" },
      "0x10": { name: "unk10", read: ["tuple", "ubyte", "short", "short", "ubyte"] },
      "0x12": { name: "unk12", read: ["buffer", 4, "hex"] },
      "0x13": { name: "unk13", read: "ubyte" },
      "0x14": { name: "unk14", read: "ubyte" },
      "0x15": { name: "unk15", read: "ubyte" },
      "0x16": { name: "unk16", read: ["array", 2, "ushort"] },
      "0x17": { name: "unk17", read: "ubyte" },
      "0x18": { name: "unk18", read: "ubyte" },
      "0x19": { name: "unk19", read: ["array", "ubyte", "ushort"] },
      "0x1A": { name: "unk1A", read: "true" },
      "0x1B": { name: "unk1B", read: "ushort" },
      "0x1C": { name: "unk1C", read: [
        "struct",
        ["unk0", "ubyte"],
        ["flags", "ubyte"],
        ["unkmain", ["buffer", 4, "hex"]],
        ["opt2", ["opt", ["flags", 1, "bitflag"], "ubyte"]],
        ["opt4", ["opt", ["flags", 2, "bitflag"], "ushort"]],
        ["opt8", ["opt", ["flags", 3, "bitflag"], "ushort"]],
        ["opt16", ["opt", ["flags", 4, "bitflag"], ["tuple", "ushort", "ubyte"]]],
        ["unk2", "ushort"]
      ] },
      "0x1D": { name: "unk1D", read: [
        "struct",
        ["unk1", ["array", "ubyte", "ushort"]],
        ["unk2", "ushort"]
      ] },
      "0x1E": { name: "unk1E", read: "true" },
      "0x1F": { name: "unk1F", read: ["array", 2, "ushort"] },
      "0x20": { name: "unk20", read: "true" },
      "0x21": { name: "unk21", read: "true" },
      "0x22": { name: "unk22", read: "true" },
      "0x23": { name: "unk23", read: [
        "struct",
        ["unk1", ["array", "ubyte", ["tuple", "short", "ubyte"]]],
        ["unk2", "ushort"]
      ] },
      "0x24": { name: "unk24", read: "true" }
    };
  }
});

// rsmv/src/opcodes/particles_1.jsonc
var require_particles_1 = __commonJS({
  "rsmv/src/opcodes/particles_1.jsonc"(exports, module) {
    module.exports = {
      "0x01": { name: "unk01", read: ["tuple", "ubyte", "byte"] },
      "0x03": { name: "unk03", read: ["array", 6, "short"] },
      "0x04": { name: "unk04", read: [
        "struct",
        ["unk0", "ubyte"],
        ["unk1_0000", "ushort"],
        ["unk2", "ushort"]
      ] },
      "0x06": { name: "unk06", read: "ubyte" },
      "0x08": { name: "unk08", read: "true" },
      "0x09": { name: "unk09", read: "true" },
      "0x0A": { name: "unk0A", read: "true" }
    };
  }
});

// rsmv/src/opcodes/audio.jsonc
var require_audio = __commonJS({
  "rsmv/src/opcodes/audio.jsonc"(exports, module) {
    module.exports = [
      "struct",
      ["magic", ["buffer", 4, "hex"]],
      ["unk_1", "uint"],
      ["unk_2", "uint"],
      ["samplefreq", "uint"],
      ["unk_3", "uint"],
      ["chunks", [
        "chunkedarray",
        "uint",
        [
          ["len", "uint"],
          ["fileid", "uint"]
        ],
        [
          ["data", ["opt", ["fileid", 0], ["buffer", ["ref", "len"], "buffer"]]]
        ]
      ]]
    ];
  }
});

// rsmv/src/opcodes/proctexture.jsonc
var require_proctexture = __commonJS({
  "rsmv/src/opcodes/proctexture.jsonc"(exports, module) {
    module.exports = ["nullarray", [
      "struct",
      ["op", ["ref", "$opcode"]],
      ["args", ["match", ["ref", "$opcode"], {
        "0x01": ["buffer", 8, "hex"]
      }]]
    ]];
  }
});

// rsmv/src/opcodes/oldproctexture.jsonc
var require_oldproctexture = __commonJS({
  "rsmv/src/opcodes/oldproctexture.jsonc"(exports, module) {
    module.exports = [
      "struct",
      ["color", "ushort"],
      ["bool0", "bool"],
      ["bool1", "bool"],
      ["spriteid", "ushort"],
      ["always00", ["buffer", 6, "hex"]]
    ];
  }
});

// rsmv/src/opcodes/maplabels.jsonc
var require_maplabels = __commonJS({
  "rsmv/src/opcodes/maplabels.jsonc"(exports, module) {
    module.exports = {
      "0x01": { name: "sprite", read: "varuint" },
      "0x02": { name: "sprite_hover", read: "varuint" },
      "0x03": { name: "text", read: "string" },
      "0x04": { name: "color_1", read: ["tuple", "ubyte", "ubyte", "ubyte"] },
      "0x05": { name: "color_2", read: ["tuple", "ubyte", "ubyte", "ubyte"] },
      "0x06": { name: "font_size", read: "ubyte" },
      "0x07": { name: "unknown_07", read: "ubyte" },
      "0x08": { name: "unknown_08", read: "ubyte" },
      "0x09": { name: "toggle_1", read: [
        "struct",
        ["varbit", "ushort"],
        ["varp", "ushort"],
        ["lower", "uint"],
        ["upper", "uint"]
      ] },
      "0x0a": { name: "rightclick_1", read: "string" },
      "0x0b": { name: "unktext_0b", read: "string" },
      "0x0f": { name: "polygon", read: [
        "struct",
        ["pointcount", "ubyte"],
        ["points", ["array", ["ref", "pointcount"], [
          "struct",
          ["x", "short"],
          ["y", "short"]
        ]]],
        ["color", ["tuple", "ubyte", "ubyte", "ubyte", "ubyte"]],
        ["always_1", ["match", "buildnr", { ">=623": "ubyte", other: 1 }]],
        ["back_color", ["tuple", "ubyte", "ubyte", "ubyte", "ubyte"]],
        ["pointplanes", ["match", "buildnr", {
          ">=629": ["array", ["ref", "pointcount"], "ubyte"],
          other: null
        }]]
      ] },
      "0x11": { name: "rightclick_2", read: "string" },
      "0x13": { name: "category", read: "ushort" },
      "0x14": { name: "toggle_2", read: [
        "struct",
        ["varbit", "ushort"],
        ["varp", "ushort"],
        ["lower", "uint"],
        ["upper", "uint"]
      ] },
      "0x15": { name: "unknown_15", read: "int" },
      "0x16": { name: "unknown_16", read: "int" },
      "0x19": { name: "background_sprite", read: "varuint" },
      "0x1a": { name: "legacy_switch", read: [
        "struct",
        ["varbit", "ushort"],
        ["varp", "ushort"],
        ["value", "ubyte"],
        ["default_ref", "ushort"],
        ["legacy_ref", "ushort"]
      ] },
      "0x1c": { name: "unknown_1c", read: "ubyte" },
      "0x1e": { name: "unknown_1e", read: "ubyte" },
      "0xF9": { name: "extra", read: "extrasmap" }
    };
  }
});

// rsmv/src/opcodes/cutscenes.jsonc
var require_cutscenes = __commonJS({
  "rsmv/src/opcodes/cutscenes.jsonc"(exports, module) {
    module.exports = [
      "struct",
      ["version", "ubyte"],
      ["width", "ushort"],
      ["height", "ushort"],
      ["unkhead", "ushort"],
      ["elements", ["array", "ubyte", [
        "struct",
        ["name", "paddedstring"],
        ["start", "float"],
        ["end", "float"],
        ["flag0", "ubyte"],
        ["graphics", ["array", ["ref", "flag0"], [
          "struct",
          ["spritename", "paddedstring"],
          ["height", "ushort"],
          ["width", "ushort"],
          ["unk", "ushort"],
          ["spriteid", "ushort"],
          ["opacityframes", ["array", "ubyte", ["tuple", "float", "float"]]],
          ["rotateframes", ["array", "ubyte", ["tuple", "float", "float"]]],
          ["translateframes", ["array", "ubyte", ["tuple", "float", "float", "float"]]],
          ["scaleframes", ["array", "ubyte", ["tuple", "float", "float", "float"]]]
        ]]],
        ["flag1", "ubyte"],
        ["sound", ["opt", "flag1!=0", "paddedstring"]],
        ["flag2", "ubyte"],
        ["subtitle", ["opt", "flag2!=0", "paddedstring"]],
        ["unkbyte", ["opt", "flag0==0", "ubyte"]],
        ["soundid", ["opt", "flag0==0", "ushort"]],
        ["extraflags", ["match", ["ref", "flag0"], { "0": "ubyte", other: 0 }]],
        ["extra_01", ["opt", "extraflags!=0", ["struct", ["start", "float"], ["end", "float"]]]]
      ]]],
      ["paddingbytes", ["buffer", ["bytesleft"], "ubyte"]]
    ];
  }
});

// rsmv/src/opcodes/clientscript.jsonc
var require_clientscript = __commonJS({
  "rsmv/src/opcodes/clientscript.jsonc"(exports, module) {
    module.exports = [
      "struct",
      ["byte0", "ubyte"],
      ["switchsize", ["footer", 2, "ushort"]],
      ["switches", [
        "footer",
        ["ref", "switchsize"],
        ["array", "ubyte", ["array", "ushort", [
          "struct",
          ["value", "int"],
          ["jump", "uint"]
        ]]]
      ]],
      ["longargcount", ["footer", 2, "ushort"]],
      ["stringargcount", ["footer", 2, "ushort"]],
      ["intargcount", ["footer", 2, "ushort"]],
      ["locallongcount", ["footer", 2, "ushort"]],
      ["localstringcount", ["footer", 2, "ushort"]],
      ["localintcount", ["footer", 2, "ushort"]],
      ["instructioncount", ["footer", 4, "uint"]],
      ["opcodedata", ["array", ["ref", "instructioncount"], ["scriptopt"]]]
    ];
  }
});

// rsmv/src/opcodes/clientscriptdata.jsonc
var require_clientscriptdata = __commonJS({
  "rsmv/src/opcodes/clientscriptdata.jsonc"(exports, module) {
    module.exports = [
      "struct",
      ["byte0", ["match", "buildnr", { ">458": "ubyte", other: 0 }]],
      ["switchsize", ["match", "buildnr", { ">=495": ["footer", 2, "ushort"], other: 0 }]],
      ["switches", [
        "footer",
        ["ref", "switchsize"],
        ["array", ["match", "buildnr", { ">=495": "ubyte", other: 0 }], ["array", "ushort", [
          "struct",
          ["value", "int"],
          ["jump", "uint"]
        ]]]
      ]],
      ["longargcount", ["match", "buildnr", { ">641": ["footer", 2, "ushort"], other: 0 }]],
      ["stringargcount", ["footer", 2, "ushort"]],
      ["intargcount", ["footer", 2, "ushort"]],
      ["locallongcount", ["match", "buildnr", { ">641": ["footer", 2, "ushort"], other: 0 }]],
      ["localstringcount", ["footer", 2, "ushort"]],
      ["localintcount", ["footer", 2, "ushort"]],
      ["instructioncount", ["footer", 4, "uint"]],
      ["opcodedata", ["buffer", ["bytesleft"], "buffer"]]
    ];
  }
});

// rsmv/src/opcodes/interfaces.jsonc
var require_interfaces = __commonJS({
  "rsmv/src/opcodes/interfaces.jsonc"(exports, module) {
    module.exports = [
      "struct",
      ["version", ["match", "buildnr", { ">500": "byte", other: -1 }]],
      ["type", "ubyte"],
      ["name", ["opt", "type&0x80", "string"]],
      ["contenttype", "ushort"],
      ["baseposx", "short"],
      ["baseposy", "short"],
      ["basewidth", "short"],
      ["baseheight", "short"],
      ["aspectwidthtype", "byte"],
      ["aspectheighttype", "byte"],
      ["aspectxtype", "byte"],
      ["aspectytype", "byte"],
      ["parentid", "ushort"],
      ["hidden", "ubyte"],
      ["containerdata", ["opt", "type=0", [
        "struct",
        ["layerwidth", "ushort"],
        ["layerheight", "ushort"],
        ["layerheightextra", ["opt", "layerheight&0x8000", "uint"]],
        ["disablehover", ["opt", "version==-1", "bool"]],
        ["v6unk1", ["opt", "version>=6", "uint"]],
        ["v6unk2", ["opt", "version==6", "uint"]]
      ]]],
      ["figuredata", ["opt", "type=3", [
        "struct",
        ["color", "uint"],
        ["filled", "ubyte"],
        ["trans", "byte"]
      ]]],
      ["textdata", ["opt", "type=4", [
        "struct",
        ["fontid", "varuint"],
        ["unk1", ["match", { "version>=0": "ubyte", other: false }]],
        ["text", "string"],
        ["unk2", "ubyte"],
        ["alignhor", "ubyte"],
        ["alignver", "ubyte"],
        ["shadow", "bool"],
        ["color", "uint"],
        ["trans", "ubyte"],
        ["multiline", ["opt", "version>=0", "ubyte"]]
      ]]],
      ["spritedata", ["opt", "type=5", [
        "struct",
        ["spriteid", "int"],
        ["rotation", "ushort"],
        ["tiling", "ubyte"],
        ["aspectwidthdata", ["match", { "aspectwidthtype==4": "uint", other: -1 }]],
        ["aspectheightdata", ["match", { "aspectheighttype==4": "uint", other: -1 }]],
        ["transparency", "ubyte"],
        ["borderthickness", "ubyte"],
        ["unk2", "int"],
        ["vflip", "bool"],
        ["hflip", "bool"],
        ["color", "uint"],
        ["clickmask", ["opt", "version>=0", "ubyte"]],
        ["v6unk", ["opt", "version>=6", "uint"]]
      ]]],
      ["modeldata", ["opt", "type=6", [
        "struct",
        ["modelid", ["match", "buildnr", { ">616": "varuint", other: "ushort" }]],
        ["mode", ["match", "buildnr", { ">616": "ubyte", other: 1 }]],
        ["positiondata", ["opt", "mode!=0", [
          "struct",
          ["translate_x", "short"],
          ["translate_y", "short"],
          ["unkextra", ["opt", "mode=2", "short"]],
          ["rotate_x", "ushort"],
          ["rotate_y", "ushort"],
          ["rotate_z", "ushort"],
          ["zoom", "ushort"]
        ]]],
        ["animid", ["match", "buildnr", { ">616": "varuint", other: "ushort" }]],
        ["unkdata", ["match", "buildnr", { ">616": null, other: ["buffer", 6, "hex"] }]],
        ["aspectwidthdata", ["match", { "aspectwidthtype!=0": "ushort", other: -1 }]],
        ["aspectheightdata", ["match", { "aspectheighttype!=0": "ushort", other: -1 }]]
      ]]],
      ["linedata", ["opt", "type=9", [
        "struct",
        ["width", "ubyte"],
        ["color", "uint"],
        ["dir", "bool"]
      ]]],
      ["unk10data", ["opt", "type=10", [
        "struct",
        ["data", ["buffer", 41, "hex"]],
        ["str1", "string"],
        ["data2", ["buffer", 10, "hex"]]
      ]]],
      ["unk11data", ["opt", "type=11", [
        "struct",
        ["data", ["buffer", 6, "hex"]]
      ]]],
      ["unk12data", ["opt", "type=12", [
        "struct",
        ["data", ["buffer", 36, "hex"]],
        ["str", "string"],
        ["data2", ["buffer", 10, "hex"]]
      ]]],
      ["unk13data", ["opt", "type=13", [
        "struct",
        ["data", ["buffer", 125, "hex"]]
      ]]],
      ["unk15data", ["opt", "type=15", [
        "struct",
        ["data", ["buffer", 10, "hex"]]
      ]]],
      ["unk16data", ["opt", "type=16", [
        "struct",
        ["data", ["buffer", 179, "hex"]]
      ]]],
      ["unkffff", ["opt", "version>=6", "uint"]],
      ["optmask", "ushort"],
      ["unk2", "ubyte"],
      ["unkprepre3", ["opt", "version>=7", "ubyte"]],
      ["unkpre3", ["opt", "version>=6", "ubyte"]],
      ["unk3", ["match", {
        "version==-1": ["nullarray", "ubyte", ["buffer", 3, "hex"]],
        other: [
          "struct",
          ["op", "ubyte"],
          [
            "data",
            ["opt", "op!=0", ["buffer", 4, "hex"]]
          ]
        ]
      }]],
      ["name2", "string"],
      ["menucounts", "ubyte"],
      ["rightclickopts", ["array", ["ref", "menucounts", [0, 4]], "string"]],
      ["rightclickcursors", ["array", ["ref", "menucounts", [4, 4]], [
        "struct",
        ["op", "ubyte"],
        ["cursor", "ushort"]
      ]]],
      ["unkstring1", ["opt", "optmask!&0x0400", "string"]],
      ["unk4", "ubyte"],
      ["bit4data", ["opt", "optmask&0x0400", "ubyte"]],
      ["unk5", "ubyte"],
      ["unk6", "ubyte"],
      ["unkstuff123", "string"],
      ["optmask1data_bit40", ["opt", "optmask&0x0240", ["buffer", 6, "hex"]]],
      ["cursor", ["match", { "version>=0": "ushort", other: -1 }]],
      ["unkdata", ["opt", "version>=0", "ushort"]],
      ["unkdatadata", ["opt", "version>=0 && unkdata!=0", ["buffer", 6, "hex"]]],
      ["scripts", [
        "struct",
        ["load", "uivalues"],
        ["mousehover", "uivalues"],
        ["mouseleave", "uivalues"],
        ["unk0", "uivalues"],
        ["unk1", "uivalues"],
        ["unk2", "uivalues"],
        ["unk3", "uivalues"],
        ["unk4", "uivalues"],
        ["unk5", "uivalues"],
        ["unk6", "uivalues"],
        ["unk7", ["opt", "version>=0", "uivalues"]],
        ["hovertext", "uivalues"],
        ["unk8", "uivalues"],
        ["unk9", "uivalues"],
        ["unk10", "uivalues"],
        ["unk11", "uivalues"],
        ["unk12", "uivalues"],
        ["unk13", "uivalues"],
        ["unk14", "uivalues"],
        ["unk15", "uivalues"],
        ["unk16", "uivalues"],
        ["unk17", ["opt", "version>=6", "uivalues"]],
        ["unk18", ["opt", "version>=6", "uivalues"]],
        ["unk19", ["opt", "version>=6", "uivalues"]],
        ["unk20", ["opt", "version>=7", "uivalues"]],
        ["v2unk0", "uivaluesint"],
        ["v2unk1", "uivaluesint"],
        ["v2unk2", "uivaluesint"],
        ["v2unk3", "uivaluesint"],
        ["v2unk4", "uivaluesint"]
      ]]
    ];
  }
});

// rsmv/src/opcodes/dbtables.jsonc
var require_dbtables = __commonJS({
  "rsmv/src/opcodes/dbtables.jsonc"(exports, module) {
    module.exports = {
      "0x01": { name: "unk01", read: [
        "struct",
        ["cols", "ubyte"],
        ["columndata", ["nullarray", "ubyte", 255, [
          "struct",
          ["id", ["ref", "$opcode", [0, 6]]],
          ["flags", ["ref", "$opcode", [6, 2]]],
          ["$i", 0],
          ["columns", ["chunkedarray", "ubyte", [
            ["type", "varushort"]
          ], [
            ["$colindex", ["accum", "$i", 1]],
            ["unk", ["opt", "$opcode&0x80 && $colindex==1", "ubyte"]],
            ["default", ["opt", "$opcode&0x80", ["match", ["ref", "type"], {
              "0x24": "string",
              other: "int"
            }]]]
          ]]]
        ]]]
      ] },
      "0x02": { name: "unk02", read: [
        "struct",
        ["unkint", "uint"],
        ["cols", "ubyte"],
        ["columndata", ["nullarray", "ubyte", 255, [
          "struct",
          ["id", ["ref", "$opcode", [0, 6]]],
          ["flags", ["ref", "$opcode", [6, 2]]],
          ["$i", 0],
          ["$default", 0],
          ["unkbyte", "ubyte"],
          ["columns", ["chunkedarray", "ubyte", [
            ["type", "varushort"],
            ["$colindex", ["accum", "$i", 1]]
          ], [
            ["hasdefault", ["accum", "$default", ["match", { "$colindex==1": "ubyte", other: 0 }]]]
          ], [
            ["unk1", ["opt", "hasdefault&0x02 && $colindex==1", "ubyte"]],
            ["defaultint", ["opt", "hasdefault&0x02 && type!=0x24", "int"]],
            ["defaultstring", ["opt", "hasdefault&0x02 && type==0x24", "string"]],
            ["unk2", ["opt", "hasdefault&0x02 && $colindex==1", "ubyte"]]
          ]]]
        ]]]
      ] }
    };
  }
});

// rsmv/src/opcodes/dbrows.jsonc
var require_dbrows = __commonJS({
  "rsmv/src/opcodes/dbrows.jsonc"(exports, module) {
    module.exports = {
      "0x03": { name: "unk01", read: [
        "struct",
        ["cols", "ubyte"],
        ["columndata", ["nullarray", "ubyte", 255, [
          "struct",
          ["id", ["ref", "$opcode", [0, 6]]],
          ["flags", ["ref", "$opcode", [6, 2]]],
          ["$rowcount", -1],
          ["columns", ["chunkedarray", "ubyte", [
            ["type", "varushort"]
          ], [
            ["$initrowcount", ["match", ["ref", "$rowcount"], {
              "-1": ["accum", "$rowcount", "ubyte", "hold"],
              other: ["ref", "$rowcount"]
            }]],
            ["value", ["array", ["ref", "$rowcount"], ["match", ["ref", "type"], {
              "0x24": "string",
              other: "int"
            }]]]
          ]]]
        ]]]
      ] },
      "0x04": { name: "table", read: "varushort" }
    };
  }
});

// rsmv/src/libs/bzip2fork.ts
var require_bzip2fork = __commonJS({
  "rsmv/src/libs/bzip2fork.ts"(exports, module) {
    "use strict";
    var output = new Uint8Array(1e7);
    var bzip2 = {};
    bzip2.array = function(bytes) {
      var bit = 0, byte = 0;
      var BITMASK = [0, 1, 3, 7, 15, 31, 63, 127, 255];
      return function(n) {
        var result = 0;
        while (n > 0) {
          var left = 8 - bit;
          if (n >= left) {
            result <<= left;
            result |= BITMASK[left] & bytes[byte++];
            bit = 0;
            n -= left;
          } else {
            result <<= n;
            result |= (bytes[byte] & BITMASK[n] << 8 - n - bit) >> 8 - n - bit;
            bit += n;
            n = 0;
          }
        }
        return result;
      };
    };
    bzip2.simple = function(bits) {
      var size = bzip2.header(bits);
      var all, chunk, chunks = [];
      var index = 0;
      do {
        chunk = bzip2.decompress(bits, size);
        if (chunk != -1) {
          chunks.push(chunk);
          index += chunk.byteLength;
        }
      } while (chunk != -1);
      all = new Uint8Array(index);
      index = 0;
      for (var i = 0; i < chunks.length; ++i) {
        chunk = chunks[i];
        all.set(chunk, index);
        index += chunk.byteLength;
      }
      return all;
    };
    bzip2.header = function(bits) {
      if (bits(8 * 3) != 4348520)
        throw "No magic number found";
      var i = bits(8) - 48;
      if (i < 1 || i > 9)
        throw "Not a BZIP archive";
      return i;
    };
    bzip2.decompress = function(bits, size, len) {
      var MAX_HUFCODE_BITS = 20;
      var MAX_SYMBOLS = 258;
      var SYMBOL_RUNA = 0;
      var SYMBOL_RUNB = 1;
      var GROUP_SIZE = 50;
      var bufsize = 1e5 * 9;
      for (var h = "", i = 0; i < 6; i++)
        h += bits(8).toString(16);
      if (h == "177245385090")
        return -1;
      if (h != "314159265359")
        throw "eek not valid bzip data";
      bits(32);
      if (bits(1))
        throw "unsupported obsolete version";
      var origPtr = bits(24);
      if (origPtr > bufsize)
        throw "Initial position larger than buffer size";
      var t = bits(16);
      var symToByte = new Uint8Array(256), symTotal = 0;
      for (i = 0; i < 16; i++) {
        if (t & 1 << 15 - i) {
          var k = bits(16);
          for (j = 0; j < 16; j++) {
            if (k & 1 << 15 - j) {
              symToByte[symTotal++] = 16 * i + j;
            }
          }
        }
      }
      var groupCount = bits(3);
      if (groupCount < 2 || groupCount > 6)
        throw "another error";
      var nSelectors = bits(15);
      if (nSelectors == 0)
        throw "meh";
      var mtfSymbol = [];
      for (var i = 0; i < groupCount; i++)
        mtfSymbol[i] = i;
      var selectors = new Uint8Array(32768);
      for (var i = 0; i < nSelectors; i++) {
        for (var j = 0; bits(1); j++)
          if (j >= groupCount)
            throw "whoops another error";
        var uc = mtfSymbol[j];
        mtfSymbol.splice(j, 1);
        mtfSymbol.splice(0, 0, uc);
        selectors[i] = uc;
      }
      var symCount = symTotal + 2;
      var groups = [];
      for (var j = 0; j < groupCount; j++) {
        var length = new Uint8Array(MAX_SYMBOLS), temp = new Uint8Array(MAX_HUFCODE_BITS + 1);
        t = bits(5);
        for (var i = 0; i < symCount; i++) {
          while (true) {
            if (t < 1 || t > MAX_HUFCODE_BITS)
              throw "I gave up a while ago on writing error messages";
            if (!bits(1))
              break;
            if (!bits(1))
              t++;
            else
              t--;
          }
          length[i] = t;
        }
        var minLen, maxLen;
        minLen = maxLen = length[0];
        for (var i = 1; i < symCount; i++) {
          if (length[i] > maxLen)
            maxLen = length[i];
          else if (length[i] < minLen)
            minLen = length[i];
        }
        var hufGroup;
        hufGroup = groups[j] = {};
        hufGroup.permute = new Uint32Array(MAX_SYMBOLS);
        hufGroup.limit = new Uint32Array(MAX_HUFCODE_BITS + 1);
        hufGroup.base = new Uint32Array(MAX_HUFCODE_BITS + 1);
        hufGroup.minLen = minLen;
        hufGroup.maxLen = maxLen;
        var base = hufGroup.base.subarray(1);
        var limit = hufGroup.limit.subarray(1);
        var pp = 0;
        for (var i = minLen; i <= maxLen; i++)
          for (var t = 0; t < symCount; t++)
            if (length[t] == i)
              hufGroup.permute[pp++] = t;
        for (i = minLen; i <= maxLen; i++)
          temp[i] = limit[i] = 0;
        for (i = 0; i < symCount; i++)
          temp[length[i]]++;
        pp = t = 0;
        for (i = minLen; i < maxLen; i++) {
          pp += temp[i];
          limit[i] = pp - 1;
          pp <<= 1;
          base[i + 1] = pp - (t += temp[i]);
        }
        limit[maxLen] = pp + temp[maxLen] - 1;
        base[minLen] = 0;
      }
      var byteCount = new Uint32Array(256);
      for (var i = 0; i < 256; i++)
        mtfSymbol[i] = i;
      var runPos, count, symCount, selector;
      runPos = count = symCount = selector = 0;
      var buf = new Uint32Array(bufsize);
      while (true) {
        if (!symCount--) {
          symCount = GROUP_SIZE - 1;
          if (selector >= nSelectors)
            throw "meow i'm a kitty, that's an error";
          hufGroup = groups[selectors[selector++]];
          base = hufGroup.base.subarray(1);
          limit = hufGroup.limit.subarray(1);
        }
        i = hufGroup.minLen;
        j = bits(i);
        while (true) {
          if (i > hufGroup.maxLen)
            throw "rawr i'm a dinosaur";
          if (j <= limit[i])
            break;
          i++;
          j = j << 1 | bits(1);
        }
        j -= base[i];
        if (j < 0 || j >= MAX_SYMBOLS)
          throw "moo i'm a cow";
        var nextSym = hufGroup.permute[j];
        if (nextSym == SYMBOL_RUNA || nextSym == SYMBOL_RUNB) {
          if (!runPos) {
            runPos = 1;
            t = 0;
          }
          if (nextSym == SYMBOL_RUNA)
            t += runPos;
          else
            t += 2 * runPos;
          runPos <<= 1;
          continue;
        }
        if (runPos) {
          runPos = 0;
          if (count + t >= bufsize)
            throw "Boom.";
          uc = symToByte[mtfSymbol[0]];
          byteCount[uc] += t;
          while (t--)
            buf[count++] = uc;
        }
        if (nextSym > symTotal)
          break;
        if (count >= bufsize)
          throw "I can't think of anything. Error";
        i = nextSym - 1;
        uc = mtfSymbol[i];
        mtfSymbol.splice(i, 1);
        mtfSymbol.splice(0, 0, uc);
        uc = symToByte[uc];
        byteCount[uc]++;
        buf[count++] = uc;
      }
      if (origPtr < 0 || origPtr >= count)
        throw "I'm a monkey and I'm throwing something at someone, namely you";
      var j = 0;
      for (var i = 0; i < 256; i++) {
        k = j + byteCount[i];
        byteCount[i] = j;
        j = k;
      }
      for (var i = 0; i < count; i++) {
        uc = buf[i] & 255;
        buf[byteCount[uc]] |= i << 8;
        byteCount[uc]++;
      }
      var pos = 0, current = 0, run2 = 0;
      if (count) {
        pos = buf[origPtr];
        current = pos & 255;
        pos >>= 8;
        run2 = -1;
      }
      count = count;
      var copies, previous, outbyte;
      var index = 0;
      if (!len)
        len = Infinity;
      while (count) {
        count--;
        previous = current;
        pos = buf[pos];
        current = pos & 255;
        pos >>= 8;
        if (run2++ == 3) {
          copies = current;
          outbyte = previous;
          current = -1;
        } else {
          copies = 1;
          outbyte = current;
        }
        while (copies--) {
          output[index++] = outbyte;
          if (!--len)
            return output;
        }
        if (current != previous)
          run2 = 0;
      }
      if (index > output.length) {
        throw new Error("not enough memory reserved");
      }
      return output.slice(0, index);
    };
    module.exports = bzip2;
  }
});

// ../../node_modules/webidl-conversions/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/webidl-conversions/lib/index.js"(exports, module) {
    "use strict";
    var conversions = {};
    module.exports = conversions;
    function sign(x) {
      return x < 0 ? -1 : 1;
    }
    function evenRound(x) {
      if (x % 1 === 0.5 && (x & 1) === 0) {
        return Math.floor(x);
      } else {
        return Math.round(x);
      }
    }
    function createNumberConversion(bitLength, typeOpts) {
      if (!typeOpts.unsigned) {
        --bitLength;
      }
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
      const upperBound = Math.pow(2, bitLength) - 1;
      const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
      const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
      return function(V, opts) {
        if (!opts) opts = {};
        let x = +V;
        if (opts.enforceRange) {
          if (!Number.isFinite(x)) {
            throw new TypeError("Argument is not a finite number");
          }
          x = sign(x) * Math.floor(Math.abs(x));
          if (x < lowerBound || x > upperBound) {
            throw new TypeError("Argument is not in byte range");
          }
          return x;
        }
        if (!isNaN(x) && opts.clamp) {
          x = evenRound(x);
          if (x < lowerBound) x = lowerBound;
          if (x > upperBound) x = upperBound;
          return x;
        }
        if (!Number.isFinite(x) || x === 0) {
          return 0;
        }
        x = sign(x) * Math.floor(Math.abs(x));
        x = x % moduloVal;
        if (!typeOpts.unsigned && x >= moduloBound) {
          return x - moduloVal;
        } else if (typeOpts.unsigned) {
          if (x < 0) {
            x += moduloVal;
          } else if (x === -0) {
            return 0;
          }
        }
        return x;
      };
    }
    conversions["void"] = function() {
      return void 0;
    };
    conversions["boolean"] = function(val) {
      return !!val;
    };
    conversions["byte"] = createNumberConversion(8, { unsigned: false });
    conversions["octet"] = createNumberConversion(8, { unsigned: true });
    conversions["short"] = createNumberConversion(16, { unsigned: false });
    conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
    conversions["long"] = createNumberConversion(32, { unsigned: false });
    conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
    conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
    conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
    conversions["double"] = function(V) {
      const x = +V;
      if (!Number.isFinite(x)) {
        throw new TypeError("Argument is not a finite floating-point value");
      }
      return x;
    };
    conversions["unrestricted double"] = function(V) {
      const x = +V;
      if (isNaN(x)) {
        throw new TypeError("Argument is NaN");
      }
      return x;
    };
    conversions["float"] = conversions["double"];
    conversions["unrestricted float"] = conversions["unrestricted double"];
    conversions["DOMString"] = function(V, opts) {
      if (!opts) opts = {};
      if (opts.treatNullAsEmptyString && V === null) {
        return "";
      }
      return String(V);
    };
    conversions["ByteString"] = function(V, opts) {
      const x = String(V);
      let c = void 0;
      for (let i = 0; (c = x.codePointAt(i)) !== void 0; ++i) {
        if (c > 255) {
          throw new TypeError("Argument is not a valid bytestring");
        }
      }
      return x;
    };
    conversions["USVString"] = function(V) {
      const S = String(V);
      const n = S.length;
      const U = [];
      for (let i = 0; i < n; ++i) {
        const c = S.charCodeAt(i);
        if (c < 55296 || c > 57343) {
          U.push(String.fromCodePoint(c));
        } else if (56320 <= c && c <= 57343) {
          U.push(String.fromCodePoint(65533));
        } else {
          if (i === n - 1) {
            U.push(String.fromCodePoint(65533));
          } else {
            const d = S.charCodeAt(i + 1);
            if (56320 <= d && d <= 57343) {
              const a = c & 1023;
              const b = d & 1023;
              U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
              ++i;
            } else {
              U.push(String.fromCodePoint(65533));
            }
          }
        }
      }
      return U.join("");
    };
    conversions["Date"] = function(V, opts) {
      if (!(V instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
      }
      if (isNaN(V)) {
        return void 0;
      }
      return V;
    };
    conversions["RegExp"] = function(V, opts) {
      if (!(V instanceof RegExp)) {
        V = new RegExp(V);
      }
      return V;
    };
  }
});

// ../../node_modules/whatwg-url/lib/utils.js
var require_utils = __commonJS({
  "../../node_modules/whatwg-url/lib/utils.js"(exports, module) {
    "use strict";
    module.exports.mixin = function mixin(target, source) {
      const keys = Object.getOwnPropertyNames(source);
      for (let i = 0; i < keys.length; ++i) {
        Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
      }
    };
    module.exports.wrapperSymbol = Symbol("wrapper");
    module.exports.implSymbol = Symbol("impl");
    module.exports.wrapperForImpl = function(impl) {
      return impl[module.exports.wrapperSymbol];
    };
    module.exports.implForWrapper = function(wrapper) {
      return wrapper[module.exports.implSymbol];
    };
  }
});

// ../../node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "../../node_modules/tr46/lib/mappingTable.json"(exports, module) {
    module.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
  }
});

// ../../node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "../../node_modules/tr46/index.js"(exports, module) {
    "use strict";
    var punycode = __require("punycode");
    var mappingTable = require_mappingTable();
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1
    };
    function normalize(str) {
      return str.split("\0").map(function(s) {
        return s.normalize("NFC");
      }).join("\0");
    }
    function findStatus(val) {
      var start = 0;
      var end = mappingTable.length - 1;
      while (start <= end) {
        var mid = Math.floor((start + end) / 2);
        var target = mappingTable[mid];
        if (target[0][0] <= val && target[0][1] >= val) {
          return target;
        } else if (target[0][0] > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string3) {
      return string3.replace(regexAstralSymbols, "_").length;
    }
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false;
      var processed = "";
      var len = countSymbols(domain_name);
      for (var i = 0; i < len; ++i) {
        var codePoint = domain_name.codePointAt(i);
        var status = findStatus(codePoint);
        switch (status[1]) {
          case "disallowed":
            hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
          case "ignored":
            break;
          case "mapped":
            processed += String.fromCodePoint.apply(String, status[2]);
            break;
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
              processed += String.fromCodePoint.apply(String, status[2]);
            } else {
              processed += String.fromCodePoint(codePoint);
            }
            break;
          case "valid":
            processed += String.fromCodePoint(codePoint);
            break;
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true;
              processed += String.fromCodePoint(codePoint);
            } else {
              processed += String.fromCodePoint.apply(String, status[2]);
            }
            break;
          case "disallowed_STD3_valid":
            if (useSTD3) {
              hasError = true;
            }
            processed += String.fromCodePoint(codePoint);
            break;
        }
      }
      return {
        string: processed,
        error: hasError
      };
    }
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode.toUnicode(label);
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
      }
      var error = false;
      if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
        error = true;
      }
      var len = countSymbols(label);
      for (var i = 0; i < len; ++i) {
        var status = findStatus(label.codePointAt(i));
        if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
          error = true;
          break;
        }
      }
      return {
        label,
        error
      };
    }
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option);
      result.string = normalize(result.string);
      var labels = result.string.split(".");
      for (var i = 0; i < labels.length; ++i) {
        try {
          var validation = validateLabel(labels[i]);
          labels[i] = validation.label;
          result.error = result.error || validation.error;
        } catch (e) {
          result.error = true;
        }
      }
      return {
        string: labels.join("."),
        error: result.error
      };
    }
    module.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
      var result = processing(domain_name, useSTD3, processing_option);
      var labels = result.string.split(".");
      labels = labels.map(function(l) {
        try {
          return punycode.toASCII(l);
        } catch (e) {
          result.error = true;
          return l;
        }
      });
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length;
        if (total.length > 253 || total.length === 0) {
          result.error = true;
        }
        for (var i = 0; i < labels.length; ++i) {
          if (labels.length > 63 || labels.length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error) return null;
      return labels.join(".");
    };
    module.exports.toUnicode = function(domain_name, useSTD3) {
      var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
      return {
        domain: result.string,
        error: result.error
      };
    };
    module.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  }
});

// ../../node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "../../node_modules/whatwg-url/lib/url-state-machine.js"(exports, module) {
    "use strict";
    var punycode = __require("punycode");
    var tr46 = require_tr46();
    var specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return punycode.ucs2.decode(str).length;
    }
    function at(input, idx) {
      const c = input[idx];
      return isNaN(c) ? void 0 : String.fromCodePoint(c);
    }
    function isASCIIDigit(c) {
      return c >= 48 && c <= 57;
    }
    function isASCIIAlpha(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122;
    }
    function isASCIIAlphanumeric(c) {
      return isASCIIAlpha(c) || isASCIIDigit(c);
    }
    function isASCIIHex(c) {
      return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
    }
    function isWindowsDriveLetterString(string3) {
      return string3.length === 2 && isASCIIAlpha(string3.codePointAt(0)) && (string3[1] === ":" || string3[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string3) {
      return string3.length === 2 && isASCIIAlpha(string3.codePointAt(0)) && string3[1] === ":";
    }
    function containsForbiddenHostCodePoint(string3) {
      return string3.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function containsForbiddenHostCodePointExcludingPercent(string3) {
      return string3.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url) {
      return isSpecialScheme(url.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function percentEncode(c) {
      let hex = c.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = "0" + hex;
      }
      return "%" + hex;
    }
    function utf8PercentEncode(c) {
      const buf = new Buffer(c);
      let str = "";
      for (let i = 0; i < buf.length; ++i) {
        str += percentEncode(buf[i]);
      }
      return str;
    }
    function utf8PercentDecode(str) {
      const input = new Buffer(str);
      const output = [];
      for (let i = 0; i < input.length; ++i) {
        if (input[i] !== 37) {
          output.push(input[i]);
        } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
          output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
          i += 2;
        } else {
          output.push(input[i]);
        }
      }
      return new Buffer(output).toString();
    }
    function isC0ControlPercentEncode(c) {
      return c <= 31 || c > 126;
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
    function isPathPercentEncode(c) {
      return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
    function isUserinfoPercentEncode(c) {
      return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
    }
    function percentEncodeChar(c, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c);
      if (encodeSetPredicate(c)) {
        return utf8PercentEncode(cStr);
      }
      return cStr;
    }
    function parseIPv4Number(input) {
      let R = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R = 8;
      }
      if (input === "") {
        return 0;
      }
      const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
      if (regex.test(input)) {
        return failure;
      }
      return parseInt(input, R);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return input;
      }
      const numbers = [];
      for (const part of parts) {
        if (part === "") {
          return input;
        }
        const n = parseIPv4Number(part);
        if (n === failure) {
          return input;
        }
        numbers.push(n);
      }
      for (let i = 0; i < numbers.length - 1; ++i) {
        if (numbers[i] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n of numbers) {
        ipv4 += n * Math.pow(256, 3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n = address;
      for (let i = 1; i <= 4; ++i) {
        output = String(n % 256) + output;
        if (i !== 4) {
          output = "." + output;
        }
        n = Math.floor(n / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = punycode.ucs2.decode(input);
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === 58) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === 46) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === 46 && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (isASCIIDigit(input[pointer])) {
              const number3 = parseInt(at(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number3;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number3;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === 58) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const seqResult = findLongestZeroSequence(address);
      const compress = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost(input, isSpecialArg) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (!isSpecialArg) {
        return parseOpaqueHost(input);
      }
      const domain = utf8PercentDecode(input);
      const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
      if (asciiDomain === null) {
        return failure;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
      }
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
      }
      return asciiDomain;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
      }
      let output = "";
      const decoded = punycode.ucs2.decode(input);
      for (let i = 0; i < decoded.length; ++i) {
        output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
      }
      return output;
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i = 0; i < arr.length; ++i) {
        if (arr[i] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen
      };
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
      }
      return host;
    }
    function trimControlChars(url) {
      return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
    }
    function trimTabAndNewline(url) {
      return url.replace(/\u0009|\u000A|\u000D/g, "");
    }
    function shortenPath(url) {
      const path7 = url.path;
      if (path7.length === 0) {
        return;
      }
      if (url.scheme === "file" && path7.length === 1 && isNormalizedWindowsDriveLetter(path7[0])) {
        return;
      }
      path7.pop();
    }
    function includesCredentials(url) {
      return url.username !== "" || url.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url) {
      return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
    }
    function isNormalizedWindowsDriveLetter(string3) {
      return /^[A-Za-z]:$/.test(string3);
    }
    function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c = this.input[this.pointer];
        const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
        const ret = this["parse " + this.state](c, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
      if (isASCIIAlpha(c)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
      if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
        this.buffer += cStr.toLowerCase();
      } else if (c === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
          return false;
        }
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
      if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
        return failure;
      } else if (this.base.cannotBeABaseURL && c === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
      if (c === 47) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c === 47) {
        this.state = "relative slash";
      } else if (c === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
      if (isSpecial(this.url) && (c === 47 || c === 92)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c === 47) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
      if (c !== 47 && c !== 92) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
      if (c === 64) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
          return false;
        }
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c === 91) {
          this.arrFlag = true;
        } else if (c === 93) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
      if (isASCIIDigit(c)) {
        this.buffer += cStr;
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
    URLStateMachine.prototype["parse file"] = function parseFile(c) {
      this.url.scheme = "file";
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
          !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
          !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else {
            this.parseError = true;
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          } else {
            this.url.host = this.base.host;
          }
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
      if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
      if (isSpecial(this.url)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "path";
        if (c !== 47 && c !== 92) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c !== void 0) {
        this.state = "path";
        if (c !== 47) {
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c) {
      if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
        if (isSpecial(this.url) && c === 92) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c === void 0 || c === 63 || c === 35)) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        }
        if (c === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += percentEncodeChar(c, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
      if (c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (!isNaN(c) && c !== 37) {
          this.parseError = true;
        }
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c)) {
          this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
      if (isNaN(c) || !this.stateOverride && c === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8";
        }
        const buffer = new Buffer(this.buffer);
        for (let i = 0; i < buffer.length; ++i) {
          if (buffer[i] < 33 || buffer[i] > 126 || buffer[i] === 34 || buffer[i] === 35 || buffer[i] === 60 || buffer[i] === 62) {
            this.url.query += percentEncode(buffer[i]);
          } else {
            this.url.query += String.fromCodePoint(buffer[i]);
          }
        }
        this.buffer = "";
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
      if (isNaN(c)) {
      } else if (c === 0) {
        this.parseError = true;
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
      }
      return true;
    };
    function serializeURL(url, excludeFragment) {
      let output = url.scheme + ":";
      if (url.host !== null) {
        output += "//";
        if (url.username !== "" || url.password !== "") {
          output += url.username;
          if (url.password !== "") {
            output += ":" + url.password;
          }
          output += "@";
        }
        output += serializeHost(url.host);
        if (url.port !== null) {
          output += ":" + url.port;
        }
      } else if (url.host === null && url.scheme === "file") {
        output += "//";
      }
      if (url.cannotBeABaseURL) {
        output += url.path[0];
      } else {
        for (const string3 of url.path) {
          output += "/" + string3;
        }
      }
      if (url.query !== null) {
        output += "?" + url.query;
      }
      if (!excludeFragment && url.fragment !== null) {
        output += "#" + url.fragment;
      }
      return output;
    }
    function serializeOrigin(tuple) {
      let result = tuple.scheme + "://";
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += ":" + tuple.port;
      }
      return result;
    }
    module.exports.serializeURL = serializeURL;
    module.exports.serializeURLOrigin = function(url) {
      switch (url.scheme) {
        case "blob":
          try {
            return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
          } catch (e) {
            return "null";
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url.scheme,
            host: url.host,
            port: url.port
          });
        case "file":
          return "file://";
        default:
          return "null";
      }
    };
    module.exports.basicURLParse = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
      if (usm.failure) {
        return "failure";
      }
      return usm.url;
    };
    module.exports.setTheUsername = function(url, username) {
      url.username = "";
      const decoded = punycode.ucs2.decode(username);
      for (let i = 0; i < decoded.length; ++i) {
        url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module.exports.setThePassword = function(url, password) {
      url.password = "";
      const decoded = punycode.ucs2.decode(password);
      for (let i = 0; i < decoded.length; ++i) {
        url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module.exports.serializeHost = serializeHost;
    module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module.exports.serializeInteger = function(integer) {
      return String(integer);
    };
    module.exports.parseURL = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      return module.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
    };
  }
});

// ../../node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "../../node_modules/whatwg-url/lib/URL-impl.js"(exports) {
    "use strict";
    var usm = require_url_state_machine();
    exports.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url = constructorArgs[0];
        const base = constructorArgs[1];
        let parsedBase = null;
        if (base !== void 0) {
          parsedBase = usm.basicURLParse(base);
          if (parsedBase === "failure") {
            throw new TypeError("Invalid base URL");
          }
        }
        const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v) {
        const parsedURL = usm.basicURLParse(v);
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v) {
        usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v);
      }
      get password() {
        return this._url.password;
      }
      set password(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v);
      }
      get host() {
        const url = this._url;
        if (url.host === null) {
          return "";
        }
        if (url.port === null) {
          return usm.serializeHost(url.host);
        }
        return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
      }
      set host(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0];
        }
        if (this._url.path.length === 0) {
          return "";
        }
        return "/" + this._url.path.join("/");
      }
      set pathname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return "?" + this._url.query;
      }
      set search(v) {
        const url = this._url;
        if (v === "") {
          url.query = null;
          return;
        }
        const input = v[0] === "?" ? v.substring(1) : v;
        url.query = "";
        usm.basicURLParse(input, { url, stateOverride: "query" });
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return "#" + this._url.fragment;
      }
      set hash(v) {
        if (v === "") {
          this._url.fragment = null;
          return;
        }
        const input = v[0] === "#" ? v.substring(1) : v;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// ../../node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "../../node_modules/whatwg-url/lib/URL.js"(exports, module) {
    "use strict";
    var conversions = require_lib2();
    var utils = require_utils();
    var Impl = require_URL_impl();
    var impl = utils.implSymbol;
    function URL2(url) {
      if (!this || this[impl] || !(this instanceof URL2)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
      }
      if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 2; ++i) {
        args[i] = arguments[i];
      }
      args[0] = conversions["USVString"](args[0]);
      if (args[1] !== void 0) {
        args[1] = conversions["USVString"](args[1]);
      }
      module.exports.setup(this, args);
    }
    URL2.prototype.toJSON = function toJSON() {
      if (!this || !module.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 0; ++i) {
        args[i] = arguments[i];
      }
      return this[impl].toJSON.apply(this[impl], args);
    };
    Object.defineProperty(URL2.prototype, "href", {
      get() {
        return this[impl].href;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].href = V;
      },
      enumerable: true,
      configurable: true
    });
    URL2.prototype.toString = function() {
      if (!this || !module.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      return this.href;
    };
    Object.defineProperty(URL2.prototype, "origin", {
      get() {
        return this[impl].origin;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "protocol", {
      get() {
        return this[impl].protocol;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].protocol = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "username", {
      get() {
        return this[impl].username;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].username = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "password", {
      get() {
        return this[impl].password;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].password = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "host", {
      get() {
        return this[impl].host;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].host = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hostname", {
      get() {
        return this[impl].hostname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hostname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "port", {
      get() {
        return this[impl].port;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].port = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "pathname", {
      get() {
        return this[impl].pathname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].pathname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "search", {
      get() {
        return this[impl].search;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].search = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hash", {
      get() {
        return this[impl].hash;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hash = V;
      },
      enumerable: true,
      configurable: true
    });
    module.exports = {
      is(obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL2.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData) privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils.wrapperSymbol] = obj;
      },
      interface: URL2,
      expose: {
        Window: { URL: URL2 },
        Worker: { URL: URL2 }
      }
    };
  }
});

// ../../node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({
  "../../node_modules/whatwg-url/lib/public-api.js"(exports) {
    "use strict";
    exports.URL = require_URL().interface;
    exports.serializeURL = require_url_state_machine().serializeURL;
    exports.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
    exports.basicURLParse = require_url_state_machine().basicURLParse;
    exports.setTheUsername = require_url_state_machine().setTheUsername;
    exports.setThePassword = require_url_state_machine().setThePassword;
    exports.serializeHost = require_url_state_machine().serializeHost;
    exports.serializeInteger = require_url_state_machine().serializeInteger;
    exports.parseURL = require_url_state_machine().parseURL;
  }
});

// ../../node_modules/node-fetch/lib/index.js
var require_lib3 = __commonJS({
  "../../node_modules/node-fetch/lib/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var Stream5 = _interopDefault(__require("stream"));
    var http = _interopDefault(__require("http"));
    var Url = _interopDefault(__require("url"));
    var whatwgUrl = _interopDefault(require_public_api());
    var https = _interopDefault(__require("https"));
    var zlib2 = _interopDefault(__require("zlib"));
    var Readable = Stream5.Readable;
    var BUFFER = Symbol("buffer");
    var TYPE = Symbol("type");
    var Blob2 = class _Blob {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a = blobParts;
          const length = Number(a.length);
          for (let i = 0; i < length; i++) {
            const element = a[i];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof _Blob) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== void 0 && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable();
        readable._read = function() {
        };
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new _Blob([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob2.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob2.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function FetchError(message, type, systemError) {
      Error.call(this, message);
      this.message = message;
      this.type = type;
      if (systemError) {
        this.code = this.errno = systemError.code;
      }
      Error.captureStackTrace(this, this.constructor);
    }
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    var convert;
    try {
      convert = __require("encoding").convert;
    } catch (e) {
    }
    var INTERNALS = Symbol("Body internals");
    var PassThrough = Stream5.PassThrough;
    function Body(body) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
      let size = _ref$size === void 0 ? 0 : _ref$size;
      var _ref$timeout = _ref.timeout;
      let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
      if (body == null) {
        body = null;
      } else if (isURLSearchParams(body)) {
        body = Buffer.from(body.toString());
      } else if (isBlob(body)) ;
      else if (Buffer.isBuffer(body)) ;
      else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        body = Buffer.from(body);
      } else if (ArrayBuffer.isView(body)) {
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
      } else if (body instanceof Stream5) ;
      else {
        body = Buffer.from(String(body));
      }
      this[INTERNALS] = {
        body,
        disturbed: false,
        error: null
      };
      this.size = size;
      this.timeout = timeout;
      if (body instanceof Stream5) {
        body.on("error", function(err) {
          const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
          _this[INTERNALS].error = error;
        });
      }
    }
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      /**
       * Decode response as ArrayBuffer
       *
       * @return  Promise
       */
      arrayBuffer() {
        return consumeBody.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      blob() {
        let ct = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then(function(buf) {
          return Object.assign(
            // Prevent copying
            new Blob2([], {
              type: ct.toLowerCase()
            }),
            {
              [BUFFER]: buf
            }
          );
        });
      },
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err) {
            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      text() {
        return consumeBody.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      /**
       * Decode response as buffer (non-spec api)
       *
       * @return  Promise
       */
      buffer() {
        return consumeBody.call(this);
      },
      /**
       * Decode response as text, while automatically detecting the encoding and
       * trying to decode to UTF-8 (non-spec api)
       *
       * @return  Promise
       */
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body.mixIn = function(proto) {
      for (const name of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
          Object.defineProperty(proto, name, desc);
        }
      }
    };
    function consumeBody() {
      var _this4 = this;
      if (this[INTERNALS].disturbed) {
        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
      }
      this[INTERNALS].disturbed = true;
      if (this[INTERNALS].error) {
        return Body.Promise.reject(this[INTERNALS].error);
      }
      let body = this.body;
      if (body === null) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      if (isBlob(body)) {
        body = body.stream();
      }
      if (Buffer.isBuffer(body)) {
        return Body.Promise.resolve(body);
      }
      if (!(body instanceof Stream5)) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      let accum = [];
      let accumBytes = 0;
      let abort = false;
      return new Body.Promise(function(resolve3, reject) {
        let resTimeout;
        if (_this4.timeout) {
          resTimeout = setTimeout(function() {
            abort = true;
            reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
          }, _this4.timeout);
        }
        body.on("error", function(err) {
          if (err.name === "AbortError") {
            abort = true;
            reject(err);
          } else {
            reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
          }
        });
        body.on("data", function(chunk) {
          if (abort || chunk === null) {
            return;
          }
          if (_this4.size && accumBytes + chunk.length > _this4.size) {
            abort = true;
            reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
            return;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        });
        body.on("end", function() {
          if (abort) {
            return;
          }
          clearTimeout(resTimeout);
          try {
            resolve3(Buffer.concat(accum, accumBytes));
          } catch (err) {
            reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
          }
        });
      });
    }
    function convertBody(buffer, headers) {
      if (typeof convert !== "function") {
        throw new Error("The package `encoding` must be installed to use the textConverted() function");
      }
      const ct = headers.get("content-type");
      let charset = "utf-8";
      let res, str;
      if (ct) {
        res = /charset=([^;]*)/i.exec(ct);
      }
      str = buffer.slice(0, 1024).toString();
      if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
      }
      if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
          res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
          if (res) {
            res.pop();
          }
        }
        if (res) {
          res = /charset=(.*)/i.exec(res.pop());
        }
      }
      if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
      }
      if (res) {
        charset = res.pop();
        if (charset === "gb2312" || charset === "gbk") {
          charset = "gb18030";
        }
      }
      return convert(buffer, "UTF-8", charset).toString();
    }
    function isURLSearchParams(obj) {
      if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
        return false;
      }
      return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
    }
    function isBlob(obj) {
      return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
    }
    function clone(instance) {
      let p1, p2;
      let body = instance.body;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream5 && typeof body.getBoundary !== "function") {
        p1 = new PassThrough();
        p2 = new PassThrough();
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS].body = p1;
        body = p2;
      }
      return body;
    }
    function extractContentType(body) {
      if (body === null) {
        return null;
      } else if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      } else if (isURLSearchParams(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isBlob(body)) {
        return body.type || null;
      } else if (Buffer.isBuffer(body)) {
        return null;
      } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        return null;
      } else if (ArrayBuffer.isView(body)) {
        return null;
      } else if (typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      } else if (body instanceof Stream5) {
        return null;
      } else {
        return "text/plain;charset=UTF-8";
      }
    }
    function getTotalBytes(instance) {
      const body = instance.body;
      if (body === null) {
        return 0;
      } else if (isBlob(body)) {
        return body.size;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (body && typeof body.getLengthSync === "function") {
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
        body.hasKnownLength && body.hasKnownLength()) {
          return body.getLengthSync();
        }
        return null;
      } else {
        return null;
      }
    }
    function writeToStream(dest, instance) {
      const body = instance.body;
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    }
    Body.Promise = global.Promise;
    var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function validateName(name) {
      name = `${name}`;
      if (invalidTokenRegex.test(name) || name === "") {
        throw new TypeError(`${name} is not a legal HTTP header name`);
      }
    }
    function validateValue(value) {
      value = `${value}`;
      if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
      }
    }
    function find(map, name) {
      name = name.toLowerCase();
      for (const key in map) {
        if (key.toLowerCase() === name) {
          return key;
        }
      }
      return void 0;
    }
    var MAP = Symbol("map");
    var Headers = class _Headers {
      /**
       * Headers class
       *
       * @param   Object  headers  Response headers
       * @return  Void
       */
      constructor() {
        let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init instanceof _Headers) {
          const rawHeaders = init.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init == null) ;
        else if (typeof init === "object") {
          const method = init[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init)) {
              const value = init[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      /**
       * Return combined header value given name
       *
       * @param   String  name  Header name
       * @return  Mixed
       */
      get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      /**
       * Iterate over all headers
       *
       * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
       * @param   Boolean   thisArg   `this` context for callback function
       * @return  Void
       */
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i = 0;
        while (i < pairs.length) {
          var _pairs$i = pairs[i];
          const name = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name, this);
          pairs = getHeaders(this);
          i++;
        }
      }
      /**
       * Overwrite header values given name
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== void 0 ? key : name] = [value];
      }
      /**
       * Append a value onto existing header
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name] = [value];
        }
      }
      /**
       * Check for header name existence
       *
       * @param   String   name  Header name
       * @return  Boolean
       */
      has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== void 0;
      }
      /**
       * Delete all header values given name
       *
       * @param   String  name  Header name
       * @return  Void
       */
      delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      /**
       * Return raw headers (non-spec api)
       *
       * @return  Object
       */
      raw() {
        return this[MAP];
      }
      /**
       * Get an iterator on keys.
       *
       * @return  Iterator
       */
      keys() {
        return createHeadersIterator(this, "key");
      }
      /**
       * Get an iterator on values.
       *
       * @return  Iterator
       */
      values() {
        return createHeadersIterator(this, "value");
      }
      /**
       * Get an iterator on entries.
       *
       * This is the default iterator of the Headers object.
       *
       * @return  Iterator
       */
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers.prototype.entries = Headers.prototype[Symbol.iterator];
    Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    function getHeaders(headers) {
      let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
      const keys = Object.keys(headers[MAP]).sort();
      return keys.map(kind === "key" ? function(k) {
        return k.toLowerCase();
      } : kind === "value" ? function(k) {
        return headers[MAP][k].join(", ");
      } : function(k) {
        return [k.toLowerCase(), headers[MAP][k].join(", ")];
      });
    }
    var INTERNAL = Symbol("internal");
    function createHeadersIterator(target, kind) {
      const iterator = Object.create(HeadersIteratorPrototype);
      iterator[INTERNAL] = {
        target,
        kind,
        index: 0
      };
      return iterator;
    }
    var HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index + 1;
        return {
          value: values[index],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function exportNodeCompatibleHeaders(headers) {
      const obj = Object.assign({ __proto__: null }, headers[MAP]);
      const hostHeaderKey = find(headers[MAP], "Host");
      if (hostHeaderKey !== void 0) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
      }
      return obj;
    }
    function createHeadersLenient(obj) {
      const headers = new Headers();
      for (const name of Object.keys(obj)) {
        if (invalidTokenRegex.test(name)) {
          continue;
        }
        if (Array.isArray(obj[name])) {
          for (const val of obj[name]) {
            if (invalidHeaderCharRegex.test(val)) {
              continue;
            }
            if (headers[MAP][name] === void 0) {
              headers[MAP][name] = [val];
            } else {
              headers[MAP][name].push(val);
            }
          }
        } else if (!invalidHeaderCharRegex.test(obj[name])) {
          headers[MAP][name] = [obj[name]];
        }
      }
      return headers;
    }
    var INTERNALS$1 = Symbol("Response internals");
    var STATUS_CODES = http.STATUS_CODES;
    var Response2 = class _Response {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      /**
       * Clone this response
       *
       * @return  Response
       */
      clone() {
        return new _Response(clone(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body.mixIn(Response2.prototype);
    Object.defineProperties(Response2.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response2.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    var INTERNALS$2 = Symbol("Request internals");
    var URL2 = Url.URL || whatwgUrl.URL;
    var parse_url = Url.parse;
    var format_url = Url.format;
    function parseURL(urlStr) {
      if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
        urlStr = new URL2(urlStr).toString();
      }
      return parse_url(urlStr);
    }
    var streamDestructionSupported = "destroy" in Stream5.Readable.prototype;
    function isRequest(input) {
      return typeof input === "object" && typeof input[INTERNALS$2] === "object";
    }
    function isAbortSignal(signal) {
      const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
      return !!(proto && proto.constructor.name === "AbortSignal");
    }
    var Request = class _Request {
      constructor(input) {
        let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parseURL(input.href);
          } else {
            parsedURL = parseURL(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parseURL(input.url);
        }
        let method = init.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
        Body.call(this, inputBody, {
          timeout: init.timeout || input.timeout || 0,
          size: init.size || input.size || 0
        });
        const headers = new Headers(init.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init) signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      /**
       * Clone this request
       *
       * @return  Request
       */
      clone() {
        return new _Request(this);
      }
    };
    Body.mixIn(Request.prototype);
    Object.defineProperty(Request.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    function getNodeRequestOptions(request) {
      const parsedURL = request[INTERNALS$2].parsedURL;
      const headers = new Headers(request[INTERNALS$2].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError("Only absolute URLs are supported");
      }
      if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError("Only HTTP(S) protocols are supported");
      }
      if (request.signal && request.body instanceof Stream5.Readable && !streamDestructionSupported) {
        throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
      }
      let contentLengthValue = null;
      if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body != null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number") {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate");
      }
      let agent = request.agent;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
      });
    }
    function AbortError(message) {
      Error.call(this, message);
      this.type = "aborted";
      this.message = message;
      Error.captureStackTrace(this, this.constructor);
    }
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = "AbortError";
    var URL$1 = Url.URL || whatwgUrl.URL;
    var PassThrough$1 = Stream5.PassThrough;
    var isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
      const orig = new URL$1(original).hostname;
      const dest = new URL$1(destination).hostname;
      return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
    };
    var isSameProtocol = function isSameProtocol2(destination, original) {
      const orig = new URL$1(original).protocol;
      const dest = new URL$1(destination).protocol;
      return orig === dest;
    };
    function fetch7(url, opts) {
      if (!fetch7.Promise) {
        throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
      }
      Body.Promise = fetch7.Promise;
      return new fetch7.Promise(function(resolve3, reject) {
        const request = new Request(url, opts);
        const options = getNodeRequestOptions(request);
        const send = (options.protocol === "https:" ? https : http).request;
        const signal = request.signal;
        let response = null;
        const abort = function abort2() {
          let error = new AbortError("The user aborted a request.");
          reject(error);
          if (request.body && request.body instanceof Stream5.Readable) {
            destroyStream(request.body, error);
          }
          if (!response || !response.body) return;
          response.body.emit("error", error);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        const abortAndFinalize = function abortAndFinalize2() {
          abort();
          finalize();
        };
        const req = send(options);
        let reqTimeout;
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        function finalize() {
          req.abort();
          if (signal) signal.removeEventListener("abort", abortAndFinalize);
          clearTimeout(reqTimeout);
        }
        if (request.timeout) {
          req.once("socket", function(socket) {
            reqTimeout = setTimeout(function() {
              reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
              finalize();
            }, request.timeout);
          });
        }
        req.on("error", function(err) {
          reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
          if (response && response.body) {
            destroyStream(response.body, err);
          }
          finalize();
        });
        fixResponseChunkedTransferBadEnding(req, function(err) {
          if (signal && signal.aborted) {
            return;
          }
          if (response && response.body) {
            destroyStream(response.body, err);
          }
        });
        if (parseInt(process.version.substring(1)) < 14) {
          req.on("socket", function(s) {
            s.addListener("close", function(hadError) {
              const hasDataListener = s.listenerCount("data") > 0;
              if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
                const err = new Error("Premature close");
                err.code = "ERR_STREAM_PREMATURE_CLOSE";
                response.body.emit("error", err);
              }
            });
          });
        }
        req.on("response", function(res) {
          clearTimeout(reqTimeout);
          const headers = createHeadersLenient(res.headers);
          if (fetch7.isRedirect(res.statusCode)) {
            const location = headers.get("Location");
            let locationURL = null;
            try {
              locationURL = location === null ? null : new URL$1(location, request.url).toString();
            } catch (err) {
              if (request.redirect !== "manual") {
                reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
                finalize();
                return;
              }
            }
            switch (request.redirect) {
              case "error":
                reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
                finalize();
                return;
              case "manual":
                if (locationURL !== null) {
                  try {
                    headers.set("Location", locationURL);
                  } catch (err) {
                    reject(err);
                  }
                }
                break;
              case "follow":
                if (locationURL === null) {
                  break;
                }
                if (request.counter >= request.follow) {
                  reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                  finalize();
                  return;
                }
                const requestOpts = {
                  headers: new Headers(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  body: request.body,
                  signal: request.signal,
                  timeout: request.timeout,
                  size: request.size
                };
                if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
                  for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                    requestOpts.headers.delete(name);
                  }
                }
                if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                  reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                  finalize();
                  return;
                }
                if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                  requestOpts.method = "GET";
                  requestOpts.body = void 0;
                  requestOpts.headers.delete("content-length");
                }
                resolve3(fetch7(new Request(locationURL, requestOpts)));
                finalize();
                return;
            }
          }
          res.once("end", function() {
            if (signal) signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = res.pipe(new PassThrough$1());
          const response_options = {
            url: request.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers,
            size: request.size,
            timeout: request.timeout,
            counter: request.counter
          };
          const codings = headers.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
            response = new Response2(body, response_options);
            resolve3(response);
            return;
          }
          const zlibOptions = {
            flush: zlib2.Z_SYNC_FLUSH,
            finishFlush: zlib2.Z_SYNC_FLUSH
          };
          if (codings == "gzip" || codings == "x-gzip") {
            body = body.pipe(zlib2.createGunzip(zlibOptions));
            response = new Response2(body, response_options);
            resolve3(response);
            return;
          }
          if (codings == "deflate" || codings == "x-deflate") {
            const raw = res.pipe(new PassThrough$1());
            raw.once("data", function(chunk) {
              if ((chunk[0] & 15) === 8) {
                body = body.pipe(zlib2.createInflate());
              } else {
                body = body.pipe(zlib2.createInflateRaw());
              }
              response = new Response2(body, response_options);
              resolve3(response);
            });
            raw.on("end", function() {
              if (!response) {
                response = new Response2(body, response_options);
                resolve3(response);
              }
            });
            return;
          }
          if (codings == "br" && typeof zlib2.createBrotliDecompress === "function") {
            body = body.pipe(zlib2.createBrotliDecompress());
            response = new Response2(body, response_options);
            resolve3(response);
            return;
          }
          response = new Response2(body, response_options);
          resolve3(response);
        });
        writeToStream(req, request);
      });
    }
    function fixResponseChunkedTransferBadEnding(request, errorCallback) {
      let socket;
      request.on("socket", function(s) {
        socket = s;
      });
      request.on("response", function(response) {
        const headers = response.headers;
        if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) {
          response.once("close", function(hadError) {
            const hasDataListener = socket && socket.listenerCount("data") > 0;
            if (hasDataListener && !hadError) {
              const err = new Error("Premature close");
              err.code = "ERR_STREAM_PREMATURE_CLOSE";
              errorCallback(err);
            }
          });
        }
      });
    }
    function destroyStream(stream, err) {
      if (stream.destroy) {
        stream.destroy(err);
      } else {
        stream.emit("error", err);
        stream.end();
      }
    }
    fetch7.isRedirect = function(code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };
    fetch7.Promise = global.Promise;
    module.exports = exports = fetch7;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = exports;
    exports.Headers = Headers;
    exports.Request = Request;
    exports.Response = Response2;
    exports.FetchError = FetchError;
    exports.AbortError = AbortError;
  }
});

// rsmv/src/libs/proctexes.js
var require_proctexes = __commonJS({
  "rsmv/src/libs/proctexes.js"(exports, module) {
    "use strict";
    (function() {
      class ArrayUtils {
        static copy$byte_A$int$byte_A$int$int(src, srcOff, dest, destOff, len) {
          if (src === dest) {
            if (srcOff === destOff) {
              return;
            }
            if (destOff > srcOff && destOff < srcOff + len) {
              len--;
              let srcOff2 = srcOff + len;
              let destOff2 = destOff + len;
              len = srcOff2 - len;
              len += 7;
              while (srcOff2 >= len) {
                {
                  let destOff3 = destOff2 - 1;
                  let srcOff3 = srcOff2 - 1;
                  dest[destOff2] = src[srcOff2];
                  dest[destOff3--] = src[srcOff3--];
                  dest[destOff3--] = src[srcOff3--];
                  dest[destOff3--] = src[srcOff3--];
                  dest[destOff3--] = src[srcOff3--];
                  dest[destOff3--] = src[srcOff3--];
                  dest[destOff3--] = src[srcOff3--];
                  destOff2 = destOff3 - 1;
                  srcOff2 = srcOff3 - 1;
                  dest[destOff3] = src[srcOff3];
                }
              }
              ;
              len -= 7;
              while (srcOff2 >= len) {
                {
                  dest[destOff2--] = src[srcOff2--];
                }
              }
              ;
              return;
            }
          }
          len += srcOff;
          len -= 7;
          while (srcOff < len) {
            {
              let destOff2 = destOff + 1;
              let srcOff2 = srcOff + 1;
              dest[destOff] = src[srcOff];
              dest[destOff2++] = src[srcOff2++];
              dest[destOff2++] = src[srcOff2++];
              dest[destOff2++] = src[srcOff2++];
              dest[destOff2++] = src[srcOff2++];
              dest[destOff2++] = src[srcOff2++];
              dest[destOff2++] = src[srcOff2++];
              destOff = destOff2 + 1;
              srcOff = srcOff2 + 1;
              dest[destOff2] = src[srcOff2];
            }
          }
          ;
          len += 7;
          while (srcOff < len) {
            {
              dest[destOff++] = src[srcOff++];
            }
          }
          ;
        }
        static copy(src, srcOff, dest, destOff, len) {
          if ((src != null && src instanceof Array && (src.length == 0 || src[0] == null || typeof src[0] === "number") || src === null) && (typeof srcOff === "number" || srcOff === null) && (dest != null && dest instanceof Array && (dest.length == 0 || dest[0] == null || typeof dest[0] === "number") || dest === null) && (typeof destOff === "number" || destOff === null) && (typeof len === "number" || len === null)) {
            return ArrayUtils.copy$byte_A$int$byte_A$int$int(src, srcOff, dest, destOff, len);
          } else if ((src != null && src instanceof Array && (src.length == 0 || src[0] == null || typeof src[0] === "number") || src === null) && (typeof srcOff === "number" || srcOff === null) && (dest != null && dest instanceof Array && (dest.length == 0 || dest[0] == null || typeof dest[0] === "number") || dest === null) && (typeof destOff === "number" || destOff === null) && (typeof len === "number" || len === null)) {
            return ArrayUtils.copy$short_A$int$short_A$int$int(src, srcOff, dest, destOff, len);
          } else if ((src != null && src instanceof Array && (src.length == 0 || src[0] == null || typeof src[0] === "number") || src === null) && (typeof srcOff === "number" || srcOff === null) && (dest != null && dest instanceof Array && (dest.length == 0 || dest[0] == null || typeof dest[0] === "number") || dest === null) && (typeof destOff === "number" || destOff === null) && (typeof len === "number" || len === null)) {
            return ArrayUtils.copy$int_A$int$int_A$int$int(src, srcOff, dest, destOff, len);
          } else if ((src != null && src instanceof Array && (src.length == 0 || src[0] == null || typeof src[0] === "number") || src === null) && (typeof srcOff === "number" || srcOff === null) && (dest != null && dest instanceof Array && (dest.length == 0 || dest[0] == null || typeof dest[0] === "number") || dest === null) && (typeof destOff === "number" || destOff === null) && (typeof len === "number" || len === null)) {
            return ArrayUtils.copy$long_A$int$long_A$int$int(src, srcOff, dest, destOff, len);
          } else if ((src != null && src instanceof Array && (src.length == 0 || src[0] == null || typeof src[0] === "number") || src === null) && (typeof srcOff === "number" || srcOff === null) && (dest != null && dest instanceof Array && (dest.length == 0 || dest[0] == null || typeof dest[0] === "number") || dest === null) && (typeof destOff === "number" || destOff === null) && (typeof len === "number" || len === null)) {
            return ArrayUtils.copy$float_A$int$float_A$int$int(src, srcOff, dest, destOff, len);
          } else if ((src != null && src instanceof Array && (src.length == 0 || src[0] == null || src[0] != null) || src === null) && (typeof srcOff === "number" || srcOff === null) && (dest != null && dest instanceof Array && (dest.length == 0 || dest[0] == null || dest[0] != null) || dest === null) && (typeof destOff === "number" || destOff === null) && (typeof len === "number" || len === null)) {
            return ArrayUtils.copy$java_lang_Object_A$int$java_lang_Object_A$int$int(src, srcOff, dest, destOff, len);
          } else
            throw new Error("invalid overload");
        }
        static copy$short_A$int$short_A$int$int(src, srcOff, dest, destOff, len) {
          if (src === dest) {
            if (srcOff === destOff) {
              return;
            }
            if (destOff > srcOff && destOff < srcOff + len) {
              len--;
              let srcOff2 = srcOff + len;
              let destOff2 = destOff + len;
              len = srcOff2 - len;
              len += 7;
              while (srcOff2 >= len) {
                {
                  let destOff3 = destOff2 - 1;
                  let srcOff3 = srcOff2 - 1;
                  dest[destOff2] = src[srcOff2];
                  dest[destOff3--] = src[srcOff3--];
                  dest[destOff3--] = src[srcOff3--];
                  dest[destOff3--] = src[srcOff3--];
                  dest[destOff3--] = src[srcOff3--];
                  dest[destOff3--] = src[srcOff3--];
                  dest[destOff3--] = src[srcOff3--];
                  destOff2 = destOff3 - 1;
                  srcOff2 = srcOff3 - 1;
                  dest[destOff3] = src[srcOff3];
                }
              }
              ;
              len -= 7;
              while (srcOff2 >= len) {
                {
                  dest[destOff2--] = src[srcOff2--];
                }
              }
              ;
              return;
            }
          }
          len += srcOff;
          len -= 7;
          while (srcOff < len) {
            {
              let destOff2 = destOff + 1;
              let srcOff2 = srcOff + 1;
              dest[destOff] = src[srcOff];
              dest[destOff2++] = src[srcOff2++];
              dest[destOff2++] = src[srcOff2++];
              dest[destOff2++] = src[srcOff2++];
              dest[destOff2++] = src[srcOff2++];
              dest[destOff2++] = src[srcOff2++];
              dest[destOff2++] = src[srcOff2++];
              destOff = destOff2 + 1;
              srcOff = srcOff2 + 1;
              dest[destOff2] = src[srcOff2];
            }
          }
          ;
          len += 7;
          while (srcOff < len) {
            {
              dest[destOff++] = src[srcOff++];
            }
          }
          ;
        }
        static copy$int_A$int$int_A$int$int(src, srcOff, dest, destOff, len) {
          if (src === dest) {
            if (srcOff === destOff) {
              return;
            }
            if (destOff > srcOff && destOff < srcOff + len) {
              len--;
              let srcOff2 = srcOff + len;
              let destOff2 = destOff + len;
              len = srcOff2 - len;
              len += 7;
              while (srcOff2 >= len) {
                {
                  let destOff3 = destOff2 - 1;
                  let srcOff3 = srcOff2 - 1;
                  dest[destOff2] = src[srcOff2];
                  dest[destOff3--] = src[srcOff3--];
                  dest[destOff3--] = src[srcOff3--];
                  dest[destOff3--] = src[srcOff3--];
                  dest[destOff3--] = src[srcOff3--];
                  dest[destOff3--] = src[srcOff3--];
                  dest[destOff3--] = src[srcOff3--];
                  destOff2 = destOff3 - 1;
                  srcOff2 = srcOff3 - 1;
                  dest[destOff3] = src[srcOff3];
                }
              }
              ;
              len -= 7;
              while (srcOff2 >= len) {
                {
                  dest[destOff2--] = src[srcOff2--];
                }
              }
              ;
              return;
            }
          }
          len += srcOff;
          len -= 7;
          while (srcOff < len) {
            {
              let destOff2 = destOff + 1;
              let srcOff2 = srcOff + 1;
              dest[destOff] = src[srcOff];
              dest[destOff2++] = src[srcOff2++];
              dest[destOff2++] = src[srcOff2++];
              dest[destOff2++] = src[srcOff2++];
              dest[destOff2++] = src[srcOff2++];
              dest[destOff2++] = src[srcOff2++];
              dest[destOff2++] = src[srcOff2++];
              destOff = destOff2 + 1;
              srcOff = srcOff2 + 1;
              dest[destOff2] = src[srcOff2];
            }
          }
          ;
          len += 7;
          while (srcOff < len) {
            {
              dest[destOff++] = src[srcOff++];
            }
          }
          ;
        }
        static copy$long_A$int$long_A$int$int(src, srcOff, dest, destOff, len) {
          if (src === dest) {
            if (srcOff === destOff) {
              return;
            }
            if (destOff > srcOff && destOff < srcOff + len) {
              len--;
              let srcOff2 = srcOff + len;
              let destOff2 = destOff + len;
              len = srcOff2 - len;
              len += 3;
              while (srcOff2 >= len) {
                {
                  let destOff3 = destOff2 - 1;
                  let srcOff3 = srcOff2 - 1;
                  dest[destOff2] = src[srcOff2];
                  dest[destOff3--] = src[srcOff3--];
                  dest[destOff3--] = src[srcOff3--];
                  destOff2 = destOff3 - 1;
                  srcOff2 = srcOff3 - 1;
                  dest[destOff3] = src[srcOff3];
                }
              }
              ;
              len -= 3;
              while (srcOff2 >= len) {
                {
                  dest[destOff2--] = src[srcOff2--];
                }
              }
              ;
              return;
            }
          }
          len += srcOff;
          len -= 3;
          while (srcOff < len) {
            {
              let destOff2 = destOff + 1;
              let srcOff2 = srcOff + 1;
              dest[destOff] = src[srcOff];
              dest[destOff2++] = src[srcOff2++];
              dest[destOff2++] = src[srcOff2++];
              destOff = destOff2 + 1;
              srcOff = srcOff2 + 1;
              dest[destOff2] = src[srcOff2];
            }
          }
          ;
          len += 3;
          while (srcOff < len) {
            {
              dest[destOff++] = src[srcOff++];
            }
          }
          ;
        }
        static copy$float_A$int$float_A$int$int(src, srcOff, dest, destOff, len) {
          if (src === dest) {
            return;
          }
          len -= 7;
          while (srcOff < len) {
            {
              let destOff2 = destOff + 1;
              let srcOff2 = srcOff + 1;
              dest[destOff] = src[srcOff];
              dest[destOff2++] = src[srcOff2++];
              dest[destOff2++] = src[srcOff2++];
              dest[destOff2++] = src[srcOff2++];
              dest[destOff2++] = src[srcOff2++];
              dest[destOff2++] = src[srcOff2++];
              dest[destOff2++] = src[srcOff2++];
              destOff = destOff2 + 1;
              srcOff = srcOff2 + 1;
              dest[destOff2] = src[srcOff2];
            }
          }
          ;
          len += 7;
          while (srcOff < len) {
            {
              dest[destOff++] = src[srcOff++];
            }
          }
          ;
        }
        static copy$java_lang_Object_A$int$java_lang_Object_A$int$int(src, srcOff, dest, destOff, len) {
          if (src === dest) {
            if (srcOff === destOff) {
              return;
            }
            if (destOff > srcOff && destOff < srcOff + len) {
              len--;
              let srcOff2 = srcOff + len;
              let destOff2 = destOff + len;
              len = srcOff2 - len;
              len += 7;
              while (srcOff2 >= len) {
                {
                  let destOff3 = destOff2 - 1;
                  let srcOff3 = srcOff2 - 1;
                  dest[destOff2] = src[srcOff2];
                  dest[destOff3--] = src[srcOff3--];
                  dest[destOff3--] = src[srcOff3--];
                  dest[destOff3--] = src[srcOff3--];
                  dest[destOff3--] = src[srcOff3--];
                  dest[destOff3--] = src[srcOff3--];
                  dest[destOff3--] = src[srcOff3--];
                  destOff2 = destOff3 - 1;
                  srcOff2 = srcOff3 - 1;
                  dest[destOff3] = src[srcOff3];
                }
              }
              ;
              len -= 7;
              while (srcOff2 >= len) {
                {
                  dest[destOff2--] = src[srcOff2--];
                }
              }
              ;
              return;
            }
          }
          len += srcOff;
          len -= 7;
          while (srcOff < len) {
            {
              let destOff2 = destOff + 1;
              let srcOff2 = srcOff + 1;
              dest[destOff] = src[srcOff];
              dest[destOff2++] = src[srcOff2++];
              dest[destOff2++] = src[srcOff2++];
              dest[destOff2++] = src[srcOff2++];
              dest[destOff2++] = src[srcOff2++];
              dest[destOff2++] = src[srcOff2++];
              dest[destOff2++] = src[srcOff2++];
              destOff = destOff2 + 1;
              srcOff = srcOff2 + 1;
              dest[destOff2] = src[srcOff2];
            }
          }
          ;
          len += 7;
          while (srcOff < len) {
            {
              dest[destOff++] = src[srcOff++];
            }
          }
          ;
        }
        static clear(dest, off, len) {
          len = len - 7;
          while (off < len) {
            {
              let off2 = off + 1;
              dest[off] = 0;
              dest[off2++] = 0;
              dest[off2++] = 0;
              dest[off2++] = 0;
              dest[off2++] = 0;
              dest[off2++] = 0;
              dest[off2++] = 0;
              off = off2 + 1;
              dest[off2] = 0;
            }
          }
          ;
          len += 7;
          while (off < len) {
            {
              dest[off++] = 0;
            }
          }
          ;
        }
        static fill$short_A$int$int$short(dest, off, len, value) {
          len = len - 7;
          while (off < len) {
            {
              let off2 = off + 1;
              dest[off] = value;
              dest[off2++] = value;
              dest[off2++] = value;
              dest[off2++] = value;
              dest[off2++] = value;
              dest[off2++] = value;
              dest[off2++] = value;
              off = off2 + 1;
              dest[off2] = value;
            }
          }
          ;
          len += 7;
          while (off < len) {
            {
              dest[off++] = value;
            }
          }
          ;
        }
        static fill(dest, off, len, value) {
          if ((dest != null && dest instanceof Array && (dest.length == 0 || dest[0] == null || typeof dest[0] === "number") || dest === null) && (typeof off === "number" || off === null) && (typeof len === "number" || len === null) && (typeof value === "number" || value === null)) {
            return ArrayUtils.fill$short_A$int$int$short(dest, off, len, value);
          } else if ((dest != null && dest instanceof Array && (dest.length == 0 || dest[0] == null || typeof dest[0] === "number") || dest === null) && (typeof off === "number" || off === null) && (typeof len === "number" || len === null) && (typeof value === "number" || value === null)) {
            return ArrayUtils.fill$int_A$int$int$int(dest, off, len, value);
          } else
            throw new Error("invalid overload");
        }
        static fill$int_A$int$int$int(dest, off, len, value) {
          len = off + len - 7;
          while (off < len) {
            {
              let off2 = off + 1;
              dest[off] = value;
              dest[off2++] = value;
              dest[off2++] = value;
              dest[off2++] = value;
              dest[off2++] = value;
              dest[off2++] = value;
              dest[off2++] = value;
              off = off2 + 1;
              dest[off2] = value;
            }
          }
          ;
          len += 7;
          while (off < len) {
            {
              dest[off++] = value;
            }
          }
          ;
        }
        static sort$int_A$java_lang_Object_A(keys, values) {
          ArrayUtils.sort$int_A$java_lang_Object_A$int$int(keys, values, 0, keys.length - 1);
        }
        static sort$int_A$java_lang_Object_A$int$int(keys, values, lo, hi) {
          if (hi <= lo) {
            return;
          }
          const mid = (lo + hi) / 2 | 0;
          let i = lo;
          const pivotKey = keys[mid];
          keys[mid] = keys[hi];
          keys[hi] = pivotKey;
          const pivotValue = values[mid];
          values[mid] = values[hi];
          values[hi] = pivotValue;
          for (let j = lo; j < hi; j++) {
            {
              if (pivotKey + (j & 1) > keys[j]) {
                const key = keys[j];
                keys[j] = keys[i];
                keys[i] = key;
                const value = values[j];
                values[j] = values[i];
                values[i++] = value;
              }
            }
            ;
          }
          keys[hi] = keys[i];
          keys[i] = pivotKey;
          values[hi] = values[i];
          values[i] = pivotValue;
          ArrayUtils.sort$int_A$java_lang_Object_A$int$int(keys, values, lo, i - 1);
          ArrayUtils.sort$int_A$java_lang_Object_A$int$int(keys, values, i + 1, hi);
        }
        static sort(keys, values, lo, hi) {
          if ((keys != null && keys instanceof Array && (keys.length == 0 || keys[0] == null || typeof keys[0] === "number") || keys === null) && (values != null && values instanceof Array && (values.length == 0 || values[0] == null || values[0] != null) || values === null) && (typeof lo === "number" || lo === null) && (typeof hi === "number" || hi === null)) {
            return ArrayUtils.sort$int_A$java_lang_Object_A$int$int(keys, values, lo, hi);
          } else if ((keys != null && keys instanceof Array && (keys.length == 0 || keys[0] == null || typeof keys[0] === "string") || keys === null) && (values != null && values instanceof Array && (values.length == 0 || values[0] == null || typeof values[0] === "number") || values === null) && (typeof lo === "number" || lo === null) && (typeof hi === "number" || hi === null)) {
            return ArrayUtils.sort$java_lang_String_A$short_A$int$int(keys, values, lo, hi);
          } else if ((keys != null && keys instanceof Array && (keys.length == 0 || keys[0] == null || typeof keys[0] === "number") || keys === null) && (values != null && values instanceof Array && (values.length == 0 || values[0] == null || values[0] != null) || values === null) && (typeof lo === "number" || lo === null) && (typeof hi === "number" || hi === null)) {
            return ArrayUtils.sort$long_A$java_lang_Object_A$int$int(keys, values, lo, hi);
          } else if ((keys != null && keys instanceof Array && (keys.length == 0 || keys[0] == null || typeof keys[0] === "number") || keys === null) && (values != null && values instanceof Array && (values.length == 0 || values[0] == null || typeof values[0] === "number") || values === null) && (typeof lo === "number" || lo === null) && (typeof hi === "number" || hi === null)) {
            return ArrayUtils.sort$long_A$int_A$int$int(keys, values, lo, hi);
          } else if ((keys != null && keys instanceof Array && (keys.length == 0 || keys[0] == null || typeof keys[0] === "number") || keys === null) && (values != null && values instanceof Array && (values.length == 0 || values[0] == null || typeof values[0] === "number") || values === null) && (typeof lo === "number" || lo === null) && (typeof hi === "number" || hi === null)) {
            return ArrayUtils.sort$int_A$int_A$int$int(keys, values, lo, hi);
          } else if ((keys != null && keys instanceof Array && (keys.length == 0 || keys[0] == null || typeof keys[0] === "number") || keys === null) && (values != null && values instanceof Array && (values.length == 0 || values[0] == null || values[0] != null) || values === null) && lo === void 0 && hi === void 0) {
            return ArrayUtils.sort$int_A$java_lang_Object_A(keys, values);
          } else if ((keys != null && keys instanceof Array && (keys.length == 0 || keys[0] == null || typeof keys[0] === "string") || keys === null) && (values != null && values instanceof Array && (values.length == 0 || values[0] == null || typeof values[0] === "number") || values === null) && lo === void 0 && hi === void 0) {
            return ArrayUtils.sort$java_lang_String_A$short_A(keys, values);
          } else if ((keys != null && keys instanceof Array && (keys.length == 0 || keys[0] == null || typeof keys[0] === "number") || keys === null) && (values != null && values instanceof Array && (values.length == 0 || values[0] == null || values[0] != null) || values === null) && lo === void 0 && hi === void 0) {
            return ArrayUtils.sort$long_A$java_lang_Object_A(keys, values);
          } else if ((keys != null && keys instanceof Array && (keys.length == 0 || keys[0] == null || typeof keys[0] === "number") || keys === null) && (values != null && values instanceof Array && (values.length == 0 || values[0] == null || typeof values[0] === "number") || values === null) && lo === void 0 && hi === void 0) {
            return ArrayUtils.sort$long_A$int_A(keys, values);
          } else
            throw new Error("invalid overload");
        }
        static sort$java_lang_String_A$short_A(keys, values) {
          ArrayUtils.sort$java_lang_String_A$short_A$int$int(keys, values, 0, keys.length - 1);
        }
        static sort$java_lang_String_A$short_A$int$int(keys, values, lo, hi) {
          if (hi <= lo) {
            return;
          }
          const mid = (lo + hi) / 2 | 0;
          let i = lo;
          const pivotKey = keys[mid];
          keys[mid] = keys[hi];
          keys[hi] = pivotKey;
          const pivotValue = values[mid];
          values[mid] = values[hi];
          values[hi] = pivotValue;
          for (let j = lo; j < hi; j++) {
            {
              if (pivotKey == null || keys[j] != null && /* compareTo */
              keys[j].localeCompare(pivotKey) < (j & 1)) {
                const key = keys[j];
                keys[j] = keys[i];
                keys[i] = key;
                const value = values[j];
                values[j] = values[i];
                values[i++] = value;
              }
            }
            ;
          }
          keys[hi] = keys[i];
          keys[i] = pivotKey;
          values[hi] = values[i];
          values[i] = pivotValue;
          ArrayUtils.sort$java_lang_String_A$short_A$int$int(keys, values, lo, i - 1);
          ArrayUtils.sort$java_lang_String_A$short_A$int$int(keys, values, i + 1, hi);
        }
        static copyOfNullable$short_A(array2) {
          if (array2 == null) {
            return null;
          } else {
            const copy = ((s) => {
              let a = [];
              while (s-- > 0)
                a.push(0);
              return a;
            })(array2.length);
            ArrayUtils.copy$short_A$int$short_A$int$int(array2, 0, copy, 0, array2.length);
            return copy;
          }
        }
        static copyOfNullable(array2) {
          if (array2 != null && array2 instanceof Array && (array2.length == 0 || array2[0] == null || typeof array2[0] === "number") || array2 === null) {
            return ArrayUtils.copyOfNullable$short_A(array2);
          } else if (array2 != null && array2 instanceof Array && (array2.length == 0 || array2[0] == null || typeof array2[0] === "number") || array2 === null) {
            return ArrayUtils.copyOfNullable$int_A(array2);
          } else
            throw new Error("invalid overload");
        }
        static copyOf$short_A$int(array2, len) {
          const copy = ((s) => {
            let a = [];
            while (s-- > 0)
              a.push(0);
            return a;
          })(len);
          ArrayUtils.copy$short_A$int$short_A$int$int(array2, 0, copy, 0, len);
          return copy;
        }
        static copyOf(array2, len) {
          if ((array2 != null && array2 instanceof Array && (array2.length == 0 || array2[0] == null || typeof array2[0] === "number") || array2 === null) && (typeof len === "number" || len === null)) {
            return ArrayUtils.copyOf$short_A$int(array2, len);
          } else if ((array2 != null && array2 instanceof Array && (array2.length == 0 || array2[0] == null || typeof array2[0] === "number") || array2 === null) && (typeof len === "number" || len === null)) {
            return ArrayUtils.copyOf$float_A$int(array2, len);
          } else
            throw new Error("invalid overload");
        }
        static copyOfNullable$int_A(array2) {
          if (array2 == null) {
            return null;
          } else {
            const copy = ((s) => {
              let a = [];
              while (s-- > 0)
                a.push(0);
              return a;
            })(array2.length);
            ArrayUtils.copy$int_A$int$int_A$int$int(array2, 0, copy, 0, array2.length);
            return copy;
          }
        }
        static copyOf$float_A$int(array2, len) {
          const copy = ((s) => {
            let a = [];
            while (s-- > 0)
              a.push(0);
            return a;
          })(len);
          ArrayUtils.copy$float_A$int$float_A$int$int(array2, 0, copy, 0, len);
          return copy;
        }
        /*private*/
        static sort$long_A$java_lang_Object_A$int$int(keys, values, lo, hi) {
          if (lo >= hi) {
            return;
          }
          const mid = (hi + lo) / 2 | 0;
          let i = lo;
          const pivotKey = keys[mid];
          keys[mid] = keys[hi];
          keys[hi] = pivotKey;
          const pivotValue = values[mid];
          values[mid] = values[hi];
          values[hi] = pivotValue;
          for (let j = lo; j < hi; j++) {
            {
              if (keys[j] < ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(j & 1) + pivotKey) {
                const key = keys[j];
                keys[j] = keys[i];
                keys[i] = key;
                const value = values[j];
                values[j] = values[i];
                values[i++] = value;
              }
            }
            ;
          }
          keys[hi] = keys[i];
          keys[i] = pivotKey;
          values[hi] = values[i];
          values[i] = pivotValue;
          ArrayUtils.sort$long_A$java_lang_Object_A$int$int(keys, values, lo, i - 1);
          ArrayUtils.sort$long_A$java_lang_Object_A$int$int(keys, values, i + 1, hi);
        }
        static sort$long_A$java_lang_Object_A(keys, values) {
          ArrayUtils.sort$long_A$java_lang_Object_A$int$int(keys, values, 0, keys.length - 1);
        }
        static sort$long_A$int_A$int$int(keys, values, lo, hi) {
          if (hi <= lo) {
            return;
          }
          const mid = (hi + lo) / 2 | 0;
          let i = lo;
          const pivotKey = keys[mid];
          keys[mid] = keys[hi];
          keys[hi] = pivotKey;
          const pivotValue = values[mid];
          values[mid] = values[hi];
          values[hi] = pivotValue;
          for (let j = lo; j < hi; j++) {
            {
              if (keys[j] < ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(j & 1) + pivotKey) {
                const key = keys[j];
                keys[j] = keys[i];
                keys[i] = key;
                const value = values[j];
                values[j] = values[i];
                values[i++] = value;
              }
            }
            ;
          }
          keys[hi] = keys[i];
          keys[i] = pivotKey;
          values[hi] = values[i];
          values[i] = pivotValue;
          ArrayUtils.sort$long_A$int_A$int$int(keys, values, lo, i - 1);
          ArrayUtils.sort$long_A$int_A$int$int(keys, values, i + 1, hi);
        }
        static sort$long_A$int_A(keys, values) {
          ArrayUtils.sort$long_A$int_A$int$int(keys, values, 0, keys.length - 1);
        }
        static fillRange(dest, start, end, value) {
          end--;
          const end2 = end - 7;
          let start2 = start - 1;
          while (start2 < end2) {
            {
              start = start2 + 1;
              dest[start] = value;
              start++;
              dest[start] = value;
              start++;
              dest[start] = value;
              start++;
              dest[start] = value;
              start++;
              dest[start] = value;
              start++;
              dest[start] = value;
              start++;
              dest[start] = value;
              start2 = start + 1;
              dest[start2] = value;
            }
          }
          ;
          while (start2 < end) {
            {
              start2++;
              dest[start2] = value;
            }
          }
          ;
        }
        static sort$int_A$int_A$int$int(keys, values, lo, hi) {
          if (lo >= hi) {
            return;
          }
          let i = lo;
          const mid = (hi + lo) / 2 | 0;
          const pivotKey = keys[mid];
          keys[mid] = keys[hi];
          keys[hi] = pivotKey;
          const pivotValue = values[mid];
          values[mid] = values[hi];
          values[hi] = pivotValue;
          for (let j = lo; j < hi; j++) {
            {
              if (keys[j] > (j & 1) + pivotKey) {
                const key = keys[j];
                keys[j] = keys[i];
                keys[i] = key;
                const value = values[j];
                values[j] = values[i];
                values[i++] = value;
              }
            }
            ;
          }
          keys[hi] = keys[i];
          keys[i] = pivotKey;
          values[hi] = values[i];
          values[i] = pivotValue;
          ArrayUtils.sort$int_A$int_A$int$int(keys, values, lo, i - 1);
          ArrayUtils.sort$int_A$int_A$int$int(keys, values, i + 1, hi);
        }
      }
      ArrayUtils["__class"] = "ArrayUtils";
      class BufferPool {
        static smallBuffers_$LI$() {
          if (BufferPool.smallBuffers == null) {
            BufferPool.smallBuffers = ((s) => {
              let a = [];
              while (s-- > 0)
                a.push(null);
              return a;
            })(1e3);
          }
          return BufferPool.smallBuffers;
        }
        static mediumBuffers_$LI$() {
          if (BufferPool.mediumBuffers == null) {
            BufferPool.mediumBuffers = ((s) => {
              let a = [];
              while (s-- > 0)
                a.push(null);
              return a;
            })(250);
          }
          return BufferPool.mediumBuffers;
        }
        static largeBuffers_$LI$() {
          if (BufferPool.largeBuffers == null) {
            BufferPool.largeBuffers = ((s) => {
              let a = [];
              while (s-- > 0)
                a.push(null);
              return a;
            })(50);
          }
          return BufferPool.largeBuffers;
        }
        static allocate(size) {
          if (size === 100 && BufferPool.smallBufferCount > 0) {
            const bytes = BufferPool.smallBuffers_$LI$()[--BufferPool.smallBufferCount];
            BufferPool.smallBuffers_$LI$()[BufferPool.smallBufferCount] = null;
            return bytes;
          } else if (size === 5e3 && BufferPool.mediumBufferCount > 0) {
            const bytes = BufferPool.mediumBuffers_$LI$()[--BufferPool.mediumBufferCount];
            BufferPool.mediumBuffers_$LI$()[BufferPool.mediumBufferCount] = null;
            return bytes;
          } else if (size === 3e4 && BufferPool.largeBufferCount > 0) {
            const bytes = BufferPool.largeBuffers_$LI$()[--BufferPool.largeBufferCount];
            BufferPool.largeBuffers_$LI$()[BufferPool.largeBufferCount] = null;
            return bytes;
          } else {
            return ((s) => {
              let a = [];
              while (s-- > 0)
                a.push(0);
              return a;
            })(size);
          }
        }
      }
      BufferPool.smallBufferCount = 0;
      BufferPool.mediumBufferCount = 0;
      BufferPool.largeBufferCount = 0;
      BufferPool["__class"] = "BufferPool";
      class ColorImageCache {
        constructor(capacity, height, width) {
          this.singleRow = -1;
          this.size = 0;
          this.recentlyUsed = new LinkedList();
          this.invalid = false;
          if (this.capacity === void 0) {
            this.capacity = 0;
          }
          if (this.height === void 0) {
            this.height = 0;
          }
          if (this.entries === void 0) {
            this.entries = null;
          }
          if (this.pixels === void 0) {
            this.pixels = null;
          }
          this.capacity = capacity;
          this.height = height;
          this.entries = ((s) => {
            let a = [];
            while (s-- > 0)
              a.push(null);
            return a;
          })(this.height);
          this.pixels = (function(dims) {
            let allocate = function(dims2) {
              if (dims2.length === 0) {
                return 0;
              } else {
                let array2 = [];
                for (let i = 0; i < dims2[0]; i++) {
                  array2.push(allocate(dims2.slice(1)));
                }
                return array2;
              }
            };
            return allocate(dims);
          })([this.capacity, 3, width]);
        }
        clear() {
          for (let i = 0; i < this.capacity; i++) {
            {
              this.pixels[i][0] = null;
              this.pixels[i][1] = null;
              this.pixels[i][2] = null;
              this.pixels[i] = null;
            }
            ;
          }
          this.pixels = null;
          this.entries = null;
          this.recentlyUsed.clear();
          this.recentlyUsed = null;
        }
        get$() {
          if (this.capacity !== this.height) {
            throw Object.defineProperty(new Error("Can only retrieve a full image cache"), "__classes", { configurable: true, value: ["java.lang.Throwable", "java.lang.Object", "java.lang.RuntimeException", "java.lang.Exception"] });
          }
          for (let row = 0; row < this.capacity; row++) {
            {
              this.entries[row] = ColorImageCacheEntry.VALID_$LI$();
            }
            ;
          }
          return this.pixels;
        }
        get$int(row) {
          if (this.height === this.capacity) {
            this.invalid = this.entries[row] == null;
            this.entries[row] = ColorImageCacheEntry.VALID_$LI$();
            return this.pixels[row];
          } else if (this.capacity === 1) {
            this.invalid = row !== this.singleRow;
            this.singleRow = row;
            return this.pixels[0];
          } else {
            let entry = this.entries[row];
            if (entry == null) {
              this.invalid = true;
              if (this.capacity <= this.size) {
                const lruEntry = this.recentlyUsed.tail();
                entry = new ColorImageCacheEntry(row, lruEntry.index);
                this.entries[lruEntry.row] = null;
                lruEntry.unlink();
              } else {
                entry = new ColorImageCacheEntry(row, this.size);
                this.size++;
              }
              this.entries[row] = entry;
            } else {
              this.invalid = false;
            }
            this.recentlyUsed.addHead(entry);
            return this.pixels[entry.index];
          }
        }
        get(row) {
          if (typeof row === "number" || row === null) {
            return this.get$int(row);
          } else if (row === void 0) {
            return this.get$();
          } else
            throw new Error("invalid overload");
        }
      }
      ColorImageCache["__class"] = "ColorImageCache";
      class HashTable {
        constructor(bucketCount) {
          if (this.searchCursor === void 0) {
            this.searchCursor = null;
          }
          if (this.searchKey === void 0) {
            this.searchKey = 0;
          }
          if (this.iteratorCursor === void 0) {
            this.iteratorCursor = null;
          }
          this.iteratorBucket = 0;
          if (this.buckets === void 0) {
            this.buckets = null;
          }
          if (this.bucketCount === void 0) {
            this.bucketCount = 0;
          }
          this.buckets = ((s) => {
            let a = [];
            while (s-- > 0)
              a.push(null);
            return a;
          })(bucketCount);
          this.bucketCount = bucketCount;
          for (let i = 0; i < bucketCount; i++) {
            {
              const sentinel = this.buckets[i] = new Node();
              sentinel.prev = sentinel;
              sentinel.next = sentinel;
            }
            ;
          }
        }
        getBucketCount() {
          return this.bucketCount;
        }
        put(key, value) {
          if (value.prev != null) {
            value.unlink();
          }
          const sentinel = this.buckets[key & ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(this.bucketCount - 1) | 0];
          value.key = key;
          value.next = sentinel;
          value.prev = sentinel.prev;
          value.prev.next = value;
          value.next.prev = value;
        }
        size() {
          let size = 0;
          for (let i = 0; i < this.bucketCount; i++) {
            {
              const sentinel = this.buckets[i];
              for (let node = sentinel.next; node !== sentinel; node = node.next) {
                {
                  size++;
                }
                ;
              }
            }
            ;
          }
          return size;
        }
        head() {
          this.iteratorBucket = 0;
          return this.next();
        }
        next() {
          if (this.iteratorBucket > 0 && this.buckets[this.iteratorBucket - 1] !== this.iteratorCursor) {
            const node2 = this.iteratorCursor;
            this.iteratorCursor = node2.next;
            return node2;
          }
          let node;
          do {
            {
              if (this.iteratorBucket >= this.bucketCount) {
                return null;
              }
              node = this.buckets[this.iteratorBucket++].next;
            }
          } while (node === this.buckets[this.iteratorBucket - 1]);
          this.iteratorCursor = node.next;
          return node;
        }
        get(key) {
          this.searchKey = key;
          const sentinel = this.buckets[key & ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(this.bucketCount - 1) | 0];
          for (this.searchCursor = sentinel.next; this.searchCursor !== sentinel; this.searchCursor = this.searchCursor.next) {
            {
              if (this.searchCursor.key === key) {
                const value = this.searchCursor;
                this.searchCursor = this.searchCursor.next;
                return value;
              }
            }
            ;
          }
          this.searchCursor = null;
          return null;
        }
        toArray(array2) {
          let size = 0;
          for (let i = 0; i < this.bucketCount; i++) {
            {
              const sentinel = this.buckets[i];
              for (let node = sentinel.next; node !== sentinel; node = node.next) {
                {
                  array2[size++] = node;
                }
                ;
              }
            }
            ;
          }
          return size;
        }
        nextWithKey() {
          if (this.searchCursor == null) {
            return null;
          }
          const sentinel = this.buckets[((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(this.bucketCount - 1) & this.searchKey | 0];
          while (sentinel !== this.searchCursor) {
            {
              if (this.searchKey === this.searchCursor.key) {
                const node = this.searchCursor;
                this.searchCursor = this.searchCursor.next;
                return node;
              }
              this.searchCursor = this.searchCursor.next;
            }
          }
          ;
          this.searchCursor = null;
          return null;
        }
        clear() {
          for (let i = 0; i < this.bucketCount; i++) {
            {
              const sentinel = this.buckets[i];
              while (true) {
                {
                  const node = sentinel.next;
                  if (node === sentinel) {
                    break;
                  }
                  node.unlink();
                }
              }
              ;
            }
            ;
          }
          this.iteratorCursor = null;
          this.searchCursor = null;
        }
      }
      HashTable["__class"] = "HashTable";
      class IntUtils {
        static clp2(v) {
          v--;
          v |= v >>> 1;
          v |= v >>> 2;
          v |= v >>> 4;
          v |= v >>> 8;
          v |= v >>> 16;
          return v + 1;
        }
        static flp2(v) {
          let v2 = v >>> 1;
          v2 |= v2 >>> 1;
          v2 |= v2 >>> 2;
          v2 |= v2 >>> 4;
          v2 |= v2 >>> 8;
          v2 |= v2 >>> 16;
          return v & ~v2;
        }
        static isPowerOfTwo(v) {
          return v === (v & -v);
        }
        static bitCount(v) {
          let bits = 0;
          if (v < 0 || v >= 65536) {
            v >>>= 16;
            bits += 16;
          }
          if (v >= 256) {
            v >>>= 8;
            bits += 8;
          }
          if (v >= 16) {
            v >>>= 4;
            bits += 4;
          }
          if (v >= 4) {
            bits += 2;
            v >>>= 2;
          }
          if (v >= 1) {
            bits++;
            v >>>= 1;
          }
          return bits + v;
        }
        static bitCountFast(v) {
          v = (v >>> 1 & 1431655765) + (v & 1431655765);
          v = (v & 858993459) + (v >>> 2 & -1288490189);
          v = (v >>> 4) + v & 252645135;
          v += v >>> 8;
          v += v >>> 16;
          return v & 255;
        }
        static signum(v) {
          if (v > 0) {
            return 1;
          } else if (v < 0) {
            return -1;
          } else {
            return 0;
          }
        }
        static toString(v) {
          return v < 0 ? (
            /* toString */
            "" + v
          ) : IntUtils.toStringInternal(v);
        }
        /*private*/
        static toStringInternal(v) {
          if (v < 0) {
            return (
              /* toString */
              "" + v
            );
          }
          let len = 2;
          for (let temp = v / 10 | 0; temp !== 0; temp = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(temp / 10)) {
            {
              len++;
            }
            ;
          }
          const chars = ((s) => {
            let a = [];
            while (s-- > 0)
              a.push(null);
            return a;
          })(len);
          chars[0] = "+";
          for (let i = len - 1; i > 0; i--) {
            {
              const prevValue = v;
              v = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(v / 10);
              const digit = prevValue - v * 10;
              if (digit >= 10) {
                chars[i] = String.fromCharCode(digit + 87);
              } else {
                chars[i] = String.fromCharCode(digit + 48);
              }
            }
            ;
          }
          return chars.join("");
        }
        static bitReverse(__in, len) {
          let out = 0;
          while (len > 0) {
            {
              out = __in & 1 | out << 1;
              __in >>>= 1;
              len--;
            }
          }
          ;
          return out;
        }
        static pow(a, b) {
          let result = 1;
          while (b > 1) {
            {
              if ((b & 1) !== 0) {
                result *= a;
              }
              b >>= 1;
              a *= a;
            }
          }
          ;
          if (b === 1) {
            return a * result;
          } else {
            return result;
          }
        }
        static clamp(value, min, max) {
          if (value < min) {
            return min;
          }
          if (value > max) {
            return max;
          }
          return value;
        }
      }
      IntUtils["__class"] = "IntUtils";
      class JsTextureProvider {
        getTexture(id) {
          throw Object.defineProperty(new Error("implement from javavscript"), "__classes", { configurable: true, value: ["java.lang.Throwable", "java.lang.Object", "java.lang.RuntimeException", "java.lang.Exception"] });
        }
        getSprite(id) {
          throw Object.defineProperty(new Error("implement from javavscript"), "__classes", { configurable: true, value: ["java.lang.Throwable", "java.lang.Object", "java.lang.RuntimeException", "java.lang.Exception"] });
        }
      }
      JsTextureProvider["__class"] = "JsTextureProvider";
      class LinkedList {
        constructor() {
          if (this.cursor === void 0) {
            this.cursor = null;
          }
          this.sentinel = new Node();
          this.sentinel.next = this.sentinel;
          this.sentinel.prev = this.sentinel;
        }
        static insertBefore(node, position) {
          if (node.prev != null) {
            node.unlink();
          }
          node.next = position;
          node.prev = position.prev;
          node.prev.next = node;
          node.next.prev = node;
        }
        clear() {
          while (true) {
            {
              const node = this.sentinel.next;
              if (this.sentinel === node) {
                this.cursor = null;
                return;
              }
              node.unlink();
            }
          }
          ;
        }
        addHead(node) {
          if (node.prev != null) {
            node.unlink();
          }
          node.prev = this.sentinel;
          node.next = this.sentinel.next;
          node.prev.next = node;
          node.next.prev = node;
        }
        removeHead() {
          const node = this.sentinel.next;
          if (node === this.sentinel) {
            return null;
          } else {
            node.unlink();
            return node;
          }
        }
        isEmpty() {
          return this.sentinel.next === this.sentinel;
        }
        head() {
          const node = this.sentinel.next;
          if (node === this.sentinel) {
            this.cursor = null;
            return null;
          } else {
            this.cursor = node.next;
            return node;
          }
        }
        addTail(node) {
          if (node.prev != null) {
            node.unlink();
          }
          node.prev = this.sentinel.prev;
          node.next = this.sentinel;
          node.prev.next = node;
          node.next.prev = node;
        }
        tail() {
          const node = this.sentinel.prev;
          if (node === this.sentinel) {
            this.cursor = null;
            return null;
          } else {
            this.cursor = node.prev;
            return node;
          }
        }
        prev() {
          const node = this.cursor;
          if (node === this.sentinel) {
            this.cursor = null;
            return null;
          } else {
            this.cursor = node.prev;
            return node;
          }
        }
        next() {
          const node = this.cursor;
          if (this.sentinel === node) {
            this.cursor = null;
            return null;
          } else {
            this.cursor = node.next;
            return node;
          }
        }
      }
      LinkedList["__class"] = "LinkedList";
      class LruHashTable {
        constructor(capacity) {
          this.aClass4_Sub3_18 = new SecondaryNode();
          this.queue = new SecondaryLinkedList();
          if (this.available === void 0) {
            this.available = 0;
          }
          if (this.capacity === void 0) {
            this.capacity = 0;
          }
          if (this.table === void 0) {
            this.table = null;
          }
          this.available = capacity;
          let bucketCount;
          for (bucketCount = 1; bucketCount + bucketCount < capacity; bucketCount += bucketCount) {
            {
            }
            ;
          }
          this.capacity = capacity;
          this.table = new HashTable(bucketCount);
        }
        head() {
          return this.table.head();
        }
        put(key, value) {
          if (this.available === 0) {
            const first = this.queue.removeHead();
            first.unlink();
            first.unlinkSecondary();
            if (this.aClass4_Sub3_18 === first) {
              const second = this.queue.removeHead();
              second.unlink();
              second.unlinkSecondary();
            }
          } else {
            this.available--;
          }
          this.table.put(key, value);
          this.queue.addTail(value);
        }
        get(key) {
          const value = this.table.get(key);
          if (value != null) {
            this.queue.addTail(value);
          }
          return value;
        }
        next() {
          return this.table.next();
        }
        clear() {
          this.queue.clear();
          this.table.clear();
          this.aClass4_Sub3_18 = new SecondaryNode();
          this.available = this.capacity;
        }
      }
      LruHashTable["__class"] = "LruHashTable";
      class MergedStatics {
        static sub10_method283(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
          if (arg8 === arg4 && arg2 === arg7 && arg5 === arg6 && arg1 === arg0) {
            MergedStatics.sub9_method280(arg0, arg8, arg2, arg3, arg6);
            return;
          }
          let local36 = arg8;
          let local38 = arg2;
          const local42 = arg8 * 3;
          const local46 = arg2 * 3;
          const local50 = arg4 * 3;
          const local54 = arg5 * 3;
          const local58 = arg7 * 3;
          const local62 = arg1 * 3;
          const local72 = local50 + arg6 - arg8 - local54;
          const local81 = local58 + arg0 - local62 - arg2;
          const local92 = local54 + local42 - local50 - local50;
          const local103 = local62 + local46 - local58 - local58;
          const local108 = local58 - local46;
          const local113 = local50 - local42;
          for (let local115 = 128; local115 <= 4096; local115 += 128) {
            {
              const local126 = local115 * local115 >> 12;
              const local132 = local115 * local126 >> 12;
              const local136 = local132 * local72;
              const local140 = local126 * local92;
              const local144 = local113 * local115;
              const local148 = local103 * local126;
              const local158 = (local144 + local140 + local136 >> 12) + arg8;
              const local162 = local81 * local132;
              const local166 = local108 * local115;
              const local176 = (local166 + local162 + local148 >> 12) + arg2;
              MergedStatics.sub9_method280(local176, local36, local38, arg3, local158);
              local36 = local158;
              local38 = local176;
            }
            ;
          }
        }
        static sub22_method4693(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
          if (MergedStatics.sub2_anInt902 <= arg8 && arg8 <= MergedStatics.sub3_anInt2553 && MergedStatics.sub2_anInt902 <= arg0 && MergedStatics.sub3_anInt2553 >= arg0 && MergedStatics.sub2_anInt902 <= arg3 && MergedStatics.sub3_anInt2553 >= arg3 && MergedStatics.sub2_anInt902 <= arg4 && arg4 <= MergedStatics.sub3_anInt2553 && arg5 >= MergedStatics.sub4_anInt3086 && arg5 <= MergedStatics.sub5_anInt4230 && arg1 >= MergedStatics.sub4_anInt3086 && MergedStatics.sub5_anInt4230 >= arg1 && arg7 >= MergedStatics.sub4_anInt3086 && MergedStatics.sub5_anInt4230 >= arg7 && MergedStatics.sub4_anInt3086 <= arg6 && MergedStatics.sub5_anInt4230 >= arg6) {
            MergedStatics.sub10_method283(arg6, arg7, arg5, arg2, arg0, arg3, arg4, arg1, arg8);
          } else {
            MergedStatics.sub31_method3662(arg8, arg7, arg4, arg0, arg1, arg5, arg6, arg2, arg3);
          }
        }
        static sub9_method280(arg0, arg1, arg2, arg3, arg4) {
          let local10 = arg0 - arg2;
          let local15 = arg4 - arg1;
          if (local15 === 0) {
            if (local10 !== 0) {
              MergedStatics.sub10_method306(arg1, arg3, arg0, arg2);
            }
          } else if (local10 === 0) {
            MergedStatics.sub20_method1975(arg1, arg4, arg3, arg2);
          } else {
            if (local15 < 0) {
              local15 = -local15;
            }
            if (local10 < 0) {
              local10 = -local10;
            }
            const local70 = local10 > local15;
            if (local70) {
              const local74 = arg1;
              arg1 = arg2;
              arg2 = local74;
              const local80 = arg4;
              arg4 = arg0;
              arg0 = local80;
            }
            if (arg4 < arg1) {
              const local93 = arg1;
              arg1 = arg4;
              const local97 = arg2;
              arg2 = arg0;
              arg0 = local97;
              arg4 = local93;
            }
            let local105 = arg2;
            const local110 = arg4 - arg1;
            let local115 = arg0 - arg2;
            const local126 = arg0 > arg2 ? 1 : -1;
            if (local115 < 0) {
              local115 = -local115;
            }
            let local137 = -(local110 >> 1);
            if (local70) {
              for (let local141 = arg1; local141 <= arg4; local141++) {
                {
                  local137 += local115;
                  MergedStatics.sub5_anIntArrayArray36[local141][local105] = arg3;
                  if (local137 > 0) {
                    local105 += local126;
                    local137 -= local110;
                  }
                }
                ;
              }
            } else {
              for (let local172 = arg1; local172 <= arg4; local172++) {
                {
                  local137 += local115;
                  MergedStatics.sub5_anIntArrayArray36[local105][local172] = arg3;
                  if (local137 > 0) {
                    local105 += local126;
                    local137 -= local110;
                  }
                }
                ;
              }
            }
          }
        }
        static sub10_method306(arg0, arg1, arg2, arg3) {
          if (arg2 >= arg3) {
            for (let local10 = arg3; local10 < arg2; local10++) {
              {
                MergedStatics.sub5_anIntArrayArray36[local10][arg0] = arg1;
              }
              ;
            }
          } else {
            for (let local30 = arg2; local30 < arg3; local30++) {
              {
                MergedStatics.sub5_anIntArrayArray36[local30][arg0] = arg1;
              }
              ;
            }
          }
        }
        static sub20_method1975(arg0, arg1, arg2, arg3) {
          if (arg1 >= arg0) {
            ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[arg3], arg0, arg1, arg2);
          } else {
            ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[arg3], arg1, arg0, arg2);
          }
        }
        static sub31_method3662(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
          if (arg3 === arg0 && arg4 === arg5 && arg8 === arg2 && arg1 === arg6) {
            MergedStatics.sub32_method4022(arg5, arg6, arg7, arg0, arg2);
            return;
          }
          let local32 = arg0;
          let local34 = arg5;
          const local38 = arg0 * 3;
          const local42 = arg4 * 3;
          const local46 = arg3 * 3;
          const local50 = arg8 * 3;
          const local61 = arg2 + local46 - arg0 - local50;
          const local65 = arg5 * 3;
          const local75 = local38 + local50 - local46 - local46;
          const local79 = arg1 * 3;
          const local90 = local79 + local65 - local42 - local42;
          const local100 = local42 + arg6 - arg5 - local79;
          const local104 = local46 - local38;
          const local108 = local42 - local65;
          for (let local110 = 128; local110 <= 4096; local110 += 128) {
            {
              const local119 = local110 * local110 >> 12;
              const local123 = local119 * local75;
              const local129 = local110 * local119 >> 12;
              const local133 = local129 * local61;
              const local137 = local108 * local110;
              const local141 = local90 * local119;
              const local145 = local100 * local129;
              const local149 = local104 * local110;
              const local159 = (local149 + local123 + local133 >> 12) + arg0;
              const local170 = (local137 + local145 + local141 >> 12) + arg5;
              MergedStatics.sub32_method4022(local34, local170, arg7, local32, local159);
              local34 = local170;
              local32 = local159;
            }
            ;
          }
        }
        static sub32_method4022(arg0, arg1, arg2, arg3, arg4) {
          const local18 = arg4 - arg3;
          const local23 = arg1 - arg0;
          if (local18 === 0) {
            if (local23 !== 0) {
              MergedStatics.sub20_method1930(arg3, arg0, arg1, arg2);
            }
          } else if (local23 === 0) {
            MergedStatics.sub13_method1015(arg3, arg4, arg2, arg0);
          } else {
            const local55 = (local23 << 12) / local18 | 0;
            const local64 = arg0 - (arg3 * local55 >> 12);
            let local76;
            let local78;
            if (arg3 < MergedStatics.sub2_anInt902) {
              local78 = local64 + (MergedStatics.sub2_anInt902 * local55 >> 12);
              local76 = MergedStatics.sub2_anInt902;
            } else if (MergedStatics.sub3_anInt2553 >= arg3) {
              local76 = arg3;
              local78 = arg0;
            } else {
              local76 = MergedStatics.sub3_anInt2553;
              local78 = (MergedStatics.sub3_anInt2553 * local55 >> 12) + local64;
            }
            let local115;
            let local117;
            if (arg4 < MergedStatics.sub2_anInt902) {
              local115 = MergedStatics.sub2_anInt902;
              local117 = local64 + (MergedStatics.sub2_anInt902 * local55 >> 12);
            } else if (arg4 <= MergedStatics.sub3_anInt2553) {
              local115 = arg4;
              local117 = arg1;
            } else {
              local115 = MergedStatics.sub3_anInt2553;
              local117 = (local55 * MergedStatics.sub3_anInt2553 >> 12) + local64;
            }
            if (MergedStatics.sub4_anInt3086 > local117) {
              local115 = (MergedStatics.sub4_anInt3086 - local64 << 12) / local55 | 0;
              local117 = MergedStatics.sub4_anInt3086;
            } else if (MergedStatics.sub5_anInt4230 < local117) {
              local115 = (MergedStatics.sub5_anInt4230 - local64 << 12) / local55 | 0;
              local117 = MergedStatics.sub5_anInt4230;
            }
            if (MergedStatics.sub4_anInt3086 > local78) {
              local76 = (MergedStatics.sub4_anInt3086 - local64 << 12) / local55 | 0;
              local78 = MergedStatics.sub4_anInt3086;
            } else if (local78 > MergedStatics.sub5_anInt4230) {
              local78 = MergedStatics.sub5_anInt4230;
              local76 = (MergedStatics.sub5_anInt4230 - local64 << 12) / local55 | 0;
            }
            MergedStatics.sub9_method280(local117, local76, local78, arg2, local115);
          }
        }
        static sub20_method1930(arg0, arg1, arg2, arg3) {
          if (MergedStatics.sub2_anInt902 <= arg0 && MergedStatics.sub3_anInt2553 >= arg0) {
            arg1 = IntUtils.clamp(arg1, MergedStatics.sub4_anInt3086, MergedStatics.sub5_anInt4230);
            arg2 = IntUtils.clamp(arg2, MergedStatics.sub4_anInt3086, MergedStatics.sub5_anInt4230);
            MergedStatics.sub10_method306(arg0, arg3, arg2, arg1);
          }
        }
        static sub13_method1015(arg0, arg1, arg2, arg3) {
          if (MergedStatics.sub4_anInt3086 <= arg3 && arg3 <= MergedStatics.sub5_anInt4230) {
            arg0 = IntUtils.clamp(arg0, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
            arg1 = IntUtils.clamp(arg1, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
            MergedStatics.sub20_method1975(arg0, arg1, arg2, arg3);
          }
        }
        static sub36_method4566(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
          if (arg0 >= MergedStatics.sub2_anInt902 && arg5 <= MergedStatics.sub3_anInt2553 && MergedStatics.sub4_anInt3086 <= arg6 && arg4 <= MergedStatics.sub5_anInt4230) {
            MergedStatics.sub9_method758(arg1, arg5, arg6, arg0, arg4, arg2, arg3);
          } else {
            MergedStatics.sub22_method2190(arg4, arg3, arg2, arg1, arg0, arg5, arg6);
          }
        }
        static sub9_method758(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
          const local6 = arg2 + arg6;
          const local14 = arg4 - arg6;
          const local18 = arg3 + arg6;
          const local23 = arg1 - arg6;
          for (let local25 = arg2; local25 < local6; local25++) {
            {
              ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local25], arg3, arg1, arg0);
            }
            ;
          }
          for (let local55 = arg4; local55 > local14; local55--) {
            {
              ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local55], arg3, arg1, arg0);
            }
            ;
          }
          for (let local75 = local6; local75 <= local14; local75++) {
            {
              const local86 = MergedStatics.sub5_anIntArrayArray36[local75];
              ArrayUtils.fillRange(local86, arg3, local18, arg0);
              ArrayUtils.fillRange(local86, local18, local23, arg5);
              ArrayUtils.fillRange(local86, local23, arg1, arg0);
            }
            ;
          }
        }
        static sub22_method2190(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
          const local11 = IntUtils.clamp(arg6, MergedStatics.sub4_anInt3086, MergedStatics.sub5_anInt4230);
          const local22 = IntUtils.clamp(arg0, MergedStatics.sub4_anInt3086, MergedStatics.sub5_anInt4230);
          const local28 = IntUtils.clamp(arg4, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
          const local34 = IntUtils.clamp(arg5, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
          const local43 = IntUtils.clamp(arg6 + arg1, MergedStatics.sub4_anInt3086, MergedStatics.sub5_anInt4230);
          const local52 = IntUtils.clamp(arg0 - arg1, MergedStatics.sub4_anInt3086, MergedStatics.sub5_anInt4230);
          for (let local54 = local11; local54 < local43; local54++) {
            {
              ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local54], local28, local34, arg3);
            }
            ;
          }
          for (let local74 = local22; local74 > local52; local74--) {
            {
              ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local74], local28, local34, arg3);
            }
            ;
          }
          const local97 = IntUtils.clamp(arg4 + arg1, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
          const local106 = IntUtils.clamp(arg5 - arg1, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
          for (let local108 = local43; local108 <= local52; local108++) {
            {
              const local119 = MergedStatics.sub5_anIntArrayArray36[local108];
              ArrayUtils.fillRange(local119, local28, local97, arg3);
              ArrayUtils.fillRange(local119, local97, local106, arg2);
              ArrayUtils.fillRange(local119, local106, local34, arg3);
            }
            ;
          }
        }
        static sub32_method3997(arg0, arg1, arg2, arg3, arg4, arg5) {
          if (arg0 >= MergedStatics.sub2_anInt902 && MergedStatics.sub3_anInt2553 >= arg5 && arg2 >= MergedStatics.sub4_anInt3086 && MergedStatics.sub5_anInt4230 >= arg4) {
            if (arg3 === 1) {
              MergedStatics.sub27_method4706(arg1, arg0, arg5, arg2, arg4);
            } else {
              MergedStatics.sub14_method1200(arg1, arg0, arg4, arg5, arg3, arg2);
            }
          } else if (arg3 === 1) {
            MergedStatics.sub27_method4241(arg5, arg4, arg2, arg1, arg0);
          } else {
            MergedStatics.sub31_method3781(arg5, arg1, arg3, arg0, arg2, arg4);
          }
        }
        static sub31_method3781(arg0, arg1, arg2, arg3, arg4, arg5) {
          const local17 = IntUtils.clamp(arg4, MergedStatics.sub4_anInt3086, MergedStatics.sub5_anInt4230);
          const local23 = IntUtils.clamp(arg5, MergedStatics.sub4_anInt3086, MergedStatics.sub5_anInt4230);
          const local29 = IntUtils.clamp(arg3, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
          const local35 = IntUtils.clamp(arg0, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
          const local43 = IntUtils.clamp(arg2 + arg4, MergedStatics.sub4_anInt3086, MergedStatics.sub5_anInt4230);
          const local52 = IntUtils.clamp(arg5 - arg2, MergedStatics.sub4_anInt3086, MergedStatics.sub5_anInt4230);
          for (let local54 = local17; local54 < local43; local54++) {
            {
              ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local54], local29, local35, arg1);
            }
            ;
          }
          for (let local70 = local23; local70 > local52; local70--) {
            {
              ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local70], local29, local35, arg1);
            }
            ;
          }
          const local97 = IntUtils.clamp(arg3 + arg2, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
          const local106 = IntUtils.clamp(arg0 - arg2, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
          for (let local108 = local43; local108 <= local52; local108++) {
            {
              const local119 = MergedStatics.sub5_anIntArrayArray36[local108];
              ArrayUtils.fillRange(local119, local29, local97, arg1);
              ArrayUtils.fillRange(local119, local106, local35, arg1);
            }
            ;
          }
        }
        static sub27_method4241(arg0, arg1, arg2, arg3, arg4) {
          if (MergedStatics.sub5_anInt4230 < arg2 || MergedStatics.sub4_anInt3086 > arg1) {
            return;
          }
          let local23;
          if (MergedStatics.sub2_anInt902 > arg4) {
            arg4 = MergedStatics.sub2_anInt902;
            local23 = false;
          } else if (arg4 > MergedStatics.sub3_anInt2553) {
            arg4 = MergedStatics.sub3_anInt2553;
            local23 = false;
          } else {
            local23 = true;
          }
          let local51;
          if (arg0 < MergedStatics.sub2_anInt902) {
            arg0 = MergedStatics.sub2_anInt902;
            local51 = false;
          } else if (MergedStatics.sub3_anInt2553 < arg0) {
            arg0 = MergedStatics.sub3_anInt2553;
            local51 = false;
          } else {
            local51 = true;
          }
          let local71;
          if (MergedStatics.sub4_anInt3086 <= arg2) {
            local71 = arg2 + 1;
            ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[arg2], arg4, arg0, arg3);
          } else {
            local71 = MergedStatics.sub4_anInt3086;
          }
          let local89;
          if (MergedStatics.sub5_anInt4230 < arg1) {
            local89 = MergedStatics.sub5_anInt4230;
          } else {
            local89 = arg1 - 1;
            ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[arg1], arg4, arg0, arg3);
          }
          if (local23 && local51) {
            for (let local106 = local71; local106 <= local89; local106++) {
              {
                const local113 = MergedStatics.sub5_anIntArrayArray36[local106];
                local113[arg4] = local113[arg0] = arg3;
              }
              ;
            }
          } else if (local23) {
            for (let local149 = local71; local149 <= local89; local149++) {
              {
                MergedStatics.sub5_anIntArrayArray36[local149][arg4] = arg3;
              }
              ;
            }
          } else if (local51) {
            for (let local133 = local71; local133 <= local89; local133++) {
              {
                MergedStatics.sub5_anIntArrayArray36[local133][arg0] = arg3;
              }
              ;
            }
          }
        }
        static sub27_method4706(arg0, arg1, arg2, arg3, arg4) {
          ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[arg3++], arg1, arg2, arg0);
          ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[arg4--], arg1, arg2, arg0);
          for (let local31 = arg3; local31 <= arg4; local31++) {
            {
              const local42 = MergedStatics.sub5_anIntArrayArray36[local31];
              local42[arg1] = local42[arg2] = arg0;
            }
            ;
          }
        }
        static sub14_method1200(arg0, arg1, arg2, arg3, arg4, arg5) {
          const local10 = arg4 + arg5;
          const local18 = arg2 - arg4;
          const local22 = arg4 + arg1;
          for (let local24 = arg5; local24 < local10; local24++) {
            {
              ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local24], arg1, arg3, arg0);
            }
            ;
          }
          for (let local44 = arg2; local44 > local18; local44--) {
            {
              ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local44], arg1, arg3, arg0);
            }
            ;
          }
          const local66 = arg3 - arg4;
          for (let local68 = local10; local68 <= local18; local68++) {
            {
              const local79 = MergedStatics.sub5_anIntArrayArray36[local68];
              ArrayUtils.fillRange(local79, arg1, local22, arg0);
              ArrayUtils.fillRange(local79, local66, arg3, arg0);
            }
            ;
          }
        }
        static sub29_method3429(arg0, arg1, arg2, arg3, arg4) {
          if (MergedStatics.sub2_anInt902 <= arg0 && arg2 <= MergedStatics.sub3_anInt2553 && MergedStatics.sub4_anInt3086 <= arg3 && arg1 <= MergedStatics.sub5_anInt4230) {
            MergedStatics.sub15_method1477(arg3, arg0, arg1, arg4, arg2);
          } else {
            MergedStatics.sub22_method4701(arg0, arg2, arg3, arg4, arg1);
          }
        }
        static sub15_method1477(arg0, arg1, arg2, arg3, arg4) {
          for (let local6 = arg0; local6 <= arg2; local6++) {
            {
              ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local6], arg1, arg4, arg3);
            }
            ;
          }
        }
        static sub22_method4701(arg0, arg1, arg2, arg3, arg4) {
          const local11 = IntUtils.clamp(arg2, MergedStatics.sub4_anInt3086, MergedStatics.sub5_anInt4230);
          const local17 = IntUtils.clamp(arg4, MergedStatics.sub4_anInt3086, MergedStatics.sub5_anInt4230);
          const local23 = IntUtils.clamp(arg0, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
          const local29 = IntUtils.clamp(arg1, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
          for (let local31 = local11; local31 <= local17; local31++) {
            {
              ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local31], local23, local29, arg3);
            }
            ;
          }
        }
        static sub18_method1745(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
          if (arg0 === arg6) {
            MergedStatics.sub8_method100(arg0, arg3, arg5, arg1, arg2, arg4);
          } else if (arg2 - arg0 >= MergedStatics.sub2_anInt902 && MergedStatics.sub3_anInt2553 >= arg0 + arg2 && arg5 - arg6 >= MergedStatics.sub4_anInt3086 && arg6 + arg5 <= MergedStatics.sub5_anInt4230) {
            MergedStatics.sub10_method388(arg2, arg4, arg3, arg5, arg0, arg1, arg6);
          } else {
            MergedStatics.sub32_method4031(arg1, arg3, arg2, arg6, arg5, arg0, arg4);
          }
        }
        static sub32_method4031(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
          let local3 = 0;
          const local7 = arg3 - arg6;
          let local9 = arg3;
          let local11 = 0;
          const local16 = arg5 - arg6;
          const local20 = arg5 * arg5;
          const local28 = arg3 * arg3;
          const local32 = local16 * local16;
          const local36 = local28 << 1;
          const local40 = local7 * local7;
          const local44 = local20 << 1;
          const local48 = local40 << 1;
          const local52 = local32 << 1;
          const local56 = arg3 << 1;
          const local60 = local7 << 1;
          let local69 = local36 + (1 - local56) * local20;
          let local78 = local28 - (local56 - 1) * local44;
          let local87 = local32 * (1 - local60) + local48;
          const local91 = local20 << 2;
          let local104 = local40 - local52 * (local60 - 1);
          const local108 = local28 << 2;
          const local112 = local32 << 2;
          const local116 = local40 << 2;
          let local120 = local36 * 3;
          let local124 = local48 * 3;
          let local130 = local44 * (local56 - 3);
          let local132 = local108;
          let local138 = (local60 - 3) * local52;
          let local144 = local91 * (arg3 - 1);
          let local146 = local116;
          let local152 = (local7 - 1) * local112;
          if (arg4 >= MergedStatics.sub4_anInt3086 && MergedStatics.sub5_anInt4230 >= arg4) {
            const local166 = MergedStatics.sub5_anIntArrayArray36[arg4];
            const local177 = IntUtils.clamp(arg2 - arg5, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
            const local185 = IntUtils.clamp(arg2 + arg5, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
            const local193 = IntUtils.clamp(arg2 - local16, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
            const local203 = IntUtils.clamp(arg2 + local16, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
            ArrayUtils.fillRange(local166, local177, local193, arg1);
            ArrayUtils.fillRange(local166, local193, local203, arg0);
            ArrayUtils.fillRange(local166, local203, local185, arg1);
          }
          while (local9 > 0) {
            {
              if (local69 < 0) {
                while (local69 < 0) {
                  {
                    local69 += local120;
                    local3++;
                    local120 += local108;
                    local78 += local132;
                    local132 += local108;
                  }
                }
                ;
              }
              if (local78 < 0) {
                local3++;
                local69 += local120;
                local120 += local108;
                local78 += local132;
                local132 += local108;
              }
              const local281 = local7 >= local9;
              local78 += -local130;
              local9--;
              if (local281) {
                if (local87 < 0) {
                  while (local87 < 0) {
                    {
                      local87 += local124;
                      local104 += local146;
                      local124 += local116;
                      local146 += local116;
                      local11++;
                    }
                  }
                  ;
                }
                if (local104 < 0) {
                  local87 += local124;
                  local124 += local116;
                  local104 += local146;
                  local146 += local116;
                  local11++;
                }
                local104 += -local138;
                local138 -= local112;
                local87 += -local152;
                local152 -= local112;
              }
              local69 += -local144;
              const local363 = local9 + arg4;
              const local367 = arg4 - local9;
              local144 -= local91;
              local130 -= local91;
              if (local363 >= MergedStatics.sub4_anInt3086 && MergedStatics.sub5_anInt4230 >= local367) {
                const local389 = IntUtils.clamp(local3 + arg2, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
                const local398 = IntUtils.clamp(arg2 - local3, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
                if (local281) {
                  const local409 = IntUtils.clamp(arg2 + local11, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
                  const local418 = IntUtils.clamp(arg2 - local11, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
                  if (MergedStatics.sub4_anInt3086 <= local367) {
                    const local426 = MergedStatics.sub5_anIntArrayArray36[local367];
                    ArrayUtils.fillRange(local426, local398, local418, arg1);
                    ArrayUtils.fillRange(local426, local418, local409, arg0);
                    ArrayUtils.fillRange(local426, local409, local389, arg1);
                  }
                  if (MergedStatics.sub5_anInt4230 >= local363) {
                    const local456 = MergedStatics.sub5_anIntArrayArray36[local363];
                    ArrayUtils.fillRange(local456, local398, local418, arg1);
                    ArrayUtils.fillRange(local456, local418, local409, arg0);
                    ArrayUtils.fillRange(local456, local409, local389, arg1);
                  }
                } else {
                  if (local367 >= MergedStatics.sub4_anInt3086) {
                    ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local367], local398, local389, arg1);
                  }
                  if (MergedStatics.sub5_anInt4230 >= local363) {
                    ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local363], local398, local389, arg1);
                  }
                }
              }
            }
          }
          ;
        }
        static sub10_method388(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
          let local7 = 0;
          let local9 = arg6;
          const local14 = arg4 - arg1;
          let local16 = 0;
          const local21 = arg6 - arg1;
          const local25 = arg4 * arg4;
          const local29 = arg6 * arg6;
          const local33 = local14 * local14;
          const local37 = local21 * local21;
          const local41 = local29 << 1;
          const local45 = local37 << 1;
          const local49 = local25 << 1;
          const local53 = local33 << 1;
          const local57 = arg6 << 1;
          const local61 = local21 << 1;
          let local71 = local25 * (1 - local57) + local41;
          let local80 = local29 - local49 * (local57 - 1);
          let local89 = local45 + (1 - local61) * local33;
          let local98 = local37 - local53 * (local61 - 1);
          const local102 = local25 << 2;
          const local106 = local29 << 2;
          const local110 = local37 << 2;
          const local114 = local33 << 2;
          let local118 = local41 * 3;
          let local124 = local49 * (local57 - 3);
          let local128 = local45 * 3;
          let local130 = local106;
          let local136 = (local61 - 3) * local53;
          let local138 = local110;
          let local144 = (arg6 - 1) * local102;
          let local150 = local114 * (local21 - 1);
          const local154 = MergedStatics.sub5_anIntArrayArray36[arg3];
          ArrayUtils.fillRange(local154, arg0 - arg4, arg0 - local14, arg2);
          ArrayUtils.fillRange(local154, arg0 - local14, local14 + arg0, arg5);
          ArrayUtils.fillRange(local154, local14 + arg0, arg0 + arg4, arg2);
          while (local9 > 0) {
            {
              if (local71 < 0) {
                while (local71 < 0) {
                  {
                    local71 += local118;
                    local118 += local106;
                    local7++;
                    local80 += local130;
                    local130 += local106;
                  }
                }
                ;
              }
              if (local80 < 0) {
                local71 += local118;
                local80 += local130;
                local118 += local106;
                local7++;
                local130 += local106;
              }
              local71 += -local144;
              const local251 = arg0 - local7;
              const local258 = local21 >= local9;
              const local263 = arg0 + local7;
              local144 -= local102;
              local9--;
              local80 += -local124;
              const local277 = local9 + arg3;
              local124 -= local102;
              if (local258) {
                if (local89 < 0) {
                  while (local89 < 0) {
                    {
                      local16++;
                      local98 += local138;
                      local89 += local128;
                      local138 += local110;
                      local128 += local110;
                    }
                  }
                  ;
                }
                if (local98 < 0) {
                  local89 += local128;
                  local128 += local110;
                  local16++;
                  local98 += local138;
                  local138 += local110;
                }
                local98 += -local136;
                local89 += -local150;
                local150 -= local114;
                local136 -= local114;
              }
              const local352 = arg3 - local9;
              if (local258) {
                const local358 = arg0 - local16;
                ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local352], local251, local358, arg2);
                const local371 = arg0 + local16;
                ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local352], local358, local371, arg5);
                ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local352], local371, local263, arg2);
                ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local277], local251, local358, arg2);
                ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local277], local358, local371, arg5);
                ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local277], local371, local263, arg2);
              } else {
                ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local352], local251, local263, arg2);
                ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local277], local251, local263, arg2);
              }
            }
          }
          ;
        }
        static sub8_method100(arg0, arg1, arg2, arg3, arg4, arg5) {
          if (MergedStatics.sub2_anInt902 <= arg4 - arg0 && arg0 + arg4 <= MergedStatics.sub3_anInt2553 && arg2 - arg0 >= MergedStatics.sub4_anInt3086 && MergedStatics.sub5_anInt4230 >= arg0 + arg2) {
            MergedStatics.sub10_method896(arg5, arg1, arg0, arg3, arg4, arg2);
          } else {
            MergedStatics.sub14_method1082(arg0, arg5, arg4, arg1, arg3, arg2);
          }
        }
        static sub32_method3885(arg0) {
          if (MergedStatics.sub7_anIntArray678 == null || MergedStatics.sub7_anIntArray678.length < arg0) {
            MergedStatics.sub7_anIntArray678 = ((s) => {
              let a = [];
              while (s-- > 0)
                a.push(0);
              return a;
            })(arg0);
          }
        }
        static sub14_method1082(arg0, arg1, arg2, arg3, arg4, arg5) {
          MergedStatics.sub32_method3885(arg0);
          let local9 = arg0 - arg1;
          let local15 = arg0;
          let local17 = 0;
          let local20 = -arg0;
          if (local9 < 0) {
            local9 = 0;
          }
          let local29 = local9;
          if (MergedStatics.sub4_anInt3086 <= arg5 && arg5 <= MergedStatics.sub5_anInt4230) {
            const local40 = MergedStatics.sub5_anIntArrayArray36[arg5];
            const local48 = IntUtils.clamp(arg2 - arg0, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
            const local56 = IntUtils.clamp(arg0 + arg2, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
            const local67 = IntUtils.clamp(arg2 - local9, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
            const local77 = IntUtils.clamp(arg2 + local9, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
            ArrayUtils.fillRange(local40, local48, local67, arg3);
            ArrayUtils.fillRange(local40, local67, local77, arg4);
            ArrayUtils.fillRange(local40, local77, local56, arg3);
          }
          let local98 = -local9;
          let local100 = -1;
          let local102 = -1;
          while (local17 < local15) {
            {
              local100 += 2;
              local98 += local100;
              local102 += 2;
              if (local98 >= 0 && local29 >= 1) {
                local29--;
                local98 -= local29 << 1;
                MergedStatics.sub7_anIntArray678[local29] = local17;
              }
              local17++;
              local20 += local102;
              if (local20 >= 0) {
                local15--;
                local20 -= local15 << 1;
                const local154 = arg5 - local15;
                const local159 = arg5 + local15;
                if (MergedStatics.sub4_anInt3086 <= local159 && local154 <= MergedStatics.sub5_anInt4230) {
                  if (local15 >= local9) {
                    const local186 = IntUtils.clamp(arg2 + local17, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
                    const local194 = IntUtils.clamp(arg2 - local17, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
                    if (MergedStatics.sub5_anInt4230 >= local159) {
                      ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local159], local194, local186, arg3);
                    }
                    if (local154 >= MergedStatics.sub4_anInt3086) {
                      ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local154], local194, local186, arg3);
                    }
                  } else {
                    const local226 = MergedStatics.sub7_anIntArray678[local15];
                    const local237 = IntUtils.clamp(arg2 + local17, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
                    const local245 = IntUtils.clamp(arg2 - local17, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
                    const local254 = IntUtils.clamp(arg2 + local226, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
                    const local262 = IntUtils.clamp(arg2 - local226, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
                    if (MergedStatics.sub5_anInt4230 >= local159) {
                      const local274 = MergedStatics.sub5_anIntArrayArray36[local159];
                      ArrayUtils.fillRange(local274, local245, local262, arg3);
                      ArrayUtils.fillRange(local274, local262, local254, arg4);
                      ArrayUtils.fillRange(local274, local254, local237, arg3);
                    }
                    if (MergedStatics.sub4_anInt3086 <= local154) {
                      const local300 = MergedStatics.sub5_anIntArrayArray36[local154];
                      ArrayUtils.fillRange(local300, local245, local262, arg3);
                      ArrayUtils.fillRange(local300, local262, local254, arg4);
                      ArrayUtils.fillRange(local300, local254, local237, arg3);
                    }
                  }
                }
              }
              const local322 = arg5 + local17;
              const local327 = arg5 - local17;
              if (MergedStatics.sub4_anInt3086 <= local322 && MergedStatics.sub5_anInt4230 >= local327) {
                const local337 = local15 + arg2;
                const local342 = arg2 - local15;
                if (local337 >= MergedStatics.sub2_anInt902 && MergedStatics.sub3_anInt2553 >= local342) {
                  const local359 = IntUtils.clamp(local337, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
                  const local365 = IntUtils.clamp(local342, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
                  if (local17 >= local9) {
                    if (MergedStatics.sub5_anInt4230 >= local322) {
                      ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local322], local365, local359, arg3);
                    }
                    if (MergedStatics.sub4_anInt3086 <= local327) {
                      ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local327], local365, local359, arg3);
                    }
                  } else {
                    const local415 = local29 >= local17 ? local29 : MergedStatics.sub7_anIntArray678[local17];
                    const local424 = IntUtils.clamp(arg2 + local415, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
                    const local432 = IntUtils.clamp(arg2 - local415, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
                    if (MergedStatics.sub5_anInt4230 >= local322) {
                      const local440 = MergedStatics.sub5_anIntArrayArray36[local322];
                      ArrayUtils.fillRange(local440, local365, local432, arg3);
                      ArrayUtils.fillRange(local440, local432, local424, arg4);
                      ArrayUtils.fillRange(local440, local424, local359, arg3);
                    }
                    if (MergedStatics.sub4_anInt3086 <= local327) {
                      const local469 = MergedStatics.sub5_anIntArrayArray36[local327];
                      ArrayUtils.fillRange(local469, local365, local432, arg3);
                      ArrayUtils.fillRange(local469, local432, local424, arg4);
                      ArrayUtils.fillRange(local469, local424, local359, arg3);
                    }
                  }
                }
              }
            }
          }
          ;
        }
        static sub10_method896(arg0, arg1, arg2, arg3, arg4, arg5) {
          MergedStatics.sub32_method3885(arg2);
          let local10 = 0;
          let local13 = -arg2;
          let local17 = arg2 - arg0;
          let local19 = arg2;
          let local21 = -1;
          let local23 = -1;
          const local27 = MergedStatics.sub5_anIntArrayArray36[arg5];
          if (local17 < 0) {
            local17 = 0;
          }
          let local34 = local17;
          const local39 = arg4 - local17;
          ArrayUtils.fillRange(local27, arg4 - arg2, local39, arg1);
          const local57 = local17 + arg4;
          let local60 = -local17;
          ArrayUtils.fillRange(local27, local39, local57, arg3);
          ArrayUtils.fillRange(local27, local57, arg4 + arg2, arg1);
          while (local19 > local10) {
            {
              local23 += 2;
              local13 += local23;
              local21 += 2;
              local60 += local21;
              if (local60 >= 0 && local34 >= 1) {
                MergedStatics.sub7_anIntArray678[local34] = local10;
                local34--;
                local60 -= local34 << 1;
              }
              local10++;
              if (local13 >= 0) {
                local19--;
                if (local19 >= local17) {
                  const local126 = MergedStatics.sub5_anIntArrayArray36[arg5 + local19];
                  const local131 = arg4 + local10;
                  const local138 = MergedStatics.sub5_anIntArrayArray36[arg5 - local19];
                  const local143 = arg4 - local10;
                  ArrayUtils.fillRange(local126, local143, local131, arg1);
                  ArrayUtils.fillRange(local138, local143, local131, arg1);
                } else {
                  const local163 = MergedStatics.sub5_anIntArrayArray36[local19 + arg5];
                  const local167 = MergedStatics.sub7_anIntArray678[local19];
                  const local174 = MergedStatics.sub5_anIntArrayArray36[arg5 - local19];
                  const local178 = local10 + arg4;
                  const local182 = arg4 - local167;
                  const local186 = local167 + arg4;
                  const local191 = arg4 - local10;
                  ArrayUtils.fillRange(local163, local191, local182, arg1);
                  ArrayUtils.fillRange(local163, local182, local186, arg3);
                  ArrayUtils.fillRange(local163, local186, local178, arg1);
                  ArrayUtils.fillRange(local174, local191, local182, arg1);
                  ArrayUtils.fillRange(local174, local182, local186, arg3);
                  ArrayUtils.fillRange(local174, local186, local178, arg1);
                }
                local13 -= local19 << 1;
              }
              const local240 = MergedStatics.sub5_anIntArrayArray36[arg5 + local10];
              const local247 = MergedStatics.sub5_anIntArrayArray36[arg5 - local10];
              const local251 = local19 + arg4;
              const local256 = arg4 - local19;
              if (local17 <= local10) {
                ArrayUtils.fillRange(local240, local256, local251, arg1);
                ArrayUtils.fillRange(local247, local256, local251, arg1);
              } else {
                const local286 = local10 > local34 ? MergedStatics.sub7_anIntArray678[local10] : local34;
                const local290 = local286 + arg4;
                const local294 = arg4 - local286;
                ArrayUtils.fillRange(local240, local256, local294, arg1);
                ArrayUtils.fillRange(local240, local294, local290, arg3);
                ArrayUtils.fillRange(local240, local290, local251, arg1);
                ArrayUtils.fillRange(local247, local256, local294, arg1);
                ArrayUtils.fillRange(local247, local294, local290, arg3);
                ArrayUtils.fillRange(local247, local290, local251, arg1);
              }
            }
          }
          ;
        }
        static sub28_method3323(arg0, arg1, arg2, arg3, arg4) {
          if (arg0 === arg4) {
            MergedStatics.sub32_method4032(arg4, arg2, arg3, arg1);
          } else if (MergedStatics.sub2_anInt902 <= arg1 - arg4 && MergedStatics.sub3_anInt2553 >= arg1 + arg4 && arg3 - arg0 >= MergedStatics.sub4_anInt3086 && MergedStatics.sub5_anInt4230 >= arg3 + arg0) {
            MergedStatics.sub19_method4379(arg0, arg1, arg2, arg3, arg4);
          } else {
            MergedStatics.sub26_method4814(arg3, arg0, arg2, arg4, arg1);
          }
        }
        static sub32_method4032(arg0, arg1, arg2, arg3) {
          if (arg3 - arg0 >= MergedStatics.sub2_anInt902 && MergedStatics.sub3_anInt2553 >= arg3 + arg0 && arg2 - arg0 >= MergedStatics.sub4_anInt3086 && arg2 + arg0 <= MergedStatics.sub5_anInt4230) {
            MergedStatics.sub11_method565(arg2, arg3, arg0, arg1);
          } else {
            MergedStatics.sub29_method3463(arg2, arg3, arg0, arg1);
          }
        }
        static sub29_method3463(arg0, arg1, arg2, arg3) {
          let local3 = 0;
          let local14 = arg2;
          let local16 = -1;
          let local19 = -arg2;
          const local27 = IntUtils.clamp(arg2 + arg1, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
          const local35 = IntUtils.clamp(arg1 - arg2, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
          ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[arg0], local35, local27, arg3);
          while (local14 > local3) {
            {
              local16 += 2;
              local19 += local16;
              if (local19 > 0) {
                local14--;
                local19 -= local14 << 1;
                const local72 = arg0 - local14;
                const local76 = local14 + arg0;
                if (local76 >= MergedStatics.sub4_anInt3086 && local72 <= MergedStatics.sub5_anInt4230) {
                  const local98 = IntUtils.clamp(arg1 + local3, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
                  const local106 = IntUtils.clamp(arg1 - local3, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
                  if (MergedStatics.sub5_anInt4230 >= local76) {
                    ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local76], local106, local98, arg3);
                  }
                  if (MergedStatics.sub4_anInt3086 <= local72) {
                    ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local72], local106, local98, arg3);
                  }
                }
              }
              local3++;
              const local138 = arg0 - local3;
              const local142 = arg0 + local3;
              if (MergedStatics.sub4_anInt3086 <= local142 && local138 <= MergedStatics.sub5_anInt4230) {
                const local166 = IntUtils.clamp(arg1 + local14, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
                const local174 = IntUtils.clamp(arg1 - local14, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
                if (local142 <= MergedStatics.sub5_anInt4230) {
                  ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local142], local174, local166, arg3);
                }
                if (MergedStatics.sub4_anInt3086 <= local138) {
                  ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local138], local174, local166, arg3);
                }
              }
            }
          }
          ;
        }
        static sub11_method565(arg0, arg1, arg2, arg3) {
          ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[arg0], arg1 - arg2, arg2 + arg1, arg3);
          let local20 = 0;
          let local33 = arg2;
          let local36 = -arg2;
          let local38 = -1;
          while (local33 > local20) {
            {
              local38 += 2;
              local20++;
              local36 += local38;
              if (local36 >= 0) {
                local33--;
                local36 -= local33 << 1;
                const local69 = MergedStatics.sub5_anIntArrayArray36[arg0 - local33];
                const local76 = MergedStatics.sub5_anIntArrayArray36[arg0 + local33];
                const local80 = arg1 - local20;
                const local84 = arg1 + local20;
                ArrayUtils.fillRange(local76, local80, local84, arg3);
                ArrayUtils.fillRange(local69, local80, local84, arg3);
              }
              const local101 = arg1 + local33;
              const local106 = arg1 - local33;
              const local112 = MergedStatics.sub5_anIntArrayArray36[arg0 + local20];
              const local118 = MergedStatics.sub5_anIntArrayArray36[arg0 - local20];
              ArrayUtils.fillRange(local112, local106, local101, arg3);
              ArrayUtils.fillRange(local118, local106, local101, arg3);
            }
          }
          ;
        }
        static sub19_method4379(arg0, arg1, arg2, arg3, arg4) {
          ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[arg3], arg1 - arg4, arg4 + arg1, arg2);
          let local20 = 0;
          let local22 = arg0;
          const local26 = arg4 * arg4;
          const local34 = arg0 * arg0;
          const local38 = local26 << 1;
          const local42 = arg0 << 1;
          const local46 = local34 << 1;
          let local54 = local34 - local38 * (local42 - 1);
          let local63 = local46 + (1 - local42) * local26;
          const local67 = local26 << 2;
          let local75 = local46 * 3;
          let local83 = local38 * ((arg0 << 1) - 3);
          const local87 = local34 << 2;
          let local93 = local87;
          let local99 = (arg0 - 1) * local67;
          while (local22 > 0) {
            {
              if (local63 < 0) {
                while (local63 < 0) {
                  {
                    local20++;
                    local63 += local75;
                    local54 += local93;
                    local93 += local87;
                    local75 += local87;
                  }
                }
                ;
              }
              local22--;
              if (local54 < 0) {
                local54 += local93;
                local63 += local75;
                local75 += local87;
                local93 += local87;
                local20++;
              }
              const local150 = arg3 - local22;
              local63 += -local99;
              const local159 = arg1 + local20;
              local99 -= local67;
              const local167 = local22 + arg3;
              local54 += -local83;
              local83 -= local67;
              const local181 = arg1 - local20;
              ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local150], local181, local159, arg2);
              ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local167], local181, local159, arg2);
            }
          }
          ;
        }
        static sub26_method4814(arg0, arg1, arg2, arg3, arg4) {
          let local7 = arg1;
          let local9 = 0;
          const local21 = arg1 * arg1;
          const local25 = arg3 * arg3;
          const local29 = local25 << 1;
          const local33 = local21 << 1;
          const local37 = arg1 << 1;
          let local46 = local21 - (local37 - 1) * local29;
          let local56 = (1 - local37) * local25 + local33;
          const local60 = local25 << 2;
          const local64 = local21 << 2;
          let local72 = local33 * 3;
          let local78 = local64;
          let local86 = ((arg1 << 1) - 3) * local29;
          if (arg0 >= MergedStatics.sub4_anInt3086 && MergedStatics.sub5_anInt4230 >= arg0) {
            const local109 = IntUtils.clamp(arg4 + arg3, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
            const local117 = IntUtils.clamp(arg4 - arg3, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
            ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[arg0], local117, local109, arg2);
          }
          let local131 = local60 * (arg1 - 1);
          while (local7 > 0) {
            {
              if (local56 < 0) {
                while (local56 < 0) {
                  {
                    local56 += local72;
                    local46 += local78;
                    local78 += local64;
                    local72 += local64;
                    local9++;
                  }
                }
                ;
              }
              local7--;
              if (local46 < 0) {
                local46 += local78;
                local78 += local64;
                local56 += local72;
                local9++;
                local72 += local64;
              }
              local56 += -local131;
              const local198 = arg0 - local7;
              local46 += -local86;
              local131 -= local60;
              const local211 = local7 + arg0;
              local86 -= local60;
              if (local211 >= MergedStatics.sub4_anInt3086 && MergedStatics.sub5_anInt4230 >= local198) {
                const local229 = IntUtils.clamp(local9 + arg4, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
                const local237 = IntUtils.clamp(arg4 - local9, MergedStatics.sub2_anInt902, MergedStatics.sub3_anInt2553);
                if (MergedStatics.sub4_anInt3086 <= local198) {
                  ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local198], local237, local229, arg2);
                }
                if (local211 <= MergedStatics.sub5_anInt4230) {
                  ArrayUtils.fillRange(MergedStatics.sub5_anIntArrayArray36[local211], local237, local229, arg2);
                }
              }
            }
          }
          ;
        }
        static sub18_method4374(arg0, arg1) {
          MergedStatics.sub5_anInt4230 = arg0;
          MergedStatics.sub3_anInt2553 = arg1;
          MergedStatics.sub4_anInt3086 = 0;
          MergedStatics.sub2_anInt902 = 0;
        }
        static sub35_method4335(arg0) {
          MergedStatics.sub5_anIntArrayArray36 = arg0;
        }
      }
      MergedStatics.sub5_anInt4230 = 100;
      MergedStatics.sub4_anInt3086 = 0;
      MergedStatics.sub7_anIntArray678 = null;
      MergedStatics.sub3_anInt2553 = 100;
      MergedStatics.sub2_anInt902 = 0;
      MergedStatics.sub5_anIntArrayArray36 = null;
      MergedStatics["__class"] = "MergedStatics";
      class Node {
        constructor() {
          if (this.prev === void 0) {
            this.prev = null;
          }
          if (this.next === void 0) {
            this.next = null;
          }
          if (this.key === void 0) {
            this.key = 0;
          }
        }
        isLinked() {
          return this.prev != null;
        }
        unlink() {
          if (this.prev != null) {
            this.prev.next = this.next;
            this.next.prev = this.prev;
            this.prev = null;
            this.next = null;
          }
        }
      }
      Node["__class"] = "Node";
      class Random {
        constructor(seed) {
          if (typeof seed === "number" || seed === null) {
            let __args = arguments;
            if (this.nextNextGaussian === void 0) {
              this.nextNextGaussian = 0;
            }
            if (this.seedhi === void 0) {
              this.seedhi = 0;
            }
            if (this.seedlo === void 0) {
              this.seedlo = 0;
            }
            this.haveNextNextGaussian = false;
            this.setSeed$long(seed);
          } else if (seed === void 0) {
            let __args = arguments;
            if (this.nextNextGaussian === void 0) {
              this.nextNextGaussian = 0;
            }
            if (this.seedhi === void 0) {
              this.seedhi = 0;
            }
            if (this.seedlo === void 0) {
              this.seedlo = 0;
            }
            this.haveNextNextGaussian = false;
            const seed2 = Random.uniqueSeed++ + Date.now();
            const hi = (Math.floor(seed2 * Random.twoToTheMinus24) | 0) & 16777215;
            const lo = seed2 - hi * Random.twoToThe24 | 0;
            this.setSeed$int$int(hi, lo);
          } else
            throw new Error("invalid overload");
        }
        static __static_initialize() {
          if (!Random.__static_initialized) {
            Random.__static_initialized = true;
            Random.__static_initializer_0();
          }
        }
        static twoToTheXMinus24_$LI$() {
          Random.__static_initialize();
          if (Random.twoToTheXMinus24 == null) {
            Random.twoToTheXMinus24 = ((s) => {
              let a = [];
              while (s-- > 0)
                a.push(0);
              return a;
            })(25);
          }
          return Random.twoToTheXMinus24;
        }
        static twoToTheXMinus48_$LI$() {
          Random.__static_initialize();
          if (Random.twoToTheXMinus48 == null) {
            Random.twoToTheXMinus48 = ((s) => {
              let a = [];
              while (s-- > 0)
                a.push(0);
              return a;
            })(33);
          }
          return Random.twoToTheXMinus48;
        }
        static __static_initializer_0() {
          let twoToTheXMinus48Tmp = 152587890625e-16;
          for (let i = 32; i >= 0; i--) {
            {
              Random.twoToTheXMinus48_$LI$()[i] = twoToTheXMinus48Tmp;
              twoToTheXMinus48Tmp *= 0.5;
            }
            ;
          }
          let twoToTheXMinus24Tmp = 1;
          for (let i = 24; i >= 0; i--) {
            {
              Random.twoToTheXMinus24_$LI$()[i] = twoToTheXMinus24Tmp;
              twoToTheXMinus24Tmp *= 0.5;
            }
            ;
          }
        }
        /**
         * Returns the next pseudo-random, uniformly distributed {@code boolean} value
         * generated by this generator.
         *
         * @return {boolean} a pseudo-random, uniformly distributed boolean value.
         */
        nextBoolean() {
          return this.nextInternal(1) !== 0;
        }
        /**
         * Modifies the {@code byte} array by a random sequence of {@code byte}s
         * generated by this random number generator.
         *
         * @param {byte[]} buf non-null array to contain the new random {@code byte}s.
         * @see #next
         */
        nextBytes(buf) {
          let rand = 0;
          let count = 0;
          let loop = 0;
          while (count < buf.length) {
            {
              if (loop === 0) {
                rand = this.nextInternal(32) | 0;
                loop = 3;
              } else {
                loop--;
              }
              buf[count++] = rand | 0;
              rand >>= 8;
            }
          }
          ;
        }
        /**
         * Generates a normally distributed random {@code double} number between 0.0
         * inclusively and 1.0 exclusively.
         *
         * @return {number} a random {@code double} in the range [0.0 - 1.0)
         * @see #nextFloat
         */
        nextDouble() {
          return this.nextInternal(26) * Random.twoToTheMinus26 + this.nextInternal(27) * Random.twoToTheMinus53;
        }
        /**
         * Generates a normally distributed random {@code float} number between 0.0
         * inclusively and 1.0 exclusively.
         *
         * @return {number} float a random {@code float} number between [0.0 and 1.0)
         * @see #nextDouble
         */
        nextFloat() {
          return Math.fround(this.nextInternal(24) * Random.twoToTheMinus24);
        }
        /**
         * Pseudo-randomly generates (approximately) a normally distributed {@code
         * double} value with mean 0.0 and a standard deviation value of {@code 1.0}
         * using the <i>polar method<i> of G. E. P. Box, M. E. Muller, and G.
         * Marsaglia, as described by Donald E. Knuth in <i>The Art of Computer
         * Programming, Volume 2: Seminumerical Algorithms</i>, section 3.4.1,
         * subsection C, algorithm P.
         *
         * @return {number} a random {@code double}
         * @see #nextDouble
         */
        nextGaussian() {
          if (this.haveNextNextGaussian) {
            this.haveNextNextGaussian = false;
            return this.nextNextGaussian;
          }
          let v1;
          let v2;
          let s;
          do {
            {
              v1 = 2 * this.nextDouble() - 1;
              v2 = 2 * this.nextDouble() - 1;
              s = v1 * v1 + v2 * v2;
            }
          } while (s >= 1);
          const norm = s === 0 ? 0 : Math.sqrt(-2 * Math.log(s) / s);
          this.nextNextGaussian = v2 * norm;
          this.haveNextNextGaussian = true;
          return v1 * norm;
        }
        /**
         * Generates a uniformly distributed 32-bit {@code int} value from the random
         * number sequence.
         *
         * @return {number} a uniformly distributed {@code int} value.
         * @see java.lang.Integer#MAX_VALUE
         * @see java.lang.Integer#MIN_VALUE
         * @see #next
         * @see #nextLong
         */
        nextInt() {
          return this.nextInternal(32) | 0;
        }
        /**
         * Generates a uniformly distributed 64-bit integer value from the random
         * number sequence.
         *
         * @return {number} 64-bit random integer.
         * @see java.lang.Integer#MAX_VALUE
         * @see java.lang.Integer#MIN_VALUE
         * @see #next
         * @see #nextInt()
         * @see #nextInt(int)
         */
        nextLong() {
          return (((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(this.nextInternal(32)) << 32) + ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(this.nextInternal(32));
        }
        setSeed$long(seed) {
          this.setSeed$int$int(seed >> 24 & 16777215 | 0, seed & 16777215 | 0);
        }
        /**
         * Returns a pseudo-random uniformly distributed {@code int} value of the
         * number of bits specified by the argument {@code bits} as described by
         * Donald E. Knuth in <i>The Art of Computer Programming, Volume 2:
         * Seminumerical Algorithms</i>, section 3.2.1.
         *
         * @param {number} bits number of bits of the returned value.
         * @return {number} a pseudo-random generated int number.
         * @see #nextBytes
         * @see #nextDouble
         * @see #nextFloat
         * @see #nextInt()
         * @see #nextInt(int)
         * @see #nextGaussian
         * @see #nextLong
         */
        next(bits) {
          return this.nextInternal(bits) | 0;
        }
        /*private*/
        nextInternal(bits) {
          let hi = this.seedhi * Random.multiplierLo + this.seedlo * Random.multiplierHi;
          let lo = this.seedlo * Random.multiplierLo + 11;
          const carry = Math.floor(lo * Random.twoToTheMinus24);
          hi += carry;
          lo -= carry * Random.twoToThe24;
          hi %= Random.twoToThe24;
          this.seedhi = hi;
          this.seedlo = lo;
          if (bits <= 24) {
            return Math.floor(this.seedhi * Random.twoToTheXMinus24_$LI$()[bits]);
          } else {
            const h = this.seedhi * (1 << bits - 24);
            const l = Math.floor(this.seedlo * Random.twoToTheXMinus48_$LI$()[bits]);
            let dval = h + l;
            if (dval >= Random.twoToThe31) {
              dval -= Random.twoToThe32;
            }
            return dval;
          }
        }
        setSeed$int$int(seedhi, seedlo) {
          this.seedhi = seedhi ^ 1502;
          this.seedlo = seedlo ^ 15525485;
          this.haveNextNextGaussian = false;
        }
        setSeed(seedhi, seedlo) {
          if ((typeof seedhi === "number" || seedhi === null) && (typeof seedlo === "number" || seedlo === null)) {
            return this.setSeed$int$int(seedhi, seedlo);
          } else if ((typeof seedhi === "number" || seedhi === null) && seedlo === void 0) {
            return this.setSeed$long(seedhi);
          } else
            throw new Error("invalid overload");
        }
      }
      Random.__static_initialized = false;
      Random.multiplierHi = 1502;
      Random.multiplierLo = 15525485;
      Random.twoToThe24 = 16777216;
      Random.twoToThe31 = 2147483648;
      Random.twoToThe32 = 4294967296;
      Random.twoToTheMinus24 = 5960464477539063e-23;
      Random.twoToTheMinus26 = 14901161193847656e-24;
      Random.twoToTheMinus31 = 4656612873077393e-25;
      Random.twoToTheMinus53 = 11102230246251565e-32;
      Random.uniqueSeed = 0;
      Random["__class"] = "Random";
      class RandomUtils {
        static nextInt(random, bound) {
          if (bound <= 0) {
            throw Object.defineProperty(new Error(), "__classes", { configurable: true, value: ["java.lang.Throwable", "java.lang.Object", "java.lang.RuntimeException", "java.lang.IllegalArgumentException", "java.lang.Exception"] });
          } else if (IntUtils.isPowerOfTwo(bound)) {
            return random.nextInt() & bound - 1;
          } else {
            const local45 = -2147483648 - (4294967296 % ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(bound) | 0) | 0;
            let local48;
            do {
              {
                local48 = random.nextInt();
              }
            } while (local48 >= local45);
            return RandomUtils.method3538(local48, bound);
          }
        }
        /*private*/
        static method3538(arg0, bound) {
          const local7 = arg0 >> 31 & bound - 1;
          return local7 + (arg0 + (arg0 >>> 31)) % bound;
        }
      }
      RandomUtils["__class"] = "RandomUtils";
      class SecondaryLinkedList {
        constructor() {
          if (this.cursor === void 0) {
            this.cursor = null;
          }
          this.sentinel = new SecondaryNode();
          this.sentinel.secondaryPrev = this.sentinel;
          this.sentinel.secondaryNext = this.sentinel;
        }
        static insertAfter(node, position) {
          if (node.secondaryPrev != null) {
            node.unlinkSecondary();
          }
          node.secondaryNext = position.secondaryNext;
          node.secondaryPrev = position;
          node.secondaryPrev.secondaryNext = node;
          node.secondaryNext.secondaryPrev = node;
        }
        head() {
          const node = this.sentinel.secondaryNext;
          if (node === this.sentinel) {
            this.cursor = null;
            return null;
          } else {
            this.cursor = node.secondaryNext;
            return node;
          }
        }
        addTail(node) {
          if (node.secondaryPrev != null) {
            node.unlinkSecondary();
          }
          node.secondaryNext = this.sentinel;
          node.secondaryPrev = this.sentinel.secondaryPrev;
          node.secondaryPrev.secondaryNext = node;
          node.secondaryNext.secondaryPrev = node;
        }
        size() {
          let size = 0;
          let node = this.sentinel.secondaryNext;
          while (this.sentinel !== node) {
            {
              node = node.secondaryNext;
              size++;
            }
          }
          ;
          return size;
        }
        removeHead() {
          const node = this.sentinel.secondaryNext;
          if (this.sentinel === node) {
            return null;
          } else {
            node.unlinkSecondary();
            return node;
          }
        }
        clear() {
          while (true) {
            {
              const node = this.sentinel.secondaryNext;
              if (node === this.sentinel) {
                this.cursor = null;
                return;
              }
              node.unlinkSecondary();
            }
          }
          ;
        }
        next() {
          const node = this.cursor;
          if (this.sentinel === node) {
            this.cursor = null;
            return null;
          } else {
            this.cursor = node.secondaryNext;
            return node;
          }
        }
      }
      SecondaryLinkedList["__class"] = "SecondaryLinkedList";
      class TextureMathUtils {
        static __static_initialize() {
          if (!TextureMathUtils.__static_initialized) {
            TextureMathUtils.__static_initialized = true;
            TextureMathUtils.__static_initializer_0();
          }
        }
        static INVERSE_SQUARE_ROOT_$LI$() {
          TextureMathUtils.__static_initialize();
          if (TextureMathUtils.INVERSE_SQUARE_ROOT == null) {
            TextureMathUtils.INVERSE_SQUARE_ROOT = ((s) => {
              let a = [];
              while (s-- > 0)
                a.push(0);
              return a;
            })(32896);
          }
          return TextureMathUtils.INVERSE_SQUARE_ROOT;
        }
        static __static_initializer_0() {
          let i = 0;
          for (let x = 0; x < 256; x++) {
            {
              for (let y = 0; y <= x; y++) {
                {
                  TextureMathUtils.INVERSE_SQUARE_ROOT_$LI$()[i++] = 255 / Math.sqrt(Math.fround((x * x + y * y + 65535) / 65535)) | 0;
                }
                ;
              }
            }
            ;
          }
        }
      }
      TextureMathUtils.__static_initialized = false;
      TextureMathUtils["__class"] = "TextureMathUtils";
      class TextureOpRasterizerShape {
        constructor(fillColor, outlineColor, outlineWidth) {
          if (this.fillColor === void 0) {
            this.fillColor = 0;
          }
          if (this.outlineWidth === void 0) {
            this.outlineWidth = 0;
          }
          if (this.outlineColor === void 0) {
            this.outlineColor = 0;
          }
          this.fillColor = fillColor;
          this.outlineWidth = outlineWidth;
          this.outlineColor = outlineColor;
        }
      }
      TextureOpRasterizerShape["__class"] = "TextureOpRasterizerShape";
      class Buffer2 extends Node {
        constructor(bytes) {
          if (bytes != null && bytes instanceof Array && (bytes.length == 0 || bytes[0] == null || typeof bytes[0] === "number") || bytes === null) {
            let __args = arguments;
            super();
            if (this.bytes === void 0) {
              this.bytes = null;
            }
            if (this.position === void 0) {
              this.position = 0;
            }
            this.bytes = bytes;
            this.position = 0;
          } else if (typeof bytes === "number" || bytes === null) {
            let __args = arguments;
            let size = __args[0];
            super();
            if (this.bytes === void 0) {
              this.bytes = null;
            }
            if (this.position === void 0) {
              this.position = 0;
            }
            this.bytes = BufferPool.allocate(size);
            this.position = 0;
          } else
            throw new Error("invalid overload");
        }
        static crc32$byte_A$int$int(bytes, off, len) {
          throw Object.defineProperty(new Error("removed"), "__classes", { configurable: true, value: ["java.lang.Throwable", "java.lang.Object", "java.lang.RuntimeException", "java.lang.Exception"] });
        }
        static crc32(bytes, off, len) {
          if ((bytes != null && bytes instanceof Array && (bytes.length == 0 || bytes[0] == null || typeof bytes[0] === "number") || bytes === null) && (typeof off === "number" || off === null) && (typeof len === "number" || len === null)) {
            return Buffer2.crc32$byte_A$int$int(bytes, off, len);
          } else if ((bytes != null && bytes instanceof Array && (bytes.length == 0 || bytes[0] == null || typeof bytes[0] === "number") || bytes === null) && (typeof off === "number" || off === null) && len === void 0) {
            return Buffer2.crc32$byte_A$int(bytes, off);
          } else
            throw new Error("invalid overload");
        }
        static crc32$byte_A$int(bytes, len) {
          return Buffer2.crc32$byte_A$int$int(bytes, 0, len);
        }
        static getStringLength(value) {
          return value.length + 1;
        }
        writeString(value) {
          throw Object.defineProperty(new Error("removed"), "__classes", { configurable: true, value: ["java.lang.Throwable", "java.lang.Object", "java.lang.RuntimeException", "java.lang.Exception"] });
        }
        readShort() {
          this.position += 2;
          let value = ((this.bytes[this.position - 2] & 255) << 8) + (this.bytes[this.position - 1] & 255);
          if (value > 32767) {
            value -= 65536;
          }
          return value;
        }
        writeUnsignedShortSmart(value) {
          if (value >= 0 && value < 128) {
            this.writeByte(value);
          } else if (value >= 0 && value < 32768) {
            this.writeShort(value + 32768);
          } else {
            throw Object.defineProperty(new Error(), "__classes", { configurable: true, value: ["java.lang.Throwable", "java.lang.Object", "java.lang.RuntimeException", "java.lang.IllegalArgumentException", "java.lang.Exception"] });
          }
        }
        writeByteC(value) {
          this.bytes[this.position++] = -value | 0;
        }
        readUnsignedShortSmart() {
          const peek = this.bytes[this.position] & 255;
          return peek < 128 ? this.readUnsignedByte() : this.readUnsignedShort() - 32768;
        }
        writeVarInt(value) {
          if ((value & -128) !== 0) {
            if ((value & -16384) !== 0) {
              if ((value & -2097152) !== 0) {
                if ((value & -268435456) !== 0) {
                  this.writeByte(value >>> 28 | 128);
                }
                this.writeByte(value >>> 21 | 128);
              }
              this.writeByte(value >>> 14 | 128);
            }
            this.writeByte(value >>> 7 | 128);
          }
          this.writeByte(value & 127);
        }
        writeByte(value) {
          this.bytes[this.position++] = value | 0;
        }
        writeLong(value) {
          this.bytes[this.position++] = value >> 56 | 0;
          this.bytes[this.position++] = value >> 48 | 0;
          this.bytes[this.position++] = value >> 40 | 0;
          this.bytes[this.position++] = value >> 32 | 0;
          this.bytes[this.position++] = value >> 24 | 0;
          this.bytes[this.position++] = value >> 16 | 0;
          this.bytes[this.position++] = value >> 8 | 0;
          this.bytes[this.position++] = value | 0;
        }
        readIntAlt3Reverse() {
          this.position += 4;
          return ((this.bytes[this.position - 1] & 255) << 16) + ((this.bytes[this.position - 2] & 255) << 24) + ((this.bytes[this.position - 4] & 255) << 8) + (this.bytes[this.position - 3] & 255);
        }
        writeIntAlt3(value) {
          this.bytes[this.position++] = value >> 16 | 0;
          this.bytes[this.position++] = value >> 24 | 0;
          this.bytes[this.position++] = value | 0;
          this.bytes[this.position++] = value >> 8 | 0;
        }
        readShortLE() {
          this.position += 2;
          let value = ((this.bytes[this.position - 1] & 255) << 8) + (this.bytes[this.position - 2] & 255);
          if (value > 32767) {
            value -= 65536;
          }
          return value;
        }
        writeByteS(value) {
          this.bytes[this.position++] = 128 - value | 0;
        }
        readIntAlt3() {
          this.position += 4;
          return (this.bytes[this.position - 2] & 255) + ((this.bytes[this.position - 4] & 255) << 16) + ((this.bytes[this.position - 3] & 255) << 24) + ((this.bytes[this.position - 1] & 255) << 8);
        }
        readUnsignedShortLEA() {
          this.position += 2;
          return ((this.bytes[this.position - 1] & 255) << 8) + (this.bytes[this.position - 2] - 128 & 255);
        }
        readUnsignedByteC() {
          return -this.bytes[this.position++] & 255;
        }
        method4590() {
          this.position += 3;
          return ((this.bytes[this.position - 2] & 255) << 16) + ((this.bytes[this.position - 3] & 255) << 8) + (this.bytes[this.position - 1] & 255);
        }
        writeIntAlt3Reverse(value) {
          this.bytes[this.position++] = value >> 8 | 0;
          this.bytes[this.position++] = value | 0;
          this.bytes[this.position++] = value >> 24 | 0;
          this.bytes[this.position++] = value >> 16 | 0;
        }
        readString() {
          throw Object.defineProperty(new Error("removed"), "__classes", { configurable: true, value: ["java.lang.Throwable", "java.lang.Object", "java.lang.RuntimeException", "java.lang.Exception"] });
        }
        writeBytes(bytes, len) {
          for (let i = 0; i < len; i++) {
            {
              this.bytes[this.position++] = bytes[i];
            }
            ;
          }
        }
        readInt() {
          this.position += 4;
          return (this.bytes[this.position - 1] & 255) + ((this.bytes[this.position - 4] & 255) << 24) + ((this.bytes[this.position - 3] & 255) << 16) + ((this.bytes[this.position - 2] & 255) << 8);
        }
        readVarLong(bytes) {
          bytes--;
          if (bytes < 0 || bytes > 7) {
            throw Object.defineProperty(new Error(), "__classes", { configurable: true, value: ["java.lang.Throwable", "java.lang.Object", "java.lang.RuntimeException", "java.lang.IllegalArgumentException", "java.lang.Exception"] });
          }
          let value = 0;
          for (let shift = bytes * 8; shift >= 0; shift -= 8) {
            {
              value |= (((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(this.bytes[this.position++]) & 255) << shift;
            }
            ;
          }
          return value;
        }
        readShortSmart() {
          const peek = this.bytes[this.position] & 255;
          return peek < 128 ? this.readUnsignedByte() - 64 : this.readUnsignedShort() - 49152;
        }
        readUnsignedMultiSmart() {
          let total = 0;
          let value;
          for (value = this.readUnsignedShortSmart(); value === 32767; value = this.readUnsignedShortSmart()) {
            {
              total += 32767;
            }
            ;
          }
          return total + value;
        }
        writeIntLE(value) {
          this.bytes[this.position++] = value | 0;
          this.bytes[this.position++] = value >> 8 | 0;
          this.bytes[this.position++] = value >> 16 | 0;
          this.bytes[this.position++] = value >> 24 | 0;
        }
        readBytesA(bytes, len) {
          for (let i = 0; i < len; i++) {
            {
              bytes[i] = this.bytes[this.position++] - 128 | 0;
            }
            ;
          }
        }
        verifyCrc32() {
          this.position -= 4;
          const actual = Buffer2.crc32$byte_A$int$int(this.bytes, 0, this.position);
          const expected = this.readInt();
          return actual === expected;
        }
        writeMedium(value) {
          this.bytes[this.position++] = value >> 16 | 0;
          this.bytes[this.position++] = value >> 8 | 0;
          this.bytes[this.position++] = value | 0;
        }
        writeShortLE(value) {
          this.bytes[this.position++] = value | 0;
          this.bytes[this.position++] = value >> 8 | 0;
        }
        writeFloat(value) {
          const bits = ((f) => {
            let buf = new ArrayBuffer(4);
            new Float32Array(buf)[0] = f;
            return new Uint32Array(buf)[0];
          })(value);
          this.bytes[this.position++] = bits >> 24 | 0;
          this.bytes[this.position++] = bits >> 16 | 0;
          this.bytes[this.position++] = bits >> 8 | 0;
          this.bytes[this.position++] = bits | 0;
        }
        readUnsignedByteS() {
          return 128 - this.bytes[this.position++] & 255;
        }
        writeVarLong(value, bytes) {
          bytes--;
          if (bytes < 0 || bytes > 7) {
            throw Object.defineProperty(new Error(), "__classes", { configurable: true, value: ["java.lang.Throwable", "java.lang.Object", "java.lang.RuntimeException", "java.lang.IllegalArgumentException", "java.lang.Exception"] });
          }
          for (let shift = bytes * 8; shift >= 0; shift -= 8) {
            {
              this.bytes[this.position++] = value >> shift | 0;
            }
            ;
          }
        }
        xteaDecrypt(key, len) {
          const blocks = (len - 5) / 8 | 0;
          const position = this.position;
          this.position = 5;
          for (let i = 0; i < blocks; i++) {
            {
              let v0 = this.readInt();
              let v1 = this.readInt();
              let sum = -957401312;
              let rounds = 32;
              while (rounds-- > 0) {
                {
                  v1 -= (v0 << 4 ^ v0 >>> 5) + v0 ^ key[sum >>> 11 & 3] + sum;
                  sum -= -1640531527;
                  v0 -= (v1 << 4 ^ v1 >>> 5) + v1 ^ sum + key[sum & 3];
                }
              }
              ;
              this.position -= 8;
              this.writeInt(v0);
              this.writeInt(v1);
            }
            ;
          }
          this.position = position;
        }
        readByteS() {
          return 128 - this.bytes[this.position++] | 0;
        }
        readVarInt() {
          let b = this.bytes[this.position++];
          let value = 0;
          while (b < 0) {
            {
              value = (b & 127 | value) << 7;
              b = this.bytes[this.position++];
            }
          }
          ;
          return value | b;
        }
        writeIntLength(len) {
          this.bytes[this.position - len - 4] = len >> 24 | 0;
          this.bytes[this.position - len - 3] = len >> 16 | 0;
          this.bytes[this.position - len - 2] = len >> 8 | 0;
          this.bytes[this.position - len - 1] = len | 0;
        }
        writeByteA(value) {
          this.bytes[this.position++] = value + 128 | 0;
        }
        readBytes(bytes, len) {
          for (let i = 0; i < len; i++) {
            {
              bytes[i] = this.bytes[this.position++];
            }
            ;
          }
        }
        writeShortLE2(value) {
          this.bytes[this.position++] = value | 0;
          this.bytes[this.position++] = value >> 8 | 0;
        }
        writeShortA(arg0) {
          this.bytes[this.position++] = arg0 >> 8 | 0;
          this.bytes[this.position++] = arg0 + 128 | 0;
        }
        readByteC() {
          return -this.bytes[this.position++] | 0;
        }
        readUnsignedShort() {
          this.position += 2;
          return (this.bytes[this.position - 1] & 255) + ((this.bytes[this.position - 2] & 255) << 8);
        }
        writeInt(value) {
          this.bytes[this.position++] = value >> 24 | 0;
          this.bytes[this.position++] = value >> 16 | 0;
          this.bytes[this.position++] = value >> 8 | 0;
          this.bytes[this.position++] = value | 0;
        }
        readUnsignedMedium() {
          this.position += 3;
          return (this.bytes[this.position - 1] & 255) + ((this.bytes[this.position - 3] & 255) << 16) + ((this.bytes[this.position - 2] & 255) << 8);
        }
        readIntLE() {
          this.position += 4;
          return (this.bytes[this.position - 4] & 255) + ((this.bytes[this.position - 1] & 255) << 24) + ((this.bytes[this.position - 2] & 255) << 16) + ((this.bytes[this.position - 3] & 255) << 8);
        }
        writeCrc32(off) {
          const checksum = Buffer2.crc32$byte_A$int$int(this.bytes, off, this.position);
          this.writeInt(checksum);
          return checksum;
        }
        readLong() {
          const high = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(this.readInt()) & 4294967295;
          const low = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(this.readInt()) & 4294967295;
          return (high << 32) + low;
        }
        readUnsignedByteA() {
          return this.bytes[this.position++] - 128 & 255;
        }
        writeIntLE2(value) {
          this.bytes[this.position++] = value | 0;
          this.bytes[this.position++] = value >> 8 | 0;
          this.bytes[this.position++] = value >> 16 | 0;
          this.bytes[this.position++] = value >> 24 | 0;
        }
        readStringFast() {
          if (this.bytes[this.position] === 0) {
            this.position++;
            return null;
          } else {
            return this.readString();
          }
        }
        readShortA() {
          this.position += 2;
          let value = (this.bytes[this.position - 1] - 128 & 255) + ((this.bytes[this.position - 2] & 255) << 8);
          if (value > 32767) {
            value -= 65536;
          }
          return value;
        }
        xteaEncrypt(key) {
          const position = this.position / 8 | 0;
          this.position = 0;
          for (let i = 0; i < position; i++) {
            {
              let v0 = this.readInt();
              let v1 = this.readInt();
              let sum = 0;
              let rounds = 32;
              while (rounds-- > 0) {
                {
                  v0 += v1 + (v1 << 4 ^ v1 >>> 5) ^ sum + key[sum & 3];
                  sum += -1640531527;
                  v1 += sum + key[sum >>> 11 & -1354760189] ^ (v0 >>> 5 ^ v0 << 4) + v0;
                }
              }
              ;
              this.position -= 8;
              this.writeInt(v0);
              this.writeInt(v1);
            }
            ;
          }
        }
        readUnsignedByte() {
          return this.bytes[this.position++] & 255;
        }
        readUnsignedShortA() {
          this.position += 2;
          return ((this.bytes[this.position - 2] & 255) << 8) + (this.bytes[this.position - 1] - 128 & 255);
        }
        writeShort(value) {
          this.bytes[this.position++] = value >> 8 | 0;
          this.bytes[this.position++] = value | 0;
        }
        writeFloatLE(value) {
          const bits = ((f) => {
            let buf = new ArrayBuffer(4);
            new Float32Array(buf)[0] = f;
            return new Uint32Array(buf)[0];
          })(value);
          this.bytes[this.position++] = bits | 0;
          this.bytes[this.position++] = bits >> 8 | 0;
          this.bytes[this.position++] = bits >> 16 | 0;
          this.bytes[this.position++] = bits >> 24 | 0;
        }
        readVersionedString() {
          throw Object.defineProperty(new Error("removed"), "__classes", { configurable: true, value: ["java.lang.Throwable", "java.lang.Object", "java.lang.RuntimeException", "java.lang.Exception"] });
        }
        readBytesReverse(bytes, len) {
          for (let i = len - 1; i >= 0; i--) {
            {
              bytes[i] = this.bytes[this.position++];
            }
            ;
          }
        }
        readUnsignedShortLE() {
          this.position += 2;
          return ((this.bytes[this.position - 1] & 255) << 8) + (this.bytes[this.position - 2] & 255);
        }
        writeShortLEA(value) {
          this.bytes[this.position++] = value + 128 | 0;
          this.bytes[this.position++] = value >> 8 | 0;
        }
        readByte() {
          return this.bytes[this.position++];
        }
        writeByteLength(len) {
          this.bytes[this.position - len - 1] = len | 0;
        }
      }
      Buffer2["__class"] = "Buffer";
      class ColorImageCacheEntry extends Node {
        constructor(row, index) {
          super();
          if (this.row === void 0) {
            this.row = 0;
          }
          if (this.index === void 0) {
            this.index = 0;
          }
          this.row = row;
          this.index = index;
        }
        static VALID_$LI$() {
          if (ColorImageCacheEntry.VALID == null) {
            ColorImageCacheEntry.VALID = new ColorImageCacheEntry(0, 0);
          }
          return ColorImageCacheEntry.VALID;
        }
      }
      ColorImageCacheEntry["__class"] = "ColorImageCacheEntry";
      class MonochromeImageCacheEntry extends Node {
        constructor(row, index) {
          super();
          if (this.row === void 0) {
            this.row = 0;
          }
          if (this.index === void 0) {
            this.index = 0;
          }
          this.row = row;
          this.index = index;
        }
        static VALID_$LI$() {
          if (MonochromeImageCacheEntry.VALID == null) {
            MonochromeImageCacheEntry.VALID = new MonochromeImageCacheEntry(0, 0);
          }
          return MonochromeImageCacheEntry.VALID;
        }
      }
      MonochromeImageCacheEntry["__class"] = "MonochromeImageCacheEntry";
      class SecondaryNode extends Node {
        constructor() {
          super();
          if (this.secondaryPrev === void 0) {
            this.secondaryPrev = null;
          }
          if (this.secondaryKey === void 0) {
            this.secondaryKey = 0;
          }
          if (this.secondaryNext === void 0) {
            this.secondaryNext = null;
          }
        }
        unlinkSecondary() {
          if (this.secondaryPrev != null) {
            this.secondaryPrev.secondaryNext = this.secondaryNext;
            this.secondaryNext.secondaryPrev = this.secondaryPrev;
            this.secondaryPrev = null;
            this.secondaryNext = null;
          }
        }
        isSecondaryLinked() {
          return this.secondaryPrev != null;
        }
      }
      SecondaryNode["__class"] = "SecondaryNode";
      class TextureOp2 extends Node {
        constructor(childOpsCount, monochrome) {
          super();
          if (this.colorImageCache === void 0) {
            this.colorImageCache = null;
          }
          if (this.monochromeImageCache === void 0) {
            this.monochromeImageCache = null;
          }
          if (this.imageCacheCapacity === void 0) {
            this.imageCacheCapacity = 0;
          }
          if (this.monochrome === void 0) {
            this.monochrome = false;
          }
          if (this.childOps === void 0) {
            this.childOps = null;
          }
          this.monochrome = monochrome;
          this.childOps = ((s) => {
            let a = [];
            while (s-- > 0)
              a.push(null);
            return a;
          })(childOpsCount);
        }
        static permutations_$LI$() {
          if (TextureOp2.permutations == null) {
            TextureOp2.permutations = new LruHashTable(16);
          }
          return TextureOp2.permutations;
        }
        static createTrigonometryTables() {
          if (TextureOp2.SINE != null && TextureOp2.COSINE != null) {
            return;
          }
          TextureOp2.COSINE = ((s) => {
            let a = [];
            while (s-- > 0)
              a.push(0);
            return a;
          })(256);
          TextureOp2.SINE = ((s) => {
            let a = [];
            while (s-- > 0)
              a.push(0);
            return a;
          })(256);
          for (let i = 0; i < 256; i++) {
            {
              const radians = i / 255 * 6.283185307179586;
              TextureOp2.SINE[i] = Math.sin(radians) * 4096 | 0;
              TextureOp2.COSINE[i] = Math.cos(radians) * 4096 | 0;
            }
            ;
          }
        }
        static getPermutation(seed) {
          let node = TextureOp2.permutations_$LI$().get(seed);
          if (node == null) {
            const permutation = ((s) => {
              let a = [];
              while (s-- > 0)
                a.push(0);
              return a;
            })(512);
            const random = new Random(seed);
            for (let i = 0; i < 255; i++) {
              {
                permutation[i] = i | 0;
              }
              ;
            }
            for (let i = 0; i < 255; i++) {
              {
                const j = 255 - i;
                const k = RandomUtils.nextInt(random, j);
                const temp = permutation[k];
                permutation[k] = permutation[j];
                permutation[j] = permutation[511 - i] = temp;
              }
              ;
            }
            node = new ByteArraySecondaryNode(permutation);
            TextureOp2.permutations_$LI$().put(seed, node);
          }
          return node.value;
        }
        static perlinFade(t) {
          const cube = (t * t >> 12) * t >> 12 | 0;
          const mul6Sub15 = t * 6 - 61440 | 0;
          const mulTAdd10 = (t * mul6Sub15 >> 12) + 40960 | 0;
          return cube * mulTAdd10 >> 12 | 0;
        }
        static decode(buffer) {
          buffer.readUnsignedByte();
          const type = buffer.readUnsignedByte();
          const op = TextureOp2.create(type);
          op.imageCacheCapacity = buffer.readUnsignedByte();
          const codes = buffer.readUnsignedByte();
          for (let i = 0; i < codes; i++) {
            {
              const code = buffer.readUnsignedByte();
              op.decode(buffer, code);
            }
            ;
          }
          op.postDecode();
          return op;
        }
        /*private*/
        static create(type) {
          if (type === 0) {
            return new TextureOpMonochromeFill();
          } else if (type === 1) {
            return new TextureOpColorFill();
          } else if (type === 2) {
            return new TextureOpHorizontalGradient();
          } else if (type === 3) {
            return new TextureOpVerticalGradient();
          } else if (type === 4) {
            return new TextureOpBricks();
          } else if (type === 5) {
            return new TextureOpBoxBlur();
          } else if (type === 6) {
            return new TextureOpClamp();
          } else if (type === 7) {
            return new TextureOpCombine();
          } else if (type === 8) {
            return new TextureOpCurve();
          } else if (type === 9) {
            return new TextureOpFlip();
          } else if (type === 10) {
            return new TextureOpColorGradient();
          } else if (type === 11) {
            return new TextureOpColorize();
          } else if (type === 12) {
            return new TextureOpWaveform();
          } else if (type === 13) {
            return new TextureOpNoise();
          } else if (type === 14) {
            return new TextureOpWeave();
          } else if (type === 15) {
            return new TextureOpVoronoiNoise();
          } else if (type === 16) {
            return new TextureOpHerringbone();
          } else if (type === 17) {
            return new TextureOpHslAdjust();
          } else if (type === 18) {
            return new TextureOpTiledSprite();
          } else if (type === 19) {
            return new TextureOpPolarDistortion();
          } else if (type === 20) {
            return new TextureOpTile();
          } else if (type === 21) {
            return new TextureOpInterpolate();
          } else if (type === 22) {
            return new TextureOpInvert();
          } else if (type === 23) {
            return new TextureOpKaleidoscope();
          } else if (type === 24) {
            return new TextureOpMonochrome();
          } else if (type === 25) {
            return new TextureOpBrightness();
          } else if (type === 26) {
            return new TextureOpBinary();
          } else if (type === 27) {
            return new TextureOpSquareWaveform();
          } else if (type === 28) {
            return new TextureOpIrregularBricks();
          } else if (type === 29) {
            return new TextureOpRasterizer();
          } else if (type === 30) {
            return new TextureOpRange();
          } else if (type === 31) {
            return new TextureOpMandelbrot();
          } else if (type === 32) {
            return new TextureOpEmboss();
          } else if (type === 33) {
            return new TextureOpColorEdgeDetector();
          } else if (type === 34) {
            return new TextureOpPerlinNoise();
          } else if (type === 35) {
            return new TextureOpMonochromeEdgeDetector();
          } else if (type === 36) {
            return new TextureOpTexture();
          } else if (type === 37) {
            return new TextureOp37();
          } else if (type === 38) {
            return new TextureOpLineNoise();
          } else if (type === 39) {
            return new TextureOpSprite();
          } else {
            return null;
          }
        }
        getChildColorOutput(index, y) {
          if (!this.childOps[index].monochrome) {
            return this.childOps[index].getColorOutput(y);
          }
          const colorRow = [null, null, null];
          const monochromeRow = this.childOps[index].getMonochromeOutput(y);
          colorRow[0] = monochromeRow;
          colorRow[2] = monochromeRow;
          colorRow[1] = monochromeRow;
          return colorRow;
        }
        decode(buffer, code) {
        }
        getSpriteId() {
          return -1;
        }
        getTextureId() {
          return -1;
        }
        getMonochromeOutput(y) {
          throw Object.defineProperty(new Error("This operation does not have a monochrome output"), "__classes", { configurable: true, value: ["java.lang.Throwable", "java.lang.IllegalStateException", "java.lang.Object", "java.lang.RuntimeException", "java.lang.Exception"] });
        }
        getColorOutput(y) {
          throw Object.defineProperty(new Error("This operation does not have a colour output"), "__classes", { configurable: true, value: ["java.lang.Throwable", "java.lang.IllegalStateException", "java.lang.Object", "java.lang.RuntimeException", "java.lang.Exception"] });
        }
        clearImageCache() {
          if (this.monochrome) {
            this.monochromeImageCache.clear();
            this.monochromeImageCache = null;
          } else {
            this.colorImageCache.clear();
            this.colorImageCache = null;
          }
        }
        createImageCache(height, width) {
          const capacity = this.imageCacheCapacity === 255 ? height : this.imageCacheCapacity;
          if (this.monochrome) {
            this.monochromeImageCache = new MonochromeImageCache(capacity, height, width);
          } else {
            this.colorImageCache = new ColorImageCache(capacity, height, width);
          }
        }
        getChildMonochromeOutput(index, y) {
          return this.childOps[index].monochrome ? this.childOps[index].getMonochromeOutput(y) : this.childOps[index].getColorOutput(y)[0];
        }
        postDecode() {
        }
      }
      TextureOp2.COSINE = null;
      TextureOp2.SINE = null;
      TextureOp2["__class"] = "TextureOp";
      class TextureOpRasterizerBezierCurve extends TextureOpRasterizerShape {
        constructor(x0, y0, x1, y1, x2, y2, x3, y3, color, outlineWidth) {
          super(-1, color, outlineWidth);
          if (this.y1 === void 0) {
            this.y1 = 0;
          }
          if (this.x0 === void 0) {
            this.x0 = 0;
          }
          if (this.y0 === void 0) {
            this.y0 = 0;
          }
          if (this.x1 === void 0) {
            this.x1 = 0;
          }
          if (this.x2 === void 0) {
            this.x2 = 0;
          }
          if (this.y2 === void 0) {
            this.y2 = 0;
          }
          if (this.x3 === void 0) {
            this.x3 = 0;
          }
          if (this.y3 === void 0) {
            this.y3 = 0;
          }
          this.y1 = y1;
          this.x0 = x0;
          this.y0 = y0;
          this.x1 = x1;
          this.x2 = x2;
          this.y2 = y2;
          this.x3 = x3;
          this.y3 = y3;
        }
        static create(buffer) {
          return new TextureOpRasterizerBezierCurve(buffer.readShort(), buffer.readShort(), buffer.readShort(), buffer.readShort(), buffer.readShort(), buffer.readShort(), buffer.readShort(), buffer.readShort(), buffer.readUnsignedMedium(), buffer.readUnsignedByte());
        }
        renderOutline(width, height) {
          const x0 = width * this.x0 >> 12;
          const x1 = width * this.x1 >> 12;
          const y1 = height * this.y1 >> 12;
          const x2 = width * this.x2 >> 12;
          const y0 = height * this.y0 >> 12;
          const y2 = height * this.y2 >> 12;
          const y3 = height * this.y3 >> 12;
          const x3 = width * this.x3 >> 12;
          MergedStatics.sub22_method4693(x1, y1, this.outlineColor, x2, x3, y0, y3, y2, x0);
        }
        renderFill(width, height) {
        }
        render(width, height) {
        }
      }
      TextureOpRasterizerBezierCurve["__class"] = "TextureOpRasterizerBezierCurve";
      class TextureOpRasterizerEllipse extends TextureOpRasterizerShape {
        constructor(x, y, horizontalRadius, verticalRadius, fillColor, outlineColor, outlineWidth) {
          super(fillColor, outlineColor, outlineWidth);
          if (this.x === void 0) {
            this.x = 0;
          }
          if (this.horizontalRadius === void 0) {
            this.horizontalRadius = 0;
          }
          if (this.y === void 0) {
            this.y = 0;
          }
          if (this.verticalRadius === void 0) {
            this.verticalRadius = 0;
          }
          this.x = x;
          this.horizontalRadius = horizontalRadius;
          this.y = y;
          this.verticalRadius = verticalRadius;
        }
        static create(buffer) {
          return new TextureOpRasterizerEllipse(buffer.readShort(), buffer.readShort(), buffer.readShort(), buffer.readShort(), buffer.readUnsignedMedium(), buffer.readUnsignedMedium(), buffer.readUnsignedByte());
        }
        render(width, height) {
          const x = this.x * width >> 12;
          const horizontalRadius = this.horizontalRadius * width >> 12;
          const verticalRadius = this.verticalRadius * height >> 12;
          const y = this.y * height >> 12;
          MergedStatics.sub18_method1745(horizontalRadius, this.fillColor, x, this.outlineColor, this.outlineWidth, y, verticalRadius);
        }
        renderFill(width, height) {
          const x = this.x * width >> 12;
          const horizontalRadius = this.horizontalRadius * width >> 12;
          const verticalRadius = this.verticalRadius * height >> 12;
          const y = this.y * height >> 12;
          MergedStatics.sub28_method3323(verticalRadius, x, this.fillColor, y, horizontalRadius);
        }
        renderOutline(width, height) {
        }
      }
      TextureOpRasterizerEllipse["__class"] = "TextureOpRasterizerEllipse";
      class TextureOpRasterizerLine extends TextureOpRasterizerShape {
        constructor(x0, y0, x1, y1, color, outlineWidth) {
          super(-1, color, outlineWidth);
          if (this.x1 === void 0) {
            this.x1 = 0;
          }
          if (this.y0 === void 0) {
            this.y0 = 0;
          }
          if (this.x0 === void 0) {
            this.x0 = 0;
          }
          if (this.y1 === void 0) {
            this.y1 = 0;
          }
          this.x1 = x1;
          this.y0 = y0;
          this.x0 = x0;
          this.y1 = y1;
        }
        static create(buffer) {
          return new TextureOpRasterizerLine(buffer.readShort(), buffer.readShort(), buffer.readShort(), buffer.readShort(), buffer.readUnsignedMedium(), buffer.readUnsignedByte());
        }
        renderFill(width, height) {
        }
        renderOutline(width, height) {
          const x0 = this.x0 * width >> 12;
          const x1 = this.x1 * width >> 12;
          const y1 = this.y1 * height >> 12;
          const y0 = this.y0 * height >> 12;
          MergedStatics.sub32_method4022(y0, y1, this.outlineColor, x0, x1);
        }
        render(width, height) {
        }
      }
      TextureOpRasterizerLine["__class"] = "TextureOpRasterizerLine";
      class TextureOpRasterizerRectangle extends TextureOpRasterizerShape {
        constructor(x0, y0, x1, y1, fillColor, outlineColor, outlineWidth) {
          super(fillColor, outlineColor, outlineWidth);
          if (this.x1 === void 0) {
            this.x1 = 0;
          }
          if (this.y1 === void 0) {
            this.y1 = 0;
          }
          if (this.x0 === void 0) {
            this.x0 = 0;
          }
          if (this.y0 === void 0) {
            this.y0 = 0;
          }
          this.x1 = x1;
          this.y1 = y1;
          this.x0 = x0;
          this.y0 = y0;
        }
        static create(buffer) {
          return new TextureOpRasterizerRectangle(buffer.readShort(), buffer.readShort(), buffer.readShort(), buffer.readShort(), buffer.readUnsignedMedium(), buffer.readUnsignedMedium(), buffer.readUnsignedByte());
        }
        render(width, height) {
          const x0 = this.x0 * width >> 12;
          const y0 = this.y0 * height >> 12;
          const x1 = this.x1 * width >> 12;
          const y1 = this.y1 * height >> 12;
          MergedStatics.sub36_method4566(x0, this.outlineColor, this.fillColor, this.outlineWidth, y1, x1, y0);
        }
        renderOutline(width, height) {
          const x0 = this.x0 * width >> 12;
          const x1 = this.x1 * width >> 12;
          const y0 = this.y0 * height >> 12;
          const y1 = this.y1 * height >> 12;
          MergedStatics.sub32_method3997(x0, this.outlineColor, y0, this.outlineWidth, y1, x1);
        }
        renderFill(width, height) {
          const x0 = this.x0 * width >> 12;
          const x1 = this.x1 * width >> 12;
          const y0 = this.y0 * height >> 12;
          const y1 = this.y1 * height >> 12;
          MergedStatics.sub29_method3429(x0, y1, x1, y0, this.fillColor);
        }
      }
      TextureOpRasterizerRectangle["__class"] = "TextureOpRasterizerRectangle";
      class ByteArraySecondaryNode extends SecondaryNode {
        constructor(value) {
          super();
          if (this.value === void 0) {
            this.value = null;
          }
          this.value = value;
        }
      }
      ByteArraySecondaryNode["__class"] = "ByteArraySecondaryNode";
      class Sprite extends SecondaryNode {
        constructor() {
          super();
          if (this.innerWidth === void 0) {
            this.innerWidth = 0;
          }
          if (this.yOffset === void 0) {
            this.yOffset = 0;
          }
          if (this.xOffset === void 0) {
            this.xOffset = 0;
          }
          if (this.height === void 0) {
            this.height = 0;
          }
          if (this.width === void 0) {
            this.width = 0;
          }
          if (this.innerHeight === void 0) {
            this.innerHeight = 0;
          }
        }
        renderRotatedScaledTransparent$int$int$int$int$int$int(pivotX, pivotY, x, y, angle, scale) {
          throw new Error("cannot invoke abstract overloaded method... check your argument(s) type(s)");
        }
        renderRotatedScaledTransparent(pivotX, pivotY, x, y, angle, scale) {
          if ((typeof pivotX === "number" || pivotX === null) && (typeof pivotY === "number" || pivotY === null) && (typeof x === "number" || x === null) && (typeof y === "number" || y === null) && (typeof angle === "number" || angle === null) && (typeof scale === "number" || scale === null)) {
            return this.renderRotatedScaledTransparent$int$int$int$int$int$int(pivotX, pivotY, x, y, angle, scale);
          } else if ((typeof pivotX === "number" || pivotX === null) && (typeof pivotY === "number" || pivotY === null) && (typeof x === "number" || x === null) && (typeof y === "number" || y === null) && angle === void 0 && scale === void 0) {
            return this.renderRotatedScaledTransparent$int$int$int$int(pivotX, pivotY, x, y);
          } else
            throw new Error("invalid overload");
        }
        renderRotatedScaledTransparent$int$int$int$int(y, angle, x, scale) {
          const halfInnerWidth = this.innerWidth << 3;
          x = (halfInnerWidth & 15) + (x << 4);
          const halfInnerHeight = this.innerHeight << 3;
          y = (halfInnerHeight & 15) + (y << 4);
          this.renderRotatedScaledTransparent$int$int$int$int$int$int(halfInnerWidth, halfInnerHeight, x, y, angle, scale);
        }
      }
      Sprite["__class"] = "Sprite";
      class Texture6 extends SecondaryNode {
        constructor(buffer) {
          super();
          if (this.spriteIds === void 0) {
            this.spriteIds = null;
          }
          if (this.textureIds === void 0) {
            this.textureIds = null;
          }
          if (this.brightnessOp === void 0) {
            this.brightnessOp = null;
          }
          if (this.colorOp === void 0) {
            this.colorOp = null;
          }
          if (this.alphaOp === void 0) {
            this.alphaOp = null;
          }
          if (this.ops === void 0) {
            this.ops = null;
          }
          let spriteCount = 0;
          const opCount = buffer.readUnsignedByte();
          this.ops = ((s) => {
            let a = [];
            while (s-- > 0)
              a.push(null);
            return a;
          })(opCount);
          let textureCount = 0;
          const childOpIds = ((s) => {
            let a = [];
            while (s-- > 0)
              a.push(null);
            return a;
          })(opCount);
          for (let i = 0; i < opCount; i++) {
            {
              const op = TextureOp2.decode(buffer);
              if (op.getSpriteId() >= 0) {
                spriteCount++;
              }
              if (op.getTextureId() >= 0) {
                textureCount++;
              }
              const childOpsCount = op.childOps.length;
              childOpIds[i] = ((s) => {
                let a = [];
                while (s-- > 0)
                  a.push(0);
                return a;
              })(childOpsCount);
              for (let j = 0; j < childOpsCount; j++) {
                {
                  childOpIds[i][j] = buffer.readUnsignedByte();
                }
                ;
              }
              this.ops[i] = op;
            }
            ;
          }
          this.textureIds = ((s) => {
            let a = [];
            while (s-- > 0)
              a.push(0);
            return a;
          })(textureCount);
          let textureIdsIndex = 0;
          this.spriteIds = ((s) => {
            let a = [];
            while (s-- > 0)
              a.push(0);
            return a;
          })(spriteCount);
          let spriteIdsIndex = 0;
          for (let i = 0; i < opCount; i++) {
            {
              const op = this.ops[i];
              const childOpsCount = op.childOps.length;
              for (let j = 0; j < childOpsCount; j++) {
                {
                  op.childOps[j] = this.ops[childOpIds[i][j]];
                }
                ;
              }
              const spriteId = op.getSpriteId();
              const textureId = op.getTextureId();
              if (spriteId > 0) {
                this.spriteIds[spriteIdsIndex++] = spriteId;
              }
              if (textureId > 0) {
                this.textureIds[textureIdsIndex++] = textureId;
              }
              childOpIds[i] = null;
            }
            ;
          }
          this.colorOp = this.ops[buffer.readUnsignedByte()];
          this.alphaOp = this.ops[buffer.readUnsignedByte()];
          this.brightnessOp = this.ops[buffer.readUnsignedByte()];
        }
        static brightnessMap_$LI$() {
          if (Texture6.brightnessMap == null) {
            Texture6.brightnessMap = ((s) => {
              let a = [];
              while (s-- > 0)
                a.push(0);
              return a;
            })(256);
          }
          return Texture6.brightnessMap;
        }
        /*private*/
        static setBrightness(brightness) {
          if (Texture6.brightness === brightness) {
            return;
          }
          for (let i = 0; i < 256; i++) {
            {
              const j = Math.pow(i / 255, brightness) * 255 | 0;
              Texture6.brightnessMap_$LI$()[i] = j > 255 ? 255 : j;
            }
            ;
          }
          Texture6.brightness = brightness;
        }
        static setSize(width, height) {
          if (width !== Texture6.width) {
            Texture6.normalisedX = ((s) => {
              let a = [];
              while (s-- > 0)
                a.push(0);
              return a;
            })(width);
            for (let x = 0; x < width; x++) {
              {
                Texture6.normalisedX[x] = (x << 12) / width | 0;
              }
              ;
            }
            Texture6.widthMask = width - 1;
            Texture6.width = width;
            Texture6.widthTimes32 = width * 32;
          }
          if (height === Texture6.height) {
            return;
          }
          if (height === Texture6.width) {
            Texture6.normalisedY = Texture6.normalisedX;
          } else {
            Texture6.normalisedY = ((s) => {
              let a = [];
              while (s-- > 0)
                a.push(0);
              return a;
            })(height);
            for (let y = 0; y < height; y++) {
              {
                Texture6.normalisedY[y] = (y << 12) / height | 0;
              }
              ;
            }
          }
          Texture6.heightMask = height - 1;
          Texture6.height = height;
        }
        getPixels(width, height, loadedtexes, brightness, columnMajor, flipHorizontal) {
          Texture6.setBrightness(brightness);
          Texture6.setSize(width, height);
          const pixels = ((s) => {
            let a = [];
            while (s-- > 0)
              a.push(0);
            return a;
          })(width * height);
          for (let i = 0; i < this.ops.length; i++) {
            {
              this.ops[i].createImageCache(height, width);
            }
            ;
          }
          Texture6.loadedTextures = loadedtexes;
          let x1;
          let dx;
          let x0;
          if (flipHorizontal) {
            x0 = width - 1;
            x1 = -1;
            dx = -1;
          } else {
            dx = 1;
            x1 = width;
            x0 = 0;
          }
          let index = 0;
          for (let y = 0; y < height; y++) {
            {
              if (columnMajor) {
                index = y;
              }
              let reds;
              let greens;
              let blues;
              if (this.colorOp.monochrome) {
                const output = this.colorOp.getMonochromeOutput(y);
                greens = output;
                blues = output;
                reds = output;
              } else {
                const output = this.colorOp.getColorOutput(y);
                reds = output[0];
                blues = output[2];
                greens = output[1];
              }
              for (let x = x0; x !== x1; x += dx) {
                {
                  let red2 = reds[x] >> 4;
                  let green = greens[x] >> 4;
                  if (green > 255) {
                    green = 255;
                  }
                  let blue = blues[x] >> 4;
                  if (red2 > 255) {
                    red2 = 255;
                  }
                  if (blue > 255) {
                    blue = 255;
                  }
                  if (green < 0) {
                    green = 0;
                  }
                  if (red2 < 0) {
                    red2 = 0;
                  }
                  const green2 = Texture6.brightnessMap_$LI$()[green];
                  const red22 = Texture6.brightnessMap_$LI$()[red2];
                  if (blue < 0) {
                    blue = 0;
                  }
                  const blue2 = Texture6.brightnessMap_$LI$()[blue];
                  pixels[index++] = blue2 + (red22 << 16) + (green2 << 8);
                  if (columnMajor) {
                    index += width - 1;
                  }
                }
                ;
              }
            }
            ;
          }
          for (let i = 0; i < this.ops.length; i++) {
            {
              this.ops[i].clearImageCache();
            }
            ;
          }
          return pixels;
        }
      }
      Texture6.loadedTextures = null;
      Texture6.spriteGroupId = -1;
      Texture6.brightness = -1;
      Texture6.width = 0;
      Texture6.height = 0;
      Texture6.widthMask = 0;
      Texture6.heightMask = 0;
      Texture6.normalisedX = null;
      Texture6.normalisedY = null;
      Texture6.widthTimes32 = 0;
      Texture6["__class"] = "Texture";
      class MonochromeImageCache {
        constructor(capacity, height, width) {
          this.size = 0;
          this.singleRow = -1;
          this.recentlyUsed = new LinkedList();
          this.invalid = false;
          if (this.height === void 0) {
            this.height = 0;
          }
          if (this.entries === void 0) {
            this.entries = null;
          }
          if (this.capacity === void 0) {
            this.capacity = 0;
          }
          if (this.pixels === void 0) {
            this.pixels = null;
          }
          this.height = height;
          this.entries = ((s) => {
            let a = [];
            while (s-- > 0)
              a.push(null);
            return a;
          })(this.height);
          this.capacity = capacity;
          this.pixels = (function(dims) {
            let allocate = function(dims2) {
              if (dims2.length === 0) {
                return 0;
              } else {
                let array2 = [];
                for (let i = 0; i < dims2[0]; i++) {
                  array2.push(allocate(dims2.slice(1)));
                }
                return array2;
              }
            };
            return allocate(dims);
          })([this.capacity, width]);
        }
        static __static_initialize() {
          if (!MonochromeImageCache.__static_initialized) {
            MonochromeImageCache.__static_initialized = true;
            MonochromeImageCache.__static_initializer_0();
          }
        }
        static PERLIN_FADE_$LI$() {
          MonochromeImageCache.__static_initialize();
          if (MonochromeImageCache.PERLIN_FADE == null) {
            MonochromeImageCache.PERLIN_FADE = ((s) => {
              let a = [];
              while (s-- > 0)
                a.push(0);
              return a;
            })(4096);
          }
          return MonochromeImageCache.PERLIN_FADE;
        }
        static __static_initializer_0() {
          for (let t = 0; t < 4096; t++) {
            {
              MonochromeImageCache.PERLIN_FADE_$LI$()[t] = TextureOp2.perlinFade(t);
            }
            ;
          }
        }
        get$() {
          if (this.capacity !== this.height) {
            throw Object.defineProperty(new Error("Can only retrieve a full image cache"), "__classes", { configurable: true, value: ["java.lang.Throwable", "java.lang.Object", "java.lang.RuntimeException", "java.lang.Exception"] });
          }
          for (let row = 0; row < this.capacity; row++) {
            {
              this.entries[row] = MonochromeImageCacheEntry.VALID_$LI$();
            }
            ;
          }
          return this.pixels;
        }
        get$int(row) {
          if (this.capacity === this.height) {
            this.invalid = this.entries[row] == null;
            this.entries[row] = MonochromeImageCacheEntry.VALID_$LI$();
            return this.pixels[row];
          } else if (this.capacity === 1) {
            this.invalid = row !== this.singleRow;
            this.singleRow = row;
            return this.pixels[0];
          } else {
            let entry = this.entries[row];
            if (entry == null) {
              this.invalid = true;
              if (this.capacity > this.size) {
                entry = new MonochromeImageCacheEntry(row, this.size);
                this.size++;
              } else {
                const lruEntry = this.recentlyUsed.tail();
                entry = new MonochromeImageCacheEntry(row, lruEntry.index);
                this.entries[lruEntry.row] = null;
                lruEntry.unlink();
              }
              this.entries[row] = entry;
            } else {
              this.invalid = false;
            }
            this.recentlyUsed.addHead(entry);
            return this.pixels[entry.index];
          }
        }
        get(row) {
          if (typeof row === "number" || row === null) {
            return this.get$int(row);
          } else if (row === void 0) {
            return this.get$();
          } else
            throw new Error("invalid overload");
        }
        clear() {
          for (let i = 0; i < this.capacity; i++) {
            {
              this.pixels[i] = null;
            }
            ;
          }
          this.pixels = null;
          this.entries = null;
          this.recentlyUsed.clear();
          this.recentlyUsed = null;
        }
      }
      MonochromeImageCache.__static_initialized = false;
      MonochromeImageCache["__class"] = "MonochromeImageCache";
      class TextureOp37 extends TextureOp2 {
        constructor() {
          super(0, true);
          this.anInt4505 = 0;
          this.anInt4503 = 8192;
          this.anInt4508 = 2048;
          this.anInt4504 = 0;
          this.anInt4515 = 2048;
          this.anInt4507 = 12288;
          this.anInt4517 = 4096;
        }
        /*private*/
        method3687(x, y) {
          const local9 = (y - x) * this.anInt4507 >> 12;
          let local24 = TextureOp2.COSINE[local9 * 255 >> 12 & 255];
          local24 = (local24 << 12) / this.anInt4507 | 0;
          local24 = (local24 << 12) / this.anInt4503 | 0;
          local24 = this.anInt4517 * local24 >> 12;
          return local24 > x + y && -local24 < x + y;
        }
        /*private*/
        method3690(x, y) {
          const local13 = (y + x) * this.anInt4507 >> 12;
          let local23 = TextureOp2.COSINE[local13 * 255 >> 12 & 255];
          local23 = (local23 << 12) / this.anInt4507 | 0;
          local23 = (local23 << 12) / this.anInt4503 | 0;
          local23 = local23 * this.anInt4517 >> 12;
          return local23 > y - x && y - x > -local23;
        }
        postDecode() {
          TextureOp2.createTrigonometryTables();
        }
        decode(buffer, code) {
          if (code === 0) {
            this.anInt4508 = buffer.readUnsignedShort();
          } else if (code === 1) {
            this.anInt4505 = buffer.readUnsignedShort();
          } else if (code === 2) {
            this.anInt4504 = buffer.readUnsignedShort();
          } else if (code === 3) {
            this.anInt4515 = buffer.readUnsignedShort();
          } else if (code === 4) {
            this.anInt4507 = buffer.readUnsignedShort();
          } else if (code === 5) {
            this.anInt4517 = buffer.readUnsignedShort();
          } else if (code === 6) {
            this.anInt4503 = buffer.readUnsignedShort();
          }
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            const local22 = Texture6.normalisedY[y] - 2048;
            for (let x = 0; x < Texture6.width; x++) {
              {
                const local33 = Texture6.normalisedX[x] - 2048;
                let local38 = local33 + this.anInt4508;
                local38 = local38 >= -2048 ? local38 : local38 + 4096;
                let local53 = local22 + this.anInt4505;
                local38 = local38 <= 2048 ? local38 : local38 - 4096;
                local53 = local53 >= -2048 ? local53 : local53 + 4096;
                local53 = local53 <= 2048 ? local53 : local53 - 4096;
                let local87 = local33 + this.anInt4504;
                let local92 = local22 + this.anInt4515;
                local87 = local87 >= -2048 ? local87 : local87 + 4096;
                local87 = local87 <= 2048 ? local87 : local87 - 4096;
                local92 = local92 >= -2048 ? local92 : local92 + 4096;
                local92 = local92 <= 2048 ? local92 : local92 - 4096;
                dest[x] = this.method3687(local38, local53) || this.method3690(local87, local92) ? 4096 : 0;
              }
              ;
            }
          }
          return dest;
        }
      }
      TextureOp37["__class"] = "TextureOp37";
      class TextureOpBinary extends TextureOp2 {
        constructor() {
          super(1, true);
          this.minValue = 0;
          this.maxValue = 4096;
        }
        decode(buffer, code) {
          if (code === 0) {
            this.minValue = buffer.readUnsignedShort();
          } else if (code === 1) {
            this.maxValue = buffer.readUnsignedShort();
          }
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            const src = this.getChildMonochromeOutput(0, y);
            for (let x = 0; x < Texture6.width; x++) {
              {
                const value = src[x];
                dest[x] = value >= this.minValue && value <= this.maxValue ? 4096 : 0;
              }
              ;
            }
          }
          return dest;
        }
      }
      TextureOpBinary["__class"] = "TextureOpBinary";
      class TextureOpBoxBlur extends TextureOp2 {
        constructor() {
          super(1, false);
          this.radiusY = 1;
          this.radiusX = 1;
        }
        getColorOutput(y) {
          const dest = this.colorImageCache.get$int(y);
          if (this.colorImageCache.invalid) {
            const local32 = this.radiusY + this.radiusY + 1;
            const local36 = 65536 / local32 | 0;
            const local44 = this.radiusX + this.radiusX + 1;
            const local48 = 65536 / local44 | 0;
            const local51 = ((s) => {
              let a = [];
              while (s-- > 0)
                a.push(null);
              return a;
            })(local32);
            for (let local57 = y - this.radiusY; local57 <= y + this.radiusY; local57++) {
              {
                const src = this.getChildColorOutput(0, local57 & Texture6.heightMask);
                const local80 = (function(dims) {
                  let allocate = function(dims2) {
                    if (dims2.length === 0) {
                      return 0;
                    } else {
                      let array2 = [];
                      for (let i = 0; i < dims2[0]; i++) {
                        array2.push(allocate(dims2.slice(1)));
                      }
                      return array2;
                    }
                  };
                  return allocate(dims);
                })([3, Texture6.width]);
                let local82 = 0;
                let local84 = 0;
                const srcRed = src[0];
                let local90 = 0;
                const srcBlue = src[2];
                const srcGreen = src[1];
                for (let local102 = -this.radiusX; local102 <= this.radiusX; local102++) {
                  {
                    const local114 = Texture6.widthMask & local102;
                    local90 += srcGreen[local114];
                    local82 += srcRed[local114];
                    local84 += srcBlue[local114];
                  }
                  ;
                }
                const local139 = local80[0];
                const local143 = local80[1];
                const local147 = local80[2];
                let local149 = 0;
                while (Texture6.width > local149) {
                  {
                    local139[local149] = local48 * local82 >> 16;
                    local143[local149] = local90 * local48 >> 16;
                    local147[local149] = local48 * local84 >> 16;
                    let local184 = local149 - this.radiusX & Texture6.widthMask;
                    const local190 = local90 - srcGreen[local184];
                    const local196 = local82 - srcRed[local184];
                    local149++;
                    const local203 = local84 - srcBlue[local184];
                    local184 = local149 + this.radiusX & Texture6.widthMask;
                    local82 = local196 + srcRed[local184];
                    local90 = local190 + srcGreen[local184];
                    local84 = local203 + srcBlue[local184];
                  }
                }
                ;
                local51[local57 + this.radiusY - y] = local80;
              }
              ;
            }
            const destGreen = dest[1];
            const destBlue = dest[2];
            const destRed = dest[0];
            for (let local259 = 0; local259 < Texture6.width; local259++) {
              {
                let local264 = 0;
                let local266 = 0;
                let local268 = 0;
                for (let local270 = 0; local270 < local32; local270++) {
                  {
                    const local277 = local51[local270];
                    local268 += local277[2][local259];
                    local264 += local277[0][local259];
                    local266 += local277[1][local259];
                  }
                  ;
                }
                destRed[local259] = local36 * local264 >> 16;
                destGreen[local259] = local36 * local266 >> 16;
                destBlue[local259] = local268 * local36 >> 16;
              }
              ;
            }
          }
          return dest;
        }
        decode(buffer, code) {
          if (code === 0) {
            this.radiusX = buffer.readUnsignedByte();
          } else if (code === 1) {
            this.radiusY = buffer.readUnsignedByte();
          } else if (code === 2) {
            this.monochrome = buffer.readUnsignedByte() === 1;
          }
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            const windowY = this.radiusY + this.radiusY + 1;
            const windowYReciprocal = 65536 / windowY | 0;
            const windowX = this.radiusX + this.radiusX + 1;
            const windowXReciprocal = 65536 / windowX | 0;
            const horizontalAverages = ((s) => {
              let a = [];
              while (s-- > 0)
                a.push(null);
              return a;
            })(windowY);
            for (let y0 = y - this.radiusY; y0 <= y + this.radiusY; y0++) {
              {
                const src = this.getChildMonochromeOutput(0, Texture6.heightMask & y0);
                const horizontalAverage = ((s) => {
                  let a = [];
                  while (s-- > 0)
                    a.push(0);
                  return a;
                })(Texture6.width);
                let horizontalSum = 0;
                for (let x02 = -this.radiusX; x02 <= this.radiusX; x02++) {
                  {
                    horizontalSum += src[x02 & Texture6.widthMask];
                  }
                  ;
                }
                let x0 = 0;
                while (x0 < Texture6.width) {
                  {
                    horizontalAverage[x0] = horizontalSum * windowXReciprocal >> 16;
                    const local128 = horizontalSum - src[x0 - this.radiusX & Texture6.widthMask];
                    x0++;
                    horizontalSum = local128 + src[Texture6.widthMask & x0 + this.radiusX];
                  }
                }
                ;
                horizontalAverages[y0 + this.radiusY - y] = horizontalAverage;
              }
              ;
            }
            for (let x0 = 0; x0 < Texture6.width; x0++) {
              {
                let verticalSum = 0;
                for (let y0 = 0; y0 < windowY; y0++) {
                  {
                    verticalSum += horizontalAverages[y0][x0];
                  }
                  ;
                }
                dest[x0] = verticalSum * windowYReciprocal >> 16;
              }
              ;
            }
          }
          return dest;
        }
      }
      TextureOpBoxBlur["__class"] = "TextureOpBoxBlur";
      class TextureOpBricks extends TextureOp2 {
        constructor() {
          super(0, true);
          if (this.anInt4937 === void 0) {
            this.anInt4937 = 0;
          }
          if (this.anIntArrayArray41 === void 0) {
            this.anIntArrayArray41 = null;
          }
          if (this.anInt4948 === void 0) {
            this.anInt4948 = 0;
          }
          if (this.anIntArray536 === void 0) {
            this.anIntArray536 = null;
          }
          if (this.anInt4949 === void 0) {
            this.anInt4949 = 0;
          }
          if (this.anIntArrayArray42 === void 0) {
            this.anIntArrayArray42 = null;
          }
          this.anInt4935 = 81;
          this.anInt4943 = 4;
          this.anInt4944 = 0;
          this.anInt4942 = 1024;
          this.anInt4941 = 1024;
          this.anInt4945 = 409;
          this.anInt4954 = 204;
          this.anInt4936 = 8;
        }
        /*private*/
        method4057() {
          const random = new Random(this.anInt4936);
          this.anInt4937 = 4096 / this.anInt4936 | 0;
          this.anIntArray536 = ((s) => {
            let a = [];
            while (s-- > 0)
              a.push(0);
            return a;
          })(this.anInt4936 + 1);
          this.anIntArrayArray41 = (function(dims) {
            let allocate = function(dims2) {
              if (dims2.length === 0) {
                return 0;
              } else {
                let array2 = [];
                for (let i = 0; i < dims2[0]; i++) {
                  array2.push(allocate(dims2.slice(1)));
                }
                return array2;
              }
            };
            return allocate(dims);
          })([this.anInt4936, this.anInt4943 + 1]);
          this.anIntArrayArray42 = (function(dims) {
            let allocate = function(dims2) {
              if (dims2.length === 0) {
                return 0;
              } else {
                let array2 = [];
                for (let i = 0; i < dims2[0]; i++) {
                  array2.push(allocate(dims2.slice(1)));
                }
                return array2;
              }
            };
            return allocate(dims);
          })([this.anInt4936, this.anInt4943]);
          this.anIntArray536[0] = 0;
          this.anInt4949 = 4096 / this.anInt4943 | 0;
          const local57 = this.anInt4949 / 2 | 0;
          this.anInt4948 = this.anInt4935 / 2 | 0;
          const local68 = this.anInt4937 / 2 | 0;
          for (let local74 = 0; local74 < this.anInt4936; local74++) {
            {
              if (local74 > 0) {
                let local87 = this.anInt4937;
                const local99 = (RandomUtils.nextInt(random, 4096) - 2048) * this.anInt4954 >> 12;
                local87 += local99 * local68 >> 12;
                this.anIntArray536[local74] = local87 + this.anIntArray536[local74 - 1];
              }
              this.anIntArrayArray41[local74][0] = 0;
              for (let local128 = 0; local128 < this.anInt4943; local128++) {
                {
                  if (local128 > 0) {
                    let local139 = this.anInt4949;
                    const local153 = (RandomUtils.nextInt(random, 4096) - 2048) * this.anInt4945 >> 12;
                    local139 += local57 * local153 >> 12;
                    this.anIntArrayArray41[local74][local128] = this.anIntArrayArray41[local74][local128 - 1] + local139;
                  }
                  this.anIntArrayArray42[local74][local128] = this.anInt4941 <= 0 ? 4096 : 4096 - RandomUtils.nextInt(random, this.anInt4941);
                }
                ;
              }
              this.anIntArrayArray41[local74][this.anInt4943] = 4096;
            }
            ;
          }
          this.anIntArray536[this.anInt4936] = 4096;
        }
        postDecode() {
          this.method4057();
        }
        decode(buffer, code) {
          if (code === 0) {
            this.anInt4943 = buffer.readUnsignedByte();
          } else if (code === 1) {
            this.anInt4936 = buffer.readUnsignedByte();
          } else if (code === 2) {
            this.anInt4945 = buffer.readUnsignedShort();
          } else if (code === 3) {
            this.anInt4954 = buffer.readUnsignedShort();
          } else if (code === 4) {
            this.anInt4942 = buffer.readUnsignedShort();
          } else if (code === 5) {
            this.anInt4944 = buffer.readUnsignedShort();
          } else if (code === 6) {
            this.anInt4935 = buffer.readUnsignedShort();
          } else if (code === 7) {
            this.anInt4941 = buffer.readUnsignedShort();
          }
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            let local19 = 0;
            let local26;
            for (local26 = this.anInt4944 + Texture6.normalisedY[y]; local26 < 0; local26 += 4096) {
              {
              }
              ;
            }
            while (local26 > 4096) {
              {
                local26 -= 4096;
              }
            }
            ;
            while (this.anInt4936 > local19 && local26 >= this.anIntArray536[local19]) {
              {
                local19++;
              }
            }
            ;
            const local64 = local19 - 1;
            const local69 = this.anIntArray536[local19];
            const local80 = (local19 & 1) === 0;
            const local87 = this.anIntArray536[local19 - 1];
            if (local87 + this.anInt4948 < local26 && local26 < local69 - this.anInt4948) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  const local123 = local80 ? this.anInt4942 : -this.anInt4942;
                  let local135 = Texture6.normalisedX[x] + (local123 * this.anInt4949 >> 12);
                  let local137 = 0;
                  while (local135 < 0) {
                    {
                      local135 += 4096;
                    }
                  }
                  ;
                  while (local135 > 4096) {
                    {
                      local135 -= 4096;
                    }
                  }
                  ;
                  while (local137 < this.anInt4943 && local135 >= this.anIntArrayArray41[local64][local137]) {
                    {
                      local137++;
                    }
                  }
                  ;
                  const local175 = this.anIntArrayArray41[local64][local137];
                  const local179 = local137 - 1;
                  const local186 = this.anIntArrayArray41[local64][local179];
                  if (local186 + this.anInt4948 < local135 && local175 - this.anInt4948 > local135) {
                    dest[x] = this.anIntArrayArray42[local64][local179];
                  } else {
                    dest[x] = 0;
                  }
                }
                ;
              }
            } else {
              ArrayUtils.fill$int_A$int$int$int(dest, 0, Texture6.width, 0);
            }
          }
          return dest;
        }
      }
      TextureOpBricks["__class"] = "TextureOpBricks";
      class TextureOpBrightness extends TextureOp2 {
        constructor() {
          super(1, false);
          this.maxValue = 409;
          this.redFactor = 4096;
          this.blueFactor = 4096;
          this.colorDelta = [0, 0, 0];
          this.greenFactor = 4096;
        }
        getColorOutput(y) {
          const dest = this.colorImageCache.get$int(y);
          if (this.colorImageCache.invalid) {
            const src = this.getChildColorOutput(0, y);
            const srcRed = src[0];
            const srcGreen = src[1];
            const srcBlue = src[2];
            const destGreen = dest[1];
            const destRed = dest[0];
            const destBlue = dest[2];
            for (let x = 0; x < Texture6.width; x++) {
              {
                const r = srcRed[x];
                let absR = r - this.colorDelta[0];
                if (absR < 0) {
                  absR = -absR;
                }
                if (absR <= this.maxValue) {
                  const g = srcGreen[x];
                  let absG = g - this.colorDelta[1];
                  if (absG < 0) {
                    absG = -absG;
                  }
                  if (absG <= this.maxValue) {
                    const b = srcBlue[x];
                    let absB = b - this.colorDelta[2];
                    if (absB < 0) {
                      absB = -absB;
                    }
                    if (absB <= this.maxValue) {
                      destRed[x] = r * this.redFactor >> 12;
                      destGreen[x] = g * this.greenFactor >> 12;
                      destBlue[x] = b * this.blueFactor >> 12;
                    } else {
                      destRed[x] = r;
                      destGreen[x] = g;
                      destBlue[x] = b;
                    }
                  } else {
                    destRed[x] = r;
                    destGreen[x] = g;
                    destBlue[x] = srcBlue[x];
                  }
                } else {
                  destRed[x] = r;
                  destGreen[x] = srcGreen[x];
                  destBlue[x] = srcBlue[x];
                }
              }
              ;
            }
          }
          return dest;
        }
        decode(buffer, code) {
          if (code === 0) {
            this.maxValue = buffer.readUnsignedShort();
          } else if (code === 1) {
            this.blueFactor = buffer.readUnsignedShort();
          } else if (code === 2) {
            this.greenFactor = buffer.readUnsignedShort();
          } else if (code === 3) {
            this.redFactor = buffer.readUnsignedShort();
          } else if (code === 4) {
            const rgb = buffer.readUnsignedMedium();
            this.colorDelta[0] = (rgb & 16711680) << 4;
            this.colorDelta[2] = rgb >> 12 & 0;
            this.colorDelta[1] = rgb >> 4 & 4080;
          }
        }
      }
      TextureOpBrightness["__class"] = "TextureOpBrightness";
      class TextureOpClamp extends TextureOp2 {
        constructor() {
          super(1, false);
          this.minValue = 0;
          this.maxValue = 4096;
        }
        decode(buffer, code) {
          if (code === 0) {
            this.minValue = buffer.readUnsignedShort();
          } else if (code === 1) {
            this.maxValue = buffer.readUnsignedShort();
          } else if (code === 2) {
            this.monochrome = buffer.readUnsignedByte() === 1;
          }
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            const src = this.getChildMonochromeOutput(0, y);
            for (let x = 0; x < Texture6.width; x++) {
              {
                const value = src[x];
                if (value < this.minValue) {
                  dest[x] = this.minValue;
                } else if (value > this.maxValue) {
                  dest[x] = this.maxValue;
                } else {
                  dest[x] = value;
                }
              }
              ;
            }
          }
          return dest;
        }
        getColorOutput(y) {
          const dest = this.colorImageCache.get$int(y);
          if (this.colorImageCache.invalid) {
            const src = this.getChildColorOutput(0, y);
            const srcRed = src[0];
            const srcGreen = src[1];
            const destRed = dest[0];
            const srcBlue = src[2];
            const destGreen = dest[1];
            const destBlue = dest[2];
            for (let x = 0; x < Texture6.width; x++) {
              {
                const green = srcGreen[x];
                const red2 = srcRed[x];
                const blue = srcBlue[x];
                if (red2 < this.minValue) {
                  destRed[x] = this.minValue;
                } else if (red2 > this.maxValue) {
                  destRed[x] = this.maxValue;
                } else {
                  destRed[x] = red2;
                }
                if (green < this.minValue) {
                  destGreen[x] = this.minValue;
                } else if (green > this.maxValue) {
                  destGreen[x] = this.maxValue;
                } else {
                  destGreen[x] = green;
                }
                if (blue < this.minValue) {
                  destBlue[x] = this.minValue;
                } else if (blue > this.maxValue) {
                  destBlue[x] = this.maxValue;
                } else {
                  destBlue[x] = blue;
                }
              }
              ;
            }
          }
          return dest;
        }
      }
      TextureOpClamp["__class"] = "TextureOpClamp";
      class TextureOpColorEdgeDetector extends TextureOp2 {
        constructor() {
          super(1, false);
          this.anInt3634 = 4096;
          this.aBoolean263 = true;
        }
        decode(buffer, code) {
          if (code === 0) {
            this.anInt3634 = buffer.readUnsignedShort();
          } else if (code === 1) {
            this.aBoolean263 = buffer.readUnsignedByte() === 1;
          }
        }
        getColorOutput(y) {
          const dest = this.colorImageCache.get$int(y);
          if (this.colorImageCache.invalid) {
            const src0 = this.getChildMonochromeOutput(0, Texture6.heightMask & y - 1);
            const src1 = this.getChildMonochromeOutput(0, y);
            const src2 = this.getChildMonochromeOutput(0, y + 1 & Texture6.heightMask);
            const destRed = dest[0];
            const destGreen = dest[1];
            const destBlue = dest[2];
            for (let x = 0; x < Texture6.width; x++) {
              {
                const dy = (src2[x] - src0[x]) * this.anInt3634;
                const dx = this.anInt3634 * (src1[x + 1 & Texture6.widthMask] - src1[x - 1 & Texture6.widthMask]);
                const dy0 = dy >> 12;
                const dx0 = dx >> 12;
                const dySquared = dy0 * dy0 >> 12;
                const dxSquared = dx0 * dx0 >> 12;
                const local137 = Math.sqrt(Math.fround((dySquared + dxSquared + 4096) / 4096)) * 4096 | 0;
                let red2;
                let green;
                let blue;
                if (local137 === 0) {
                  green = 0;
                  blue = 0;
                  red2 = 0;
                } else {
                  green = dy / local137 | 0;
                  blue = 16777216 / local137 | 0;
                  red2 = dx / local137 | 0;
                }
                if (this.aBoolean263) {
                  red2 = (red2 >> 1) + 2048;
                  green = (green >> 1) + 2048;
                  blue = (blue >> 1) + 2048;
                }
                destRed[x] = red2;
                destGreen[x] = green;
                destBlue[x] = blue;
              }
              ;
            }
          }
          return dest;
        }
      }
      TextureOpColorEdgeDetector["__class"] = "TextureOpColorEdgeDetector";
      class TextureOpColorFill extends TextureOp2 {
        constructor(color) {
          if (typeof color === "number" || color === null) {
            let __args = arguments;
            super(0, false);
            if (this.blue === void 0) {
              this.blue = 0;
            }
            if (this.green === void 0) {
              this.green = 0;
            }
            if (this.red === void 0) {
              this.red = 0;
            }
            this.setColor(color);
          } else if (color === void 0) {
            let __args = arguments;
            {
              let __args2 = arguments;
              let color2 = 0;
              super(0, false);
              if (this.blue === void 0) {
                this.blue = 0;
              }
              if (this.green === void 0) {
                this.green = 0;
              }
              if (this.red === void 0) {
                this.red = 0;
              }
              this.setColor(color2);
            }
            if (this.blue === void 0) {
              this.blue = 0;
            }
            if (this.green === void 0) {
              this.green = 0;
            }
            if (this.red === void 0) {
              this.red = 0;
            }
          } else
            throw new Error("invalid overload");
        }
        decode(buffer, code) {
          if (code === 0) {
            this.setColor(buffer.readUnsignedMedium());
          }
        }
        getColorOutput(y) {
          const dest = this.colorImageCache.get$int(y);
          if (this.colorImageCache.invalid) {
            const green = dest[1];
            const red2 = dest[0];
            const blue = dest[2];
            for (let x = 0; x < Texture6.width; x++) {
              {
                red2[x] = this.red;
                green[x] = this.green;
                blue[x] = this.blue;
              }
              ;
            }
          }
          return dest;
        }
        /*private*/
        setColor(color) {
          this.green = color >> 4 & 4080;
          this.red = color >> 12 & 4080;
          this.blue = (color & 255) << 4;
        }
      }
      TextureOpColorFill["__class"] = "TextureOpColorFill";
      class TextureOpColorGradient extends TextureOp2 {
        constructor() {
          super(1, false);
          if (this.samples === void 0) {
            this.samples = null;
          }
          this.colors = ((s) => {
            let a = [];
            while (s-- > 0)
              a.push(0);
            return a;
          })(257);
        }
        /*private*/
        setPreset(preset) {
          if (preset === 0) {
            return;
          }
          if (preset === 1) {
            this.samples = (function(dims) {
              let allocate = function(dims2) {
                if (dims2.length === 0) {
                  return 0;
                } else {
                  let array2 = [];
                  for (let i = 0; i < dims2[0]; i++) {
                    array2.push(allocate(dims2.slice(1)));
                  }
                  return array2;
                }
              };
              return allocate(dims);
            })([2, 4]);
            this.samples[0][0] = 0;
            this.samples[0][3] = 0;
            this.samples[0][1] = 0;
            this.samples[1][0] = 4096;
            this.samples[0][2] = 0;
            this.samples[1][2] = 4096;
            this.samples[1][1] = 4096;
            this.samples[1][3] = 4096;
          } else if (preset === 2) {
            this.samples = (function(dims) {
              let allocate = function(dims2) {
                if (dims2.length === 0) {
                  return 0;
                } else {
                  let array2 = [];
                  for (let i = 0; i < dims2[0]; i++) {
                    array2.push(allocate(dims2.slice(1)));
                  }
                  return array2;
                }
              };
              return allocate(dims);
            })([8, 4]);
            this.samples[0][0] = 0;
            this.samples[0][1] = 2650;
            this.samples[0][2] = 2602;
            this.samples[1][0] = 2867;
            this.samples[2][0] = 3072;
            this.samples[1][2] = 1799;
            this.samples[1][1] = 2313;
            this.samples[2][2] = 1734;
            this.samples[3][2] = 1220;
            this.samples[4][2] = 963;
            this.samples[0][3] = 2361;
            this.samples[5][2] = 2152;
            this.samples[3][0] = 3276;
            this.samples[2][1] = 2618;
            this.samples[6][2] = 1060;
            this.samples[4][0] = 3481;
            this.samples[1][3] = 1558;
            this.samples[7][2] = 1413;
            this.samples[5][0] = 3686;
            this.samples[6][0] = 3891;
            this.samples[7][0] = 4096;
            this.samples[3][1] = 2296;
            this.samples[2][3] = 1413;
            this.samples[3][3] = 947;
            this.samples[4][1] = 2072;
            this.samples[5][1] = 2730;
            this.samples[6][1] = 2232;
            this.samples[7][1] = 1686;
            this.samples[4][3] = 722;
            this.samples[5][3] = 1766;
            this.samples[6][3] = 915;
            this.samples[7][3] = 1140;
          } else if (preset === 3) {
            this.samples = (function(dims) {
              let allocate = function(dims2) {
                if (dims2.length === 0) {
                  return 0;
                } else {
                  let array2 = [];
                  for (let i = 0; i < dims2[0]; i++) {
                    array2.push(allocate(dims2.slice(1)));
                  }
                  return array2;
                }
              };
              return allocate(dims);
            })([7, 4]);
            this.samples[0][3] = 4096;
            this.samples[0][2] = 0;
            this.samples[1][3] = 4096;
            this.samples[2][3] = 0;
            this.samples[0][0] = 0;
            this.samples[3][3] = 0;
            this.samples[4][3] = 0;
            this.samples[1][2] = 4096;
            this.samples[2][2] = 4096;
            this.samples[5][3] = 4096;
            this.samples[3][2] = 4096;
            this.samples[0][1] = 0;
            this.samples[1][0] = 663;
            this.samples[1][1] = 0;
            this.samples[6][3] = 4096;
            this.samples[2][1] = 0;
            this.samples[4][2] = 0;
            this.samples[5][2] = 0;
            this.samples[2][0] = 1363;
            this.samples[3][0] = 2048;
            this.samples[3][1] = 4096;
            this.samples[4][0] = 2727;
            this.samples[6][2] = 0;
            this.samples[4][1] = 4096;
            this.samples[5][0] = 3411;
            this.samples[6][0] = 4096;
            this.samples[5][1] = 4096;
            this.samples[6][1] = 0;
          } else if (preset === 4) {
            this.samples = (function(dims) {
              let allocate = function(dims2) {
                if (dims2.length === 0) {
                  return 0;
                } else {
                  let array2 = [];
                  for (let i = 0; i < dims2[0]; i++) {
                    array2.push(allocate(dims2.slice(1)));
                  }
                  return array2;
                }
              };
              return allocate(dims);
            })([6, 4]);
            this.samples[0][0] = 0;
            this.samples[0][1] = 0;
            this.samples[0][2] = 0;
            this.samples[1][2] = 0;
            this.samples[0][3] = 0;
            this.samples[1][0] = 1843;
            this.samples[1][1] = 0;
            this.samples[2][0] = 2457;
            this.samples[1][3] = 1493;
            this.samples[2][1] = 0;
            this.samples[3][1] = 0;
            this.samples[2][2] = 0;
            this.samples[3][2] = 1124;
            this.samples[3][0] = 2781;
            this.samples[2][3] = 2939;
            this.samples[3][3] = 3565;
            this.samples[4][0] = 3481;
            this.samples[5][0] = 4096;
            this.samples[4][3] = 4031;
            this.samples[4][2] = 3084;
            this.samples[4][1] = 546;
            this.samples[5][2] = 4096;
            this.samples[5][3] = 4096;
            this.samples[5][1] = 4096;
          } else if (preset === 5) {
            this.samples = (function(dims) {
              let allocate = function(dims2) {
                if (dims2.length === 0) {
                  return 0;
                } else {
                  let array2 = [];
                  for (let i = 0; i < dims2[0]; i++) {
                    array2.push(allocate(dims2.slice(1)));
                  }
                  return array2;
                }
              };
              return allocate(dims);
            })([16, 4]);
            this.samples[0][2] = 192;
            this.samples[0][1] = 80;
            this.samples[0][3] = 321;
            this.samples[0][0] = 0;
            this.samples[1][2] = 449;
            this.samples[1][1] = 321;
            this.samples[2][1] = 578;
            this.samples[1][3] = 562;
            this.samples[2][2] = 690;
            this.samples[2][3] = 803;
            this.samples[3][3] = 1140;
            this.samples[3][1] = 947;
            this.samples[3][2] = 995;
            this.samples[1][0] = 155;
            this.samples[2][0] = 389;
            this.samples[3][0] = 671;
            this.samples[4][2] = 1397;
            this.samples[5][2] = 1429;
            this.samples[4][0] = 897;
            this.samples[4][3] = 1509;
            this.samples[6][2] = 1461;
            this.samples[5][3] = 1413;
            this.samples[4][1] = 1285;
            this.samples[6][3] = 1333;
            this.samples[5][0] = 1175;
            this.samples[7][3] = 1702;
            this.samples[8][3] = 2056;
            this.samples[6][0] = 1368;
            this.samples[9][3] = 2666;
            this.samples[10][3] = 3276;
            this.samples[5][1] = 1525;
            this.samples[7][0] = 1507;
            this.samples[7][2] = 1525;
            this.samples[6][1] = 1734;
            this.samples[11][3] = 3228;
            this.samples[8][0] = 1736;
            this.samples[9][0] = 2088;
            this.samples[7][1] = 1413;
            this.samples[8][2] = 1590;
            this.samples[9][2] = 2056;
            this.samples[8][1] = 1108;
            this.samples[10][0] = 2355;
            this.samples[9][1] = 1766;
            this.samples[11][0] = 2691;
            this.samples[10][1] = 2409;
            this.samples[12][0] = 3031;
            this.samples[13][0] = 3522;
            this.samples[10][2] = 2586;
            this.samples[11][1] = 3116;
            this.samples[11][2] = 3148;
            this.samples[12][3] = 3196;
            this.samples[14][0] = 3727;
            this.samples[15][0] = 4096;
            this.samples[12][2] = 3710;
            this.samples[13][3] = 3019;
            this.samples[13][2] = 3421;
            this.samples[12][1] = 3806;
            this.samples[14][3] = 3228;
            this.samples[15][3] = 2746;
            this.samples[13][1] = 3437;
            this.samples[14][1] = 3116;
            this.samples[15][1] = 2377;
            this.samples[14][2] = 3148;
            this.samples[15][2] = 2505;
          } else if (preset === 6) {
            this.samples = (function(dims) {
              let allocate = function(dims2) {
                if (dims2.length === 0) {
                  return 0;
                } else {
                  let array2 = [];
                  for (let i = 0; i < dims2[0]; i++) {
                    array2.push(allocate(dims2.slice(1)));
                  }
                  return array2;
                }
              };
              return allocate(dims);
            })([4, 4]);
            this.samples[0][3] = 0;
            this.samples[0][1] = 0;
            this.samples[1][3] = 0;
            this.samples[0][2] = 4096;
            this.samples[1][2] = 4096;
            this.samples[2][3] = 0;
            this.samples[2][2] = 4096;
            this.samples[0][0] = 2048;
            this.samples[3][3] = 0;
            this.samples[1][1] = 4096;
            this.samples[3][2] = 0;
            this.samples[1][0] = 2867;
            this.samples[2][1] = 4096;
            this.samples[3][1] = 4096;
            this.samples[2][0] = 3276;
            this.samples[3][0] = 4096;
          } else {
            throw Object.defineProperty(new Error("Invalid gradient preset"), "__classes", { configurable: true, value: ["java.lang.Throwable", "java.lang.Object", "java.lang.RuntimeException", "java.lang.Exception"] });
          }
        }
        /*private*/
        interpolate() {
          const samplesLen = this.samples.length;
          if (samplesLen <= 0) {
            return;
          }
          for (let i = 0; i < 257; i++) {
            {
              let sample = 0;
              const position = i << 4;
              for (let j = 0; j < samplesLen && position >= this.samples[j][0]; j++) {
                {
                  sample++;
                }
                ;
              }
              let red2;
              let green;
              let blue;
              if (sample >= samplesLen) {
                const lastSample = this.samples[samplesLen - 1];
                blue = lastSample[3];
                red2 = lastSample[1];
                green = lastSample[2];
              } else {
                const nextSample = this.samples[sample];
                if (sample <= 0) {
                  green = nextSample[2];
                  red2 = nextSample[1];
                  blue = nextSample[3];
                } else {
                  const prevSample = this.samples[sample - 1];
                  const nextWeight = (position - prevSample[0] << 12) / (nextSample[0] - prevSample[0]) | 0;
                  const prevWeight = 4096 - nextWeight;
                  green = nextSample[2] * nextWeight + prevSample[2] * prevWeight >> 12;
                  red2 = nextSample[1] * nextWeight + prevSample[1] * prevWeight >> 12;
                  blue = nextSample[3] * nextWeight + prevSample[3] * prevWeight >> 12;
                }
              }
              let green2 = green >> 4;
              if (green2 < 0) {
                green2 = 0;
              } else if (green2 > 255) {
                green2 = 255;
              }
              let blue2 = blue >> 4;
              let red22 = red2 >> 4;
              if (red22 < 0) {
                red22 = 0;
              } else if (red22 > 255) {
                red22 = 255;
              }
              if (blue2 < 0) {
                blue2 = 0;
              } else if (blue2 > 255) {
                blue2 = 255;
              }
              this.colors[i] = blue2 | green2 << 8 | red22 << 16;
            }
            ;
          }
        }
        postDecode() {
          if (this.samples == null) {
            this.setPreset(1);
          }
          this.interpolate();
        }
        decode(buffer, code) {
          if (code !== 0) {
            return;
          }
          const preset = buffer.readUnsignedByte();
          if (preset !== 0) {
            this.setPreset(preset);
            return;
          }
          this.samples = (function(dims) {
            let allocate = function(dims2) {
              if (dims2.length === 0) {
                return 0;
              } else {
                let array2 = [];
                for (let i = 0; i < dims2[0]; i++) {
                  array2.push(allocate(dims2.slice(1)));
                }
                return array2;
              }
            };
            return allocate(dims);
          })([buffer.readUnsignedByte(), 4]);
          for (let i = 0; i < this.samples.length; i++) {
            {
              this.samples[i][0] = buffer.readUnsignedShort();
              this.samples[i][1] = buffer.readUnsignedByte() << 4;
              this.samples[i][2] = buffer.readUnsignedByte() << 4;
              this.samples[i][3] = buffer.readUnsignedByte() << 4;
            }
            ;
          }
        }
        getColorOutput(y) {
          const dest = this.colorImageCache.get$int(y);
          if (this.colorImageCache.invalid) {
            const src = this.getChildMonochromeOutput(0, y);
            const green = dest[1];
            const blue = dest[2];
            const red2 = dest[0];
            for (let x = 0; x < Texture6.width; x++) {
              {
                let value = src[x] >> 4;
                if (value < 0) {
                  value = 0;
                }
                if (value > 256) {
                  value = 256;
                }
                const color = this.colors[value];
                red2[x] = color >> 12 & 4080;
                green[x] = color >> 4 & 4080;
                blue[x] = (color & 255) << 4;
              }
              ;
            }
          }
          return dest;
        }
      }
      TextureOpColorGradient["__class"] = "TextureOpColorGradient";
      class TextureOpColorize extends TextureOp2 {
        constructor() {
          super(1, false);
          this.green = 4096;
          this.red = 4096;
          this.blue = 4096;
        }
        decode(buffer, code) {
          if (code === 0) {
            this.red = buffer.readUnsignedShort();
          } else if (code === 1) {
            this.green = buffer.readUnsignedShort();
          } else if (code === 2) {
            this.blue = buffer.readUnsignedShort();
          }
        }
        getColorOutput(y) {
          const dest = this.colorImageCache.get$int(y);
          if (this.colorImageCache.invalid) {
            const src = this.getChildColorOutput(0, y);
            const srcGreen = src[1];
            const srcRed = src[0];
            const destRed = dest[0];
            const destGreen = dest[1];
            const srcBlue = src[2];
            const destBlue = dest[2];
            for (let x = 0; x < Texture6.width; x++) {
              {
                const red2 = srcRed[x];
                const blue = srcBlue[x];
                const green = srcGreen[x];
                if (red2 === blue && blue === green) {
                  destRed[x] = this.red * red2 >> 12;
                  destGreen[x] = this.green * blue >> 12;
                  destBlue[x] = this.blue * green >> 12;
                } else {
                  destRed[x] = this.red;
                  destGreen[x] = this.green;
                  destBlue[x] = this.blue;
                }
              }
              ;
            }
          }
          return dest;
        }
      }
      TextureOpColorize["__class"] = "TextureOpColorize";
      class TextureOpCombine extends TextureOp2 {
        constructor() {
          super(2, false);
          this.function = 6;
        }
        decode(buffer, code) {
          if (code === 0) {
            this.function = buffer.readUnsignedByte();
          } else if (code === 1) {
            this.monochrome = buffer.readUnsignedByte() === 1;
          }
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            const src0 = this.getChildMonochromeOutput(0, y);
            const src1 = this.getChildMonochromeOutput(1, y);
            const __function = this.function;
            if (__function === 1) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  dest[x] = src1[x] + src0[x];
                }
                ;
              }
            } else if (__function === 2) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  dest[x] = src0[x] - src1[x];
                }
                ;
              }
            } else if (__function === 3) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  dest[x] = src0[x] * src1[x] >> 12;
                }
                ;
              }
            } else if (__function === 4) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  const value1 = src1[x];
                  dest[x] = value1 === 0 ? 4096 : (src0[x] << 12) / value1 | 0;
                }
                ;
              }
            } else if (__function === 5) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  dest[x] = 4096 - ((4096 - src0[x]) * (4096 - src1[x]) >> 12);
                }
                ;
              }
            } else if (__function === 6) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  const value1 = src1[x];
                  dest[x] = value1 >= 2048 ? 4096 - ((4096 - value1) * (4096 - src0[x]) >> 11) : value1 * src0[x] >> 11;
                }
                ;
              }
            } else if (__function === 7) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  const value0 = src0[x];
                  dest[x] = value0 === 4096 ? 4096 : (src1[x] << 12) / (4096 - value0) | 0;
                }
                ;
              }
            } else if (__function === 8) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  const value = src0[x];
                  dest[x] = value === 0 ? 0 : 4096 - ((4096 - src1[x] << 12) / value | 0);
                }
                ;
              }
            } else if (__function === 9) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  const value0 = src0[x];
                  const value1 = src1[x];
                  dest[x] = value0 < value1 ? value0 : value1;
                }
                ;
              }
            } else if (__function === 10) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  const value0 = src0[x];
                  const value1 = src1[x];
                  dest[x] = value0 <= value1 ? value1 : value0;
                }
                ;
              }
            } else if (__function === 11) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  const value1 = src1[x];
                  const value0 = src0[x];
                  dest[x] = value0 > value1 ? value0 - value1 : value1 - value0;
                }
                ;
              }
            } else if (__function === 12) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  const value0 = src0[x];
                  const value1 = src1[x];
                  dest[x] = value0 + value1 - (value0 * value1 >> 11);
                }
                ;
              }
            }
          }
          return dest;
        }
        getColorOutput(y) {
          const dest = this.colorImageCache.get$int(y);
          if (this.colorImageCache.invalid) {
            const src0 = this.getChildColorOutput(0, y);
            const src1 = this.getChildColorOutput(1, y);
            const destRed = dest[0];
            const destGreen = dest[1];
            const src0Red = src0[0];
            const destBlue = dest[2];
            const src0Green = src0[1];
            const src1Blue = src1[2];
            const src0Blue = src0[2];
            const src1Green = src1[1];
            const src1Red = src1[0];
            const __function = this.function;
            if (__function === 1) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  destRed[x] = src0Red[x] + src1Red[x];
                  destGreen[x] = src0Green[x] + src1Green[x];
                  destBlue[x] = src0Blue[x] + src1Blue[x];
                }
                ;
              }
            } else if (__function === 2) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  destRed[x] = src0Red[x] - src1Red[x];
                  destGreen[x] = src0Green[x] - src1Green[x];
                  destBlue[x] = src0Blue[x] - src1Blue[x];
                }
                ;
              }
            } else if (__function === 3) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  destRed[x] = src0Red[x] * src1Red[x] >> 12;
                  destGreen[x] = src1Green[x] * src0Green[x] >> 12;
                  destBlue[x] = src1Blue[x] * src0Blue[x] >> 12;
                }
                ;
              }
            } else if (__function === 4) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  const green1 = src1Green[x];
                  const red1 = src1Red[x];
                  const blue1 = src1Blue[x];
                  destRed[x] = red1 === 0 ? 4096 : (src0Red[x] << 12) / red1 | 0;
                  destGreen[x] = green1 === 0 ? 4096 : (src0Green[x] << 12) / green1 | 0;
                  destBlue[x] = blue1 === 0 ? 4096 : (src0Blue[x] << 12) / blue1 | 0;
                }
                ;
              }
            } else if (__function === 5) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  destRed[x] = 4096 - ((4096 - src0Red[x]) * (4096 - src1Red[x]) >> 12);
                  destGreen[x] = 4096 - ((4096 - src0Green[x]) * (4096 - src1Green[x]) >> 12);
                  destBlue[x] = 4096 - ((4096 - src0Blue[x]) * (4096 - src1Blue[x]) >> 12);
                }
                ;
              }
            } else if (__function === 6) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  const green1 = src1Green[x];
                  const red1 = src1Red[x];
                  const blue1 = src1Blue[x];
                  destRed[x] = red1 >= 2048 ? 4096 - ((4096 - src0Red[x]) * (4096 - red1) >> 11) : red1 * src0Red[x] >> 11;
                  destGreen[x] = green1 >= 2048 ? 4096 - ((4096 - src0Green[x]) * (4096 - green1) >> 11) : src0Green[x] * green1 >> 11;
                  destBlue[x] = blue1 >= 2048 ? 4096 - ((4096 - src0Blue[x]) * (4096 - blue1) >> 11) : src0Blue[x] * blue1 >> 11;
                }
                ;
              }
            } else if (__function === 7) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  const blue0 = src0Blue[x];
                  const green0 = src0Green[x];
                  const red0 = src0Red[x];
                  destRed[x] = red0 === 4096 ? 4096 : (src1Red[x] << 12) / (4096 - red0) | 0;
                  destGreen[x] = green0 === 4096 ? 4096 : (src1Green[x] << 12) / (4096 - green0) | 0;
                  destBlue[x] = blue0 === 4096 ? 4096 : (src1Blue[x] << 12) / (4096 - blue0) | 0;
                }
                ;
              }
            } else if (__function === 8) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  const green0 = src0Green[x];
                  const blue0 = src0Blue[x];
                  const red0 = src0Red[x];
                  destRed[x] = red0 === 0 ? 0 : 4096 - ((4096 - src1Red[x] << 12) / red0 | 0);
                  destGreen[x] = green0 === 0 ? 0 : 4096 - ((4096 - src1Green[x] << 12) / green0 | 0);
                  destBlue[x] = blue0 === 0 ? 0 : 4096 - ((4096 - src1Blue[x] << 12) / blue0 | 0);
                }
                ;
              }
            } else if (__function === 9) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  const blue0 = src0Blue[x];
                  const blue1 = src1Blue[x];
                  const green1 = src1Green[x];
                  const red1 = src1Red[x];
                  const red0 = src0Red[x];
                  const green0 = src0Green[x];
                  destRed[x] = red0 < red1 ? red0 : red1;
                  destGreen[x] = green0 < green1 ? green0 : green1;
                  destBlue[x] = blue0 < blue1 ? blue0 : blue1;
                }
                ;
              }
            } else if (__function === 10) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  const red0 = src0Red[x];
                  const blue0 = src0Blue[x];
                  const blue1 = src1Blue[x];
                  const red1 = src1Red[x];
                  const green1 = src1Green[x];
                  const green0 = src0Green[x];
                  destRed[x] = red0 > red1 ? red0 : red1;
                  destGreen[x] = green0 > green1 ? green0 : green1;
                  destBlue[x] = blue0 > blue1 ? blue0 : blue1;
                }
                ;
              }
            } else if (__function === 11) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  const red1 = src1Red[x];
                  const green1 = src1Green[x];
                  const blue0 = src0Blue[x];
                  const blue1 = src1Blue[x];
                  const red0 = src0Red[x];
                  const green0 = src0Green[x];
                  destRed[x] = red0 <= red1 ? red1 - red0 : red0 - red1;
                  destGreen[x] = green0 <= green1 ? green1 - green0 : green0 - green1;
                  destBlue[x] = blue0 <= blue1 ? blue1 - blue0 : blue0 - blue1;
                }
                ;
              }
            } else if (__function === 12) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  const green0 = src0Green[x];
                  const blue0 = src0Blue[x];
                  const red1 = src1Red[x];
                  const blue1 = src1Blue[x];
                  const red0 = src0Red[x];
                  const green1 = src1Green[x];
                  destRed[x] = red1 + red0 - (red0 * red1 >> 11);
                  destGreen[x] = green0 + green1 - (green0 * green1 >> 11);
                  destBlue[x] = blue0 + blue1 - (blue0 * blue1 >> 11);
                }
                ;
              }
            }
          }
          return dest;
        }
      }
      TextureOpCombine["__class"] = "TextureOpCombine";
      class TextureOpCurve extends TextureOp2 {
        constructor() {
          super(1, true);
          if (this.markers === void 0) {
            this.markers = null;
          }
          if (this.firstMarker === void 0) {
            this.firstMarker = null;
          }
          if (this.lastMarker === void 0) {
            this.lastMarker = null;
          }
          this.aShortArray73 = ((s) => {
            let a = [];
            while (s-- > 0)
              a.push(0);
            return a;
          })(257);
          this.anInt3819 = 0;
        }
        /*private*/
        getMarker(index) {
          if (index < 0) {
            return this.firstMarker;
          } else if (index < this.markers.length) {
            return this.markers[index];
          } else {
            return this.lastMarker;
          }
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            const src = this.getChildMonochromeOutput(0, y);
            for (let x = 0; x < Texture6.width; x++) {
              {
                let local43 = src[x] >> 4;
                if (local43 < 0) {
                  local43 = 0;
                }
                if (local43 > 256) {
                  local43 = 256;
                }
                dest[x] = this.aShortArray73[local43];
              }
              ;
            }
          }
          return dest;
        }
        /*private*/
        method3182() {
          const local13 = this.anInt3819;
          if (local13 === 2) {
            for (let local28 = 0; local28 < 257; local28++) {
              {
                const local35 = local28 << 4;
                let local37;
                for (local37 = 1; local37 < this.markers.length - 1 && local35 >= this.markers[local37][0]; local37++) {
                  {
                  }
                  ;
                }
                const local62 = this.markers[local37];
                const local69 = this.markers[local37 - 1];
                const local78 = this.getMarker(local37 - 2)[1];
                const local82 = local62[1];
                const local86 = local69[1];
                const local92 = local82 - local78;
                const local101 = this.getMarker(local37 + 1)[1];
                const local118 = (local35 - local69[0] << 12) / (local62[0] - local69[0]) | 0;
                const local128 = local101 + local86 - local78 - local82;
                const local135 = local78 - local86 - local128;
                const local141 = local118 * local118 >> 12;
                const local147 = local118 * local92 >> 12;
                const local157 = (local118 * local128 >> 12) * local141 >> 12;
                const local163 = local141 * local135 >> 12;
                let local172 = local157 + local163 + local147 + local86;
                if (local172 <= -32768) {
                  local172 = -32767;
                }
                if (local172 >= 32768) {
                  local172 = 32767;
                }
                this.aShortArray73[local28] = local172 | 0;
              }
              ;
            }
          } else if (local13 === 1) {
            for (let local200 = 0; local200 < 257; local200++) {
              {
                const local207 = local200 << 4;
                let local209;
                for (local209 = 1; this.markers.length - 1 > local209 && this.markers[local209][0] <= local207; local209++) {
                  {
                  }
                  ;
                }
                const local238 = this.markers[local209 - 1];
                const local243 = this.markers[local209];
                const local261 = (local207 - local238[0] << 12) / (local243[0] - local238[0]) | 0;
                const local274 = 4096 - TextureOp2.COSINE[local261 >> 5 & 255] >> 1;
                const local279 = 4096 - local274;
                let local293 = local274 * local243[1] + local279 * local238[1] >> 12;
                if (local293 <= -32768) {
                  local293 = -32767;
                }
                if (local293 >= 32768) {
                  local293 = 32767;
                }
                this.aShortArray73[local200] = local293 | 0;
              }
              ;
            }
          } else {
            for (let local320 = 0; local320 < 257; local320++) {
              {
                const local327 = local320 << 4;
                let local329;
                for (local329 = 1; this.markers.length - 1 > local329 && local327 >= this.markers[local329][0]; local329++) {
                  {
                  }
                  ;
                }
                const local362 = this.markers[local329 - 1];
                const local367 = this.markers[local329];
                const local384 = (local327 - local362[0] << 12) / (local367[0] - local362[0]) | 0;
                const local389 = 4096 - local384;
                let local403 = local367[1] * local384 + local389 * local362[1] >> 12;
                if (local403 <= -32768) {
                  local403 = -32767;
                }
                if (local403 >= 32768) {
                  local403 = 32767;
                }
                this.aShortArray73[local320] = local403 | 0;
              }
              ;
            }
          }
        }
        /*private*/
        method3183() {
          const local8 = this.markers[0];
          const local13 = this.markers[1];
          const local22 = this.markers[this.markers.length - 1];
          const local31 = this.markers[this.markers.length - 2];
          this.lastMarker = [local31[0] + local31[0] - local22[0], local31[1] + local31[1] - local22[1]];
          this.firstMarker = [local8[0] + local8[0] - local13[0], local8[1] + local8[1] - local13[1]];
        }
        postDecode() {
          if (this.markers == null) {
            this.markers = [[0, 0], [4096, 4096]];
          }
          if (this.markers.length < 2) {
            throw Object.defineProperty(new Error("Curve operation requires at least two markers"), "__classes", { configurable: true, value: ["java.lang.Throwable", "java.lang.Object", "java.lang.RuntimeException", "java.lang.Exception"] });
          }
          if (this.anInt3819 === 2) {
            this.method3183();
          }
          TextureOp2.createTrigonometryTables();
          this.method3182();
        }
        decode(buffer, code) {
          if (code !== 0) {
            return;
          }
          this.anInt3819 = buffer.readUnsignedByte();
          this.markers = (function(dims) {
            let allocate = function(dims2) {
              if (dims2.length === 0) {
                return 0;
              } else {
                let array2 = [];
                for (let i = 0; i < dims2[0]; i++) {
                  array2.push(allocate(dims2.slice(1)));
                }
                return array2;
              }
            };
            return allocate(dims);
          })([buffer.readUnsignedByte(), 2]);
          for (let i = 0; i < this.markers.length; i++) {
            {
              this.markers[i][0] = buffer.readUnsignedShort();
              this.markers[i][1] = buffer.readUnsignedShort();
            }
            ;
          }
        }
      }
      TextureOpCurve["__class"] = "TextureOpCurve";
      class TextureOpEmboss extends TextureOp2 {
        constructor() {
          super(1, true);
          this.azimuth = 3216;
          this.elevation = 3216;
          this.depth = 4096;
          this.anIntArray57 = [0, 0, 0];
        }
        decode(buffer, code) {
          if (code === 0) {
            this.depth = buffer.readUnsignedShort();
          } else if (code === 1) {
            this.azimuth = buffer.readUnsignedShort();
          } else if (code === 2) {
            this.elevation = buffer.readUnsignedShort();
          }
        }
        postDecode() {
          this.method642();
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            const local24 = Texture6.widthTimes32 * this.depth >> 12;
            const local36 = this.getChildMonochromeOutput(0, y - 1 & Texture6.heightMask);
            const local44 = this.getChildMonochromeOutput(0, y);
            const local56 = this.getChildMonochromeOutput(0, Texture6.heightMask & y + 1);
            for (let x = 0; x < Texture6.width; x++) {
              {
                const local82 = local24 * (local44[Texture6.widthMask & x - 1] - local44[Texture6.widthMask & x + 1]) >> 12;
                let local86 = local82 >> 4;
                const local99 = (local56[x] - local36[x]) * local24 >> 12;
                if (local86 < 0) {
                  local86 = -local86;
                }
                let local112 = local99 >> 4;
                if (local112 < 0) {
                  local112 = -local112;
                }
                if (local112 > 255) {
                  local112 = 255;
                }
                if (local86 > 255) {
                  local86 = 255;
                }
                const local149 = TextureMathUtils.INVERSE_SQUARE_ROOT_$LI$()[local86 + ((local112 + 1) * local112 >> 1)] & 255;
                let local155 = local82 * local149 >> 8;
                let local161 = local149 * local99 >> 8;
                local155 = this.anIntArray57[0] * local155 >> 12;
                let local176 = local149 * 4096 >> 8;
                local161 = this.anIntArray57[1] * local161 >> 12;
                local176 = this.anIntArray57[2] * local176 >> 12;
                dest[x] = local176 + local161 + local155;
              }
              ;
            }
          }
          return dest;
        }
        /*private*/
        method642() {
          const local11 = Math.cos(Math.fround(this.elevation / 4096));
          this.anIntArray57[0] = Math.sin(Math.fround(this.azimuth / 4096)) * 4096 * local11 | 0;
          this.anIntArray57[1] = Math.cos(Math.fround(this.azimuth / 4096)) * local11 * 4096 | 0;
          this.anIntArray57[2] = Math.sin(Math.fround(this.elevation / 4096)) * 4096 | 0;
          const local69 = this.anIntArray57[0] * this.anIntArray57[0] >> 12;
          const local81 = this.anIntArray57[2] * this.anIntArray57[2] >> 12;
          const local93 = this.anIntArray57[1] * this.anIntArray57[1] >> 12;
          const local106 = Math.sqrt(local81 + local69 + local93 >> 12) * 4096 | 0;
          if (local106 !== 0) {
            this.anIntArray57[0] = (this.anIntArray57[0] << 12) / local106 | 0;
            this.anIntArray57[2] = (this.anIntArray57[2] << 12) / local106 | 0;
            this.anIntArray57[1] = (this.anIntArray57[1] << 12) / local106 | 0;
          }
        }
      }
      TextureOpEmboss["__class"] = "TextureOpEmboss";
      class TextureOpFlip extends TextureOp2 {
        constructor() {
          super(1, false);
          this.flipVertical = true;
          this.flipHorizontal = true;
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            const src = this.getChildMonochromeOutput(0, this.flipVertical ? Texture6.heightMask - y : y);
            if (this.flipHorizontal) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  dest[x] = src[Texture6.widthMask - x];
                }
                ;
              }
            } else {
              ArrayUtils.copy$int_A$int$int_A$int$int(src, 0, dest, 0, Texture6.width);
            }
          }
          return dest;
        }
        decode(buffer, code) {
          if (code === 0) {
            this.flipHorizontal = buffer.readUnsignedByte() === 1;
          } else if (code === 1) {
            this.flipVertical = buffer.readUnsignedByte() === 1;
          } else if (code === 2) {
            this.monochrome = buffer.readUnsignedByte() === 1;
          }
        }
        getColorOutput(y) {
          const dest = this.colorImageCache.get$int(y);
          if (this.colorImageCache.invalid) {
            const src = this.getChildColorOutput(0, this.flipVertical ? Texture6.heightMask - y : y);
            const srcRed = src[0];
            const srcGreen = src[1];
            const destRed = dest[0];
            const srcBlue = src[2];
            const destGreen = dest[1];
            const destBlue = dest[2];
            if (this.flipHorizontal) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  destRed[x] = srcRed[Texture6.widthMask - x];
                  destGreen[x] = srcGreen[Texture6.widthMask - x];
                  destBlue[x] = srcBlue[Texture6.widthMask - x];
                }
                ;
              }
            } else {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  destRed[x] = srcRed[x];
                  destGreen[x] = srcGreen[x];
                  destBlue[x] = srcBlue[x];
                }
                ;
              }
            }
          }
          return dest;
        }
      }
      TextureOpFlip["__class"] = "TextureOpFlip";
      class TextureOpHerringbone extends TextureOp2 {
        constructor() {
          super(0, true);
          this.scaleX = 1;
          this.ratio = 204;
          this.scaleY = 1;
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            for (let x = 0; x < Texture6.width; x++) {
              {
                const normalisedX = Texture6.normalisedX[x];
                let local40 = normalisedX * this.scaleX >> 12;
                const normalisedY = Texture6.normalisedY[y];
                const local51 = normalisedY * this.scaleY >> 12;
                const local61 = this.scaleX * (normalisedX % (4096 / this.scaleX | 0));
                const local71 = normalisedY % (4096 / this.scaleY | 0) * this.scaleY;
                if (local71 < this.ratio) {
                  for (local40 -= local51; local40 < 0; local40 += 4) {
                    {
                    }
                    ;
                  }
                  while (local40 > 3) {
                    {
                      local40 -= 4;
                    }
                  }
                  ;
                  if (local40 !== 1) {
                    dest[x] = 0;
                    continue;
                  }
                  if (local61 < this.ratio) {
                    dest[x] = 0;
                    continue;
                  }
                }
                if (local61 < this.ratio) {
                  let local131;
                  for (local131 = local40 - local51; local131 < 0; local131 += 4) {
                    {
                    }
                    ;
                  }
                  while (local131 > 3) {
                    {
                      local131 -= 4;
                    }
                  }
                  ;
                  if (local131 > 0) {
                    dest[x] = 0;
                    continue;
                  }
                }
                dest[x] = 4096;
              }
              ;
            }
          }
          return dest;
        }
        decode(buffer, code) {
          if (code === 0) {
            this.scaleX = buffer.readUnsignedByte();
          } else if (code === 1) {
            this.scaleY = buffer.readUnsignedByte();
          } else if (code === 2) {
            this.ratio = buffer.readUnsignedShort();
          }
        }
      }
      TextureOpHerringbone["__class"] = "TextureOpHerringbone";
      class TextureOpHorizontalGradient extends TextureOp2 {
        constructor() {
          super(0, true);
        }
        getMonochromeOutput(y) {
          return Texture6.normalisedX;
        }
      }
      TextureOpHorizontalGradient["__class"] = "TextureOpHorizontalGradient";
      class TextureOpHslAdjust extends TextureOp2 {
        constructor() {
          super(1, false);
          if (this.red === void 0) {
            this.red = 0;
          }
          if (this.green === void 0) {
            this.green = 0;
          }
          if (this.hue === void 0) {
            this.hue = 0;
          }
          if (this.lightness === void 0) {
            this.lightness = 0;
          }
          if (this.saturation === void 0) {
            this.saturation = 0;
          }
          if (this.blue === void 0) {
            this.blue = 0;
          }
          this.lightnessDelta = 0;
          this.hueDelta = 0;
          this.saturationDelta = 0;
        }
        /*private*/
        hslToRgb(h, s, l) {
          const q = l > 2048 ? s + l - (l * s >> 12) : l * (s + 4096) >> 12;
          if (q <= 0) {
            this.red = this.green = this.blue = l;
            return;
          }
          const p = l + l - q;
          const local47 = (q - p << 12) / q | 0;
          h *= 6;
          const hPrime = h >> 12;
          const local64 = h - (hPrime << 12);
          let local70 = local47 * q >> 12;
          local70 = local70 * local64 >> 12;
          const local81 = q - local70;
          const local85 = p + local70;
          if (hPrime === 0) {
            this.green = local85;
            this.red = q;
            this.blue = p;
          } else if (hPrime === 1) {
            this.green = q;
            this.red = local81;
            this.blue = p;
          } else if (hPrime === 2) {
            this.red = p;
            this.green = q;
            this.blue = local85;
          } else if (hPrime === 3) {
            this.red = p;
            this.green = local81;
            this.blue = q;
          } else if (hPrime === 4) {
            this.red = local85;
            this.green = p;
            this.blue = q;
          } else if (hPrime === 5) {
            this.green = p;
            this.red = q;
            this.blue = local81;
          }
        }
        decode(buffer, code) {
          if (code === 0) {
            this.hueDelta = buffer.readShort();
          } else if (code === 1) {
            this.saturationDelta = (buffer.readByte() << 12) / 100 | 0;
          } else if (code === 2) {
            this.lightnessDelta = (buffer.readByte() << 12) / 100 | 0;
          }
        }
        /*private*/
        rgbToHsl(r, g, b) {
          let xMax = r > g ? r : g;
          xMax = b > xMax ? b : xMax;
          let xMin = r < g ? r : g;
          xMin = b < xMin ? b : xMin;
          this.lightness = (xMax + xMin) / 2 | 0;
          const chroma = xMax - xMin;
          if (chroma <= 0) {
            this.hue = 0;
          } else {
            const tempB = (xMax - b << 12) / chroma | 0;
            const tempR = (xMax - r << 12) / chroma | 0;
            const tempG = (xMax - g << 12) / chroma | 0;
            if (xMax === r) {
              this.hue = xMin === g ? tempB + 20480 : 4096 - tempG;
            } else if (xMax === g) {
              this.hue = xMin === b ? tempR + 4096 : 12288 - tempB;
            } else {
              this.hue = xMin === r ? tempG + 12288 : 20480 - tempR;
            }
            this.hue = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(this.hue / 6);
          }
          if (this.lightness > 0 && this.lightness < 4096) {
            this.saturation = (chroma << 12) / (this.lightness <= 2048 ? this.lightness * 2 : 8192 - this.lightness * 2) | 0;
          } else {
            this.saturation = 0;
          }
        }
        getColorOutput(y) {
          const dest = this.colorImageCache.get$int(y);
          if (this.colorImageCache.invalid) {
            const src = this.getChildColorOutput(0, y);
            const srcRed = src[0];
            const srcGreen = src[1];
            const destRed = dest[0];
            const srcBlue = src[2];
            const destGreen = dest[1];
            const destBlue = dest[2];
            for (let x = 0; x < Texture6.width; x++) {
              {
                this.rgbToHsl(srcRed[x], srcGreen[x], srcBlue[x]);
                this.lightness += this.lightnessDelta;
                this.saturation += this.saturationDelta;
                if (this.saturation < 0) {
                  this.saturation = 0;
                }
                this.hue += this.hueDelta;
                if (this.saturation > 4096) {
                  this.saturation = 4096;
                }
                while (this.hue < 0) {
                  {
                    this.hue += 4096;
                  }
                }
                ;
                if (this.lightness < 0) {
                  this.lightness = 0;
                }
                if (this.lightness > 4096) {
                  this.lightness = 4096;
                }
                while (this.hue > 4096) {
                  {
                    this.hue -= 4096;
                  }
                }
                ;
                this.hslToRgb(this.hue, this.saturation, this.lightness);
                destRed[x] = this.red;
                destGreen[x] = this.green;
                destBlue[x] = this.blue;
              }
              ;
            }
          }
          return dest;
        }
      }
      TextureOpHslAdjust["__class"] = "TextureOpHslAdjust";
      class TextureOpInterpolate extends TextureOp2 {
        constructor() {
          super(3, false);
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            const src0 = this.getChildMonochromeOutput(0, y);
            const src1 = this.getChildMonochromeOutput(1, y);
            const src2 = this.getChildMonochromeOutput(2, y);
            for (let x = 0; x < Texture6.width; x++) {
              {
                const alpha = src2[x];
                if (alpha === 4096) {
                  dest[x] = src0[x];
                } else if (alpha === 0) {
                  dest[x] = src1[x];
                } else {
                  dest[x] = alpha * src0[x] + src1[x] * (4096 - alpha) >> 12;
                }
              }
              ;
            }
          }
          return dest;
        }
        decode(buffer, code) {
          if (code === 0) {
            this.monochrome = buffer.readUnsignedByte() === 1;
          }
        }
        getColorOutput(y) {
          const dest = this.colorImageCache.get$int(y);
          if (this.colorImageCache.invalid) {
            const src2 = this.getChildMonochromeOutput(2, y);
            const src0 = this.getChildColorOutput(0, y);
            const src1 = this.getChildColorOutput(1, y);
            const destRed = dest[0];
            const destGreen = dest[1];
            const destBlue = dest[2];
            const src0Green = src0[1];
            const src0Red = src0[0];
            const src1Green = src1[1];
            const src1Red = src1[0];
            const src0Blue = src0[2];
            const src1Blue = src1[2];
            for (let x = 0; x < Texture6.width; x++) {
              {
                const alpha = src2[x];
                if (alpha === 4096) {
                  destRed[x] = src0Red[x];
                  destGreen[x] = src0Green[x];
                  destBlue[x] = src0Blue[x];
                } else if (alpha === 0) {
                  destRed[x] = src1Red[x];
                  destGreen[x] = src1Green[x];
                  destBlue[x] = src1Blue[x];
                } else {
                  const local141 = 4096 - alpha;
                  destRed[x] = src1Red[x] * local141 + src0Red[x] * alpha >> 12;
                  destGreen[x] = src1Green[x] * local141 + alpha * src0Green[x] >> 12;
                  destBlue[x] = src0Blue[x] * alpha + local141 * src1Blue[x] >> 12;
                }
              }
              ;
            }
          }
          return dest;
        }
      }
      TextureOpInterpolate["__class"] = "TextureOpInterpolate";
      class TextureOpInvert extends TextureOp2 {
        constructor() {
          super(1, false);
        }
        decode(buffer, code) {
          if (code === 0) {
            this.monochrome = buffer.readUnsignedByte() === 1;
          }
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            const src = this.getChildMonochromeOutput(0, y);
            for (let x = 0; x < Texture6.width; x++) {
              {
                dest[x] = 4096 - src[x];
              }
              ;
            }
          }
          return dest;
        }
        getColorOutput(y) {
          const dest = this.colorImageCache.get$int(y);
          if (this.colorImageCache.invalid) {
            const src = this.getChildColorOutput(0, y);
            const srcRed = src[0];
            const srcBlue = src[2];
            const destRed = dest[0];
            const srcGreen = src[1];
            const destGreen = dest[1];
            const destBlue = dest[2];
            for (let x = 0; x < Texture6.width; x++) {
              {
                destRed[x] = 4096 - srcRed[x];
                destGreen[x] = 4096 - srcGreen[x];
                destBlue[x] = 4096 - srcBlue[x];
              }
              ;
            }
          }
          return dest;
        }
      }
      TextureOpInvert["__class"] = "TextureOpInvert";
      class TextureOpIrregularBricks extends TextureOp2 {
        constructor() {
          super(0, true);
          if (this.anInt79 === void 0) {
            this.anInt79 = 0;
          }
          this.anInt72 = 409;
          this.anInt81 = 1024;
          this.anInt77 = 1024;
          this.anInt82 = 819;
          this.anInt76 = 0;
          this.anInt75 = 1024;
          this.anInt84 = 1024;
          this.seed = 0;
          this.anInt87 = 2048;
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (!this.monochromeImageCache.invalid) {
            return dest;
          }
          let local23 = 0;
          const pixels = this.monochromeImageCache.get$();
          let local30 = 0;
          let local32 = 0;
          let local34 = 0;
          let local36 = 0;
          let local38 = true;
          let local40 = 0;
          let local42 = true;
          const local49 = this.anInt84 * Texture6.width >> 12;
          let local51 = 0;
          const local58 = this.anInt72 * Texture6.height >> 12;
          const local65 = Texture6.width * this.anInt87 >> 12;
          const local72 = this.anInt82 * Texture6.height >> 12;
          if (local72 <= 1) {
            return pixels[y];
          }
          this.anInt79 = (Texture6.width / 8 | 0) * this.anInt81 >> 12;
          const local99 = (Texture6.width / local49 | 0) + 1;
          const random = new Random(this.seed);
          let local110 = (function(dims) {
            let allocate = function(dims2) {
              if (dims2.length === 0) {
                return 0;
              } else {
                let array2 = [];
                for (let i = 0; i < dims2[0]; i++) {
                  array2.push(allocate(dims2.slice(1)));
                }
                return array2;
              }
            };
            return allocate(dims);
          })([local99, 3]);
          let local114 = (function(dims) {
            let allocate = function(dims2) {
              if (dims2.length === 0) {
                return 0;
              } else {
                let array2 = [];
                for (let i = 0; i < dims2[0]; i++) {
                  array2.push(allocate(dims2.slice(1)));
                }
                return array2;
              }
            };
            return allocate(dims);
          })([local99, 3]);
          while (true) {
            {
              while (true) {
                {
                  let local125 = local49 + RandomUtils.nextInt(random, local65 - local49);
                  let local135 = RandomUtils.nextInt(random, local72 - local58) + local58;
                  let local139 = local32 + local125;
                  if (local139 > Texture6.width) {
                    local125 = Texture6.width - local32;
                    local139 = Texture6.width;
                  }
                  let local153;
                  if (local38) {
                    local153 = 0;
                  } else {
                    let local157 = local36;
                    const local161 = local114[local36];
                    local153 = local161[2];
                    let local167 = 0;
                    let local171 = local23 + local139;
                    if (local171 < 0) {
                      local171 += Texture6.width;
                    }
                    if (Texture6.width < local171) {
                      local171 -= Texture6.width;
                    }
                    while (true) {
                      {
                        const local196 = local114[local157];
                        if (local196[0] <= local171 && local171 <= local196[1]) {
                          if (local157 !== local36) {
                            let local238 = local32 + local23;
                            if (local238 < 0) {
                              local238 += Texture6.width;
                            }
                            if (local238 > Texture6.width) {
                              local238 -= Texture6.width;
                            }
                            for (let local258 = 1; local258 <= local167; local258++) {
                              {
                                const local269 = local114[(local258 + local36) % local40];
                                local153 = Math.max(local153, local269[2]);
                              }
                              ;
                            }
                            for (let local280 = 0; local280 <= local167; local280++) {
                              {
                                const local295 = local114[(local280 + local36) % local40];
                                const local299 = local295[2];
                                if (local299 !== local153) {
                                  const local306 = local295[1];
                                  const local310 = local295[0];
                                  let local320;
                                  let local322;
                                  if (local238 < local171) {
                                    local320 = Math.max(local238, local310);
                                    local322 = Math.min(local171, local306);
                                  } else if (local310 === 0) {
                                    local322 = Math.min(local171, local306);
                                    local320 = 0;
                                  } else {
                                    local320 = Math.max(local238, local310);
                                    local322 = Texture6.width;
                                  }
                                  this.method69(local153 - local299, local322 - local320, local34 + local320, local299, random, pixels);
                                }
                              }
                              ;
                            }
                          }
                          local36 = local157;
                          break;
                        }
                        local157++;
                        if (local157 >= local40) {
                          local157 = 0;
                        }
                        local167++;
                      }
                    }
                    ;
                  }
                  if (Texture6.height < local135 + local153) {
                    local135 = Texture6.height - local153;
                  } else {
                    local42 = false;
                  }
                  if (local139 === Texture6.width) {
                    this.method69(local135, local125, local32 + local30, local153, random, pixels);
                    if (local42) {
                      return dest;
                    }
                    local38 = false;
                    const local440 = local51 + 1;
                    const local442 = local110[local51];
                    local42 = true;
                    local442[1] = local139;
                    local34 = local30;
                    local40 = local440;
                    local442[0] = local32;
                    local442[2] = local135 + local153;
                    local30 = RandomUtils.nextInt(random, Texture6.width);
                    const local469 = local114;
                    local36 = 0;
                    local23 = local30 - local34;
                    local114 = local110;
                    let local480 = local23;
                    local110 = local469;
                    if (local23 < 0) {
                      local480 = local23 + Texture6.width;
                    }
                    local51 = 0;
                    if (Texture6.width < local480) {
                      local480 -= Texture6.width;
                    }
                    while (true) {
                      {
                        const local506 = local114[local36];
                        if (local480 >= local506[0] && local506[1] >= local480) {
                          local32 = 0;
                          break;
                        }
                        local36++;
                        if (local40 <= local36) {
                          local36 = 0;
                        }
                      }
                    }
                    ;
                  } else {
                    const local388 = local110[local51++];
                    local388[1] = local139;
                    local388[2] = local135 + local153;
                    local388[0] = local32;
                    this.method69(local135, local125, local30 + local32, local153, random, pixels);
                    local32 = local139;
                  }
                }
              }
              ;
            }
          }
          ;
        }
        postDecode() {
        }
        /*private*/
        method69(arg0, arg1, arg2, arg3, arg4, arg5) {
          const local20 = this.anInt77 > 0 ? 4096 - RandomUtils.nextInt(arg4, this.anInt77) : 4096;
          const local28 = this.anInt79 * this.anInt75 >> 12;
          const local44 = this.anInt79 - (local28 > 0 ? RandomUtils.nextInt(arg4, local28) : 0);
          if (Texture6.width <= arg2) {
            arg2 -= Texture6.width;
          }
          if (local44 > 0) {
            if (arg0 <= 0 || arg1 <= 0) {
              return;
            }
            const local67 = arg1 / 2 | 0;
            const local71 = arg0 / 2 | 0;
            const local82 = local67 >= local44 ? local44 : local67;
            const local93 = local44 > local71 ? local71 : local44;
            const local97 = arg2 + local82;
            const local104 = arg1 - local82 * 2;
            for (let local106 = 0; local106 < arg0; local106++) {
              {
                const local116 = arg5[local106 + arg3];
                if (local93 <= local106) {
                  const local260 = arg0 - local106 - 1;
                  if (local93 <= local260) {
                    for (let local403 = 0; local403 < local82; local403++) {
                      {
                        local116[Texture6.widthMask & arg2 + local403] = local116[Texture6.widthMask & arg1 + arg2 - local403 - 1] = local20 * local403 / local82 | 0;
                      }
                      ;
                    }
                    if (local97 + local104 <= Texture6.width) {
                      ArrayUtils.fill$int_A$int$int$int(local116, local97, local104, local20);
                    } else {
                      const local461 = Texture6.width - local97;
                      ArrayUtils.fill$int_A$int$int$int(local116, local97, local461, local20);
                      ArrayUtils.fill$int_A$int$int$int(local116, 0, local104 - local461, local20);
                    }
                  } else {
                    const local274 = local260 * local20 / local93 | 0;
                    if (this.anInt76 === 0) {
                      for (let local327 = 0; local327 < local82; local327++) {
                        {
                          const local336 = local327 * local20 / local82 | 0;
                          local116[Texture6.widthMask & arg2 + local327] = local116[arg1 + arg2 - local327 - 1 & Texture6.widthMask] = local274 * local336 >> 12;
                        }
                        ;
                      }
                    } else {
                      for (let local280 = 0; local280 < local82; local280++) {
                        {
                          const local289 = local20 * local280 / local82 | 0;
                          local116[Texture6.widthMask & local280 + arg2] = local116[Texture6.widthMask & arg2 + arg1 - local280 - 1] = local274 > local289 ? local289 : local274;
                        }
                        ;
                      }
                    }
                    if (Texture6.width < local104 + local97) {
                      const local379 = Texture6.width - local97;
                      ArrayUtils.fill$int_A$int$int$int(local116, local97, local379, local274);
                      ArrayUtils.fill$int_A$int$int$int(local116, 0, local104 - local379, local274);
                    } else {
                      ArrayUtils.fill$int_A$int$int$int(local116, local97, local104, local274);
                    }
                  }
                } else {
                  const local130 = local106 * local20 / local93 | 0;
                  if (this.anInt76 === 0) {
                    for (let local184 = 0; local184 < local82; local184++) {
                      {
                        const local193 = local20 * local184 / local82 | 0;
                        local116[Texture6.widthMask & local184 + arg2] = local116[arg2 + arg1 - local184 - 1 & Texture6.widthMask] = local193 * local130 >> 12;
                      }
                      ;
                    }
                  } else {
                    for (let local138 = 0; local138 < local82; local138++) {
                      {
                        const local151 = local20 * local138 / local82 | 0;
                        local116[local138 + arg2 & Texture6.widthMask] = local116[arg1 + arg2 - local138 - 1 & Texture6.widthMask] = local130 <= local151 ? local130 : local151;
                      }
                      ;
                    }
                  }
                  if (local97 + local104 > Texture6.width) {
                    const local231 = Texture6.width - local97;
                    ArrayUtils.fill$int_A$int$int$int(local116, local97, local231, local130);
                    ArrayUtils.fill$int_A$int$int$int(local116, 0, local104 - local231, local130);
                  } else {
                    ArrayUtils.fill$int_A$int$int$int(local116, local97, local104, local130);
                  }
                }
              }
              ;
            }
          } else if (Texture6.width >= arg1 + arg2) {
            for (let local486 = 0; local486 < arg0; local486++) {
              {
                ArrayUtils.fill$int_A$int$int$int(arg5[local486 + arg3], arg2, arg1, local20);
              }
              ;
            }
          } else {
            const local507 = Texture6.width - arg2;
            for (let local509 = 0; local509 < arg0; local509++) {
              {
                const local518 = arg5[local509 + arg3];
                ArrayUtils.fill$int_A$int$int$int(local518, arg2, local507, local20);
                ArrayUtils.fill$int_A$int$int$int(local518, 0, arg1 - local507, local20);
              }
              ;
            }
          }
        }
        decode(buffer, code) {
          if (code === 0) {
            this.seed = buffer.readUnsignedByte();
          } else if (code === 1) {
            this.anInt84 = buffer.readUnsignedShort();
          } else if (code === 2) {
            this.anInt87 = buffer.readUnsignedShort();
          } else if (code === 3) {
            this.anInt72 = buffer.readUnsignedShort();
          } else if (code === 4) {
            this.anInt82 = buffer.readUnsignedShort();
          } else if (code === 5) {
            this.anInt81 = buffer.readUnsignedShort();
          } else if (code === 6) {
            this.anInt76 = buffer.readUnsignedByte();
          } else if (code === 7) {
            this.anInt75 = buffer.readUnsignedShort();
          } else if (code === 8) {
            this.anInt77 = buffer.readUnsignedShort();
          }
        }
      }
      TextureOpIrregularBricks["__class"] = "TextureOpIrregularBricks";
      class TextureOpKaleidoscope extends TextureOp2 {
        constructor() {
          super(1, false);
        }
        getColorOutput(y) {
          const dest = this.colorImageCache.get$int(y);
          if (this.colorImageCache.invalid) {
            const destRed = dest[0];
            const destGreen = dest[1];
            const destBlue = dest[2];
            for (let x = 0; x < Texture6.width; x++) {
              {
                this.method4301(x, y);
                const src = this.getChildColorOutput(0, TextureOpKaleidoscope.y0);
                destRed[x] = src[0][TextureOpKaleidoscope.x0];
                destGreen[x] = src[1][TextureOpKaleidoscope.x0];
                destBlue[x] = src[2][TextureOpKaleidoscope.x0];
              }
              ;
            }
          }
          return dest;
        }
        decode(buffer, code) {
          if (code === 0) {
            this.monochrome = buffer.readUnsignedByte() === 1;
          }
        }
        /*private*/
        method4301(x, y) {
          const normalisedX = Texture6.normalisedX[x];
          const normalisedY = Texture6.normalisedY[y];
          const angle = Math.fround(Math.atan2(normalisedX - 2048, normalisedY - 2048));
          if (angle >= -3.141592653589793 && angle <= -2.356194490192345) {
            TextureOpKaleidoscope.x0 = x;
            TextureOpKaleidoscope.y0 = y;
          } else if (angle <= -1.5707963267948966 && angle >= -2.356194490192345) {
            TextureOpKaleidoscope.y0 = x;
            TextureOpKaleidoscope.x0 = y;
          } else if (angle <= -0.7853981633974483 && angle >= -1.5707963267948966) {
            TextureOpKaleidoscope.x0 = Texture6.width - y;
            TextureOpKaleidoscope.y0 = x;
          } else if (angle <= 0 && angle >= -0.7853981633974483) {
            TextureOpKaleidoscope.y0 = Texture6.height - y;
            TextureOpKaleidoscope.x0 = x;
          } else if (angle >= 0 && angle <= 0.7853981633974483) {
            TextureOpKaleidoscope.x0 = Texture6.width - x;
            TextureOpKaleidoscope.y0 = Texture6.height - y;
          } else if (angle >= 0.7853981633974483 && angle <= 1.5707963267948966) {
            TextureOpKaleidoscope.x0 = Texture6.width - y;
            TextureOpKaleidoscope.y0 = Texture6.height - x;
          } else if (angle >= 1.5707963267948966 && angle <= 2.356194490192345) {
            TextureOpKaleidoscope.x0 = y;
            TextureOpKaleidoscope.y0 = Texture6.height - x;
          } else if (angle >= 2.356194490192345 && angle <= 3.141592653589793) {
            TextureOpKaleidoscope.y0 = y;
            TextureOpKaleidoscope.x0 = Texture6.width - x;
          }
          TextureOpKaleidoscope.x0 &= Texture6.widthMask;
          TextureOpKaleidoscope.y0 &= Texture6.heightMask;
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            for (let x = 0; x < Texture6.width; x++) {
              {
                this.method4301(x, y);
                const src = this.getChildMonochromeOutput(0, TextureOpKaleidoscope.y0);
                dest[x] = src[TextureOpKaleidoscope.x0];
              }
              ;
            }
          }
          return dest;
        }
      }
      TextureOpKaleidoscope.y0 = 0;
      TextureOpKaleidoscope.x0 = 0;
      TextureOpKaleidoscope["__class"] = "TextureOpKaleidoscope";
      class TextureOpLineNoise extends TextureOp2 {
        constructor() {
          super(0, true);
          this.seed = 0;
          this.minAngle = 0;
          this.count = 2e3;
          this.maxAngle = 4096;
          this.length = 16;
        }
        postDecode() {
          TextureOp2.createTrigonometryTables();
        }
        decode(buffer, code) {
          if (code === 0) {
            this.seed = buffer.readUnsignedByte();
          } else if (code === 1) {
            this.count = buffer.readUnsignedShort();
          } else if (code === 2) {
            this.length = buffer.readUnsignedByte();
          } else if (code === 3) {
            this.minAngle = buffer.readUnsignedShort();
          } else if (code === 4) {
            this.maxAngle = buffer.readUnsignedShort();
          }
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            const local16 = this.maxAngle >> 1;
            const pixels = this.monochromeImageCache.get$();
            const random = new Random(this.seed);
            for (let i = 0; i < this.count; i++) {
              {
                let angle = this.maxAngle > 0 ? this.minAngle + RandomUtils.nextInt(random, this.maxAngle) - local16 : this.minAngle;
                angle = angle >> 4 & 255;
                let x0 = RandomUtils.nextInt(random, Texture6.width);
                let y0 = RandomUtils.nextInt(random, Texture6.height);
                let x1 = x0 + (TextureOp2.COSINE[angle] * this.length >> 12);
                let y1 = y0 + (TextureOp2.SINE[angle] * this.length >> 12);
                let local105 = y1 - y0;
                let local110 = x1 - x0;
                if (local110 !== 0 || local105 !== 0) {
                  if (local105 < 0) {
                    local105 = -local105;
                  }
                  if (local110 < 0) {
                    local110 = -local110;
                  }
                  const local145 = local105 > local110;
                  if (local145) {
                    const local150 = x1;
                    const local152 = x0;
                    x0 = y0;
                    x1 = y1;
                    y0 = local152;
                    y1 = local150;
                  }
                  if (x0 > x1) {
                    const local165 = x0;
                    x0 = x1;
                    const local169 = y0;
                    x1 = local165;
                    y0 = y1;
                    y1 = local169;
                  }
                  let local177 = y0;
                  const local181 = x1 - x0;
                  let local186 = -local181 / 2 | 0;
                  let local191 = y1 - y0;
                  const local201 = 1024 - (RandomUtils.nextInt(random, 4096) >> 2);
                  if (local191 < 0) {
                    local191 = -local191;
                  }
                  const local213 = 2048 / local181 | 0;
                  const local224 = y1 <= y0 ? -1 : 1;
                  for (let local226 = x0; local226 < x1; local226++) {
                    {
                      local186 += local191;
                      const local247 = local201 + (local226 - x0) * local213 + 1024;
                      const local251 = local177 & Texture6.heightMask;
                      const local255 = Texture6.widthMask & local226;
                      if (local186 > 0) {
                        local186 += -local181;
                        local177 += local224;
                      }
                      if (local145) {
                        pixels[local251][local255] = local247;
                      } else {
                        pixels[local255][local251] = local247;
                      }
                    }
                    ;
                  }
                }
              }
              ;
            }
          }
          return dest;
        }
      }
      TextureOpLineNoise["__class"] = "TextureOpLineNoise";
      class TextureOpMandelbrot extends TextureOp2 {
        constructor() {
          super(0, true);
          this.anInt1159 = 20;
          this.anInt1157 = 0;
          this.anInt1160 = 1365;
          this.anInt1164 = 0;
        }
        decode(buffer, code) {
          if (code === 0) {
            this.anInt1160 = buffer.readUnsignedShort();
          } else if (code === 1) {
            this.anInt1159 = buffer.readUnsignedShort();
          } else if (code === 2) {
            this.anInt1164 = buffer.readUnsignedShort();
          } else if (code === 3) {
            this.anInt1157 = buffer.readUnsignedShort();
          }
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            for (let x = 0; x < Texture6.width; x++) {
              {
                const local42 = this.anInt1164 + ((Texture6.normalisedX[x] << 12) / this.anInt1160 | 0);
                const local54 = this.anInt1157 + ((Texture6.normalisedY[y] << 12) / this.anInt1160 | 0);
                let local58 = local54;
                let local60 = local42;
                let local64 = 0;
                let local70 = local42 * local42 >> 12;
                let local76 = local54 * local54 >> 12;
                while (local70 + local76 < 16384 && local64 < this.anInt1159) {
                  {
                    local64++;
                    local58 = local54 + (local58 * local60 >> 12) * 2;
                    local60 = local42 + local70 - local76;
                    local76 = local58 * local58 >> 12;
                    local70 = local60 * local60 >> 12;
                  }
                }
                ;
                dest[x] = local64 >= this.anInt1159 - 1 ? 0 : (local64 << 12) / this.anInt1159 | 0;
              }
              ;
            }
          }
          return dest;
        }
      }
      TextureOpMandelbrot["__class"] = "TextureOpMandelbrot";
      class TextureOpMonochrome extends TextureOp2 {
        constructor() {
          super(1, true);
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            const src = this.getChildColorOutput(0, y);
            const srcBlue = src[2];
            const srcGreen = src[1];
            const srcRed = src[0];
            for (let x = 0; x < Texture6.width; x++) {
              {
                dest[x] = (srcGreen[x] + srcRed[x] + srcBlue[x]) / 3 | 0;
              }
              ;
            }
          }
          return dest;
        }
      }
      TextureOpMonochrome["__class"] = "TextureOpMonochrome";
      class TextureOpMonochromeEdgeDetector extends TextureOp2 {
        constructor() {
          super(1, true);
          this.anInt4832 = 4096;
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            const src0 = this.getChildMonochromeOutput(0, y - 1 & Texture6.heightMask);
            const src1 = this.getChildMonochromeOutput(0, y);
            const src2 = this.getChildMonochromeOutput(0, y + 1 & Texture6.heightMask);
            for (let x = 0; x < Texture6.width; x++) {
              {
                const dy = this.anInt4832 * (src2[x] - src0[x]);
                const dx = this.anInt4832 * (src1[Texture6.widthMask & x + 1] - src1[Texture6.widthMask & x - 1]);
                const dx0 = dx >> 12;
                const dy0 = dy >> 12;
                const dySquared = dy0 * dy0 >> 12;
                const dxSquared = dx0 * dx0 >> 12;
                const local117 = Math.sqrt(Math.fround((dySquared + dxSquared + 4096) / 4096)) * 4096 | 0;
                const local128 = local117 === 0 ? 0 : 16777216 / local117 | 0;
                dest[x] = 4096 - local128;
              }
              ;
            }
          }
          return dest;
        }
        decode(buffer, code) {
          if (code === 0) {
            this.anInt4832 = buffer.readUnsignedShort();
          }
        }
      }
      TextureOpMonochromeEdgeDetector["__class"] = "TextureOpMonochromeEdgeDetector";
      class TextureOpMonochromeFill extends TextureOp2 {
        constructor(value) {
          if (typeof value === "number" || value === null) {
            let __args = arguments;
            super(0, true);
            if (this.value === void 0) {
              this.value = 0;
            }
            this.value = 4096;
            this.value = value;
          } else if (value === void 0) {
            let __args = arguments;
            {
              let __args2 = arguments;
              let value2 = 4096;
              super(0, true);
              if (this.value === void 0) {
                this.value = 0;
              }
              this.value = 4096;
              this.value = value2;
            }
            if (this.value === void 0) {
              this.value = 0;
            }
          } else
            throw new Error("invalid overload");
        }
        decode(buffer, code) {
          if (code === 0) {
            this.value = (buffer.readUnsignedByte() << 12) / 255 | 0;
          }
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            ArrayUtils.fill$int_A$int$int$int(dest, 0, Texture6.width, this.value);
          }
          return dest;
        }
      }
      TextureOpMonochromeFill["__class"] = "TextureOpMonochromeFill";
      class TextureOpNoise extends TextureOp2 {
        constructor() {
          super(0, true);
        }
        /*private*/
        noise(x, y) {
          let noise = x + y * 57;
          noise ^= noise << 1;
          return 4096 - ((noise * (noise * 15731 * noise + 789221 | 0) + 1376312589 & 2147483647) / 262144 | 0 | 0) | 0;
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            const heightFraction = Texture6.normalisedY[y];
            for (let x = 0; x < Texture6.width; x++) {
              {
                dest[x] = this.noise(Texture6.normalisedX[x], heightFraction) % 4096;
              }
              ;
            }
          }
          return dest;
        }
      }
      TextureOpNoise["__class"] = "TextureOpNoise";
      class TextureOpPerlinNoise extends TextureOp2 {
        constructor() {
          super(0, true);
          if (this.aShortArray37 === void 0) {
            this.aShortArray37 = null;
          }
          if (this.aShortArray38 === void 0) {
            this.aShortArray38 = null;
          }
          this.permutation = ((s) => {
            let a = [];
            while (s-- > 0)
              a.push(0);
            return a;
          })(512);
          this.aBoolean181 = true;
          this.anInt2620 = 1638;
          this.anInt2625 = 4;
          this.anInt2628 = 4;
          this.seed = 0;
          this.anInt2631 = 4;
        }
        /*private*/
        method2049() {
          if (this.anInt2620 > 0) {
            this.aShortArray38 = ((s) => {
              let a = [];
              while (s-- > 0)
                a.push(0);
              return a;
            })(this.anInt2628);
            this.aShortArray37 = ((s) => {
              let a = [];
              while (s-- > 0)
                a.push(0);
              return a;
            })(this.anInt2628);
            for (let local64 = 0; local64 < this.anInt2628; local64++) {
              {
                this.aShortArray37[local64] = Math.pow(Math.fround(this.anInt2620 / 4096), local64) * 4096 | 0;
                this.aShortArray38[local64] = Math.pow(2, local64) | 0;
              }
              ;
            }
          } else if (this.aShortArray37 != null && this.aShortArray37.length === this.anInt2628) {
            this.aShortArray38 = ((s) => {
              let a = [];
              while (s-- > 0)
                a.push(0);
              return a;
            })(this.anInt2628);
            for (let local29 = 0; local29 < this.anInt2628; local29++) {
              {
                this.aShortArray38[local29] = Math.pow(2, local29) | 0;
              }
              ;
            }
          }
        }
        decode(buffer, code) {
          if (code === 0) {
            this.aBoolean181 = buffer.readUnsignedByte() === 1;
          } else if (code === 1) {
            this.anInt2628 = buffer.readUnsignedByte();
          } else if (code === 2) {
            this.anInt2620 = buffer.readShort();
            if (this.anInt2620 < 0) {
              this.aShortArray37 = ((s) => {
                let a = [];
                while (s-- > 0)
                  a.push(0);
                return a;
              })(this.anInt2628);
              for (let local81 = 0; local81 < this.anInt2628; local81++) {
                {
                  this.aShortArray37[local81] = buffer.readShort() | 0;
                }
                ;
              }
            }
          } else if (code === 3) {
            this.anInt2631 = this.anInt2625 = buffer.readUnsignedByte();
          } else if (code === 4) {
            this.seed = buffer.readUnsignedByte();
          } else if (code === 5) {
            this.anInt2631 = buffer.readUnsignedByte();
          } else if (code === 6) {
            this.anInt2625 = buffer.readUnsignedByte();
          }
        }
        /*private*/
        method2051(arg0, arg1, arg2, arg3, arg4, arg5) {
          const local5 = arg5 - 4096;
          let local13 = arg0 >> 12;
          arg0 &= 4095;
          let local21 = local13 + 1;
          local13 &= 255;
          if (local21 >= arg4) {
            local21 = 0;
          }
          const local35 = arg0 - 4096;
          const local39 = local21 & 255;
          const local48 = this.permutation[arg3 + local13] & 3;
          let local65;
          if (local48 <= 1) {
            local65 = local48 === 0 ? arg5 + arg0 : arg5 - arg0;
          } else {
            local65 = local48 === 2 ? arg0 - arg5 : -arg5 - arg0;
          }
          const local92 = this.permutation[arg3 + local39] & 3;
          const local96 = MonochromeImageCache.PERLIN_FADE_$LI$()[arg0];
          let local115;
          if (local92 > 1) {
            local115 = local92 === 2 ? local35 - arg5 : -local35 - arg5;
          } else {
            local115 = local92 === 0 ? arg5 + local35 : arg5 - local35;
          }
          const local138 = this.permutation[local13 + arg1] & 3;
          const local150 = local65 + (local96 * (local115 - local65) >> 12);
          let local166;
          if (local138 > 1) {
            local166 = local138 === 2 ? arg0 - local5 : -arg0 - local5;
          } else {
            local166 = local138 === 0 ? local5 + arg0 : local5 - arg0;
          }
          const local189 = this.permutation[arg1 + local39] & 3;
          let local206;
          if (local189 <= 1) {
            local206 = local189 === 0 ? local5 + local35 : local5 - local35;
          } else {
            local206 = local189 === 2 ? local35 - local5 : -local5 - local35;
          }
          const local234 = local166 + ((local206 - local166) * local96 >> 12);
          return local150 + ((local234 - local150) * arg2 >> 12);
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            this.method2053(dest, y);
          }
          return dest;
        }
        method2053(dest, y) {
          const local20 = this.anInt2625 * Texture6.normalisedY[y];
          if (this.anInt2628 === 1) {
            const local31 = this.aShortArray37[0];
            const local38 = this.aShortArray38[0] << 12;
            const local45 = local38 * this.anInt2631 >> 12;
            const local52 = this.anInt2625 * local38 >> 12;
            let local58 = local38 * local20 >> 12;
            const local62 = local58 >> 12;
            local58 &= 4095;
            const local75 = this.permutation[local62 & 255] & 255;
            const local79 = MonochromeImageCache.PERLIN_FADE_$LI$()[local58];
            let local83 = local62 + 1;
            if (local52 <= local83) {
              local83 = 0;
            }
            const local101 = this.permutation[local83 & 255] & 255;
            if (this.aBoolean181) {
              for (let local147 = 0; local147 < Texture6.width; local147++) {
                {
                  const local157 = Texture6.normalisedX[local147] * this.anInt2631;
                  let local171 = this.method2051(local38 * local157 >> 12, local101, local79, local75, local45, local58);
                  local171 = local171 * local31 >> 12;
                  dest[local147] = (local171 >> 1) + 2048;
                }
                ;
              }
            } else {
              for (let local106 = 0; local106 < Texture6.width; local106++) {
                {
                  const local120 = Texture6.normalisedX[local106] * this.anInt2631;
                  const local134 = this.method2051(local38 * local120 >> 12, local101, local79, local75, local45, local58);
                  dest[local106] = local31 * local134 >> 12;
                }
                ;
              }
            }
            return;
          }
          const local194 = this.aShortArray37[0];
          if (local194 > 8 || local194 < -8) {
            const local211 = this.aShortArray38[0] << 12;
            let local217 = local211 * local20 >> 12;
            const local221 = local217 >> 12;
            const local228 = this.anInt2631 * local211 >> 12;
            const local235 = local211 * this.anInt2625 >> 12;
            local217 &= 4095;
            const local248 = this.permutation[local221 & 255] & 255;
            const local252 = MonochromeImageCache.PERLIN_FADE_$LI$()[local217];
            let local256 = local221 + 1;
            if (local256 >= local235) {
              local256 = 0;
            }
            const local275 = this.permutation[local256 & 255] & 255;
            for (let local277 = 0; local277 < Texture6.width; local277++) {
              {
                const local287 = this.anInt2631 * Texture6.normalisedX[local277];
                const local301 = this.method2051(local211 * local287 >> 12, local275, local252, local248, local228, local217);
                dest[local277] = local194 * local301 >> 12;
              }
              ;
            }
          }
          for (let local314 = 1; local314 < this.anInt2628; local314++) {
            {
              const local323 = this.aShortArray37[local314];
              if (local323 > 8 || local323 < -8) {
                const local336 = this.aShortArray38[local314] << 12;
                const local343 = local336 * this.anInt2631 >> 12;
                let local349 = local20 * local336 >> 12;
                const local356 = this.anInt2625 * local336 >> 12;
                const local360 = local349 >> 12;
                let local364 = local360 + 1;
                local349 &= 4095;
                const local377 = this.permutation[local360 & 255] & 255;
                if (local364 >= local356) {
                  local364 = 0;
                }
                const local392 = this.permutation[local364 & 255] & 255;
                const local396 = MonochromeImageCache.PERLIN_FADE_$LI$()[local349];
                if (this.aBoolean181 && local314 === this.anInt2628 - 1) {
                  for (let local447 = 0; local447 < Texture6.width; local447++) {
                    {
                      const local461 = Texture6.normalisedX[local447] * this.anInt2631;
                      let local475 = this.method2051(local461 * local336 >> 12, local392, local396, local377, local343, local349);
                      local475 = dest[local447] + (local323 * local475 >> 12);
                      dest[local447] = (local475 >> 1) + 2048;
                    }
                    ;
                  }
                } else {
                  for (let local407 = 0; local407 < Texture6.width; local407++) {
                    {
                      const local417 = Texture6.normalisedX[local407] * this.anInt2631;
                      const local431 = this.method2051(local336 * local417 >> 12, local392, local396, local377, local343, local349);
                      dest[local407] += local323 * local431 >> 12;
                    }
                    ;
                  }
                }
              }
            }
            ;
          }
        }
        postDecode() {
          this.permutation = TextureOp2.getPermutation(this.seed);
          this.method2049();
          for (let local19 = this.anInt2628 - 1; local19 >= 1; local19--) {
            {
              const local35 = this.aShortArray37[local19];
              if (local35 > 8 || local35 < -8) {
                break;
              }
              this.anInt2628--;
            }
            ;
          }
        }
      }
      TextureOpPerlinNoise["__class"] = "TextureOpPerlinNoise";
      class TextureOpPolarDistortion extends TextureOp2 {
        constructor() {
          super(3, false);
          this.magnitude = 32768;
        }
        postDecode() {
          TextureOp2.createTrigonometryTables();
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            const src1 = this.getChildMonochromeOutput(1, y);
            const src2 = this.getChildMonochromeOutput(2, y);
            for (let x = 0; x < Texture6.width; x++) {
              {
                const angle = src1[x] >> 4 & 255;
                const magnitude = this.magnitude * src2[x] >> 12;
                const y0 = magnitude * TextureOp2.SINE[angle] >> 12;
                const y1 = Texture6.heightMask & y + (y0 >> 12);
                const x0 = magnitude * TextureOp2.COSINE[angle] >> 12;
                const x1 = Texture6.widthMask & x + (x0 >> 12);
                const src0 = this.getChildMonochromeOutput(0, y1);
                dest[x] = src0[x1];
              }
              ;
            }
          }
          return dest;
        }
        decode(buffer, code) {
          if (code === 0) {
            this.magnitude = buffer.readUnsignedShort() << 4;
          } else if (code === 1) {
            this.monochrome = buffer.readUnsignedByte() === 1;
          }
        }
        getColorOutput(y) {
          const dest = this.colorImageCache.get$int(y);
          if (this.colorImageCache.invalid) {
            const src1 = this.getChildMonochromeOutput(1, y);
            const src2 = this.getChildMonochromeOutput(2, y);
            const destRed = dest[0];
            const destGreen = dest[1];
            const destBlue = dest[2];
            for (let x = 0; x < Texture6.width; x++) {
              {
                const magnitude = src2[x] * this.magnitude >> 12;
                const angle = src1[x] * 255 >> 12 & 255;
                const y0 = magnitude * TextureOp2.SINE[angle] >> 12;
                const x0 = magnitude * TextureOp2.COSINE[angle] >> 12;
                const x1 = (x0 >> 12) + x & Texture6.widthMask;
                const y1 = (y0 >> 12) + y & Texture6.heightMask;
                const src0 = this.getChildColorOutput(0, y1);
                destRed[x] = src0[0][x1];
                destGreen[x] = src0[1][x1];
                destBlue[x] = src0[2][x1];
              }
              ;
            }
          }
          return dest;
        }
      }
      TextureOpPolarDistortion["__class"] = "TextureOpPolarDistortion";
      class TextureOpRange extends TextureOp2 {
        constructor() {
          super(1, false);
          this.range = 2048;
          this.minValue = 1024;
          this.maxValue = 3072;
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            const src = this.getChildMonochromeOutput(0, y);
            for (let x = 0; x < Texture6.width; x++) {
              {
                dest[x] = this.minValue + (src[x] * this.range >> 12);
              }
              ;
            }
          }
          return dest;
        }
        getColorOutput(y) {
          const dest = this.colorImageCache.get$int(y);
          if (this.colorImageCache.invalid) {
            const src = this.getChildColorOutput(0, y);
            const srcRed = src[0];
            const srcGreen = src[1];
            const destRed = dest[0];
            const destBlue = dest[2];
            const destGreen = dest[1];
            const srcBlue = src[2];
            for (let x = 0; x < Texture6.width; x++) {
              {
                destRed[x] = this.minValue + (this.range * srcRed[x] >> 12);
                destGreen[x] = this.minValue + (this.range * srcGreen[x] >> 12);
                destBlue[x] = this.minValue + (this.range * srcBlue[x] >> 12);
              }
              ;
            }
          }
          return dest;
        }
        postDecode() {
          this.range = this.maxValue - this.minValue;
        }
        decode(buffer, code) {
          if (code === 0) {
            this.minValue = buffer.readUnsignedShort();
          } else if (code === 1) {
            this.maxValue = buffer.readUnsignedShort();
          } else if (code === 2) {
            this.monochrome = buffer.readUnsignedByte() === 1;
          }
        }
      }
      TextureOpRange["__class"] = "TextureOpRange";
      class TextureOpRasterizer extends TextureOp2 {
        constructor() {
          super(0, true);
          if (this.ops === void 0) {
            this.ops = null;
          }
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            this.render(this.monochromeImageCache.get$());
          }
          return dest;
        }
        getColorOutput(y) {
          const entry = this.colorImageCache.get$int(y);
          if (this.colorImageCache.invalid) {
            const width = Texture6.width;
            const height = Texture6.height;
            const src = (function(dims) {
              let allocate = function(dims2) {
                if (dims2.length === 0) {
                  return 0;
                } else {
                  let array2 = [];
                  for (let i = 0; i < dims2[0]; i++) {
                    array2.push(allocate(dims2.slice(1)));
                  }
                  return array2;
                }
              };
              return allocate(dims);
            })([height, width]);
            const dest = this.colorImageCache.get$();
            this.render(src);
            for (let y0 = 0; y0 < Texture6.height; y0++) {
              {
                const destRow = dest[y0];
                const destGreen = destRow[1];
                const destBlue = destRow[2];
                const srcRow = src[y0];
                const destRed = destRow[0];
                for (let x = 0; x < Texture6.width; x++) {
                  {
                    const rgb = srcRow[x];
                    destBlue[x] = (rgb & 255) << 4;
                    destGreen[x] = rgb >> 4 & 4080;
                    destRed[x] = rgb >> 12 & 4080;
                  }
                  ;
                }
              }
              ;
            }
          }
          return entry;
        }
        decode(buffer, code) {
          if (code === 0) {
            this.ops = ((s) => {
              let a = [];
              while (s-- > 0)
                a.push(null);
              return a;
            })(buffer.readUnsignedByte());
            for (let i = 0; i < this.ops.length; i++) {
              {
                const op = buffer.readUnsignedByte();
                if (op === 0) {
                  this.ops[i] = TextureOpRasterizerLine.create(buffer);
                } else if (op === 1) {
                  this.ops[i] = TextureOpRasterizerBezierCurve.create(buffer);
                } else if (op === 2) {
                  this.ops[i] = TextureOpRasterizerRectangle.create(buffer);
                } else if (op === 3) {
                  this.ops[i] = TextureOpRasterizerEllipse.create(buffer);
                }
              }
              ;
            }
          } else if (code === 1) {
            this.monochrome = buffer.readUnsignedByte() === 1;
          }
        }
        /*private*/
        render(pixels) {
          const width = Texture6.width;
          const height = Texture6.height;
          MergedStatics.sub35_method4335(pixels);
          MergedStatics.sub18_method4374(Texture6.heightMask, Texture6.widthMask);
          if (this.ops == null) {
            return;
          }
          for (let i = 0; i < this.ops.length; i++) {
            {
              const op = this.ops[i];
              const outlineColor = op.outlineColor;
              const fillColor = op.fillColor;
              if (fillColor >= 0) {
                if (outlineColor >= 0) {
                  op.render(width, height);
                } else {
                  op.renderFill(width, height);
                }
              } else if (outlineColor >= 0) {
                op.renderOutline(width, height);
              }
            }
            ;
          }
        }
      }
      TextureOpRasterizer["__class"] = "TextureOpRasterizer";
      class TextureOpSprite extends TextureOp2 {
        constructor() {
          super(0, false);
          if (this.height === void 0) {
            this.height = 0;
          }
          if (this.width === void 0) {
            this.width = 0;
          }
          if (this.pixels === void 0) {
            this.pixels = null;
          }
          this.spriteId = -1;
        }
        loadSprite() {
          if (this.pixels != null) {
            return true;
          } else if (this.spriteId >= 0) {
            const img = Texture6.loadedTextures.getSprite(this.spriteId);
            this.width = img.width;
            this.height = img.height;
            this.pixels = img.data;
            return true;
          } else {
            return false;
          }
        }
        decode(buffer, code) {
          if (code === 0) {
            this.spriteId = buffer.readUnsignedShort();
          }
        }
        clearImageCache() {
          super.clearImageCache();
          this.pixels = null;
        }
        getSpriteId() {
          return this.spriteId;
        }
        getColorOutput(y) {
          const dest = this.colorImageCache.get$int(y);
          if (this.colorImageCache.invalid && this.loadSprite()) {
            const destRed = dest[0];
            const destGreen = dest[1];
            const destBlue = dest[2];
            let index = (Texture6.height === this.height ? y : y * this.height / Texture6.height | 0) * this.width;
            if (this.width === Texture6.width) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  destRed[x] = this.pixels[index++];
                  destGreen[x] = this.pixels[index++];
                  destBlue[x] = this.pixels[index++];
                  index++;
                }
                ;
              }
            } else {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  const srcX = this.width * x / Texture6.width | 0;
                  destRed[x] = this.pixels[(index + srcX) * 4 + 0] << 4;
                  destGreen[x] = this.pixels[(index + srcX) * 4 + 1] << 4;
                  destBlue[x] = this.pixels[(index + srcX) * 4 + 2] << 4;
                }
                ;
              }
            }
          }
          return dest;
        }
      }
      TextureOpSprite["__class"] = "TextureOpSprite";
      class TextureOpSquareWaveform extends TextureOp2 {
        constructor() {
          super(0, true);
          if (this.anIntArray498 === void 0) {
            this.anIntArray498 = null;
          }
          if (this.anIntArray499 === void 0) {
            this.anIntArray499 = null;
          }
          this.frequency = 10;
          this.ratio = 2048;
          this.mode = 0;
        }
        decode(buffer, code) {
          if (code === 0) {
            this.frequency = buffer.readUnsignedByte();
          } else if (code === 1) {
            this.ratio = buffer.readUnsignedShort();
          } else if (code === 2) {
            this.mode = buffer.readUnsignedByte();
          }
        }
        postDecode() {
          this.method3784();
        }
        /*private*/
        method3784() {
          this.anIntArray498 = ((s) => {
            let a = [];
            while (s-- > 0)
              a.push(0);
            return a;
          })(this.frequency + 1);
          const local17 = 4096 / this.frequency | 0;
          this.anIntArray499 = ((s) => {
            let a = [];
            while (s-- > 0)
              a.push(0);
            return a;
          })(this.frequency + 1);
          const local31 = local17 * this.ratio >> 12;
          let local33 = 0;
          for (let local35 = 0; local35 < this.frequency; local35++) {
            {
              this.anIntArray498[local35] = local33;
              this.anIntArray499[local35] = local31 + local33;
              local33 += local17;
            }
            ;
          }
          this.anIntArray498[this.frequency] = 4096;
          this.anIntArray499[this.frequency] = this.anIntArray499[0] + 4096;
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            const local26 = Texture6.normalisedY[y];
            if (this.mode === 0) {
              let local140 = 0;
              for (let local142 = 0; local142 < this.frequency; local142++) {
                {
                  if (local26 >= this.anIntArray498[local142] && local26 < this.anIntArray498[local142 + 1]) {
                    if (local26 < this.anIntArray499[local142]) {
                      local140 = 4096;
                    }
                    break;
                  }
                }
                ;
              }
              ArrayUtils.fill$int_A$int$int$int(dest, 0, Texture6.width, local140);
            } else {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  let local40 = 0;
                  let local42 = 0;
                  const normalisedX = Texture6.normalisedX[x];
                  const local49 = this.mode;
                  if (local49 === 1) {
                    local40 = normalisedX;
                  } else if (local49 === 2) {
                    local40 = (local26 + normalisedX - 4096 >> 1) + 2048;
                  } else if (local49 === 3) {
                    local40 = (normalisedX - local26 >> 1) + 2048;
                  }
                  for (let local86 = 0; local86 < this.frequency; local86++) {
                    {
                      if (this.anIntArray498[local86] <= local40 && local40 < this.anIntArray498[local86 + 1]) {
                        if (local40 < this.anIntArray499[local86]) {
                          local42 = 4096;
                        }
                        break;
                      }
                    }
                    ;
                  }
                  dest[x] = local42;
                }
                ;
              }
            }
          }
          return dest;
        }
      }
      TextureOpSquareWaveform["__class"] = "TextureOpSquareWaveform";
      class TextureOpTexture extends TextureOp2 {
        constructor() {
          super(0, false);
          if (this.width === void 0) {
            this.width = 0;
          }
          if (this.height === void 0) {
            this.height = 0;
          }
          if (this.pixels === void 0) {
            this.pixels = null;
          }
          this.textureId = -1;
        }
        getColorOutput(y) {
          const dest = this.colorImageCache.get$int(y);
          if (this.colorImageCache.invalid && this.loadTexture()) {
            let index = this.width * (Texture6.height === this.height ? y : y * this.height / Texture6.height | 0);
            const destRed = dest[0];
            const destBlue = dest[2];
            const destGreen = dest[1];
            if (this.width === Texture6.width) {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  const color = this.pixels[index++];
                  destBlue[x] = (color & 255) << 4;
                  destGreen[x] = color >> 4 & 4080;
                  destRed[x] = color >> 12 & 4080;
                }
                ;
              }
            } else {
              for (let x = 0; x < Texture6.width; x++) {
                {
                  const srcX = this.width * x / Texture6.width | 0;
                  const color = this.pixels[srcX + index];
                  destBlue[x] = (color & 255) << 4;
                  destGreen[x] = color >> 4 & 4080;
                  destRed[x] = color >> 12 & 4080;
                }
                ;
              }
            }
          }
          return dest;
        }
        /*private*/
        loadTexture() {
          if (this.pixels != null) {
            return true;
          } else if (this.textureId >= 0) {
            const img = Texture6.loadedTextures.getTexture(this.textureId);
            this.width = img.width;
            this.height = img.height;
            this.pixels = ((s) => {
              let a = [];
              while (s-- > 0)
                a.push(0);
              return a;
            })(img.data.length | 0);
            const data = img.data;
            for (let i = 0; i < img.data.length / 4; i++) {
              {
                this.pixels[i] = data[i * 4 + 0] << 16 | data[i * 4 + 1] << 8 | data[i * 4 + 2];
              }
              ;
            }
            return true;
          } else {
            return false;
          }
        }
        decode(buffer, code) {
          if (code === 0) {
            this.textureId = buffer.readUnsignedShort();
          }
        }
        clearImageCache() {
          super.clearImageCache();
          this.pixels = null;
        }
        getTextureId() {
          return this.textureId;
        }
      }
      TextureOpTexture["__class"] = "TextureOpTexture";
      class TextureOpTile extends TextureOp2 {
        constructor() {
          super(1, false);
          this.horizontalTiles = 4;
          this.verticalTiles = 4;
        }
        decode(buffer, code) {
          if (code === 0) {
            this.horizontalTiles = buffer.readUnsignedByte();
          } else if (code === 1) {
            this.verticalTiles = buffer.readUnsignedByte();
          }
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            const tileWidth = Texture6.width / this.horizontalTiles | 0;
            const tileHeight = Texture6.height / this.verticalTiles | 0;
            let src;
            if (tileHeight > 0) {
              const srcY = y % tileHeight;
              src = this.getChildMonochromeOutput(0, Texture6.height * srcY / tileHeight | 0);
            } else {
              src = this.getChildMonochromeOutput(0, 0);
            }
            for (let x = 0; x < Texture6.width; x++) {
              {
                if (tileWidth > 0) {
                  const srcX = x % tileWidth;
                  dest[x] = src[srcX * Texture6.width / tileWidth | 0];
                } else {
                  dest[x] = src[0];
                }
              }
              ;
            }
          }
          return dest;
        }
        getColorOutput(y) {
          const dest = this.colorImageCache.get$int(y);
          if (this.colorImageCache.invalid) {
            const tileWidth = Texture6.width / this.horizontalTiles | 0;
            const tileHeight = Texture6.height / this.verticalTiles | 0;
            let src;
            if (tileHeight > 0) {
              const srcY = y % tileHeight;
              src = this.getChildColorOutput(0, srcY * Texture6.height / tileHeight | 0);
            } else {
              src = this.getChildColorOutput(0, 0);
            }
            const srcRed = src[0];
            const srcGreen = src[1];
            const srcBlue = src[2];
            const destRed = dest[0];
            const destGreen = dest[1];
            const destBlue = dest[2];
            for (let x = 0; x < Texture6.width; x++) {
              {
                let index;
                if (tileWidth <= 0) {
                  index = 0;
                } else {
                  const srcX = x % tileWidth;
                  index = Texture6.width * srcX / tileWidth | 0;
                }
                destRed[x] = srcRed[index];
                destGreen[x] = srcGreen[index];
                destBlue[x] = srcBlue[index];
              }
              ;
            }
          }
          return dest;
        }
      }
      TextureOpTile["__class"] = "TextureOpTile";
      class TextureOpVerticalGradient extends TextureOp2 {
        constructor() {
          super(0, true);
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            ArrayUtils.fill$int_A$int$int$int(dest, 0, Texture6.width, Texture6.normalisedY[y]);
          }
          return dest;
        }
      }
      TextureOpVerticalGradient["__class"] = "TextureOpVerticalGradient";
      class TextureOpVoronoiNoise extends TextureOp2 {
        constructor() {
          super(0, true);
          this.aShortArray81 = ((s) => {
            let a = [];
            while (s-- > 0)
              a.push(0);
            return a;
          })(512);
          this.anInt4553 = 2;
          this.anInt4552 = 2048;
          this.seed = 0;
          this.anInt4548 = 1;
          this.anInt4551 = 5;
          this.permutation = ((s) => {
            let a = [];
            while (s-- > 0)
              a.push(0);
            return a;
          })(512);
          this.anInt4557 = 5;
        }
        postDecode() {
          this.permutation = TextureOp2.getPermutation(this.seed);
          this.method3715();
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            const local30 = Texture6.normalisedY[y] * this.anInt4557 + 2048;
            const local34 = local30 >> 12;
            const local38 = local34 + 1;
            for (let x = 0; x < Texture6.width; x++) {
              {
                TextureOpVoronoiNoise.anInt5205 = 2147483647;
                TextureOpVoronoiNoise.anInt2979 = 2147483647;
                TextureOpVoronoiNoise.anInt2464 = 2147483647;
                TextureOpVoronoiNoise.anInt4260 = 2147483647;
                const local65 = Texture6.normalisedX[x] * this.anInt4551 + 2048;
                const local69 = local65 >> 12;
                const local73 = local69 + 1;
                for (let local77 = local34 - 1; local77 <= local38; local77++) {
                  {
                    const local106 = this.permutation[(local77 >= this.anInt4557 ? local77 - this.anInt4557 : local77) & 255] & 255;
                    for (let local110 = local69 - 1; local110 <= local73; local110++) {
                      {
                        let local137 = (this.permutation[local106 + (this.anInt4551 <= local110 ? local110 - this.anInt4551 : local110) & 255] & 255) * 2;
                        const local151 = local65 - (local110 << 12) - this.aShortArray81[local137++];
                        const local164 = local30 - (local77 << 12) - this.aShortArray81[local137];
                        const local167 = this.anInt4548;
                        let local203;
                        if (local167 === 1) {
                          local203 = local164 * local164 + local151 * local151 >> 12;
                        } else if (local167 === 3) {
                          const local213 = local151 >= 0 ? local151 : -local151;
                          const local220 = local164 < 0 ? -local164 : local164;
                          local203 = local220 >= local213 ? local220 : local213;
                        } else if (local167 === 4) {
                          const local244 = Math.sqrt(Math.fround((local151 < 0 ? -local151 : local151) / 4096)) * 4096 | 0;
                          const local262 = Math.sqrt(Math.fround((local164 >= 0 ? local164 : -local164) / 4096)) * 4096 | 0;
                          const local266 = local262 + local244;
                          local203 = local266 * local266 >> 12;
                        } else if (local167 === 5) {
                          const local278 = local151 * local151;
                          const local282 = local164 * local164;
                          local203 = Math.sqrt(Math.sqrt(Math.fround((local278 + local282) / 16777216))) * 4096 | 0;
                        } else if (local167 === 2) {
                          local203 = (local151 < 0 ? -local151 : local151) + (local164 >= 0 ? local164 : -local164);
                        } else {
                          local203 = Math.sqrt(Math.fround((local151 * local151 + local164 * local164) / 16777216)) * 4096 | 0;
                        }
                        if (local203 < TextureOpVoronoiNoise.anInt4260) {
                          TextureOpVoronoiNoise.anInt5205 = TextureOpVoronoiNoise.anInt2979;
                          TextureOpVoronoiNoise.anInt2979 = TextureOpVoronoiNoise.anInt2464;
                          TextureOpVoronoiNoise.anInt2464 = TextureOpVoronoiNoise.anInt4260;
                          TextureOpVoronoiNoise.anInt4260 = local203;
                        } else if (local203 < TextureOpVoronoiNoise.anInt2464) {
                          TextureOpVoronoiNoise.anInt5205 = TextureOpVoronoiNoise.anInt2979;
                          TextureOpVoronoiNoise.anInt2979 = TextureOpVoronoiNoise.anInt2464;
                          TextureOpVoronoiNoise.anInt2464 = local203;
                        } else if (local203 < TextureOpVoronoiNoise.anInt2979) {
                          TextureOpVoronoiNoise.anInt5205 = TextureOpVoronoiNoise.anInt2979;
                          TextureOpVoronoiNoise.anInt2979 = local203;
                        } else if (TextureOpVoronoiNoise.anInt5205 > local203) {
                          TextureOpVoronoiNoise.anInt5205 = local203;
                        }
                      }
                      ;
                    }
                  }
                  ;
                }
                const local390 = this.anInt4553;
                if (local390 === 0) {
                  dest[x] = TextureOpVoronoiNoise.anInt4260;
                } else if (local390 === 1) {
                  dest[x] = TextureOpVoronoiNoise.anInt2464;
                } else if (local390 === 3) {
                  dest[x] = TextureOpVoronoiNoise.anInt2979;
                } else if (local390 === 4) {
                  dest[x] = TextureOpVoronoiNoise.anInt5205;
                } else if (local390 === 2) {
                  dest[x] = TextureOpVoronoiNoise.anInt2464 - TextureOpVoronoiNoise.anInt4260;
                }
              }
              ;
            }
          }
          return dest;
        }
        /*private*/
        method3715() {
          const random = new Random(this.seed);
          this.aShortArray81 = ((s) => {
            let a = [];
            while (s-- > 0)
              a.push(0);
            return a;
          })(512);
          if (this.anInt4552 > 0) {
            for (let local27 = 0; local27 < 512; local27++) {
              {
                this.aShortArray81[local27] = RandomUtils.nextInt(random, this.anInt4552) | 0;
              }
              ;
            }
          }
        }
        decode(buffer, code) {
          if (code === 0) {
            this.anInt4551 = this.anInt4557 = buffer.readUnsignedByte();
          } else if (code === 1) {
            this.seed = buffer.readUnsignedByte();
          } else if (code === 2) {
            this.anInt4552 = buffer.readUnsignedShort();
          } else if (code === 3) {
            this.anInt4553 = buffer.readUnsignedByte();
          } else if (code === 4) {
            this.anInt4548 = buffer.readUnsignedByte();
          } else if (code === 5) {
            this.anInt4551 = buffer.readUnsignedByte();
          } else if (code === 6) {
            this.anInt4557 = buffer.readUnsignedByte();
          }
        }
      }
      TextureOpVoronoiNoise.anInt5205 = 0;
      TextureOpVoronoiNoise.anInt2979 = 0;
      TextureOpVoronoiNoise.anInt2464 = 0;
      TextureOpVoronoiNoise.anInt4260 = 0;
      TextureOpVoronoiNoise["__class"] = "TextureOpVoronoiNoise";
      class TextureOpWaveform extends TextureOp2 {
        constructor() {
          super(0, true);
          this.shape = 0;
          this.frequency = 1;
          this.waveform = 0;
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            const local26 = Texture6.normalisedY[y];
            const local32 = local26 - 2048 >> 1;
            for (let x = 0; x < Texture6.width; x++) {
              {
                const local41 = Texture6.normalisedX[x];
                const local47 = local41 - 2048 >> 1;
                let local79;
                if (this.shape === 0) {
                  local79 = (local41 - local26) * this.frequency;
                } else {
                  const local60 = local32 * local32 + local47 * local47 >> 12;
                  const local70 = Math.sqrt(Math.fround(local60 / 4096)) * 4096 | 0;
                  local79 = this.frequency * local70 * 3.141592653589793 | 0;
                }
                let local95 = local79 - (local79 & -4096);
                if (this.waveform === 0) {
                  local95 = TextureOp2.SINE[local95 >> 4 & 255] + 4096 >> 1;
                } else if (this.waveform === 2) {
                  let local118 = local95 - 2048;
                  if (local118 < 0) {
                    local118 = -local118;
                  }
                  local95 = 2048 - local118 << 1;
                }
                dest[x] = local95;
              }
              ;
            }
          }
          return dest;
        }
        postDecode() {
          TextureOp2.createTrigonometryTables();
        }
        decode(buffer, code) {
          if (code === 0) {
            this.shape = buffer.readUnsignedByte();
          } else if (code === 1) {
            this.waveform = buffer.readUnsignedByte();
          } else if (code === 3) {
            this.frequency = buffer.readUnsignedByte();
          }
        }
      }
      TextureOpWaveform["__class"] = "TextureOpWaveform";
      class TextureOpWeave extends TextureOp2 {
        constructor() {
          super(0, true);
          this.thickness = 585;
        }
        decode(buffer, code) {
          if (code === 0) {
            this.thickness = buffer.readUnsignedShort();
          }
        }
        getMonochromeOutput(y) {
          const dest = this.monochromeImageCache.get$int(y);
          if (this.monochromeImageCache.invalid) {
            const local27 = Texture6.normalisedY[y];
            for (let x = 0; x < Texture6.width; x++) {
              {
                const local40 = Texture6.normalisedX[x];
                if (this.thickness < local40 && 4096 - this.thickness > local40 && local27 > 2048 - this.thickness && this.thickness + 2048 > local27) {
                  let local78 = 2048 - local40;
                  local78 = local78 < 0 ? -local78 : local78;
                  local78 <<= 12;
                  local78 = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(local78 / 2048 - this.thickness);
                  dest[x] = 4096 - local78;
                } else if (2048 - this.thickness < local40 && this.thickness + 2048 > local40) {
                  let local127 = local27 - 2048;
                  local127 = local127 >= 0 ? local127 : -local127;
                  local127 -= this.thickness;
                  local127 <<= 12;
                  dest[x] = local127 / (2048 - this.thickness) | 0;
                } else if (local27 < this.thickness || local27 > 4096 - this.thickness) {
                  let local180 = local40 - 2048;
                  local180 = local180 < 0 ? -local180 : local180;
                  local180 -= this.thickness;
                  local180 <<= 12;
                  dest[x] = local180 / (2048 - this.thickness) | 0;
                } else if (this.thickness <= local40 && local40 <= 4096 - this.thickness) {
                  dest[x] = 0;
                } else {
                  let local236 = 2048 - local27;
                  local236 = local236 < 0 ? -local236 : local236;
                  local236 <<= 12;
                  local236 = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(local236 / 2048 - this.thickness);
                  dest[x] = 4096 - local236;
                }
              }
              ;
            }
          }
          return dest;
        }
      }
      TextureOpWeave["__class"] = "TextureOpWeave";
      class TextureOpTiledSprite extends TextureOpSprite {
        getColorOutput(y) {
          const dest = this.colorImageCache.get$int(y);
          if (this.colorImageCache.invalid && this.loadSprite()) {
            const destGreen = dest[1];
            const destBlue = dest[2];
            const srcY = this.height * (y % this.height);
            const destRed = dest[0];
            for (let x = 0; x < Texture6.width; x++) {
              {
                const color = this.pixels[srcY + x % this.width];
                destBlue[x] = (color & 255) << 4;
                destGreen[x] = color >> 4 & 4080;
                destRed[x] = color >> 12 & 4080;
              }
              ;
            }
          }
          return dest;
        }
      }
      TextureOpTiledSprite["__class"] = "TextureOpTiledSprite";
      MonochromeImageCache.PERLIN_FADE_$LI$();
      MonochromeImageCache.__static_initialize();
      Texture6.brightnessMap_$LI$();
      TextureOp2.permutations_$LI$();
      MonochromeImageCacheEntry.VALID_$LI$();
      ColorImageCacheEntry.VALID_$LI$();
      TextureMathUtils.INVERSE_SQUARE_ROOT_$LI$();
      TextureMathUtils.__static_initialize();
      Random.twoToTheXMinus48_$LI$();
      Random.twoToTheXMinus24_$LI$();
      Random.__static_initialize();
      BufferPool.largeBuffers_$LI$();
      BufferPool.mediumBuffers_$LI$();
      BufferPool.smallBuffers_$LI$();
      module.exports = {
        Texture: Texture6,
        Buffer: Buffer2
      };
    })();
  }
});

// rsmv/src/rs3shaders/minimap-loc-vert.glsl.c
var require_minimap_loc_vert_glsl = __commonJS({
  "rsmv/src/rs3shaders/minimap-loc-vert.glsl.c"(exports, module) {
    module.exports = "\r\n#version 460\r\n\r\n/***************************************************/\r\n/***************** GLSL Header *********************/\r\n/***************************************************/\r\n#ifdef GL_EXT_gpu_shader4\r\n#extension GL_EXT_gpu_shader4 : enable\r\n#endif\r\n#ifdef GL_ARB_gpu_shader5\r\n#extension GL_ARB_gpu_shader5 : enable\r\n#endif\r\n#ifdef GL_ARB_derivative_control\r\n#extension GL_ARB_derivative_control : enable\r\n#endif\r\n\r\n#ifdef GL_ARB_texture_gather\r\n#extension GL_ARB_texture_gather : enable\r\n#endif\r\n\r\n#define OGL_BACKEND\r\n\r\n#undef attribute\r\n#define attribute in\r\n\r\n#undef gl_FragColor\r\n#define gl_FragColor FragColor\r\n\r\n#define shadow2DCompat texture\r\n\r\n#undef textureCube\r\n#define textureCube texture\r\n\r\n#undef texture2D\r\n#define texture2D texture\r\n\r\n#undef texture3D\r\n#define texture3D texture\r\n\r\n#undef texture2DLod\r\n#define texture2DLod textureLod\r\n\r\n#undef textureCubeLod\r\n#define textureCubeLod textureLod\r\n\r\n#undef texture2DGrad\r\n#define texture2DGrad textureGrad\r\n\r\n#define MSAA_AVAILABLE\r\n\r\n#define TEXTURE_OFFSET_AVAILABLE\r\n#if !defined(lowp)\r\n#define lowp\r\n#endif\r\n#if !defined(mediump)\r\n#define mediump\r\n#endif\r\n#if !defined(highp)\r\n#define highp\r\n#endif\r\n\r\n#define GRAPHICS_QUALITY_LOW 0\r\n#define GRAPHICS_QUALITY_MEDIUM 1\r\n#define GRAPHICS_QUALITY_HIGH 2\r\n#define GRAPHICS_QUALITY_ULTRA 3\r\n\r\n#define shadow2DLodCompat texture2DLod\r\n\r\n#define texture2DLodCompat texture2DLod\r\n\r\n#define textureCubeLodCompat textureCubeLod\r\n\r\n#define textureGatherCompat(sampler, texCoord, viewportScale) textureGather(sampler, texCoord).wzxy\r\n\r\n#define UNIFORM_BUFFER_BEGIN(name) \\\r\n    layout(std140) uniform name    \\\r\n    {\r\n#define UNIFORM_BUFFER_END \\\r\n    }                      \\\r\n    ;\r\n\r\nmat3 Mat4ToMat3(const mat4 inputMatrix)\r\n{\r\n    return mat3(inputMatrix);\r\n}\r\n\r\n#define isNaN isnan\r\n\r\n#ifndef GL_ARB_derivative_control\r\n#define dFdxFine dFdx\r\n#define dFdyFine dFdy\r\n#define fwidthFine fwidth\r\n#endif\r\n\r\n/***************************************************/\r\n\r\n/***************************************************/\r\n/***************** Effect Defines ******************/\r\n/***************************************************/\r\n#define TEXTURE_ALBEDO_GLOBAL\r\n#define SUNLIGHT_DIRECT_LIGHTING\r\n#define TEXTURE_ATLAS\r\n#define VIEW_TRANSFORMS\r\n#define TINT\r\n\r\n/*************************************************/\r\n\r\n/***************************************************/\r\n/********** Mandatory Shader Fragments *************/\r\n/***************************************************/\r\n\r\n#define GRAPHICS_QUALITY_LOW 0\r\n#define GRAPHICS_QUALITY_MEDIUM 1\r\n#define GRAPHICS_QUALITY_HIGH 2\r\n#define GRAPHICS_QUALITY_ULTRA 3\r\n\r\n#define MATERIAL_SETTINGS_SLOT_PIXEL_RESOLUTION_X 3.0\r\n#define MATERIAL_SETTINGS_SLOT_PIXEL_RESOLUTION_Y 4.0\r\n#define MATERIAL_SETTINGS_SLOTS_DIMENSION_COUNT_X 42.0\r\n#define MATERIAL_SETTINGS_SLOTS_DIMENSION_COUNT_Y 32.0\r\n#define MATERIAL_SETTINGS_TEXTURE_RESOLUTION 128.0\r\n#ifndef MATH_UTILS_INC\r\n#define MATH_UTILS_INC\r\nconst float PI = 3.14159, INV_PI = .31831, TWOPI = PI * 2., INV_TWOPI = 1. / TWOPI, PI_OVER_4 = PI / 4., PI_OVER_2 = PI / 2., SQRT_2_PI = .797885, INV_EIGHT = .125;\r\nfloat SpecPowToBeckmannRoughness(float f) { return sqrt(2. / (f + 2.)); }\r\nfloat PerceptualRoughnessToRoughness(float f) { return f * f; }\r\nfloat RoughnessToPerceptualRoughness(float f) { return sqrt(f); }\r\n#endif\r\n#ifndef CONVERSION_UTILS_INC\r\n#define CONVERSION_UTILS_INC\r\nvec3 SRGBToLinear(vec3 srgbColour)\r\n{\r\n#if defined(GAMMA_CORRECT_INPUTS)\r\n    return srgbColour * srgbColour;\r\n#else\r\n    return pow(srgbColour, vec3(2.2, 2.2, 2.2));\r\n#endif\r\n}\r\nvec3 LinearToSRGB(vec3 s) { return max(vec3(1.055) * pow(s, vec3(.416667)) - vec3(.055), vec3(0.)); }\r\nfloat LinearToSRGB(float s)\r\n{\r\n    const float p = 1. / 2.2;\r\n    return pow(s, p);\r\n}\r\nvec3 LinearToSRGBRunescape(vec3 s) { return sqrt(s); }\r\nfloat LinearToSRGBRunescape(float s) { return sqrt(s); }\r\nvec4 convertRGBtoHSL(vec4 s)\r\n{\r\n    const float p = 1. / 6.;\r\n    float v = s.s, m = s.t, t = s.p, f = min(min(s.s, s.t), s.p), q = max(max(s.s, s.t), s.p), r = q - f, G = (f + q) * .5, i = 0., e = 0.;\r\n    if (G > 0. && G < 1.)\r\n    {\r\n        float L = G < .5 ? G : 1. - G;\r\n        i = r / (L * 2.);\r\n    }\r\n    if (r > 0.)\r\n    {\r\n        vec3 L = vec3(q == v && q != m ? 1. : 0., q == m && q != t ? 1. : 0., q == t && q != v ? 1. : 0.), o = vec3((m - t) / r, 2. + (t - v) / r, 4. + (v - m) / r);\r\n        e += dot(o, L);\r\n        e *= p;\r\n        if (e < 0.)\r\n            e += 1.;\r\n    }\r\n    return vec4(e, i, G, s.q);\r\n}\r\nvec4 convertHSLtoRGB(vec4 s)\r\n{\r\n    const float v = 1. / 3., q = 2. / 3., m = 6.;\r\n    float p = s.s, t = s.t, r = s.p;\r\n    vec3 f = vec3(m * (p - q), 0., m * (1. - p));\r\n    if (p < q)\r\n        f.s = 0., f.t = m * (q - p), f.p = m * (p - v);\r\n    if (p < v)\r\n        f.s = m * (v - p), f.t = m * p, f.p = 0.;\r\n    f = min(f, 1.);\r\n    float L = 2. * t, i = 1. - t, G = 1. - r, e = 2. * r - 1.;\r\n    vec3 c = L * f + i, o;\r\n    if (r >= .5)\r\n        o = G * c + e;\r\n    else\r\n        o = r * c;\r\n    return vec4(o, s.q);\r\n}\r\n#endif\r\n#ifndef PACK_UTILS_INC\r\n#define PACK_UTILS_INC\r\n#ifndef SHADER_LIB_COMMON_INC\r\n#define SHADER_LIB_COMMON_INC\r\n#define USE_MOD_PACK\r\n#endif\r\n\r\nvec4 PackFloatToRGBA(highp float valueToPack)\r\n{\r\n#if defined(USE_MOD_PACK) || defined(USE_FRACT_PACK)\r\n    const highp vec4 bitShift = vec4(256 * 256 * 256, 256 * 256, 256, 1.0);\r\n    const highp vec4 bitMask = vec4(0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\r\n    highp vec4 fragColour = mod(valueToPack * bitShift * vec4(255), vec4(256)) / vec4(255);\r\n    return fragColour - fragColour.xxyz * bitMask;\r\n#endif\r\n#ifdef USE_ARAS_PACK\r\n    const highp vec4 bitShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\r\n    const highp vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\r\n    highp vec4 fragColour = fract(valueToPack * bitShift);\r\n    return fragColour - (fragColour.xxyz * bitMask);\r\n#endif\r\n}\r\nvec2 NormalPackSphereMap(vec3 v)\r\n{\r\n    vec2 f = normalize(v.st) * sqrt(-v.p * .5 + .5);\r\n    f = f * .5 + .5;\r\n    return f * 65535.;\r\n}\r\nvec2 PackFloatToVec2(float v)\r\n{\r\n    vec2 f;\r\n    const float b = 1. / 255.;\r\n    vec2 h = vec2(1., 255.), r = fract(h * v);\r\n    r.s -= r.t * b;\r\n    return r.st;\r\n}\r\n#endif\r\n#ifndef UNPACK_UTILS_INC\r\n#define UNPACK_UTILS_INC\r\n#ifndef SHADER_LIB_COMMON_INC\r\n#define SHADER_LIB_COMMON_INC\r\n#define USE_MOD_PACK\r\n#endif\r\n\r\nhighp float UnpackRGBAToFloat(highp vec4 valueToUnpack)\r\n{\r\n#if defined(USE_MOD_PACK) || defined(USE_FRACT_PACK)\r\n    const highp vec4 bitShifts = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\r\n    return dot(valueToUnpack, bitShifts);\r\n#endif\r\n#ifdef USE_ARAS_PACK\r\n    const highp vec4 bitShifts = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);\r\n    return dot(valueToUnpack, bitShifts);\r\n#endif\r\n}\r\nvec3 ColourUnpack(highp float v)\r\n{\r\n    vec3 f;\r\n    f.s = floor(v / 256. / 256.);\r\n    f.t = floor((v - f.s * 256. * 256.) / 256.);\r\n    f.p = floor(v - f.s * 256. * 256. - f.t * 256.);\r\n    return f / 256.;\r\n}\r\nvec3 NormalUnpackSphereMap(vec2 v)\r\n{\r\n    vec4 f = vec4(v.s / 32767. - 1., v.t / 32767. - 1., 1., -1.);\r\n    float U = dot(f.stp, -f.stq);\r\n    f.st *= sqrt(U);\r\n    f.p = U;\r\n    return f.stp * 2. + vec3(0., 0., -1.);\r\n}\r\nhighp float UnpackRGBAToIntegerFloat(highp vec4 f) { return floor(f.s * 255. + .5) * 256. * 256. * 256. + floor(f.t * 255. + .5) * 256. * 256. + floor(f.p * 255. + .5) * 256. + floor(f.q * 255. + .5); }\r\nhighp float UnpackRGBAToIntegerFloat16(highp vec2 f) { return floor(f.s * 255. + .5) * 256. + floor(f.t * 255. + .5); }\r\nhighp int UnpackRGBAToInt(vec4 f) { return int(UnpackRGBAToIntegerFloat(f)); }\r\nhighp vec4 UnpackFloatToRGBA(highp float f)\r\n{\r\n    const highp vec4 v = vec4(1., 255., 65025., 1.65814e+07), s = vec4(vec3(1. / 255.), 0.);\r\n    highp vec4 U = fract(f * v);\r\n    U -= U.sstp * s;\r\n    return U;\r\n}\r\nhighp float UnpackVec2ToFloat(highp vec2 f) { return floor(f.s * 255. + .5) * 256. + floor(f.t * 255. + .5); }\r\n#endif\r\n#if defined(MSAA) && defined(MSAA_AVAILABLE)\r\n#define SAMPLER_2D_AUTO_MULTISAMPLE sampler2DMS\r\n#define MSAA_SAMPLERS_ENABLED 1\r\n#define texture2DMultisample(sampler, texCoord, texSize) texelFetch(sampler, ivec2((texCoord)*texSize), 0)\r\n#else\r\n#define SAMPLER_2D_AUTO_MULTISAMPLE sampler2D\r\n#define MSAA_SAMPLERS_ENABLED 0\r\n#define texture2DMultisample(sampler, texCoord, texSize) texture2DLodCompat(sampler, texCoord, 0.0)\r\n#endif\r\nUNIFORM_BUFFER_BEGIN(ViewportLookupScale)\r\nuniform highp vec4 uViewportLookupScale;\r\nuniform highp vec4 uViewportOffsetScale;\r\nuniform highp vec4 uFullScreenLookupScale;\r\nUNIFORM_BUFFER_END\r\n\r\n/***************************************************/\r\n\r\nattribute vec4 aVertexPosition_BoneLabel;\r\nattribute vec2 aTextureUV;\r\nattribute vec4 aVertexNormal_BatchFlags, aVertexTangent, aVertexColour, aVertexColourUnwhitenedRGB_TilePositionLevel, aMaterialSettingsSlotXY_TilePositionXZ, aVertexSkinBones, aVertexSkinWeights;\r\nuniform float uSmoothSkinning;\r\nuniform mat4 uModelMatrix;\r\nuniform float uVertexScale;\r\n\r\nUNIFORM_BUFFER_BEGIN(ViewTransforms)\r\nuniform highp vec3 uCameraPosition;\r\nuniform highp mat4 uViewMatrix;\r\nuniform highp mat4 uProjectionMatrix;\r\nuniform highp mat4 uViewProjMatrix;\r\nuniform highp vec4 uZBufferParams;\r\nUNIFORM_BUFFER_END\r\nuniform mediump vec4 uTint;\r\nuniform float uFade;\r\nout highp vec3 vWorldPosition;\r\nout highp vec3 vNormal;\r\nout mediump vec4 vVertexAlbedo;\r\nout vec2 vTextureUV;\r\nflat out vec3 vMaterialSettingsSlotXY_BatchFlags;\r\n#ifndef CONVERSION_UTILS_INC\r\n#define CONVERSION_UTILS_INC\r\nvec3 SRGBToLinear(vec3 srgbColour)\r\n{\r\n#if defined(GAMMA_CORRECT_INPUTS)\r\n    return srgbColour * srgbColour;\r\n#else\r\n    return pow(srgbColour, vec3(2.2, 2.2, 2.2));\r\n#endif\r\n}\r\nvec3 LinearToSRGB(vec3 s) { return max(vec3(1.055) * pow(s, vec3(.416667)) - vec3(.055), vec3(0.)); }\r\nfloat LinearToSRGB(float s)\r\n{\r\n    const float p = 1. / 2.2;\r\n    return pow(s, p);\r\n}\r\nvec3 LinearToSRGBRunescape(vec3 s) { return sqrt(s); }\r\nfloat LinearToSRGBRunescape(float s) { return sqrt(s); }\r\nvec4 convertRGBtoHSL(vec4 s)\r\n{\r\n    const float p = 1. / 6.;\r\n    float v = s.s, m = s.t, t = s.p, f = min(min(s.s, s.t), s.p), q = max(max(s.s, s.t), s.p), r = q - f, G = (f + q) * .5, i = 0., e = 0.;\r\n    if (G > 0. && G < 1.)\r\n    {\r\n        float L = G < .5 ? G : 1. - G;\r\n        i = r / (L * 2.);\r\n    }\r\n    if (r > 0.)\r\n    {\r\n        vec3 L = vec3(q == v && q != m ? 1. : 0., q == m && q != t ? 1. : 0., q == t && q != v ? 1. : 0.), o = vec3((m - t) / r, 2. + (t - v) / r, 4. + (v - m) / r);\r\n        e += dot(o, L);\r\n        e *= p;\r\n        if (e < 0.)\r\n            e += 1.;\r\n    }\r\n    return vec4(e, i, G, s.q);\r\n}\r\nvec4 convertHSLtoRGB(vec4 s)\r\n{\r\n    const float v = 1. / 3., q = 2. / 3., m = 6.;\r\n    float p = s.s, t = s.t, r = s.p;\r\n    vec3 f = vec3(m * (p - q), 0., m * (1. - p));\r\n    if (p < q)\r\n        f.s = 0., f.t = m * (q - p), f.p = m * (p - v);\r\n    if (p < v)\r\n        f.s = m * (v - p), f.t = m * p, f.p = 0.;\r\n    f = min(f, 1.);\r\n    float L = 2. * t, i = 1. - t, G = 1. - r, e = 2. * r - 1.;\r\n    vec3 c = L * f + i, o;\r\n    if (r >= .5)\r\n        o = G * c + e;\r\n    else\r\n        o = r * c;\r\n    return vec4(o, s.q);\r\n}\r\n#endif\r\n\r\n#if defined(TEXTURE_ATLAS) && defined(NORMAL_MAP)\r\n#define USE_NORMAL_MAP\r\n#endif\r\n\r\n#if __VERSION__ <= 120\r\n#ifdef in\r\n#undef in\r\n#endif\r\n#ifdef out\r\n#undef out\r\n#endif\r\n#endif\r\n\r\n#if defined(ANIMATION_VERTEX)\r\n#if defined(USE_BONE_HALF_FLOATS)\r\nmat4 GetBoneFromIndex(float u)\r\n{\r\n    uint f = uint(u), v = f % 2u, n = (f * 3u - v) / 2u;\r\n    uvec4 d = (1u - v) * uBoneTransforms[n] + v * uvec4(uBoneTransforms[n].pq, uBoneTransforms[n + 1u].st);\r\n    uvec2 G = (1u - v) * uvec2(uBoneTransforms[n + 1u].st) + v * uvec2(uBoneTransforms[n + 1u].pq);\r\n    vec2 m = unpackHalf2x16(d.s), A = unpackHalf2x16(d.t), e = unpackHalf2x16(d.p), U = unpackHalf2x16(d.q), s = unpackHalf2x16(G.s), a = unpackHalf2x16(G.t);\r\n    mat4 t = mat4(vec4(m.st, A.s, 0.), vec4(A.t, e.st, 0.), vec4(U.st, s.s, 0.), vec4(s.t, a.st, 1.));\r\n    return t;\r\n}\r\n#else\r\nmat4 GetBoneFromIndex(float u)\r\n{\r\n    int n = int(u * 3.);\r\n    return mat4(vec4(uBoneTransforms[n].stp, 0.), vec4(uBoneTransforms[n].q, uBoneTransforms[n + 1].st, 0.), vec4(uBoneTransforms[n + 1].pq, uBoneTransforms[n + 2].s, 0.), vec4(uBoneTransforms[n + 2].tpq, 1.));\r\n}\r\n#endif\r\n#endif\r\n\r\nvoid AssignTextureAtlasVaryings(out vec2 d, out vec2 v, vec2 s, vec2 p)\r\n{\r\n    d = s.st, v = p;\r\n}\r\nmat3 ResolveNormalTransformMatrix(mat4 v)\r\n{\r\n    mat3 p = Mat4ToMat3(v);\r\n#if defined(ANIMATION_VERTEX)\r\n    const highp float d = 2e-16;\r\n    float s = step(d, abs(p[0].s) + abs(p[1].t));\r\n    p[0].s = mix(1., p[0].s, s);\r\n    p[1].t = mix(1., p[1].t, s);\r\n#endif\r\n    return p;\r\n}\r\nvec2 ClipSpacePosToUVSpacePos(vec2 s) { return s.st * .5 + vec2(.5, .5); }\r\nvec4 OffsetPositionAlongNormal(vec4 p, vec3 s, vec4 t, vec2 d, float v)\r\n{\r\n    if (v <= 0.)\r\n        return t;\r\n    else\r\n    {\r\n        vec2 a = t.st / t.q, l = ClipSpacePosToUVSpacePos(a) * d;\r\n        vec4 f = p;\r\n        f.stp -= s;\r\n        vec4 u = uViewProjMatrix * f;\r\n        vec2 G = ClipSpacePosToUVSpacePos(u.st / u.q) * d;\r\n        u.st = a;\r\n        vec2 q = G - l;\r\n        q = -q;\r\n        float A = dot(q, q);\r\n        if (A > 0.)\r\n            q /= sqrt(A), u.st += q * v / d;\r\n        u.st *= u.q;\r\n        return u;\r\n    }\r\n}\r\n#if defined(ANIMATION_VERTEX)\r\nmat4 GetBoneMatrix(out float s)\r\n{\r\n    s = floor(aVertexPosition_BoneLabel.q / 256.);\r\n    float v = aVertexPosition_BoneLabel.q - s * 256.;\r\n    mat4 p = GetBoneFromIndex(v), f = uSmoothSkinning < 0. ? mat4(1.) : GetBoneFromIndex(aVertexSkinBones.s);\r\n    if (uSmoothSkinning > 0.)\r\n    {\r\n        f *= aVertexSkinWeights.s;\r\n        mat4 u = GetBoneFromIndex(aVertexSkinBones.t);\r\n        f += u * aVertexSkinWeights.t;\r\n        u = GetBoneFromIndex(aVertexSkinBones.p);\r\n        f += u * aVertexSkinWeights.p;\r\n        u = GetBoneFromIndex(aVertexSkinBones.q);\r\n        f += u * aVertexSkinWeights.q;\r\n    }\r\n    return f * p;\r\n}\r\nmat4 GetBoneMatrixRigid(out float s)\r\n{\r\n    s = floor(aVertexPosition_BoneLabel.q / 256.);\r\n    float v = aVertexPosition_BoneLabel.q - s * 256.;\r\n    mat4 p = GetBoneFromIndex(v), u = uSmoothSkinning < 0. ? mat4(1.) : GetBoneFromIndex(aVertexSkinBones.s);\r\n    return u * p;\r\n}\r\n#endif\r\nvoid AssignPositionNormalVaryings(out float v)\r\n{\r\n    vec3 u = aVertexPosition_BoneLabel.stp;\r\n    mat4 p;\r\n#if defined(ANIMATION_VERTEX)\r\n    mat4 d = GetBoneMatrix(v), s = uModelMatrix;\r\n    p = s * d;\r\n#else\r\n    v = 0.;\r\n    p = uModelMatrix;\r\n#endif\r\n    vec3 a = u * uVertexScale;\r\n    vec4 t = p * vec4(a, 1.),\r\n         q = uViewProjMatrix * t;\r\n#if !defined(MODEL_GEOMETRY_SHADOW_VS)\r\n    mat3 f = ResolveNormalTransformMatrix(p);\r\n    vNormal = f * aVertexNormal_BatchFlags.stp;\r\n    vNormal = normalize(vNormal);\r\n    vNormal = isNaN(vNormal.s) ? vec3(0., 1., 0.) : vNormal;\r\n#if defined(USE_NORMAL_MAP) && !defined(PER_FRAGMENT_TANGENTS)\r\n    vTangent.stp = f * aVertexTangent.stp;\r\n    vTangent.stp = normalize(vTangent.stp);\r\n    vTangent.stp = isNaN(vTangent.s) ? vec3(1., 0., 0.) : vTangent.stp;\r\n    vTangent.q = aVertexTangent.q;\r\n#endif\r\n\r\n#if defined(MODEL_GEOMETRY_HIGHLIGHT_VS)\r\n    q = OffsetPositionAlongNormal(t, vNormal, q, uViewportLookupScale.pq, uHighlightScale);\r\n#endif\r\n    vWorldPosition = t.stp;\r\n#endif\r\n    gl_Position = q;\r\n#if !defined(ANIMATION_VERTEX) && defined(PUSH_TO_FARPLANE)\r\n    gl_Position.p = gl_Position.q * .9999;\r\n#endif\r\n}\r\n#if __VERSION__ <= 120\r\n#define in varying\r\n#define out varying\r\n#endif\r\n\r\nvoid main()\r\n{\r\n    float d = 1.;\r\n    AssignPositionNormalVaryings(d);\r\n#if defined(TEXTURE_ATLAS)\r\n\r\n#if defined(TEXTURE_ALBEDO_GLOBAL)\r\n    vVertexAlbedo = aVertexColour;\r\n#else\r\n    vVertexAlbedo = vec4(mix(aVertexColourUnwhitenedRGB_TilePositionLevel.stp, aVertexColour.stp, step(.5, fract(aVertexNormal_BatchFlags.q * 8.))), aVertexColour.q);\r\n#endif\r\n\r\n#else\r\n    vVertexAlbedo = vec4(aVertexColourUnwhitenedRGB_TilePositionLevel.stp, aVertexColour.q);\r\n#endif\r\n    // vVertexAlbedo.q += uFade;\r\n#if defined(TINT)\r\n\r\n#if !defined(PUSH_TO_FARPLANE)\r\n    // vVertexAlbedo.stp = vVertexAlbedo.stp + uTint.q * (uTint.stp - vVertexAlbedo.stp);\r\n#endif\r\n\r\n#endif\r\n\r\n#if defined(ANIMATION_VERTEX)\r\n    vVertexAlbedo.q += uLabelDeltas[int(d)].q;\r\n    vVertexAlbedo.q = clamp(vVertexAlbedo.q, 0., 1.);\r\n#if defined(ANIMATION_COLOUR_RGB) || defined(ANIMATION_COLOUR_HSL)\r\n\r\n#if defined(ANIMATION_COLOUR_RGB)\r\n    vVertexAlbedo.stp += uLabelDeltas[int(d)].stp;\r\n#endif\r\n\r\n#if defined(ANIMATION_COLOUR_HSL)\r\n    vVertexAlbedo = convertRGBtoHSL(vVertexAlbedo);\r\n    vVertexAlbedo.s = fract(vVertexAlbedo.s + uLabelDeltas[int(d)].s);\r\n    vVertexAlbedo.tp = clamp(vVertexAlbedo.tp + uLabelDeltas[int(d)].tp, 0., 1.);\r\n    vVertexAlbedo = convertHSLtoRGB(vVertexAlbedo);\r\n#endif\r\n\r\n#if defined(BAKED_SRGB_TO_LINEAR) && !defined(GAMMA_CORRECT_INPUTS)\r\n    vVertexAlbedo.stp = SRGBToLinear(vVertexAlbedo.stp);\r\n#endif\r\n\r\n#endif\r\n\r\n#endif\r\n\r\n#if !defined(BAKED_SRGB_TO_LINEAR) && defined(GAMMA_CORRECT_INPUTS)\r\n    vVertexAlbedo.stp = SRGBToLinear(vVertexAlbedo.stp);\r\n#endif\r\n\r\n#if defined(GOURAUD_SHADING)\r\n    float p = dot(vNormal, uInvSunDirection);\r\n    vVertexAlbedo.stp = vVertexAlbedo.stp * (uAmbientColour + uSunColour * p);\r\n#endif\r\n\r\n#if defined(POINT_LIGHTING)\r\n    vTilePosition = vec3(floor(aVertexColourUnwhitenedRGB_TilePositionLevel.q * 255. + .1), aMaterialSettingsSlotXY_TilePositionXZ.pq);\r\n#endif\r\n    vMaterialSettingsSlotXY_BatchFlags.p = aVertexNormal_BatchFlags.q + .25 / 128.;\r\n#if defined(TEXTURE_ATLAS)\r\n    AssignTextureAtlasVaryings(vTextureUV, vMaterialSettingsSlotXY_BatchFlags.st, aTextureUV, aMaterialSettingsSlotXY_TilePositionXZ.st);\r\n#endif\r\n\r\n#if defined(DEBUG_VERTEX_BONE_COLOUR)\r\n\r\n#if defined(ANIMATION_VERTEX)\r\n    vVertexAlbedo.stpq = vec4(mod(aVertexPosition_BoneLabel.q / 5., 1.), mod(aVertexPosition_BoneLabel.q / 14., 1.), mod(aVertexPosition_BoneLabel.q / 63., 1.), 1.);\r\n#else\r\n    vVertexAlbedo.stpq = vec4(0.);\r\n#endif\r\n\r\n#endif\r\n\r\n#if defined(LIGHT_SCATTERING) || defined(FOG_DISTANCE)\r\n    vec4 o = uModelMatrix * vec4(aVertexPosition_BoneLabel.stp, 1.);\r\n    vec3 v = o.stp - uCameraPosition;\r\n    float a = length(v);\r\n#if defined(LIGHT_SCATTERING) && defined(SUNLIGHT_DIRECT_LIGHTING)\r\n    ComputeInOutScattering(normalize(v), a, uInvSunDirection.stp, vOutScattering, vInScattering);\r\n#else\r\n    vOutScattering = vec3(1.);\r\n    vInScattering = vec3(0.);\r\n#endif\r\n\r\n#if defined(FOG_DISTANCE)\r\n    float q = FogBasedOnDistance(a);\r\n    vInScattering = mix(vInScattering, uFogColour.stp, q);\r\n    vOutScattering *= 1. - q;\r\n#endif\r\n\r\n#endif\r\n}\r\n";
  }
});

// rsmv/src/rs3shaders/minimap-loc-frag.glsl.c
var require_minimap_loc_frag_glsl = __commonJS({
  "rsmv/src/rs3shaders/minimap-loc-frag.glsl.c"(exports, module) {
    module.exports = "\r\n#version 460\r\n\r\n/***************************************************/\r\n/***************** GLSL Header *********************/\r\n/***************************************************/\r\n#ifdef GL_EXT_gpu_shader4\r\n#extension GL_EXT_gpu_shader4 : enable\r\n#endif\r\n#ifdef GL_ARB_gpu_shader5\r\n#extension GL_ARB_gpu_shader5 : enable\r\n#endif\r\n#ifdef GL_ARB_derivative_control\r\n#extension GL_ARB_derivative_control : enable\r\n#endif\r\n\r\n#ifdef GL_ARB_texture_gather\r\n#extension GL_ARB_texture_gather : enable\r\n#endif\r\n\r\n#define OGL_BACKEND\r\n\r\n#undef attribute\r\n#define attribute in\r\n\r\n#undef gl_FragColor\r\n#define gl_FragColor FragColor\r\n\r\n#define shadow2DCompat texture\r\n\r\n#undef textureCube\r\n#define textureCube texture\r\n\r\n#undef texture2D\r\n#define texture2D texture\r\n\r\n#undef texture3D\r\n#define texture3D texture\r\n\r\n#undef texture2DLod\r\n#define texture2DLod textureLod\r\n\r\n#undef textureCubeLod\r\n#define textureCubeLod textureLod\r\n\r\n#undef texture2DGrad\r\n#define texture2DGrad textureGrad\r\n\r\n#define MSAA_AVAILABLE\r\n\r\n#define TEXTURE_OFFSET_AVAILABLE\r\n#if !defined(lowp)\r\n#define lowp\r\n#endif\r\n#if !defined(mediump)\r\n#define mediump\r\n#endif\r\n#if !defined(highp)\r\n#define highp\r\n#endif\r\n\r\n#define GRAPHICS_QUALITY_LOW 0\r\n#define GRAPHICS_QUALITY_MEDIUM 1\r\n#define GRAPHICS_QUALITY_HIGH 2\r\n#define GRAPHICS_QUALITY_ULTRA 3\r\n\r\n#define shadow2DLodCompat texture2DLod\r\n\r\n#define texture2DLodCompat texture2DLod\r\n\r\n#define textureCubeLodCompat textureCubeLod\r\n\r\n#define textureGatherCompat(sampler, texCoord, viewportScale) textureGather(sampler, texCoord).wzxy\r\n\r\n#define SHADER_TYPE_PIXEL\r\n\r\nout vec4 gl_FragColor;\r\n\r\n#define UNIFORM_BUFFER_BEGIN(name) \\\r\n    layout(std140) uniform name    \\\r\n    {\r\n#define UNIFORM_BUFFER_END \\\r\n    }                      \\\r\n    ;\r\n\r\nmat3 Mat4ToMat3(const mat4 inputMatrix)\r\n{\r\n    return mat3(inputMatrix);\r\n}\r\n\r\n#define isNaN isnan\r\n\r\n#ifndef GL_ARB_derivative_control\r\n#define dFdxFine dFdx\r\n#define dFdyFine dFdy\r\n#define fwidthFine fwidth\r\n#endif\r\n\r\n/***************************************************/\r\n\r\n/***************************************************/\r\n/***************** Effect Defines ******************/\r\n/***************************************************/\r\n#define AMBIENT_LIGHTING\r\n#define DIFFUSE_LIGHTING\r\n#define ALBEDO_LIGHTING\r\n#define TEXTURE_ALBEDO_GLOBAL\r\n#define SUNLIGHT_DIRECT_LIGHTING\r\n#define TEXTURE_ATLAS\r\n#define ALPHA_ENABLED\r\n#define VIEW_TRANSFORMS\r\n#define TINT\r\n\r\n/*************************************************/\r\n\r\n/***************************************************/\r\n/********** Mandatory Shader Fragments *************/\r\n/***************************************************/\r\n\r\n#define GRAPHICS_QUALITY_LOW 0\r\n#define GRAPHICS_QUALITY_MEDIUM 1\r\n#define GRAPHICS_QUALITY_HIGH 2\r\n#define GRAPHICS_QUALITY_ULTRA 3\r\n\r\n#define MATERIAL_SETTINGS_SLOT_PIXEL_RESOLUTION_X 3.0\r\n#define MATERIAL_SETTINGS_SLOT_PIXEL_RESOLUTION_Y 4.0\r\n#define MATERIAL_SETTINGS_SLOTS_DIMENSION_COUNT_X 42.0\r\n#define MATERIAL_SETTINGS_SLOTS_DIMENSION_COUNT_Y 32.0\r\n#define MATERIAL_SETTINGS_TEXTURE_RESOLUTION 128.0\r\n#ifndef MATH_UTILS_INC\r\n#define MATH_UTILS_INC\r\nconst float PI = 3.14159, INV_PI = .31831, TWOPI = PI * 2., INV_TWOPI = 1. / TWOPI, PI_OVER_4 = PI / 4., PI_OVER_2 = PI / 2., SQRT_2_PI = .797885, INV_EIGHT = .125;\r\nfloat SpecPowToBeckmannRoughness(float f) { return sqrt(2. / (f + 2.)); }\r\nfloat PerceptualRoughnessToRoughness(float f) { return f * f; }\r\nfloat RoughnessToPerceptualRoughness(float f) { return sqrt(f); }\r\n#endif\r\n#ifndef CONVERSION_UTILS_INC\r\n#define CONVERSION_UTILS_INC\r\nvec3 SRGBToLinear(vec3 srgbColour)\r\n{\r\n#if defined(GAMMA_CORRECT_INPUTS)\r\n    return srgbColour * srgbColour;\r\n#else\r\n    return pow(srgbColour, vec3(2.2, 2.2, 2.2));\r\n#endif\r\n}\r\nvec3 LinearToSRGB(vec3 s) { return max(vec3(1.055) * pow(s, vec3(.416667)) - vec3(.055), vec3(0.)); }\r\nfloat LinearToSRGB(float s)\r\n{\r\n    const float p = 1. / 2.2;\r\n    return pow(s, p);\r\n}\r\nvec3 LinearToSRGBRunescape(vec3 s) { return sqrt(s); }\r\nfloat LinearToSRGBRunescape(float s) { return sqrt(s); }\r\nvec4 convertRGBtoHSL(vec4 s)\r\n{\r\n    const float p = 1. / 6.;\r\n    float v = s.s, m = s.t, t = s.p, f = min(min(s.s, s.t), s.p), q = max(max(s.s, s.t), s.p), r = q - f, G = (f + q) * .5, i = 0., e = 0.;\r\n    if (G > 0. && G < 1.)\r\n    {\r\n        float L = G < .5 ? G : 1. - G;\r\n        i = r / (L * 2.);\r\n    }\r\n    if (r > 0.)\r\n    {\r\n        vec3 L = vec3(q == v && q != m ? 1. : 0., q == m && q != t ? 1. : 0., q == t && q != v ? 1. : 0.), o = vec3((m - t) / r, 2. + (t - v) / r, 4. + (v - m) / r);\r\n        e += dot(o, L);\r\n        e *= p;\r\n        if (e < 0.)\r\n            e += 1.;\r\n    }\r\n    return vec4(e, i, G, s.q);\r\n}\r\nvec4 convertHSLtoRGB(vec4 s)\r\n{\r\n    const float v = 1. / 3., q = 2. / 3., m = 6.;\r\n    float p = s.s, t = s.t, r = s.p;\r\n    vec3 f = vec3(m * (p - q), 0., m * (1. - p));\r\n    if (p < q)\r\n        f.s = 0., f.t = m * (q - p), f.p = m * (p - v);\r\n    if (p < v)\r\n        f.s = m * (v - p), f.t = m * p, f.p = 0.;\r\n    f = min(f, 1.);\r\n    float L = 2. * t, i = 1. - t, G = 1. - r, e = 2. * r - 1.;\r\n    vec3 c = L * f + i, o;\r\n    if (r >= .5)\r\n        o = G * c + e;\r\n    else\r\n        o = r * c;\r\n    return vec4(o, s.q);\r\n}\r\n#endif\r\n#ifndef PACK_UTILS_INC\r\n#define PACK_UTILS_INC\r\n#ifndef SHADER_LIB_COMMON_INC\r\n#define SHADER_LIB_COMMON_INC\r\n#define USE_MOD_PACK\r\n#endif\r\n\r\nvec4 PackFloatToRGBA(highp float valueToPack)\r\n{\r\n#if defined(USE_MOD_PACK) || defined(USE_FRACT_PACK)\r\n    const highp vec4 bitShift = vec4(256 * 256 * 256, 256 * 256, 256, 1.0);\r\n    const highp vec4 bitMask = vec4(0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\r\n    highp vec4 fragColour = mod(valueToPack * bitShift * vec4(255), vec4(256)) / vec4(255);\r\n    return fragColour - fragColour.xxyz * bitMask;\r\n#endif\r\n#ifdef USE_ARAS_PACK\r\n    const highp vec4 bitShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\r\n    const highp vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\r\n    highp vec4 fragColour = fract(valueToPack * bitShift);\r\n    return fragColour - (fragColour.xxyz * bitMask);\r\n#endif\r\n}\r\nvec2 NormalPackSphereMap(vec3 v)\r\n{\r\n    vec2 f = normalize(v.st) * sqrt(-v.p * .5 + .5);\r\n    f = f * .5 + .5;\r\n    return f * 65535.;\r\n}\r\nvec2 PackFloatToVec2(float v)\r\n{\r\n    vec2 f;\r\n    const float b = 1. / 255.;\r\n    vec2 h = vec2(1., 255.), r = fract(h * v);\r\n    r.s -= r.t * b;\r\n    return r.st;\r\n}\r\n#endif\r\n#ifndef UNPACK_UTILS_INC\r\n#define UNPACK_UTILS_INC\r\n#ifndef SHADER_LIB_COMMON_INC\r\n#define SHADER_LIB_COMMON_INC\r\n#define USE_MOD_PACK\r\n#endif\r\n\r\nhighp float UnpackRGBAToFloat(highp vec4 valueToUnpack)\r\n{\r\n#if defined(USE_MOD_PACK) || defined(USE_FRACT_PACK)\r\n    const highp vec4 bitShifts = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\r\n    return dot(valueToUnpack, bitShifts);\r\n#endif\r\n#ifdef USE_ARAS_PACK\r\n    const highp vec4 bitShifts = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);\r\n    return dot(valueToUnpack, bitShifts);\r\n#endif\r\n}\r\nvec3 ColourUnpack(highp float v)\r\n{\r\n    vec3 f;\r\n    f.s = floor(v / 256. / 256.);\r\n    f.t = floor((v - f.s * 256. * 256.) / 256.);\r\n    f.p = floor(v - f.s * 256. * 256. - f.t * 256.);\r\n    return f / 256.;\r\n}\r\nvec3 NormalUnpackSphereMap(vec2 v)\r\n{\r\n    vec4 f = vec4(v.s / 32767. - 1., v.t / 32767. - 1., 1., -1.);\r\n    float U = dot(f.stp, -f.stq);\r\n    f.st *= sqrt(U);\r\n    f.p = U;\r\n    return f.stp * 2. + vec3(0., 0., -1.);\r\n}\r\nhighp float UnpackRGBAToIntegerFloat(highp vec4 f) { return floor(f.s * 255. + .5) * 256. * 256. * 256. + floor(f.t * 255. + .5) * 256. * 256. + floor(f.p * 255. + .5) * 256. + floor(f.q * 255. + .5); }\r\nhighp float UnpackRGBAToIntegerFloat16(highp vec2 f) { return floor(f.s * 255. + .5) * 256. + floor(f.t * 255. + .5); }\r\nhighp int UnpackRGBAToInt(vec4 f) { return int(UnpackRGBAToIntegerFloat(f)); }\r\nhighp vec4 UnpackFloatToRGBA(highp float f)\r\n{\r\n    const highp vec4 v = vec4(1., 255., 65025., 1.65814e+07), s = vec4(vec3(1. / 255.), 0.);\r\n    highp vec4 U = fract(f * v);\r\n    U -= U.sstp * s;\r\n    return U;\r\n}\r\nhighp float UnpackVec2ToFloat(highp vec2 f) { return floor(f.s * 255. + .5) * 256. + floor(f.t * 255. + .5); }\r\n#endif\r\n#if defined(MSAA) && defined(MSAA_AVAILABLE)\r\n#define SAMPLER_2D_AUTO_MULTISAMPLE sampler2DMS\r\n#define MSAA_SAMPLERS_ENABLED 1\r\n#define texture2DMultisample(sampler, texCoord, texSize) texelFetch(sampler, ivec2((texCoord)*texSize), 0)\r\n#else\r\n#define SAMPLER_2D_AUTO_MULTISAMPLE sampler2D\r\n#define MSAA_SAMPLERS_ENABLED 0\r\n#define texture2DMultisample(sampler, texCoord, texSize) texture2DLodCompat(sampler, texCoord, 0.0)\r\n#endif\r\nUNIFORM_BUFFER_BEGIN(ViewportLookupScale)\r\nuniform highp vec4 uViewportLookupScale;\r\nuniform highp vec4 uViewportOffsetScale;\r\nuniform highp vec4 uFullScreenLookupScale;\r\nUNIFORM_BUFFER_END\r\n\r\n/***************************************************/\r\n\r\nuniform highp float uTextureAnimationTime;\r\n\r\nUNIFORM_BUFFER_BEGIN(ViewTransforms)\r\nuniform highp vec3 uCameraPosition;\r\nuniform highp mat4 uViewMatrix;\r\nuniform highp mat4 uProjectionMatrix;\r\nuniform highp mat4 uViewProjMatrix;\r\nuniform highp vec4 uZBufferParams;\r\nUNIFORM_BUFFER_END\r\n\r\nUNIFORM_BUFFER_BEGIN(Sunlight)\r\nuniform highp vec3 uInvSunDirection;\r\nuniform mediump vec3 uAmbientColour;\r\nuniform mediump vec3 uSunColour;\r\nuniform mediump float uDummy;\r\nUNIFORM_BUFFER_END\r\n#ifndef LIGHT_SCATTERING_VS_UNIFORMS\r\n#define LIGHT_SCATTERING_VS_UNIFORMS\r\nUNIFORM_BUFFER_BEGIN(SimpleScattering)\r\nuniform mediump vec3 uOutscatteringAmount;\r\nuniform mediump vec3 uInscatteringAmount;\r\nuniform mediump vec3 uScatteringTintColour;\r\nuniform highp vec4 uScatteringParameters;\r\nUNIFORM_BUFFER_END\r\n#endif\r\n#ifndef BRDF_INC\r\n#define BRDF_INC\r\n#ifndef NDF_INC\r\n#define NDF_INC\r\n#ifndef MATH_UTILS_INC\r\n#define MATH_UTILS_INC\r\nconst float PI = 3.14159, INV_PI = .31831, TWOPI = PI * 2., INV_TWOPI = 1. / TWOPI, PI_OVER_4 = PI / 4., PI_OVER_2 = PI / 2., SQRT_2_PI = .797885, INV_EIGHT = .125;\r\nfloat SpecPowToBeckmannRoughness(float f) { return sqrt(2. / (f + 2.)); }\r\nfloat PerceptualRoughnessToRoughness(float f) { return f * f; }\r\nfloat RoughnessToPerceptualRoughness(float f) { return sqrt(f); }\r\n#endif\r\n\r\nfloat BlinnPhongNDF(float f, float N)\r\n{\r\n    return (f + 2.) * INV_EIGHT * pow(N, f);\r\n}\r\nfloat GGXTrowbridgeReitzNDF(float N, float f)\r\n{\r\n    float P = N * N, I = f * f, T = I * (P - 1.) + 1.;\r\n    return P / (PI * (T * T + .0001));\r\n}\r\nfloat BeckmannNDF(float N, float f)\r\n{\r\n    float P = N * N, I = f * f;\r\n    return exp((I - 1.) / (P * I)) / (PI * P * (I * I));\r\n}\r\n#endif\r\n\r\n#ifndef VISIBILITY_FUNC_INC\r\n#define VISIBILITY_FUNC_INC\r\n#ifndef MATH_UTILS_INC\r\n#define MATH_UTILS_INC\r\nconst float PI = 3.14159, INV_PI = .31831, TWOPI = PI * 2., INV_TWOPI = 1. / TWOPI, PI_OVER_4 = PI / 4., PI_OVER_2 = PI / 2., SQRT_2_PI = .797885, INV_EIGHT = .125;\r\nfloat SpecPowToBeckmannRoughness(float f) { return sqrt(2. / (f + 2.)); }\r\nfloat PerceptualRoughnessToRoughness(float f) { return f * f; }\r\nfloat RoughnessToPerceptualRoughness(float f) { return sqrt(f); }\r\n#endif\r\n\r\nfloat SchlickSmithVis(float V, float f, float S)\r\n{\r\n    float P = 1. / sqrt(PI_OVER_4 * V + PI_OVER_2), d = 1. - P, v = (f * d + P) * (S * d + P);\r\n    return 1. / (v + .0001);\r\n}\r\nfloat KelemenSzirmayKalosVis(vec3 V, vec3 P)\r\n{\r\n    vec3 f = V + P;\r\n    return 4. / max(0., dot(f, f));\r\n}\r\n#endif\r\n\r\n#define GGX_NDF\r\n#define SCHLICK_SMITH_VIS\r\nvec3 CookTorranceBRDF(float d, float S, vec3 n, vec3 v, vec3 f, vec3 B, vec3 R, float F)\r\n{\r\n    float m = max(0., dot(v, f)), r = 1.;\r\n#if defined(BLINN_PHONG_NDF)\r\n    r = BlinnPhongNDF(d, m);\r\n#elif defined(GGX_NDF)\r\n    r = GGXTrowbridgeReitzNDF(PerceptualRoughnessToRoughness(S), m);\r\n#elif defined(BECKMANN_NDF)\r\n    r = max(0.f, BeckmannNDF(SpecPowToBeckmannRoughness(d), m));\r\n#else\r\n\r\n#error CookTorranceBRDF normal distribution function not specified\r\n\r\n#endif\r\n    float C = 1.;\r\n#if defined(SCHLICK_SMITH_VIS)\r\n    C = SchlickSmithVis(d, F, max(0., dot(v, B)));\r\n#elif defined(KELEMEN_SZIRMAY_KALOS_VIS)\r\n    C = KelemenSzirmayKalosVis(R, B);\r\n#endif\r\n    return n * (r * C);\r\n}\r\nfloat RunescapeLegacyBRDF(vec3 d, vec3 v, vec3 f, float B, float S)\r\n{\r\n    vec3 n = reflect(-d, f);\r\n    float C = pow(max(0., dot(n, v)), B);\r\n    return C * S;\r\n}\r\nfloat RunescapeRT5BRDF(vec3 d, vec3 v, float S) { return BlinnPhongNDF(S, max(0., dot(d, v))); }\r\nvec3 ShiftTangent(vec3 d, vec3 S, float B) { return normalize(d + B * S); }\r\nvec3 AnisotropicBRDF(vec3 v, vec3 d, vec3 S, vec3 f, vec3 B, float n, float m, float R, float C)\r\n{\r\n    const float F = 7.5, r = 1., e = .5, o = 1.;\r\n    float s = R - .5;\r\n    S = ShiftTangent(S, d, e + (C * 2. - 1.) * o + s);\r\n    float p = abs(dot(S, f)), a = 1. - p, t = 1. - abs(dot(S, B)), K = p * dot(d, B);\r\n    K += a * t;\r\n    K = pow(K, F) * n;\r\n    K = mix(K, K * C, o);\r\n    float G = pow(dot(d, v), m), P = mix(G, K, r);\r\n    return vec3(P, P, P);\r\n}\r\n#endif\r\nuniform float uAlphaTestThreshold;\r\nuniform vec4 uAtlasMeta;\r\nuniform sampler2D uTextureAtlas;\r\nuniform sampler2D uTextureAtlasSettings;\r\nuniform samplerCube uGlobalEnvironmentMap;\r\nuniform vec4 uGlobalEnvironmentMappingParams;\r\nuniform vec4 uTint;\r\nin highp vec3 vWorldPosition;\r\nin highp vec3 vNormal;\r\nin mediump vec4 vVertexAlbedo;\r\nin vec2 vTextureUV;\r\nflat in vec3 vMaterialSettingsSlotXY_BatchFlags;\r\n#ifndef CONVERSION_UTILS_INC\r\n#define CONVERSION_UTILS_INC\r\nvec3 SRGBToLinear(vec3 srgbColour)\r\n{\r\n#if defined(GAMMA_CORRECT_INPUTS)\r\n    return srgbColour * srgbColour;\r\n#else\r\n    return pow(srgbColour, vec3(2.2, 2.2, 2.2));\r\n#endif\r\n}\r\nvec3 LinearToSRGB(vec3 s) { return max(vec3(1.055) * pow(s, vec3(.416667)) - vec3(.055), vec3(0.)); }\r\nfloat LinearToSRGB(float s)\r\n{\r\n    const float p = 1. / 2.2;\r\n    return pow(s, p);\r\n}\r\nvec3 LinearToSRGBRunescape(vec3 s) { return sqrt(s); }\r\nfloat LinearToSRGBRunescape(float s) { return sqrt(s); }\r\nvec4 convertRGBtoHSL(vec4 s)\r\n{\r\n    const float p = 1. / 6.;\r\n    float v = s.s, m = s.t, t = s.p, f = min(min(s.s, s.t), s.p), q = max(max(s.s, s.t), s.p), r = q - f, G = (f + q) * .5, i = 0., e = 0.;\r\n    if (G > 0. && G < 1.)\r\n    {\r\n        float L = G < .5 ? G : 1. - G;\r\n        i = r / (L * 2.);\r\n    }\r\n    if (r > 0.)\r\n    {\r\n        vec3 L = vec3(q == v && q != m ? 1. : 0., q == m && q != t ? 1. : 0., q == t && q != v ? 1. : 0.), o = vec3((m - t) / r, 2. + (t - v) / r, 4. + (v - m) / r);\r\n        e += dot(o, L);\r\n        e *= p;\r\n        if (e < 0.)\r\n            e += 1.;\r\n    }\r\n    return vec4(e, i, G, s.q);\r\n}\r\nvec4 convertHSLtoRGB(vec4 s)\r\n{\r\n    const float v = 1. / 3., q = 2. / 3., m = 6.;\r\n    float p = s.s, t = s.t, r = s.p;\r\n    vec3 f = vec3(m * (p - q), 0., m * (1. - p));\r\n    if (p < q)\r\n        f.s = 0., f.t = m * (q - p), f.p = m * (p - v);\r\n    if (p < v)\r\n        f.s = m * (v - p), f.t = m * p, f.p = 0.;\r\n    f = min(f, 1.);\r\n    float L = 2. * t, i = 1. - t, G = 1. - r, e = 2. * r - 1.;\r\n    vec3 c = L * f + i, o;\r\n    if (r >= .5)\r\n        o = G * c + e;\r\n    else\r\n        o = r * c;\r\n    return vec4(o, s.q);\r\n}\r\n#endif\r\n\r\nvec4 textureCubeSRGB(samplerCube sampler, vec3 reflDir)\r\n{\r\n    vec4 texel = textureCube(sampler, reflDir);\r\n    return texel;\r\n}\r\n\r\nvec4 textureCubeSRGB(samplerCube sampler, vec3 reflDir, float lod)\r\n{\r\n    vec4 texel = textureCube(sampler, reflDir, lod);\r\n    return texel;\r\n}\r\n\r\nvec4 textureCubeLodSRGB(samplerCube sampler, vec3 reflDir, float lod)\r\n{\r\n    vec4 texel = textureCubeLodCompat(sampler, reflDir, lod);\r\n    return texel;\r\n}\r\n#define SRGB_TEXTURES\r\n#define STANDARD_DERIVATIVES\r\n#define TEXTURE_LOD\r\n#define TEXTURE_GRAD\r\n#define TEXTURE_MIP_LIMIT\r\n#define LOOKUP_MODE_DYNAMIC\r\n\r\n#define TEXTURE_SETTINGS_USE_TEXEL_OFFSETS\r\n#ifndef CONVERSION_UTILS_INC\r\n#define CONVERSION_UTILS_INC\r\nvec3 SRGBToLinear(vec3 srgbColour)\r\n{\r\n#if defined(GAMMA_CORRECT_INPUTS)\r\n    return srgbColour * srgbColour;\r\n#else\r\n    return pow(srgbColour, vec3(2.2, 2.2, 2.2));\r\n#endif\r\n}\r\nvec3 LinearToSRGB(vec3 s) { return max(vec3(1.055) * pow(s, vec3(.416667)) - vec3(.055), vec3(0.)); }\r\nfloat LinearToSRGB(float s)\r\n{\r\n    const float p = 1. / 2.2;\r\n    return pow(s, p);\r\n}\r\nvec3 LinearToSRGBRunescape(vec3 s) { return sqrt(s); }\r\nfloat LinearToSRGBRunescape(float s) { return sqrt(s); }\r\nvec4 convertRGBtoHSL(vec4 s)\r\n{\r\n    const float p = 1. / 6.;\r\n    float v = s.s, m = s.t, t = s.p, f = min(min(s.s, s.t), s.p), q = max(max(s.s, s.t), s.p), r = q - f, G = (f + q) * .5, i = 0., e = 0.;\r\n    if (G > 0. && G < 1.)\r\n    {\r\n        float L = G < .5 ? G : 1. - G;\r\n        i = r / (L * 2.);\r\n    }\r\n    if (r > 0.)\r\n    {\r\n        vec3 L = vec3(q == v && q != m ? 1. : 0., q == m && q != t ? 1. : 0., q == t && q != v ? 1. : 0.), o = vec3((m - t) / r, 2. + (t - v) / r, 4. + (v - m) / r);\r\n        e += dot(o, L);\r\n        e *= p;\r\n        if (e < 0.)\r\n            e += 1.;\r\n    }\r\n    return vec4(e, i, G, s.q);\r\n}\r\nvec4 convertHSLtoRGB(vec4 s)\r\n{\r\n    const float v = 1. / 3., q = 2. / 3., m = 6.;\r\n    float p = s.s, t = s.t, r = s.p;\r\n    vec3 f = vec3(m * (p - q), 0., m * (1. - p));\r\n    if (p < q)\r\n        f.s = 0., f.t = m * (q - p), f.p = m * (p - v);\r\n    if (p < v)\r\n        f.s = m * (v - p), f.t = m * p, f.p = 0.;\r\n    f = min(f, 1.);\r\n    float L = 2. * t, i = 1. - t, G = 1. - r, e = 2. * r - 1.;\r\n    vec3 c = L * f + i, o;\r\n    if (r >= .5)\r\n        o = G * c + e;\r\n    else\r\n        o = r * c;\r\n    return vec4(o, s.q);\r\n}\r\n#endif\r\n\r\nfloat getMipMapLevel(vec2 v, vec2 p)\r\n{\r\n    float d = 0.;\r\n#if defined(STANDARD_DERIVATIVES)\r\n    float L = max(dot(v, v), dot(p, p));\r\n    d = .5 * log2(L);\r\n    d = max(0., d);\r\n#endif\r\n    return d;\r\n}\r\n#if defined(DEBUG_TEXEL_DENSITY)\r\nvec3 GetTexelDensityDebugColour(vec2 v, float p, vec3 d)\r\n{\r\n    float t = length(fwidth(v) * p), s = length(fwidth(d)), L = t / s, h = uDebugTexelDensity.s, f = uDebugTexelDensity.t, o = uDebugTexelDensity.p, T = uDebugTexelDensity.q;\r\n    vec3 c;\r\n    c.s = smoothstep(f / (T + 1.), h, L);\r\n    c.t = 1. - smoothstep(0., f * (T + 1.), abs(L - f));\r\n    c.p = smoothstep(1. - (f + o * T), 1. - o, 1. - L);\r\n    c *= c;\r\n    return c;\r\n}\r\n#endif\r\n#if defined(LOOKUP_MODE_DYNAMIC) && !defined(NO_SAMPLER_WRAP)\r\nflat in mediump float vSamplerWrap;\r\n#endif\r\n#if __VERSION__ <= 120\r\n#ifdef in\r\n#undef in\r\n#endif\r\n#ifdef out\r\n#undef out\r\n#endif\r\n#endif\r\n\r\nvoid getTexelBias_inner(float v, highp vec2 t, highp vec3 d, highp vec3 p, highp vec3 s, vec4 c, vec2 m, vec2 g, float L, sampler2D f, out vec4 i, out vec4 h, out vec4 o)\r\n{\r\n    float T = c.s;\r\n    highp float q = c.t, l = c.p;\r\n    float P = c.q;\r\n    highp vec3 S = vec3(d.s, p.s, s.s), y = vec3(d.t, p.t, s.t), a = vec3(d.p, p.p, s.p);\r\n    const vec2 u = vec2(1.);\r\n    vec3 D = .5 / a;\r\n    highp vec2 r, C, Y;\r\n#if !defined(LOOKUP_MODE_CLAMP) && !defined(LOOKUP_MODE_REPEAT)\r\n    const float G = .5, e = .25, n = .125, E = .0625;\r\n    vec4 O = step(.5, fract(L * vec4(G, e, n, E)));\r\n#endif\r\n\r\n#if defined(LOOKUP_MODE_CLAMP)\r\n    r = clamp(t, vec2(D.s), u - vec2(D.s));\r\n#elif defined(LOOKUP_MODE_REPEAT)\r\n    r = mod(t, u);\r\n#else\r\n    const vec2 N = vec2(.5), M = vec2(2.);\r\n    vec2 x = clamp(t, vec2(D.s), u - vec2(D.s)), R = mod(t, u), A = t - M * floor(N * t), U = u - abs(u - A);\r\n    r = O.st * x + O.pq * R + (u - O.st - O.pq) * U;\r\n#endif\r\n    r = r * a.s * l;\r\n    r += vec2(S.s, y.s) * q * l;\r\n    if (v > 1.)\r\n    {\r\n#if defined(LOOKUP_MODE_CLAMP)\r\n        C = clamp(t, vec2(D.t), u - vec2(D.t));\r\n#elif defined(LOOKUP_MODE_REPEAT)\r\n        C = mod(t, u);\r\n#else\r\n        vec2 I = clamp(t, vec2(D.t), u - vec2(D.t)), K = R, B = U;\r\n        C = O.st * I + O.pq * K + (u - O.st - O.pq) * B;\r\n#endif\r\n        C = C * a.t * l;\r\n        C += vec2(S.t, y.t) * q * l;\r\n        if (v > 2.)\r\n        {\r\n#if defined(LOOKUP_MODE_CLAMP)\r\n            Y = clamp(t, vec2(D.p), u - vec2(D.p));\r\n#elif defined(LOOKUP_MODE_REPEAT)\r\n            Y = mod(t, u);\r\n#else\r\n            vec2 b = clamp(t, vec2(D.p), u - vec2(D.p)), X = R, V = U;\r\n            Y = O.st * b + O.pq * X + (u - O.st - O.pq) * V;\r\n#endif\r\n            Y = Y * a.p * l;\r\n            Y += vec2(S.p, y.p) * q * l;\r\n        }\r\n    }\r\n    h = vec4(0.);\r\n    o = vec4(0.);\r\n#if defined(TEXTURE_MIP_LIMIT)\r\n\r\n#if defined(TEXTURE_GRAD)\r\n    highp vec2 I = m * l, K = g * l, B = I * a.s, X = K * a.s;\r\n    const vec2 b = vec2(.025);\r\n    B = clamp(B, -b, b);\r\n    X = clamp(X, -b, b);\r\n    i = texture2DGrad(f, r, B, X);\r\n    if (v > 1.)\r\n    {\r\n        B = I * a.t;\r\n        X = K * a.t;\r\n        B = clamp(B, -b, b);\r\n        X = clamp(X, -b, b);\r\n        h = texture2DGrad(f, C, B, X);\r\n        if (v > 2.)\r\n            B = I * a.p, X = K * a.p, B = clamp(B, -b, b), X = clamp(X, -b, b), o = texture2DGrad(f, Y, B, X);\r\n    }\r\n#else\r\n    i = texture2D(f, r);\r\n    if (v > 1.)\r\n    {\r\n        h = texture2D(f, C);\r\n        if (v > 2.)\r\n            o = texture2D(f, Y);\r\n    }\r\n#endif\r\n\r\n#else\r\n\r\n#if defined(TEXTURE_LOD)\r\n    vec2 V = m * a.s, W = g * a.s;\r\n    float F = getMipMapLevel(V, W);\r\n    F = min(F, P);\r\n    i = texture2DLod(f, r, F);\r\n    if (v > 1.)\r\n    {\r\n        V = m * a.t;\r\n        W = g * a.t;\r\n        F = getMipMapLevel(V, W);\r\n        F = min(F, P);\r\n        h = texture2DLod(f, C, F);\r\n        if (v > 2.)\r\n            V = m * a.p, W = g * a.p, F = getMipMapLevel(V, W), F = min(F, P), o = texture2DLod(f, Y, F);\r\n    }\r\n#else\r\n    i = texture2D(f, r);\r\n    if (v > 1.)\r\n    {\r\n        h = texture2D(f, C);\r\n        if (v > 2.)\r\n            o = texture2D(f, Y);\r\n    }\r\n#endif\r\n\r\n#endif\r\n}\r\nvoid getTexel_inner(float v, vec2 f, highp vec3 d, highp vec3 t, highp vec3 p, vec4 s, vec2 h, vec2 o, float b, sampler2D B, out vec4 D, out vec4 L, out vec4 u)\r\n{\r\n    getTexelBias_inner(v, f, d, t, p, s, h, o, b, B, D, L, u);\r\n#if defined(SRGB_TEXTURES)\r\n    if (v > 1.)\r\n        L = vec4(LinearToSRGB(L.stp), L.q);\r\n    if (v > 2.)\r\n        u = vec4(LinearToSRGB(u.stp), u.q);\r\n#else\r\n    D = vec4(SRGBToLinear(D.stp), D.q);\r\n#endif\r\n}\r\nvoid getTexel_inner(float v, vec2 f, highp vec3 d, highp vec3 t, highp vec3 p, vec4 s, float h, sampler2D o, out vec4 b, out vec4 B, out vec4 u)\r\n{\r\n    vec2 X = vec2(0.), i = vec2(0.);\r\n#if defined(STANDARD_DERIVATIVES)\r\n    X = dFdx(f);\r\n    i = dFdy(f);\r\n#endif\r\n    getTexel_inner(v, f, d, t, p, s, X, i, h, o, b, B, u);\r\n}\r\nvoid getTexel(vec2 v, highp vec3 o, vec4 h, vec2 g, vec2 s, float f, sampler2D e, out vec4 c)\r\n{\r\n    vec3 t = vec3(1.), l = vec3(1.);\r\n    vec4 i = vec4(0.), p = vec4(0.);\r\n    getTexel_inner(1., v, o, t, l, h, g, s, f, e, c, i, p);\r\n}\r\nvoid getTexel(vec2 v, highp vec3 o, vec4 h, float g, sampler2D s, out vec4 f)\r\n{\r\n    vec3 e = vec3(1.), l = vec3(1.);\r\n    vec4 t = vec4(0.), p = vec4(0.);\r\n    getTexel_inner(1., v, o, e, l, h, g, s, f, t, p);\r\n}\r\nvoid getTexel(vec2 v, highp vec3 o, highp vec3 h, vec4 g, vec2 s, vec2 f, float e, sampler2D t, out vec4 l, out vec4 p)\r\n{\r\n    vec3 i = vec3(1.);\r\n    vec4 c = vec4(0.);\r\n    getTexel_inner(2., v, o, h, i, g, s, f, e, t, l, p, c);\r\n}\r\nvoid getTexel(vec2 v, highp vec3 o, highp vec3 h, vec4 g, float s, sampler2D f, out vec4 e, out vec4 t)\r\n{\r\n    vec3 l = vec3(1.);\r\n    vec4 p = vec4(0.);\r\n    getTexel_inner(2., v, o, h, l, g, s, f, e, t, p);\r\n}\r\nvoid getTexel(vec2 v, highp vec3 o, highp vec3 h, highp vec3 g, vec4 s, vec2 f, vec2 e, float t, sampler2D l, out vec4 p, out vec4 i, out vec4 c) { getTexel_inner(3., v, o, h, g, s, f, e, t, l, p, i, c); }\r\nvoid getTexel(vec2 v, highp vec3 o, highp vec3 h, highp vec3 g, vec4 s, float f, sampler2D e, out vec4 t, out vec4 l, out vec4 p) { getTexel_inner(3., v, o, h, g, s, f, e, t, l, p); }\r\n\r\n#if __VERSION__ <= 120\r\n#define in varying\r\n#define out varying\r\n#endif\r\n\r\n#ifndef TEXTURE_SETTINGS_INC\r\n#define TEXTURE_SETTINGS_INC\r\nstruct TextureSettings\r\n{\r\n    highp vec3 textureMeta1;\r\n    highp vec3 textureMeta2;\r\n    highp vec2 uvAnim;\r\n    float wrapping;\r\n    float specular;\r\n    float normalScale;\r\n#if defined(REFRACTION)\r\n    vec4 refraction;\r\n#endif\r\n#if defined(VIEWPORTMAP)\r\n    vec4 viewportMapUVScaleAndAnim;\r\n#endif\r\n#if defined(DEBUG_MATERIAL_HIGHLIGHT)\r\n    highp float materialID;\r\n#endif\r\n};\r\n#if __VERSION__ <= 120\r\n#ifdef in\r\n#undef in\r\n#endif\r\n#ifdef out\r\n#undef out\r\n#endif\r\n#endif\r\n\r\nvoid getTextureSettings(vec2 s, out TextureSettings v)\r\n{\r\n    const highp float d = 1. / 255., S = 1. / 65535., e = 32767., t = 1. / 32767.;\r\n    const float f = 1. / MATERIAL_SETTINGS_TEXTURE_RESOLUTION;\r\n    vec2 i = (floor(s + .5) * vec2(MATERIAL_SETTINGS_SLOT_PIXEL_RESOLUTION_X, MATERIAL_SETTINGS_SLOT_PIXEL_RESOLUTION_Y) + .5) * f;\r\n    const float u = f;\r\n    vec4 T = texture2DLodCompat(uTextureAtlasSettings, i, 0.), U, n, D, m, a, R;\r\n    float h;\r\n    vec4 r;\r\n#if defined(TEXTURE_SETTINGS_USE_TEXEL_OFFSETS)\r\n\r\n#define SAMPLE_OFFSET_SLOTSIZES_AND_WRAPPING ivec2(2, 0)\r\n\r\n#define SAMPLE_OFFSET_UV_ANIM ivec2(0, 1)\r\n\r\n#define SAMPLE_OFFSET_SPECULAR_NORMAL_SCALE ivec2(1, 1)\r\n\r\n#define SAMPLE_OFFSET_REFRACTION ivec2(0, 2)\r\n\r\n#define SAMPLE_OFFSET_SLOTETC ivec2(1, 2)\r\n\r\n#define SAMPLE_OFFSET_VIEWPORTMAP_UVSCALE ivec2(2, 2)\r\n\r\n#define SAMPLE_OFFSET_VIEWPORTMAP_UVANIMATION ivec2(0, 3)\r\n\r\n#define SAMPLE_OFFSET_DEBUG ivec2(2, 3)\r\n    U = textureLodOffset(uTextureAtlasSettings, i, 0., SAMPLE_OFFSET_SLOTSIZES_AND_WRAPPING);\r\n    n = textureLodOffset(uTextureAtlasSettings, i, 0., SAMPLE_OFFSET_UV_ANIM);\r\n#if defined(SPECULAR_LIGHTING) || defined(USE_NORMAL_MAP)\r\n    D = textureLodOffset(uTextureAtlasSettings, i, 0., SAMPLE_OFFSET_SPECULAR_NORMAL_SCALE);\r\n#endif\r\n\r\n#if defined(REFRACTION)\r\n    m = textureLodOffset(uTextureAtlasSettings, i, 0., SAMPLE_OFFSET_REFRACTION);\r\n#endif\r\n    h = textureLodOffset(uTextureAtlasSettings, i, 0., SAMPLE_OFFSET_SLOTETC).q;\r\n#if defined(VIEWPORTMAP)\r\n    a = textureLodOffset(uTextureAtlasSettings, i, 0., SAMPLE_OFFSET_VIEWPORTMAP_UVSCALE);\r\n    R = textureLodOffset(uTextureAtlasSettings, i, 0., SAMPLE_OFFSET_VIEWPORTMAP_UVANIMATION);\r\n#endif\r\n\r\n#if defined(DEBUG_MATERIAL_HIGHLIGHT)\r\n    r = textureLodOffset(uTextureAtlasSettings, i, 0., SAMPLE_OFFSET_DEBUG);\r\n#endif\r\n\r\n#else\r\n    vec2 g = vec2(u * 2., 0.), o = vec2(0., u), M = vec2(u, u), p = vec2(0., u * 2.), X = vec2(u, u * 2.), q = vec2(u * 2., u * 2.), E = vec2(0., u * 3.), A = vec2(u * 2., u * 3.);\r\n    U = texture2DLodCompat(uTextureAtlasSettings, i + g, 0.);\r\n    n = texture2DLodCompat(uTextureAtlasSettings, i + o, 0.);\r\n#if defined(SPECULAR_LIGHTING) || defined(USE_NORMAL_MAP)\r\n    D = texture2DLodCompat(uTextureAtlasSettings, i + M, 0.);\r\n#endif\r\n\r\n#if defined(REFRACTION)\r\n    m = texture2DLodCompat(uTextureAtlasSettings, i + p, 0.);\r\n#endif\r\n    h = texture2DLodCompat(uTextureAtlasSettings, i + X, 0.).q;\r\n#if defined(VIEWPORTMAP)\r\n    a = texture2DLodCompat(uTextureAtlasSettings, i + q, 0.);\r\n    R = texture2DLodCompat(uTextureAtlasSettings, i + E, 0.);\r\n#endif\r\n\r\n#if defined(DEBUG_MATERIAL_HIGHLIGHT)\r\n    r = texture2DLodCompat(uTextureAtlasSettings, i + A, 0.);\r\n#endif\r\n\r\n#endif\r\n    T = floor(T * 255. + .5);\r\n    U = floor(U * 255. + .5);\r\n    h = floor(h * 255. + .5);\r\n    const float V = .5, c = .25, L = .125, P = .0625;\r\n    vec4 N = step(.5, fract(h * vec4(V, c, L, P)));\r\n    T += vec4(256.) * N;\r\n    vec2 w = U.st * uAtlasMeta.t;\r\n    v.textureMeta1 = vec3(T.st, w.s);\r\n    v.textureMeta2 = vec3(T.pq, w.t);\r\n    v.wrapping = U.q;\r\n#if defined(SPECULAR_LIGHTING) || defined(USE_NORMAL_MAP)\r\n    v.specular = UnpackVec2ToFloat(D.st) * d;\r\n    v.normalScale = UnpackVec2ToFloat(D.pq) * d;\r\n    v.normalScale = v.normalScale * .1 - 8.;\r\n#else\r\n    v.specular = 0.;\r\n    v.normalScale = 0.;\r\n#endif\r\n    highp vec2 G = vec2(UnpackVec2ToFloat(n.st), UnpackVec2ToFloat(n.pq)) - e;\r\n    G *= step(1.5, abs(G));\r\n    v.uvAnim = G * t * 2.;\r\n#if defined(REFRACTION)\r\n    v.refraction = m;\r\n    v.refraction.t = v.refraction.t * 2. + 1.;\r\n    v.refraction.p = UnpackVec2ToFloat(v.refraction.pq) * S * 10.;\r\n#endif\r\n\r\n#if defined(VIEWPORTMAP)\r\n    highp vec2 C = vec2(UnpackVec2ToFloat(a.st), UnpackVec2ToFloat(a.pq)) - e, Y = vec2(UnpackVec2ToFloat(R.st), UnpackVec2ToFloat(R.pq)) - e;\r\n    C *= step(1.5, abs(C));\r\n    Y *= step(1.5, abs(Y));\r\n    v.viewportMapUVScaleAndAnim = vec4(C * t * 2., Y * t * 2.);\r\n#endif\r\n\r\n#if defined(DEBUG_MATERIAL_HIGHLIGHT)\r\n    v.materialID = UnpackVec2ToFloat(r.st);\r\n#endif\r\n}\r\nvoid getTextureSettings1D(float v, out TextureSettings i)\r\n{\r\n    const float d = 1. / MATERIAL_SETTINGS_SLOTS_DIMENSION_COUNT_X;\r\n    float S = floor((v + .5) * d), u = v - S * MATERIAL_SETTINGS_SLOTS_DIMENSION_COUNT_X;\r\n    getTextureSettings(vec2(u, S), i);\r\n}\r\n#if __VERSION__ <= 120\r\n#define in varying\r\n#define out varying\r\n#endif\r\n\r\n#endif\r\n#ifndef CONVERSION_UTILS_INC\r\n#define CONVERSION_UTILS_INC\r\nvec3 SRGBToLinear(vec3 srgbColour)\r\n{\r\n#if defined(GAMMA_CORRECT_INPUTS)\r\n    return srgbColour * srgbColour;\r\n#else\r\n    return pow(srgbColour, vec3(2.2, 2.2, 2.2));\r\n#endif\r\n}\r\nvec3 LinearToSRGB(vec3 s) { return max(vec3(1.055) * pow(s, vec3(.416667)) - vec3(.055), vec3(0.)); }\r\nfloat LinearToSRGB(float s)\r\n{\r\n    const float p = 1. / 2.2;\r\n    return pow(s, p);\r\n}\r\nvec3 LinearToSRGBRunescape(vec3 s) { return sqrt(s); }\r\nfloat LinearToSRGBRunescape(float s) { return sqrt(s); }\r\nvec4 convertRGBtoHSL(vec4 s)\r\n{\r\n    const float p = 1. / 6.;\r\n    float v = s.s, m = s.t, t = s.p, f = min(min(s.s, s.t), s.p), q = max(max(s.s, s.t), s.p), r = q - f, G = (f + q) * .5, i = 0., e = 0.;\r\n    if (G > 0. && G < 1.)\r\n    {\r\n        float L = G < .5 ? G : 1. - G;\r\n        i = r / (L * 2.);\r\n    }\r\n    if (r > 0.)\r\n    {\r\n        vec3 L = vec3(q == v && q != m ? 1. : 0., q == m && q != t ? 1. : 0., q == t && q != v ? 1. : 0.), o = vec3((m - t) / r, 2. + (t - v) / r, 4. + (v - m) / r);\r\n        e += dot(o, L);\r\n        e *= p;\r\n        if (e < 0.)\r\n            e += 1.;\r\n    }\r\n    return vec4(e, i, G, s.q);\r\n}\r\nvec4 convertHSLtoRGB(vec4 s)\r\n{\r\n    const float v = 1. / 3., q = 2. / 3., m = 6.;\r\n    float p = s.s, t = s.t, r = s.p;\r\n    vec3 f = vec3(m * (p - q), 0., m * (1. - p));\r\n    if (p < q)\r\n        f.s = 0., f.t = m * (q - p), f.p = m * (p - v);\r\n    if (p < v)\r\n        f.s = m * (v - p), f.t = m * p, f.p = 0.;\r\n    f = min(f, 1.);\r\n    float L = 2. * t, i = 1. - t, G = 1. - r, e = 2. * r - 1.;\r\n    vec3 c = L * f + i, o;\r\n    if (r >= .5)\r\n        o = G * c + e;\r\n    else\r\n        o = r * c;\r\n    return vec4(o, s.q);\r\n}\r\n#endif\r\n\r\nconst highp float CAUSTICS_FIXED_POINT_SCALE = 10000.;\r\n#if defined(CAUSTICS) && !defined(CAUSTICS_COMPUTE) && !defined(CAUSTICS_STENCIL)\r\nfloat CalculateCausticsTerm(highp vec3 u, float t, vec3 e)\r\n{\r\n    float i = 0., s = 0.;\r\n    if (u.t <= uCausticsPlaneHeight)\r\n        s = step(1., t);\r\n    else\r\n    {\r\n#if defined(CAUSTICS_OVERWATER)\r\n        s = clamp(e.t * -1., 0., 1.);\r\n        float d = smoothstep(uCausticsOverWaterFade.s, uCausticsOverWaterFade.t, u.t - uCausticsPlaneHeight);\r\n        s *= 1. - d;\r\n#else\r\n        return 0.0;\r\n#endif\r\n    }\r\n    if (s > 0.)\r\n    {\r\n        highp vec4 C = uCausticsViewProjMatrix * vec4(u, 1.);\r\n        C.st /= 2. * C.q;\r\n        vec2 f = abs(C.st);\r\n        C.st += .5;\r\n        f = smoothstep(.4, .5, f);\r\n        s *= max(0., 1. - (f.s + f.t));\r\n        if (s > 0.)\r\n            i += textureOffset(uCausticsMap, C.st, ivec2(-1, -1)).s, i += textureOffset(uCausticsMap, C.st, ivec2(-1, 0)).s, i += textureOffset(uCausticsMap, C.st, ivec2(-1, 1)).s, i += textureOffset(uCausticsMap, C.st, ivec2(0, -1)).s, i += texture2D(uCausticsMap, C.st).s * 5., i += textureOffset(uCausticsMap, C.st, ivec2(0, 1)).s, i += textureOffset(uCausticsMap, C.st, ivec2(1, -1)).s, i += textureOffset(uCausticsMap, C.st, ivec2(1, 0)).s, i += textureOffset(uCausticsMap, C.st, ivec2(1, 1)).s, i *= s / 12.;\r\n    }\r\n    return i;\r\n}\r\n#endif\r\n#if defined(CAUSTICS_COMPUTE)\r\nvoid WriteCausticsRay(vec3 t, float i)\r\n{\r\n    vec2 s = t.sp * i * uCausticsRefractionScale, C = (gl_FragCoord.st + s * 2.) / uCausticsComputeResolution * uCausticsMapSize;\r\n    highp float u = min(uCausticsFade.s / i * uCausticsFade.t, 7. * uCausticsFade.t), f = smoothstep(uCausticsFade.p, uCausticsFade.q, i), E = f * u * CAUSTICS_FIXED_POINT_SCALE;\r\n    if (E >= 1.f)\r\n        imageAtomicAdd(uCausticsIntegerMap, ivec2(C.st), uint(E));\r\n}\r\n#endif\r\n\r\n#ifndef DISTANCE_FOG_UNIFORMS\r\n#define DISTANCE_FOG_UNIFORMS\r\n#if defined(FOG_DISTANCE)\r\nUNIFORM_BUFFER_BEGIN(DistanceFog)\r\nuniform mediump vec4 uFogColour;\r\nuniform highp vec4 uFogParams;\r\nUNIFORM_BUFFER_END\r\n#endif\r\n#endif\r\n\r\n#ifndef DISTANCE_FOG_FUNCTIONS\r\n#define DISTANCE_FOG_FUNCTIONS\r\n#if defined(FOG_DISTANCE)\r\nfloat FogBasedOnDistance(highp float f)\r\n{\r\n    highp float F = (uFogParams.t - f) * uFogParams.s;\r\n    return 1. - clamp(F, 0., 1.);\r\n}\r\nfloat FogBasedOnAngle(highp vec3 f)\r\n{\r\n    highp float F = 1. - clamp(f.t + uFogParams.q, 0., 1.);\r\n    F = pow(F, uFogParams.p);\r\n    return clamp(F, 0., 1.);\r\n}\r\n#endif\r\n#endif\r\n\r\n#if defined(TEXTURE_ATLAS) && defined(NORMAL_MAP)\r\n#define USE_NORMAL_MAP\r\n#endif\r\n\r\n#if __VERSION__ <= 120\r\n#ifdef in\r\n#undef in\r\n#endif\r\n#ifdef out\r\n#undef out\r\n#endif\r\n#endif\r\n\r\n#if defined(TEXTURE_ATLAS)\r\nvoid CalculateDerivatives(inout highp vec2 v, inout highp vec2 d, inout highp vec3 g, inout highp vec3 h, highp vec2 S, highp vec3 T)\r\n{\r\n#if defined(STANDARD_DERIVATIVES)\r\n    v = dFdx(S);\r\n    d = dFdy(S);\r\n#if defined(PER_FRAGMENT_TANGENTS)\r\n    g = dFdxFine(T);\r\n    h = dFdyFine(T);\r\n#endif\r\n\r\n#endif\r\n}\r\n#if defined(RT7_MATERIAL)\r\nvoid SampleTexturesRT7(inout vec4 v, inout vec4 d, inout vec4 S, vec2 T, TextureSettings h, float g, vec2 i, vec2 u)\r\n{\r\n#if defined(TEXTURE_ATLAS)\r\n\r\n#if !defined(TEXTURE_ALBEDO_GLOBAL)\r\n    if (fract(g * 8.) > .5)\r\n    {\r\n#endif\r\n        getTexel(T, h.textureMeta1, h.textureMeta2, h.textureMeta3, uAtlasMeta, i, u, h.wrapping, uTextureAtlas, v, d, S);\r\n#if defined(ETC_CHANNEL_SWIZZLE)\r\n        d = d.qtps;\r\n        S = S.sqpt;\r\n#endif\r\n\r\n#if !defined(TEXTURE_ALBEDO_GLOBAL)\r\n    }\r\n#endif\r\n\r\n#endif\r\n}\r\n#else\r\nvoid SampleTextures(inout vec4 v, inout vec4 d, vec2 T, TextureSettings h, float S, vec2 i, vec2 u)\r\n{\r\n#if defined(TEXTURE_ATLAS)\r\n\r\n#if !defined(TEXTURE_ALBEDO_GLOBAL)\r\n    if (fract(S * 8.) > .5)\r\n    {\r\n#endif\r\n\r\n#if defined(HDR_SCALE) || defined(USE_NORMAL_MAP)\r\n        getTexel(T, h.textureMeta1, h.textureMeta2, uAtlasMeta, i, u, h.wrapping, uTextureAtlas, v, d);\r\n#if defined(ETC_CHANNEL_SWIZZLE)\r\n        d = d.qtps;\r\n#endif\r\n\r\n#else\r\n    getTexel(T, h.textureMeta1, uAtlasMeta, i, u, h.wrapping, uTextureAtlas, v);\r\n#endif\r\n\r\n#if !defined(TEXTURE_ALBEDO_GLOBAL)\r\n    }\r\n#endif\r\n\r\n#if defined(HDR_SCALE)\r\n    v = HDRScale(v, d.s);\r\n#endif\r\n\r\n#endif\r\n}\r\n#endif\r\n#endif\r\n#if __VERSION__ <= 120\r\n#define in varying\r\n#define out varying\r\n#endif\r\n\r\nvoid ComputeTangentBitangentFromDerivatives(inout vec3 v, inout vec3 p, highp vec3 h, highp vec3 d, highp vec3 A, highp vec2 r, highp vec2 S)\r\n{\r\n    highp vec3 q = cross(h, d), c = cross(A, h), n = c * r.s + q * S.s, s = c * r.t + q * S.t;\r\n    highp float D = dot(n, n), a = dot(s, s), i = max(D, a), t = inversesqrt(i);\r\n    n *= t;\r\n    s *= t;\r\n    if (isNaN(D + a) || i <= 0.)\r\n        n = s = h;\r\n    v = n;\r\n    p = s;\r\n}\r\nvec3 ComputeBitangent(vec3 v, vec4 h)\r\n{\r\n    highp vec3 p = cross(v, h.stp);\r\n    p *= h.q;\r\n    return p;\r\n}\r\nvec3 ApplyNormalMap(highp vec3 v, highp vec3 h, highp vec3 d, highp vec3 A, highp vec2 p, highp vec2 S)\r\n{\r\n    highp vec3 D, s;\r\n    ComputeTangentBitangentFromDerivatives(D, s, h, d, A, p, S);\r\n#if defined(DEBUG_TANGENTS)\r\n    gl_FragColor.stp = normalize(D) * .5 + .5;\r\n    gl_FragColor.q = 1.;\r\n#endif\r\n\r\n#if defined(DEBUG_BITANGENTS)\r\n    gl_FragColor.stp = normalize(s) * .5 + .5;\r\n    gl_FragColor.q = 1.;\r\n#endif\r\n    highp vec3 r = v.s * D + v.t * s + v.p * h;\r\n    r = normalize(r);\r\n    return abs(r.s) + abs(r.t) + abs(r.p) < .5 ? h : r;\r\n}\r\nvec3 ApplyNormalMap(vec3 v, vec3 A, vec3 s, vec3 S)\r\n{\r\n#if defined(DEBUG_TANGENTS)\r\n    gl_FragColor.stp = s * .5 + .5;\r\n    gl_FragColor.q = 1.;\r\n#endif\r\n\r\n#if defined(DEBUG_BITANGENTS)\r\n    gl_FragColor.stp = S * .5 + .5;\r\n    gl_FragColor.q = 1.;\r\n#endif\r\n    highp vec3 p = v.s * s + v.t * S + v.p * A;\r\n    p = normalize(p);\r\n    return p;\r\n}\r\nvec3 ApplyNormalMap(vec3 v, vec3 h, vec4 r)\r\n{\r\n    vec3 p = ComputeBitangent(h, r);\r\n    return ApplyNormalMap(v, h, r.stp, p);\r\n}\r\nvec3 ApplyNormalMapTerrain(vec3 v, highp vec3 h, highp vec3 r, highp vec3 S)\r\n{\r\n    highp vec3 p = cross(h, r), s = cross(S, h), D = s * r.s + p * S.s, n = s * r.p + p * S.p;\r\n    highp float A = inversesqrt(max(dot(D, D), dot(n, n)));\r\n    D *= A;\r\n    n *= A;\r\n#if defined(DEBUG_TANGENTS)\r\n    gl_FragColor.stp = normalize(D) * .5 + .5;\r\n    gl_FragColor.q = 1.;\r\n#endif\r\n\r\n#if defined(DEBUG_BITANGENTS)\r\n    gl_FragColor.stp = normalize(n) * .5 + .5;\r\n    gl_FragColor.q = 1.;\r\n#endif\r\n    highp vec3 d = v.s * D + v.t * n + v.p * h;\r\n    d = normalize(d);\r\n    return isNaN(d.s) ? h : d;\r\n}\r\nvec3 ApplyNormalMapTerrain(vec3 v, vec3 h)\r\n{\r\n    const vec3 p = vec3(0., 0., 1.);\r\n    vec3 D = cross(p, h), s = cross(D, h);\r\n    return ApplyNormalMap(v, h, D, s);\r\n}\r\n\r\nvec3 UnpackCompressedNormal(vec3 U)\r\n{\r\n    vec3 v = vec3(U.ps * 255. / 127. - 1.00787, 0.);\r\n    v.p = sqrt(1. - min(1., dot(v.st, v.st)));\r\n    v.t = -v.t;\r\n    return v;\r\n}\r\nvec3 UnpackNormal(vec3 v, float U)\r\n{\r\n    vec3 t;\r\n#if defined(COMPRESSED_NORMALS)\r\n    t = UnpackCompressedNormal(v);\r\n#else\r\n    t = v.pst * 255. / 127. - 1.00787;\r\n    t.t = -t.t;\r\n#endif\r\n    t.st *= U;\r\n    return t;\r\n}\r\nvec3 UnpackNormal(vec3 U) { return UnpackNormal(U, 1.); }\r\nvec3 UnpackNormal(vec4 v) { return UnpackNormal(v.tpq, 1.); }\r\nvec3 UnpackNormal(vec4 v, float U) { return UnpackNormal(v.tpq, U); }\r\n\r\n#if defined(VIEWPORTMAP)\r\nvec3 SampleViewportMapColour(highp vec2 v, highp vec4 e)\r\n{\r\n    v = v * uViewportLookupScale.st;\r\n    vec2 t;\r\n#if defined(OGLES2_BACKEND)\r\n    t = uViewportMapTextureSize.st;\r\n#else\r\n    t = vec2(textureSize(uViewportMap, 0));\r\n#endif\r\n    v.s *= uViewportLookupScale.p * uViewportLookupScale.t / (t.s / t.t);\r\n    v *= e.st;\r\n    highp float u = uTextureAnimationTime;\r\n    v += e.pq * u;\r\n    return texture2DLodCompat(uViewportMap, v, 0.).stp;\r\n}\r\n#endif\r\n\r\n#ifndef VOLUMETRIC_FUNCTIONS_INC\r\n#define VOLUMETRIC_FUNCTIONS_INC\r\n#if defined(SUNLIGHT_SHADOWS) && defined(VOLUMETRIC_SCATTERING) && defined(SUNLIGHT_DIRECT_LIGHTING)\r\n#define VOLUMETRIC_SCATTERING_SUPPORTED\r\nuniform vec4 uMieG, uVolumetricScatteringParameters;\r\n#if defined(VOLUMETRIC_GROUND_FOG)\r\nuniform vec4 uGroundFogHeight_Falloff;\r\n#endif\r\n#if defined(VOLUMETRIC_SCATTERING_NOISE)\r\nuniform sampler3D sNoiseTex;\r\nuniform vec4 u3DNoiseFrequency_Strength, u3DNoiseWind_Power;\r\n#endif\r\nuniform float uTime;\r\nfloat ShadowSample(vec4 u, vec4 v, float s)\r\n{\r\n    int d = int(uMappingParams.q);\r\n    vec4 f;\r\n    int G;\r\n#if defined(CASCADE_SPLIT_SELECTION)\r\n    G = ShadowMapSelectCascadeBySplit(s, uCascadeFrustumViewDepths, uCascadeSplitSelectionFlags);\r\n#if defined(USE_LIGHT_VIEW_PROJ_TEX_MATRIX)\r\n    f = uSunlightViewProjTexMatrix[G] * u;\r\n#else\r\n    f = v * uSunlightProjTexMatScale[G] + uSunlightProjTexMatOffset[G];\r\n#endif\r\n\r\n#else\r\n\r\n#if defined(USE_LIGHT_VIEW_PROJ_TEX_MATRIX)\r\n    G = ShadowMapSelectCascadeByMap(f, u, uSunlightViewProjTexMatrix, uCascadeMinAtlasExtents);\r\n#else\r\n    G = ShadowMapSelectCascadeByMap(f, v, uSunlightProjTexMatScale, uSunlightProjTexMatOffset, uCascadeMinAtlasExtents);\r\n#endif\r\n\r\n#endif\r\n    return G >= d ? 1. : ShadowDepthMapFilter1x1(uSunlightShadowMap, f);\r\n}\r\nfloat PhaseFunction(float v, vec4 s) { return s.q * (s.s / pow(s.t - s.p * v, 1.5)); }\r\nvec4 GetScatteredInRay(int s, vec3 u, float v, float d, vec4 f)\r\n{\r\n    float G = uSunlightFadeAttenParams.t * 1.4, m = min(G, v);\r\n    vec3 V = uCameraPosition, t = V + u * m;\r\n    vec4 x = uSunlightViewMatrix * vec4(V, 1.), e = uSunlightViewMatrix * vec4(t, 1.), i = uSunlightViewMatrix * vec4(V, 0.), n = uSunlightViewMatrix * vec4(t, 0.);\r\n    vec3 E = vec3(uViewMatrix[0][2], uViewMatrix[1][2], uViewMatrix[2][2]);\r\n    int S = int(uMappingParams.q);\r\n    float q = 0., p = 1. / float(s), N = d * p, h = m * p;\r\n    vec2 r = vec2(0., 0.);\r\n#if defined(VOLUMETRIC_SCATTERING_NOISE)\r\n    vec3 P = vec3(.05 * uTime), a = u3DNoiseWind_Power.stp * uTime;\r\n    const float o = .31;\r\n    float c = u3DNoiseFrequency_Strength.s * o;\r\n    vec3 l = a * u3DNoiseFrequency_Strength.s, T = a * c;\r\n#endif\r\n    for (int X = 0; X < s; ++X)\r\n    {\r\n        vec3 U = mix(V, t, N);\r\n        vec4 I = mix(x, e, N);\r\n#if defined(VOLUMETRIC_SCATTERING_NOISE)\r\n        vec4 M = mix(i, n, N);\r\n        vec3 C = M.sts * vec3(.001) + P, g = M.sts * vec3(.001) - P;\r\n        I.sp += vec2(texture3D(sNoiseTex, g).s, texture3D(sNoiseTex, g).s) * 128. - 64.;\r\n#endif\r\n        float R = 0.;\r\n#if defined(USE_CASCADE_SPLIT_SELECTION)\r\n        vec3 O = U.stp - uCameraPosition;\r\n        R = abs(dot(O, E));\r\n#endif\r\n        float F = ShadowSample(vec4(U, 1.f), I, R), D = 1., w = 1.;\r\n#if defined(VOLUMETRIC_GROUND_FOG)\r\n        if (uGroundFogHeight_Falloff.t != 0.)\r\n        {\r\n            float L = max(0., (U.t - uGroundFogHeight_Falloff.s) * uGroundFogHeight_Falloff.t);\r\n            w = exp(-L) * 100.;\r\n        }\r\n#endif\r\n\r\n#if defined(VOLUMETRIC_SCATTERING_NOISE)\r\n        if (u3DNoiseFrequency_Strength.t != 0.)\r\n        {\r\n            vec3 L = U * u3DNoiseFrequency_Strength.s + l;\r\n            float y = float(texture3D(sNoiseTex, L));\r\n            vec3 A = U * c + T;\r\n            float H = float(texture3D(sNoiseTex, A)), W = pow(mix(y, H, .8) + .5, u3DNoiseWind_Power.q);\r\n            w *= max(0, mix(1., W, u3DNoiseFrequency_Strength.t));\r\n        }\r\n#endif\r\n        D += w;\r\n        float L = D * h, W = uVolumetricScatteringParameters.s * L;\r\n        q += uVolumetricScatteringParameters.t * L;\r\n        r += W * exp(-q) * vec2(F, 1. - F);\r\n        N += p;\r\n    }\r\n    if (v > G)\r\n    {\r\n        float L = v - G, U = uVolumetricScatteringParameters.s * L;\r\n        q += uVolumetricScatteringParameters.t * L;\r\n        r += vec2(U * exp(-q), 0.);\r\n    }\r\n    float U = r.s + r.t;\r\n    if (U > 0.)\r\n    {\r\n        float L = r.s / U, g = uVolumetricScatteringParameters.q;\r\n        L = pow(L, g);\r\n        r.st = U * vec2(L, 1. - L);\r\n        r.s = r.s * PhaseFunction(dot(u, uInvSunDirection), f);\r\n    }\r\n    return vec4(r.s, q, r.t, 1.);\r\n}\r\nvec4 GetScatteredInRay2(int s, vec3 u, float v, float f) { return GetScatteredInRay(s, u, v, f, uMieG); }\r\nvec4 GetScatteredInRayLine(int s, vec3 u, float v, vec3 f, float d, float G)\r\n{\r\n    vec4 L = GetScatteredInRay2(s, u, v, G), t = GetScatteredInRay2(s, mix(u, f, .33), mix(v, d, .33), G), m = GetScatteredInRay2(s, mix(u, f, .66), mix(v, d, .66), G), U = GetScatteredInRay2(s, f, d, G);\r\n    return L * .15 + t * .2 + m * .3 + U * .35;\r\n}\r\n#endif\r\n#endif\r\n\r\n#ifndef APPLY_VOLUMETRICS_INC\r\n#define APPLY_VOLUMETRICS_INC\r\n#ifndef VOLUMETRIC_FUNCTIONS_INC\r\n#define VOLUMETRIC_FUNCTIONS_INC\r\n#if defined(SUNLIGHT_SHADOWS) && defined(VOLUMETRIC_SCATTERING) && defined(SUNLIGHT_DIRECT_LIGHTING)\r\n#define VOLUMETRIC_SCATTERING_SUPPORTED\r\nuniform vec4 uMieG, uVolumetricScatteringParameters;\r\n#if defined(VOLUMETRIC_GROUND_FOG)\r\nuniform vec4 uGroundFogHeight_Falloff;\r\n#endif\r\n#if defined(VOLUMETRIC_SCATTERING_NOISE)\r\nuniform sampler3D sNoiseTex;\r\nuniform vec4 u3DNoiseFrequency_Strength, u3DNoiseWind_Power;\r\n#endif\r\nuniform float uTime;\r\nfloat ShadowSample(vec4 u, vec4 v, float s)\r\n{\r\n    int d = int(uMappingParams.q);\r\n    vec4 f;\r\n    int G;\r\n#if defined(CASCADE_SPLIT_SELECTION)\r\n    G = ShadowMapSelectCascadeBySplit(s, uCascadeFrustumViewDepths, uCascadeSplitSelectionFlags);\r\n#if defined(USE_LIGHT_VIEW_PROJ_TEX_MATRIX)\r\n    f = uSunlightViewProjTexMatrix[G] * u;\r\n#else\r\n    f = v * uSunlightProjTexMatScale[G] + uSunlightProjTexMatOffset[G];\r\n#endif\r\n\r\n#else\r\n\r\n#if defined(USE_LIGHT_VIEW_PROJ_TEX_MATRIX)\r\n    G = ShadowMapSelectCascadeByMap(f, u, uSunlightViewProjTexMatrix, uCascadeMinAtlasExtents);\r\n#else\r\n    G = ShadowMapSelectCascadeByMap(f, v, uSunlightProjTexMatScale, uSunlightProjTexMatOffset, uCascadeMinAtlasExtents);\r\n#endif\r\n\r\n#endif\r\n    return G >= d ? 1. : ShadowDepthMapFilter1x1(uSunlightShadowMap, f);\r\n}\r\nfloat PhaseFunction(float v, vec4 s) { return s.q * (s.s / pow(s.t - s.p * v, 1.5)); }\r\nvec4 GetScatteredInRay(int s, vec3 u, float v, float d, vec4 f)\r\n{\r\n    float G = uSunlightFadeAttenParams.t * 1.4, m = min(G, v);\r\n    vec3 V = uCameraPosition, t = V + u * m;\r\n    vec4 x = uSunlightViewMatrix * vec4(V, 1.), e = uSunlightViewMatrix * vec4(t, 1.), i = uSunlightViewMatrix * vec4(V, 0.), n = uSunlightViewMatrix * vec4(t, 0.);\r\n    vec3 E = vec3(uViewMatrix[0][2], uViewMatrix[1][2], uViewMatrix[2][2]);\r\n    int S = int(uMappingParams.q);\r\n    float q = 0., p = 1. / float(s), N = d * p, h = m * p;\r\n    vec2 r = vec2(0., 0.);\r\n#if defined(VOLUMETRIC_SCATTERING_NOISE)\r\n    vec3 P = vec3(.05 * uTime), a = u3DNoiseWind_Power.stp * uTime;\r\n    const float o = .31;\r\n    float c = u3DNoiseFrequency_Strength.s * o;\r\n    vec3 l = a * u3DNoiseFrequency_Strength.s, T = a * c;\r\n#endif\r\n    for (int X = 0; X < s; ++X)\r\n    {\r\n        vec3 U = mix(V, t, N);\r\n        vec4 I = mix(x, e, N);\r\n#if defined(VOLUMETRIC_SCATTERING_NOISE)\r\n        vec4 M = mix(i, n, N);\r\n        vec3 C = M.sts * vec3(.001) + P, g = M.sts * vec3(.001) - P;\r\n        I.sp += vec2(texture3D(sNoiseTex, g).s, texture3D(sNoiseTex, g).s) * 128. - 64.;\r\n#endif\r\n        float R = 0.;\r\n#if defined(USE_CASCADE_SPLIT_SELECTION)\r\n        vec3 O = U.stp - uCameraPosition;\r\n        R = abs(dot(O, E));\r\n#endif\r\n        float F = ShadowSample(vec4(U, 1.f), I, R), D = 1., w = 1.;\r\n#if defined(VOLUMETRIC_GROUND_FOG)\r\n        if (uGroundFogHeight_Falloff.t != 0.)\r\n        {\r\n            float L = max(0., (U.t - uGroundFogHeight_Falloff.s) * uGroundFogHeight_Falloff.t);\r\n            w = exp(-L) * 100.;\r\n        }\r\n#endif\r\n\r\n#if defined(VOLUMETRIC_SCATTERING_NOISE)\r\n        if (u3DNoiseFrequency_Strength.t != 0.)\r\n        {\r\n            vec3 L = U * u3DNoiseFrequency_Strength.s + l;\r\n            float y = float(texture3D(sNoiseTex, L));\r\n            vec3 A = U * c + T;\r\n            float H = float(texture3D(sNoiseTex, A)), W = pow(mix(y, H, .8) + .5, u3DNoiseWind_Power.q);\r\n            w *= max(0, mix(1., W, u3DNoiseFrequency_Strength.t));\r\n        }\r\n#endif\r\n        D += w;\r\n        float L = D * h, W = uVolumetricScatteringParameters.s * L;\r\n        q += uVolumetricScatteringParameters.t * L;\r\n        r += W * exp(-q) * vec2(F, 1. - F);\r\n        N += p;\r\n    }\r\n    if (v > G)\r\n    {\r\n        float L = v - G, U = uVolumetricScatteringParameters.s * L;\r\n        q += uVolumetricScatteringParameters.t * L;\r\n        r += vec2(U * exp(-q), 0.);\r\n    }\r\n    float U = r.s + r.t;\r\n    if (U > 0.)\r\n    {\r\n        float L = r.s / U, g = uVolumetricScatteringParameters.q;\r\n        L = pow(L, g);\r\n        r.st = U * vec2(L, 1. - L);\r\n        r.s = r.s * PhaseFunction(dot(u, uInvSunDirection), f);\r\n    }\r\n    return vec4(r.s, q, r.t, 1.);\r\n}\r\nvec4 GetScatteredInRay2(int s, vec3 u, float v, float f) { return GetScatteredInRay(s, u, v, f, uMieG); }\r\nvec4 GetScatteredInRayLine(int s, vec3 u, float v, vec3 f, float d, float G)\r\n{\r\n    vec4 L = GetScatteredInRay2(s, u, v, G), t = GetScatteredInRay2(s, mix(u, f, .33), mix(v, d, .33), G), m = GetScatteredInRay2(s, mix(u, f, .66), mix(v, d, .66), G), U = GetScatteredInRay2(s, f, d, G);\r\n    return L * .15 + t * .2 + m * .3 + U * .35;\r\n}\r\n#endif\r\n#endif\r\n\r\n#if defined(VOLUMETRIC_SCATTERING) && defined(SUNLIGHT_DIRECT_LIGHTING)\r\nuniform vec3 uVolumetricLitFogColour, uVolumetricUnlitFogColour;\r\nuniform mat4 uVolumetricDitherMat;\r\n#if __VERSION__ <= 120\r\n#ifdef in\r\n#undef in\r\n#endif\r\n#ifdef out\r\n#undef out\r\n#endif\r\n#endif\r\n\r\nvoid GetInAndOutScattering(vec4 v, out vec3 u, out vec3 G)\r\n{\r\n    vec3 A = uSunColour * uVolumetricLitFogColour, o = uAmbientColour * uVolumetricUnlitFogColour;\r\n    u = vec3(exp(-v.t));\r\n    G = v.s * A + v.p * o;\r\n}\r\n#if __VERSION__ <= 120\r\n#define in varying\r\n#define out varying\r\n#endif\r\n\r\nvec4 ApplyVolumetricScattering(vec4 v, vec4 u)\r\n{\r\n    vec3 A = vec3(1.), o = vec3(0.);\r\n    GetInAndOutScattering(u, A, o);\r\n    return vec4(v.stp * A + o, v.q);\r\n}\r\nfloat CalculateScatteringOffset(vec2 v)\r\n{\r\n    vec2 u = vec2(floor(mod(v.st, 4.)));\r\n    return uVolumetricDitherMat[int(u.s)][int(u.t)];\r\n}\r\n#endif\r\n#endif\r\n\r\n#ifndef LIGHTING_UTILS_H\r\n#define LIGHTING_UTILS_H\r\n#ifndef LIGHTING_INC\r\n#define LIGHTING_INC\r\n#if __VERSION__ <= 120\r\n#ifdef in\r\n#undef in\r\n#endif\r\n#ifdef out\r\n#undef out\r\n#endif\r\n#endif\r\n\r\n#ifndef FRESNEL_INC\r\n#define FRESNEL_INC\r\nvec3 FresnelSchlick(vec3 F, float f, highp float h)\r\n{\r\n    vec3 c = F + (1. - F) * pow(1. - f, h);\r\n    return c;\r\n}\r\nvec3 FresnelSchlickRoughness(vec3 f, float F, highp float h, float v)\r\n{\r\n    vec3 c = f + (max(vec3(v), f) - f) * pow(1. - F, h);\r\n    return c;\r\n}\r\nfloat FresnelSchlick(float F, float f, highp float h)\r\n{\r\n    float c = F + (1. - F) * pow(1. - f, h);\r\n    return c;\r\n}\r\nfloat FresnelSchlickRoughness(float f, float F, highp float h, float v)\r\n{\r\n    float c = f + (max(v, f) - f) * pow(1. - F, h);\r\n    return c;\r\n}\r\nfloat FresnelSchlick(vec3 F, vec3 f, float c)\r\n{\r\n    float h = max(0., dot(F, f));\r\n    return c + (1. - c) * pow(1. - h, 5.);\r\n}\r\nfloat Fresnel(vec3 F, vec3 f, float c, float h)\r\n{\r\n    float p = 1. - max(0., dot(F, f)), v = p * p;\r\n    v = v * v;\r\n    v = v * p;\r\n    return clamp(v * (1. - clamp(h, 0., 1.)) + h - c, 0., 1.);\r\n}\r\n#endif\r\n\r\n#ifndef BRDF_INC\r\n#define BRDF_INC\r\n#ifndef NDF_INC\r\n#define NDF_INC\r\n#ifndef MATH_UTILS_INC\r\n#define MATH_UTILS_INC\r\nconst float PI = 3.14159, INV_PI = .31831, TWOPI = PI * 2., INV_TWOPI = 1. / TWOPI, PI_OVER_4 = PI / 4., PI_OVER_2 = PI / 2., SQRT_2_PI = .797885, INV_EIGHT = .125;\r\nfloat SpecPowToBeckmannRoughness(float f) { return sqrt(2. / (f + 2.)); }\r\nfloat PerceptualRoughnessToRoughness(float f) { return f * f; }\r\nfloat RoughnessToPerceptualRoughness(float f) { return sqrt(f); }\r\n#endif\r\n\r\nfloat BlinnPhongNDF(float f, float N)\r\n{\r\n    return (f + 2.) * INV_EIGHT * pow(N, f);\r\n}\r\nfloat GGXTrowbridgeReitzNDF(float N, float f)\r\n{\r\n    float P = N * N, I = f * f, T = I * (P - 1.) + 1.;\r\n    return P / (PI * (T * T + .0001));\r\n}\r\nfloat BeckmannNDF(float N, float f)\r\n{\r\n    float P = N * N, I = f * f;\r\n    return exp((I - 1.) / (P * I)) / (PI * P * (I * I));\r\n}\r\n#endif\r\n\r\n#ifndef VISIBILITY_FUNC_INC\r\n#define VISIBILITY_FUNC_INC\r\n#ifndef MATH_UTILS_INC\r\n#define MATH_UTILS_INC\r\nconst float PI = 3.14159, INV_PI = .31831, TWOPI = PI * 2., INV_TWOPI = 1. / TWOPI, PI_OVER_4 = PI / 4., PI_OVER_2 = PI / 2., SQRT_2_PI = .797885, INV_EIGHT = .125;\r\nfloat SpecPowToBeckmannRoughness(float f) { return sqrt(2. / (f + 2.)); }\r\nfloat PerceptualRoughnessToRoughness(float f) { return f * f; }\r\nfloat RoughnessToPerceptualRoughness(float f) { return sqrt(f); }\r\n#endif\r\n\r\nfloat SchlickSmithVis(float V, float f, float S)\r\n{\r\n    float P = 1. / sqrt(PI_OVER_4 * V + PI_OVER_2), d = 1. - P, v = (f * d + P) * (S * d + P);\r\n    return 1. / (v + .0001);\r\n}\r\nfloat KelemenSzirmayKalosVis(vec3 V, vec3 P)\r\n{\r\n    vec3 f = V + P;\r\n    return 4. / max(0., dot(f, f));\r\n}\r\n#endif\r\n\r\n#define GGX_NDF\r\n#define SCHLICK_SMITH_VIS\r\nvec3 CookTorranceBRDF(float d, float S, vec3 n, vec3 v, vec3 f, vec3 B, vec3 R, float F)\r\n{\r\n    float m = max(0., dot(v, f)), r = 1.;\r\n#if defined(BLINN_PHONG_NDF)\r\n    r = BlinnPhongNDF(d, m);\r\n#elif defined(GGX_NDF)\r\n    r = GGXTrowbridgeReitzNDF(PerceptualRoughnessToRoughness(S), m);\r\n#elif defined(BECKMANN_NDF)\r\n    r = max(0.f, BeckmannNDF(SpecPowToBeckmannRoughness(d), m));\r\n#else\r\n\r\n#error CookTorranceBRDF normal distribution function not specified\r\n\r\n#endif\r\n    float C = 1.;\r\n#if defined(SCHLICK_SMITH_VIS)\r\n    C = SchlickSmithVis(d, F, max(0., dot(v, B)));\r\n#elif defined(KELEMEN_SZIRMAY_KALOS_VIS)\r\n    C = KelemenSzirmayKalosVis(R, B);\r\n#endif\r\n    return n * (r * C);\r\n}\r\nfloat RunescapeLegacyBRDF(vec3 d, vec3 v, vec3 f, float B, float S)\r\n{\r\n    vec3 n = reflect(-d, f);\r\n    float C = pow(max(0., dot(n, v)), B);\r\n    return C * S;\r\n}\r\nfloat RunescapeRT5BRDF(vec3 d, vec3 v, float S) { return BlinnPhongNDF(S, max(0., dot(d, v))); }\r\nvec3 ShiftTangent(vec3 d, vec3 S, float B) { return normalize(d + B * S); }\r\nvec3 AnisotropicBRDF(vec3 v, vec3 d, vec3 S, vec3 f, vec3 B, float n, float m, float R, float C)\r\n{\r\n    const float F = 7.5, r = 1., e = .5, o = 1.;\r\n    float s = R - .5;\r\n    S = ShiftTangent(S, d, e + (C * 2. - 1.) * o + s);\r\n    float p = abs(dot(S, f)), a = 1. - p, t = 1. - abs(dot(S, B)), K = p * dot(d, B);\r\n    K += a * t;\r\n    K = pow(K, F) * n;\r\n    K = mix(K, K * C, o);\r\n    float G = pow(dot(d, v), m), P = mix(G, K, r);\r\n    return vec3(P, P, P);\r\n}\r\n#endif\r\n\r\nstruct LightingTerms\r\n{\r\n    vec3 Diffuse;\r\n    vec3 Specular;\r\n};\r\nvoid ClearLightingTerms(inout LightingTerms v) { v.Diffuse = vec3(0., 0., 0.), v.Specular = vec3(0., 0., 0.); }\r\nvoid AddLightingTerms(inout LightingTerms v, LightingTerms L) { v.Diffuse += L.Diffuse, v.Specular += L.Specular; }\r\nvoid EvaluateDirLightRT5(inout LightingTerms v, vec3 f, vec3 L, vec3 d, vec3 i, float S, float c, float F, float e, float E, vec3 A)\r\n{\r\n    v.Diffuse += A * e;\r\n#if defined(SPECULAR_LIGHTING)\r\n    vec3 G = normalize(d + i);\r\n    float r = FresnelSchlick(S, clamp(dot(i, G), 0., 1.), F);\r\n#if defined(ANISOTROPY_BRDF)\r\n    vec3 D = AnisotropicBRDF(G, f, L, i, d, E, c, .5, .5);\r\n#else\r\n    vec3 n = vec3(r) * vec3(RunescapeRT5BRDF(G, f, c));\r\n#endif\r\n    n *= A * e;\r\n    v.Specular += n;\r\n#endif\r\n}\r\nvoid EvaluateDirLightRT7(inout LightingTerms v, vec3 f, vec3 L, vec3 d, vec3 i, vec3 S, float c, float E, float G, float e, float F, vec3 A)\r\n{\r\n    v.Diffuse += A * e;\r\n#if defined(SPECULAR_LIGHTING)\r\n    vec3 r = normalize(d + i), n = FresnelSchlick(S, clamp(dot(i, r), 0., 1.), G);\r\n#if defined(ANISOTROPY_BRDF)\r\n    vec3 D = AnisotropicBRDF(r, f, L, i, d, F, c, .5, .5);\r\n#else\r\n    vec3 C = CookTorranceBRDF(c, E, n, f, r, d, i, F);\r\n#endif\r\n    C *= A * e;\r\n    v.Specular += C;\r\n#endif\r\n}\r\nfloat SpecularHorizonOcclusion(float L, vec3 i, vec3 v)\r\n{\r\n    vec3 d = reflect(i, v);\r\n    float A = clamp(1. + L * dot(d, v), 0., 1.);\r\n    A *= A;\r\n    return A;\r\n}\r\n#if __VERSION__ <= 120\r\n#define in varying\r\n#define out varying\r\n#endif\r\n\r\n#endif\r\n\r\n#if !defined(DEFERRED_SHADOWS)\r\nLightingTerms EvaluateSunlightRT5(inout int i, inout float E, highp vec4 v, vec3 u, vec3 f, float d, vec3 n, float p, float S, float r)\r\n{\r\n    float t = max(0., dot(u, uInvSunDirection)), L = t;\r\n    E = 1.;\r\n#if defined(SUNLIGHT_SHADOWS)\r\n    if (S == 0. && uMappingParams.p != 0.)\r\n    {\r\n        if (L > 0.)\r\n        {\r\n            highp vec4 h = uSunlightViewMatrix * v, e = vec4(u.st, 0., 0.) * 32.;\r\n            E = DirLightShadowAtten(i, v + e, h + e, d, uSunlightShadowMap, uSunlightShadowTranslucencyMap, r);\r\n        }\r\n    }\r\n#endif\r\n    L *= E;\r\n    float h = .65;\r\n    LightingTerms D;\r\n    ClearLightingTerms(D);\r\n    EvaluateDirLightRT5(D, u, f, n, uInvSunDirection, h, p, 5., L, t, uSunColour);\r\n    return D;\r\n}\r\n#else\r\nLightingTerms EvaluateSunlightRT5(inout float E, vec3 u, vec3 v, vec3 f, vec2 d, float n, float S)\r\n{\r\n    float t = max(0., dot(u, uInvSunDirection)), L = t;\r\n    E = 1.;\r\n#if defined(SUNLIGHT_SHADOWS) && defined(DEFERRED_SHADOWS)\r\n    if (S == 0. && uMappingParams.p != 0.)\r\n        E = texture2DLod(uShadowBuffer, d, 0.).s;\r\n#endif\r\n    L *= E;\r\n    float h = .65;\r\n    LightingTerms D;\r\n    ClearLightingTerms(D);\r\n    EvaluateDirLightRT5(D, u, v, f, uInvSunDirection, h, n, 5., L, uSunColour);\r\n    return D;\r\n}\r\n#endif\r\n#if !defined(DEFERRED_SHADOWS)\r\nLightingTerms EvaluateSunlightRT7(inout int u, inout float E, highp vec4 v, vec3 f, vec3 d, float n, vec3 h, vec3 L, float p, float i, float t, float S)\r\n{\r\n    float D = max(0., dot(f, uInvSunDirection)), e = D;\r\n    E = 1.;\r\n#if defined(SUNLIGHT_SHADOWS)\r\n    if (uMappingParams.p != 0.)\r\n    {\r\n        if (D > 0.)\r\n        {\r\n            highp vec4 r = uSunlightViewMatrix * v, a = vec4(f.st, 0., 0.) * 32.;\r\n            E = DirLightShadowAtten(u, v + a, r + a, n, uSunlightShadowMap, uSunlightShadowTranslucencyMap, S);\r\n        }\r\n    }\r\n#endif\r\n    e *= E;\r\n    LightingTerms r;\r\n    ClearLightingTerms(r);\r\n    EvaluateDirLightRT7(r, f, d, h, uInvSunDirection, L, p, i, t, e, D, uSunColour);\r\n    return r;\r\n}\r\n#else\r\nLightingTerms EvaluateSunlightRT7(inout float E, vec3 u, vec3 v, vec3 f, vec2 d, vec3 n, float h, float L, float r)\r\n{\r\n    float t = max(0., dot(u, uInvSunDirection)), p = t;\r\n    E = 1.;\r\n#if defined(SUNLIGHT_SHADOWS) && defined(DEFERRED_SHADOWS)\r\n    if (uMappingParams.p != 0.)\r\n        E = texture2DLod(uShadowBuffer, d, 0.).s;\r\n#endif\r\n    LightingTerms D;\r\n    ClearLightingTerms(D);\r\n    EvaluateDirLightRT7(D, u, v, f, uInvSunDirection, n, h, L, r, t, p, uSunColour);\r\n    return D;\r\n}\r\n#endif\r\n#endif\r\n\r\n#ifndef STIPPLE_TRANSPARENCY_UTILS_INC\r\n#define STIPPLE_TRANSPARENCY_UTILS_INC\r\n#if defined(STIPPLE_TRANSPARENCY_CLIP_NEAR) || defined(STIPPLE_TRANSPARENCY_CLIP_FAR) || defined(STIPPLE_TRANSPARENCY_ALPHA)\r\n#ifndef STIPPLE_COMMON_INC\r\n#define STIPPLE_COMMON_INC\r\nhighp float GetStippleViewSpaceDepthFromPos(vec3 S)\r\n{\r\n    vec3 u = vec3(uViewMatrix[0][2], uViewMatrix[1][2], uViewMatrix[2][2]);\r\n    return dot(S, u);\r\n}\r\n#endif\r\n\r\n#ifndef NOISE_UTILS_INC\r\n#define NOISE_UTILS_INC\r\nvec4 permute(vec4 t)\r\n{\r\n    return mod((t * 34. + 1.) * t, 289.);\r\n}\r\nvec2 fade(vec2 t) { return t * t * t * (t * (t * 6. - 15.) + 10.); }\r\nfloat cnoise(highp vec2 t)\r\n{\r\n    highp vec4 v = floor(t.stst) + vec4(0., 0., 1., 1.), d = fract(t.stst) - vec4(0., 0., 1., 1.);\r\n    v = mod(v, 289.);\r\n    vec4 p = v.spsp, s = v.ttqq, h = d.spsp, e = d.ttqq, f = permute(permute(p) + s), m = 2. * fract(f * .0243902) - 1., c = abs(m) - .5, q = floor(m + .5);\r\n    m = m - q;\r\n    vec2 N = vec2(m.s, c.s), r = vec2(m.t, c.t), o = vec2(m.p, c.p), a = vec2(m.q, c.q);\r\n    vec4 G = 1.79284 - .853735 * vec4(dot(N, N), dot(o, o), dot(r, r), dot(a, a));\r\n    N *= G.s;\r\n    o *= G.t;\r\n    r *= G.p;\r\n    a *= G.q;\r\n    float i = dot(N, vec2(h.s, e.s)), n = dot(r, vec2(h.t, e.t)), l = dot(o, vec2(h.p, e.p)), I = dot(a, vec2(h.q, e.q));\r\n    vec2 u = fade(d.st), S = mix(vec2(i, l), vec2(n, I), u.s);\r\n    float g = mix(S.s, S.t, u.t);\r\n    return 2.3 * g;\r\n}\r\nhighp float GetInterleavedGradientNoise(highp vec2 t) { return clamp(fract(52.9829 * fract(.0671106 * t.s + .00583715 * t.t)), 0., .999); }\r\n#endif\r\n\r\n#define STIPPLE_TRANSPARENCY_ENABLED\r\n#if defined(STIPPLE_TRANSPARENCY_CLIP_NEAR) || defined(STIPPLE_TRANSPARENCY_CLIP_FAR)\r\nuniform vec4 uStippleTransparencyClipParams;\r\n#endif\r\n#if __VERSION__ <= 120\r\n#ifdef in\r\n#undef in\r\n#endif\r\n#ifdef out\r\n#undef out\r\n#endif\r\n#endif\r\n\r\nfloat GetStippleTransparencyAlpha(float S, inout float R)\r\n{\r\n    float f = 1.;\r\n#if defined(STIPPLE_TRANSPARENCY_CLIP_NEAR)\r\n    float d = (S - (uZBufferParams.q + uStippleTransparencyClipParams.s)) * uStippleTransparencyClipParams.t;\r\n    f *= clamp(d, 0., 1.);\r\n#endif\r\n\r\n#if defined(STIPPLE_TRANSPARENCY_CLIP_FAR)\r\n    float u = 1. - (S - (abs(uZBufferParams.p) - uStippleTransparencyClipParams.p)) * uStippleTransparencyClipParams.q;\r\n    f *= clamp(u, 0., 1.);\r\n#endif\r\n\r\n#if defined(STIPPLE_TRANSPARENCY_ALPHA)\r\n    f *= clamp(R + .005, 0., 1.);\r\n    R = 1.;\r\n#endif\r\n    return f;\r\n}\r\nbool IsStipplePixelVisible(highp vec3 S, highp vec2 R, inout float d)\r\n{\r\n    float u = GetStippleViewSpaceDepthFromPos(S);\r\n    return GetStippleTransparencyAlpha(u, d) > GetInterleavedGradientNoise(R);\r\n}\r\n#if __VERSION__ <= 120\r\n#define in varying\r\n#define out varying\r\n#endif\r\n\r\n#endif\r\n#endif\r\n\r\n#ifndef STIPPLE_CUTOUT_UTILS_INC\r\n#define STIPPLE_CUTOUT_UTILS_INC\r\n#if defined(STIPPLE_TRANSPARENCY_CUTOUT)\r\n#ifndef STIPPLE_COMMON_INC\r\n#define STIPPLE_COMMON_INC\r\nhighp float GetStippleViewSpaceDepthFromPos(vec3 S)\r\n{\r\n    vec3 u = vec3(uViewMatrix[0][2], uViewMatrix[1][2], uViewMatrix[2][2]);\r\n    return dot(S, u);\r\n}\r\n#endif\r\n\r\n#ifndef NOISE_UTILS_INC\r\n#define NOISE_UTILS_INC\r\nvec4 permute(vec4 t)\r\n{\r\n    return mod((t * 34. + 1.) * t, 289.);\r\n}\r\nvec2 fade(vec2 t) { return t * t * t * (t * (t * 6. - 15.) + 10.); }\r\nfloat cnoise(highp vec2 t)\r\n{\r\n    highp vec4 v = floor(t.stst) + vec4(0., 0., 1., 1.), d = fract(t.stst) - vec4(0., 0., 1., 1.);\r\n    v = mod(v, 289.);\r\n    vec4 p = v.spsp, s = v.ttqq, h = d.spsp, e = d.ttqq, f = permute(permute(p) + s), m = 2. * fract(f * .0243902) - 1., c = abs(m) - .5, q = floor(m + .5);\r\n    m = m - q;\r\n    vec2 N = vec2(m.s, c.s), r = vec2(m.t, c.t), o = vec2(m.p, c.p), a = vec2(m.q, c.q);\r\n    vec4 G = 1.79284 - .853735 * vec4(dot(N, N), dot(o, o), dot(r, r), dot(a, a));\r\n    N *= G.s;\r\n    o *= G.t;\r\n    r *= G.p;\r\n    a *= G.q;\r\n    float i = dot(N, vec2(h.s, e.s)), n = dot(r, vec2(h.t, e.t)), l = dot(o, vec2(h.p, e.p)), I = dot(a, vec2(h.q, e.q));\r\n    vec2 u = fade(d.st), S = mix(vec2(i, l), vec2(n, I), u.s);\r\n    float g = mix(S.s, S.t, u.t);\r\n    return 2.3 * g;\r\n}\r\nhighp float GetInterleavedGradientNoise(highp vec2 t) { return clamp(fract(52.9829 * fract(.0671106 * t.s + .00583715 * t.t)), 0., .999); }\r\n#endif\r\n\r\n#define STIPPLE_CUTOUT_STIPPLED_ALPHA_MULTIPLIER 2.0\r\nfloat GetStippleCutoutAdjustedAlpha(vec3 S, vec2 u, float G)\r\n{\r\n    float v = uStippleCutoutPosDepthVisibility.p, p = GetStippleViewSpaceDepthFromPos(S);\r\n    const float T = 500., f = 500., t = 1. / f;\r\n    float i = 0.f;\r\n    if (p < v + T)\r\n    {\r\n        float l = abs(p - (v + T));\r\n        l = clamp(l * t, 0., 1.);\r\n        vec2 c = u * 2. - vec2(1.), a = c - uStippleCutoutPosDepthVisibility.st;\r\n        a = a;\r\n        float d = uProjectionMatrix[1][1] / uProjectionMatrix[0][0];\r\n        a.s *= d;\r\n        float I = uStippleCutoutPosDepthVisibility.q, R = uStippleCutoutStartRangeAndMinAlpha.s, s = uStippleCutoutStartRangeAndMinAlpha.t, e = uStippleCutoutStartRangeAndMinAlpha.p, o = clamp((length(a) - R) * s, 0., 1.);\r\n        i = mix(pow(l * (1. - o), 2.), 0., I) - e;\r\n    }\r\n    return i;\r\n}\r\nbool IsStippleCutoutVisible(vec3 S, vec2 v, vec2 l) { return GetStippleCutoutAdjustedAlpha(S, v, STIPPLE_CUTOUT_STIPPLED_ALPHA_MULTIPLIER) > GetInterleavedGradientNoise(l); }\r\n#endif\r\n#endif\r\n\r\n#ifndef FRESNEL_INC\r\n#define FRESNEL_INC\r\nvec3 FresnelSchlick(vec3 F, float f, highp float h)\r\n{\r\n    vec3 c = F + (1. - F) * pow(1. - f, h);\r\n    return c;\r\n}\r\nvec3 FresnelSchlickRoughness(vec3 f, float F, highp float h, float v)\r\n{\r\n    vec3 c = f + (max(vec3(v), f) - f) * pow(1. - F, h);\r\n    return c;\r\n}\r\nfloat FresnelSchlick(float F, float f, highp float h)\r\n{\r\n    float c = F + (1. - F) * pow(1. - f, h);\r\n    return c;\r\n}\r\nfloat FresnelSchlickRoughness(float f, float F, highp float h, float v)\r\n{\r\n    float c = f + (max(v, f) - f) * pow(1. - F, h);\r\n    return c;\r\n}\r\nfloat FresnelSchlick(vec3 F, vec3 f, float c)\r\n{\r\n    float h = max(0., dot(F, f));\r\n    return c + (1. - c) * pow(1. - h, 5.);\r\n}\r\nfloat Fresnel(vec3 F, vec3 f, float c, float h)\r\n{\r\n    float p = 1. - max(0., dot(F, f)), v = p * p;\r\n    v = v * v;\r\n    v = v * p;\r\n    return clamp(v * (1. - clamp(h, 0., 1.)) + h - c, 0., 1.);\r\n}\r\n#endif\r\n\r\n#ifndef LIGHTING_INC\r\n#define LIGHTING_INC\r\n#if __VERSION__ <= 120\r\n#ifdef in\r\n#undef in\r\n#endif\r\n#ifdef out\r\n#undef out\r\n#endif\r\n#endif\r\n\r\n#ifndef FRESNEL_INC\r\n#define FRESNEL_INC\r\nvec3 FresnelSchlick(vec3 F, float f, highp float h)\r\n{\r\n    vec3 c = F + (1. - F) * pow(1. - f, h);\r\n    return c;\r\n}\r\nvec3 FresnelSchlickRoughness(vec3 f, float F, highp float h, float v)\r\n{\r\n    vec3 c = f + (max(vec3(v), f) - f) * pow(1. - F, h);\r\n    return c;\r\n}\r\nfloat FresnelSchlick(float F, float f, highp float h)\r\n{\r\n    float c = F + (1. - F) * pow(1. - f, h);\r\n    return c;\r\n}\r\nfloat FresnelSchlickRoughness(float f, float F, highp float h, float v)\r\n{\r\n    float c = f + (max(v, f) - f) * pow(1. - F, h);\r\n    return c;\r\n}\r\nfloat FresnelSchlick(vec3 F, vec3 f, float c)\r\n{\r\n    float h = max(0., dot(F, f));\r\n    return c + (1. - c) * pow(1. - h, 5.);\r\n}\r\nfloat Fresnel(vec3 F, vec3 f, float c, float h)\r\n{\r\n    float p = 1. - max(0., dot(F, f)), v = p * p;\r\n    v = v * v;\r\n    v = v * p;\r\n    return clamp(v * (1. - clamp(h, 0., 1.)) + h - c, 0., 1.);\r\n}\r\n#endif\r\n\r\n#ifndef BRDF_INC\r\n#define BRDF_INC\r\n#ifndef NDF_INC\r\n#define NDF_INC\r\n#ifndef MATH_UTILS_INC\r\n#define MATH_UTILS_INC\r\nconst float PI = 3.14159, INV_PI = .31831, TWOPI = PI * 2., INV_TWOPI = 1. / TWOPI, PI_OVER_4 = PI / 4., PI_OVER_2 = PI / 2., SQRT_2_PI = .797885, INV_EIGHT = .125;\r\nfloat SpecPowToBeckmannRoughness(float f) { return sqrt(2. / (f + 2.)); }\r\nfloat PerceptualRoughnessToRoughness(float f) { return f * f; }\r\nfloat RoughnessToPerceptualRoughness(float f) { return sqrt(f); }\r\n#endif\r\n\r\nfloat BlinnPhongNDF(float f, float N)\r\n{\r\n    return (f + 2.) * INV_EIGHT * pow(N, f);\r\n}\r\nfloat GGXTrowbridgeReitzNDF(float N, float f)\r\n{\r\n    float P = N * N, I = f * f, T = I * (P - 1.) + 1.;\r\n    return P / (PI * (T * T + .0001));\r\n}\r\nfloat BeckmannNDF(float N, float f)\r\n{\r\n    float P = N * N, I = f * f;\r\n    return exp((I - 1.) / (P * I)) / (PI * P * (I * I));\r\n}\r\n#endif\r\n\r\n#ifndef VISIBILITY_FUNC_INC\r\n#define VISIBILITY_FUNC_INC\r\n#ifndef MATH_UTILS_INC\r\n#define MATH_UTILS_INC\r\nconst float PI = 3.14159, INV_PI = .31831, TWOPI = PI * 2., INV_TWOPI = 1. / TWOPI, PI_OVER_4 = PI / 4., PI_OVER_2 = PI / 2., SQRT_2_PI = .797885, INV_EIGHT = .125;\r\nfloat SpecPowToBeckmannRoughness(float f) { return sqrt(2. / (f + 2.)); }\r\nfloat PerceptualRoughnessToRoughness(float f) { return f * f; }\r\nfloat RoughnessToPerceptualRoughness(float f) { return sqrt(f); }\r\n#endif\r\n\r\nfloat SchlickSmithVis(float V, float f, float S)\r\n{\r\n    float P = 1. / sqrt(PI_OVER_4 * V + PI_OVER_2), d = 1. - P, v = (f * d + P) * (S * d + P);\r\n    return 1. / (v + .0001);\r\n}\r\nfloat KelemenSzirmayKalosVis(vec3 V, vec3 P)\r\n{\r\n    vec3 f = V + P;\r\n    return 4. / max(0., dot(f, f));\r\n}\r\n#endif\r\n\r\n#define GGX_NDF\r\n#define SCHLICK_SMITH_VIS\r\nvec3 CookTorranceBRDF(float d, float S, vec3 n, vec3 v, vec3 f, vec3 B, vec3 R, float F)\r\n{\r\n    float m = max(0., dot(v, f)), r = 1.;\r\n#if defined(BLINN_PHONG_NDF)\r\n    r = BlinnPhongNDF(d, m);\r\n#elif defined(GGX_NDF)\r\n    r = GGXTrowbridgeReitzNDF(PerceptualRoughnessToRoughness(S), m);\r\n#elif defined(BECKMANN_NDF)\r\n    r = max(0.f, BeckmannNDF(SpecPowToBeckmannRoughness(d), m));\r\n#else\r\n\r\n#error CookTorranceBRDF normal distribution function not specified\r\n\r\n#endif\r\n    float C = 1.;\r\n#if defined(SCHLICK_SMITH_VIS)\r\n    C = SchlickSmithVis(d, F, max(0., dot(v, B)));\r\n#elif defined(KELEMEN_SZIRMAY_KALOS_VIS)\r\n    C = KelemenSzirmayKalosVis(R, B);\r\n#endif\r\n    return n * (r * C);\r\n}\r\nfloat RunescapeLegacyBRDF(vec3 d, vec3 v, vec3 f, float B, float S)\r\n{\r\n    vec3 n = reflect(-d, f);\r\n    float C = pow(max(0., dot(n, v)), B);\r\n    return C * S;\r\n}\r\nfloat RunescapeRT5BRDF(vec3 d, vec3 v, float S) { return BlinnPhongNDF(S, max(0., dot(d, v))); }\r\nvec3 ShiftTangent(vec3 d, vec3 S, float B) { return normalize(d + B * S); }\r\nvec3 AnisotropicBRDF(vec3 v, vec3 d, vec3 S, vec3 f, vec3 B, float n, float m, float R, float C)\r\n{\r\n    const float F = 7.5, r = 1., e = .5, o = 1.;\r\n    float s = R - .5;\r\n    S = ShiftTangent(S, d, e + (C * 2. - 1.) * o + s);\r\n    float p = abs(dot(S, f)), a = 1. - p, t = 1. - abs(dot(S, B)), K = p * dot(d, B);\r\n    K += a * t;\r\n    K = pow(K, F) * n;\r\n    K = mix(K, K * C, o);\r\n    float G = pow(dot(d, v), m), P = mix(G, K, r);\r\n    return vec3(P, P, P);\r\n}\r\n#endif\r\n\r\nstruct LightingTerms\r\n{\r\n    vec3 Diffuse;\r\n    vec3 Specular;\r\n};\r\nvoid ClearLightingTerms(inout LightingTerms v) { v.Diffuse = vec3(0., 0., 0.), v.Specular = vec3(0., 0., 0.); }\r\nvoid AddLightingTerms(inout LightingTerms v, LightingTerms L) { v.Diffuse += L.Diffuse, v.Specular += L.Specular; }\r\nvoid EvaluateDirLightRT5(inout LightingTerms v, vec3 f, vec3 L, vec3 d, vec3 i, float S, float c, float F, float e, float E, vec3 A)\r\n{\r\n    v.Diffuse += A * e;\r\n#if defined(SPECULAR_LIGHTING)\r\n    vec3 G = normalize(d + i);\r\n    float r = FresnelSchlick(S, clamp(dot(i, G), 0., 1.), F);\r\n#if defined(ANISOTROPY_BRDF)\r\n    vec3 D = AnisotropicBRDF(G, f, L, i, d, E, c, .5, .5);\r\n#else\r\n    vec3 n = vec3(r) * vec3(RunescapeRT5BRDF(G, f, c));\r\n#endif\r\n    n *= A * e;\r\n    v.Specular += n;\r\n#endif\r\n}\r\nvoid EvaluateDirLightRT7(inout LightingTerms v, vec3 f, vec3 L, vec3 d, vec3 i, vec3 S, float c, float E, float G, float e, float F, vec3 A)\r\n{\r\n    v.Diffuse += A * e;\r\n#if defined(SPECULAR_LIGHTING)\r\n    vec3 r = normalize(d + i), n = FresnelSchlick(S, clamp(dot(i, r), 0., 1.), G);\r\n#if defined(ANISOTROPY_BRDF)\r\n    vec3 D = AnisotropicBRDF(r, f, L, i, d, F, c, .5, .5);\r\n#else\r\n    vec3 C = CookTorranceBRDF(c, E, n, f, r, d, i, F);\r\n#endif\r\n    C *= A * e;\r\n    v.Specular += C;\r\n#endif\r\n}\r\nfloat SpecularHorizonOcclusion(float L, vec3 i, vec3 v)\r\n{\r\n    vec3 d = reflect(i, v);\r\n    float A = clamp(1. + L * dot(d, v), 0., 1.);\r\n    A *= A;\r\n    return A;\r\n}\r\n#if __VERSION__ <= 120\r\n#define in varying\r\n#define out varying\r\n#endif\r\n\r\n#endif\r\n\r\nvoid main()\r\n{\r\n#if defined(DEBUG_VERTEX_BONE_COLOUR)\r\n    gl_FragColor = vec4(vVertexAlbedo);\r\n    if (uDebugReturn != 0.)\r\n    {\r\n        return;\r\n    }\r\n#endif\r\n\r\n#if defined(ALPHA_ENABLED)\r\n    if (vVertexAlbedo.q == 0.)\r\n    {\r\n        discard;\r\n    }\r\n#endif\r\n    highp vec4 d = vec4(vWorldPosition.stp, 1.);\r\n#if defined(CLIP_PLANE) && !defined(PUSH_TO_FARPLANE)\r\n    if (dot(d, uClipPlane) < 0.)\r\n    {\r\n        discard;\r\n        return;\r\n    }\r\n#endif\r\n\r\n#if defined(TEXTURE_ATLAS)\r\n    TextureSettings D;\r\n    getTextureSettings(vMaterialSettingsSlotXY_BatchFlags.st, D);\r\n#endif\r\n    highp vec2 v = vec2(0.), p = vec2(0.);\r\n    highp vec3 r = vec3(0.), q = vec3(0.);\r\n    vec4 u = vec4(1.), s;\r\n#if defined(COMPRESSED_NORMALS)\r\n    s = vec4(0., .5, 0., .5);\r\n#else\r\n    s = vec4(0., .5, 1., .5);\r\n#endif\r\n    highp vec3 S = d.stp - uCameraPosition;\r\n#if defined(TEXTURE_ATLAS)\r\n    highp float G = uTextureAnimationTime;\r\n    vec2 t = vTextureUV + fract(D.uvAnim * G);\r\n    CalculateDerivatives(v, p, r, q, t, S);\r\n    SampleTextures(u, s, t, D, vMaterialSettingsSlotXY_BatchFlags.p, v, p);\r\n#endif\r\n    float i = 1., g = 0., C = 0.;\r\n    vec3 n = step(.5, fract(vMaterialSettingsSlotXY_BatchFlags.p * vec3(64., 32., 16.)));\r\n#if !defined(TEXTURE_ALBEDO_GLOBAL)\r\n    n.sp *= step(.5, fract(vMaterialSettingsSlotXY_BatchFlags.p * 8.));\r\n#endif\r\n    i += n.s * u.q * 4.;\r\n    g = n.t;\r\n    C = n.p * u.q;\r\n    u.q = min(u.q + n.s + n.p, 1.);\r\n    vec4 f = u * vVertexAlbedo;\r\n#if defined(DEBUG_GEOMETRY_INSTANCE_COLOUR)\r\n    gl_FragColor = vec4(uDebugInstanceColour.stp, f.q);\r\n    if (uDebugReturn != 0.)\r\n    {\r\n        return;\r\n    }\r\n#endif\r\n\r\n#if defined(ALPHA_ENABLED)\r\n    if (f.q <= uAlphaTestThreshold)\r\n    {\r\n        discard;\r\n    }\r\n#endif\r\n\r\n#if defined(STIPPLE_TRANSPARENCY_CUTOUT) && defined(VIEWPORTLOOKUPSCALE)\r\n    if (fract(vMaterialSettingsSlotXY_BatchFlags.p * 4.) > .5)\r\n    {\r\n#if defined(ALPHA_ENABLED)\r\n        if (uAlphaTestThreshold > .01)\r\n        {\r\n            if (IsStippleCutoutVisible(S, gl_FragCoord.st * uViewportLookupScale.st, gl_FragCoord.st))\r\n            {\r\n                discard;\r\n            }\r\n        }\r\n        else\r\n            f.q *= 1.f - GetStippleCutoutAdjustedAlpha(S, gl_FragCoord.st * uViewportLookupScale.st, 1.);\r\n#else\r\n        if (IsStippleCutoutVisible(S, gl_FragCoord.st * uViewportLookupScale.st, gl_FragCoord.st))\r\n        {\r\n            discard;\r\n        }\r\n#endif\r\n    }\r\n#endif\r\n\r\n#if defined(STIPPLE_TRANSPARENCY_ENABLED)\r\n    if (!IsStipplePixelVisible(S, gl_FragCoord.st, f.q))\r\n    {\r\n        discard;\r\n    }\r\n#endif\r\n\r\n#if defined(GOURAUD_SHADING)\r\n    gl_FragColor = f;\r\n    return;\r\n#endif\r\n    highp vec3 e = normalize(vNormal), T = vec3(0., 1., 0.), P = vec3(0., 1., 0.);\r\n#if defined(PER_FRAGMENT_TANGENTS)\r\n    ComputeTangentBitangentFromDerivatives(T, P, e, r, q, v, p);\r\n#endif\r\n\r\n#if defined(USE_NORMAL_MAP)\r\n\r\n#if !defined(PER_FRAGMENT_TANGENTS)\r\n    T = normalize(vTangent.stp);\r\n    P = ComputeBitangent(e, vTangent);\r\n#endif\r\n    vec3 A = UnpackNormal(s.tpq, D.normalScale);\r\n    e = ApplyNormalMap(A, e, T, P);\r\n#endif\r\n\r\n#if defined(DEBUG_TANGENTS) || defined(DEBUG_BITANGENTS)\r\n\r\n#if defined(DEBUG_TANGENTS)\r\n    gl_FragColor.stp = normalize(T) * .5 + .5;\r\n    gl_FragColor.q = 1.;\r\n#endif\r\n\r\n#if defined(DEBUG_BITANGENTS)\r\n    gl_FragColor.stp = normalize(P) * .5 + .5;\r\n    gl_FragColor.q = 1.;\r\n#endif\r\n    if (uDebugReturn != 0.)\r\n    {\r\n        return;\r\n    }\r\n#endif\r\n\r\n#if defined(VIEWPORTMAP)\r\n    f.stp = SampleViewportMapColour(gl_FragCoord.st, D.viewportMapUVScaleAndAnim);\r\n#endif\r\n\r\n#if defined(DEBUG_TEXEL_DENSITY)\r\n\r\n#if defined(TEXTURE_ATLAS)\r\n    gl_FragColor = vec4(GetTexelDensityDebugColour(vTextureUV, D.textureMeta1.p, S), 1.);\r\n#else\r\n    gl_FragColor = vec4(1.);\r\n#endif\r\n    if (uDebugReturn != 0.)\r\n    {\r\n        return;\r\n    }\r\n#endif\r\n\r\n#if defined(VIEWPORTLOOKUPSCALE)\r\n    vec2 E = gl_FragCoord.st * uFullScreenLookupScale.st;\r\n#endif\r\n    float h = 1.;\r\n#if defined(SSAO) && !defined(REFRACTION)\r\n    h = texture2D(uSSAOMap, E).s;\r\n#endif\r\n    LightingTerms m;\r\n    ClearLightingTerms(m);\r\n    m.Diffuse = uAmbientColour;\r\n    vec3 l = vec3(1., 1., 1.);\r\n#if defined(IRRADIANCE_LIGHTING)\r\n    l = EvaluateSHLighting2ndOrder(e, uIrradianceSHCoefs);\r\n    m.Diffuse *= l;\r\n#endif\r\n\r\n#if defined(SSAO)\r\n    m.Diffuse *= h;\r\n#endif\r\n    highp float V = length(S);\r\n    highp vec3 a = S / V;\r\n    LightingTerms R;\r\n    ClearLightingTerms(R);\r\n#if defined(SUNLIGHT_DIRECT_LIGHTING)\r\n    int I = -1;\r\n    float F = 0.;\r\n#if defined(DEFERRED_SHADOWS)\r\n    R = EvaluateSunlightRT5(F, e, P, -a, E, D.specular, g);\r\n#else\r\n    highp vec3 O = vec3(uViewMatrix[0][2], uViewMatrix[1][2], uViewMatrix[2][2]);\r\n    highp float o = abs(dot(S, O));\r\n    float L = step(.5, fract(vMaterialSettingsSlotXY_BatchFlags.p * 2.));\r\n    R = EvaluateSunlightRT5(I, F, d, e, P, o, -a, D.specular, g, L);\r\n#endif\r\n\r\n#else\r\n    R.Diffuse = vec3(1.);\r\n#endif\r\n\r\n#if defined(TEXTURE_ATLAS) && defined(DEBUG_MATERIAL_HIGHLIGHT)\r\n    if (uDebugMaterialHighlight != -1.)\r\n    {\r\n        float c = mix(.1, .5, length(R.Diffuse)), N = .1;\r\n        vec3 U = mix(vec3(N) * c, vec3(0, 1, 0), D.materialID == uDebugMaterialHighlight ? 1 : 0);\r\n        gl_FragColor = vec4(U, 1);\r\n        if (uDebugReturn != 0.)\r\n        {\r\n            return;\r\n        }\r\n    }\r\n#endif\r\n    float N = FresnelSchlick(.8, max(0., dot(-a, e)), 5.);\r\n#if defined(TEXTURE_ATLAS) && defined(GLOBAL_ENVIRONMENTMAPPING)\r\n    if (C > 0.)\r\n    {\r\n        vec3 c = reflect(-a, e);\r\n        c.s = -c.s;\r\n        c.t = -c.t;\r\n        m.Specular = textureCubeSRGB(uGlobalEnvironmentMap, c).stp * h;\r\n#if defined(NORMALIZED_ENVIRONMENTMAPPING)\r\n        m.Specular *= l * uGlobalEnvironmentMappingParams.q;\r\n#endif\r\n        f.stp = mix(f.stp, m.Specular, C * N);\r\n    }\r\n#endif\r\n    vec4 c = vec4(0., 0., 0., f.q);\r\n#if defined(POINT_LIGHTING)\r\n    vec3 U = vec3(0., 0., 0.), M = vec3(0., 0., 0.);\r\n    const vec3 B = vec3(.65, .65, .65);\r\n    const float H = 1., b = 5.;\r\n    EvaluatePointLights(U, M, B, D.specular, H, b, -a, vWorldPosition.stp, e, o, vTilePosition);\r\n#if defined(DEBUG_POINTLIGHTS)\r\n    gl_FragColor = vec4(U, f.q);\r\n    if (uDebugReturn != 0.)\r\n    {\r\n        return;\r\n    }\r\n#endif\r\n\r\n#if defined(DEBUG_POINTLIGHTS_SPECULAR)\r\n    gl_FragColor = vec4(M, f.q);\r\n    if (uDebugReturn != 0.)\r\n    {\r\n        return;\r\n    }\r\n#endif\r\n\r\n#if defined(DIFFUSE_LIGHTING)\r\n    R.Diffuse += U;\r\n#else\r\n    R.Diffuse = U;\r\n#endif\r\n\r\n#if defined(POINT_LIGHTING_SPECULAR)\r\n    R.Specular += M;\r\n#endif\r\n\r\n#else\r\n\r\n#if defined(DEBUG_POINTLIGHTS)\r\n    gl_FragColor = vec4(0., 0., 0., 1.);\r\n    if (uDebugReturn != 0.)\r\n    {\r\n        return;\r\n    }\r\n#endif\r\n\r\n#if defined(DEBUG_POINTLIGHTS_SPECULAR)\r\n    gl_FragColor = vec4(0., 0., 0., 1.);\r\n    if (uDebugReturn != 0.)\r\n    {\r\n        return;\r\n    }\r\n#endif\r\n\r\n#if !defined(DIFFUSE_LIGHTING)\r\n    R.Diffuse = vec3(0.);\r\n#endif\r\n\r\n#endif\r\n    float x = 0.;\r\n#if defined(CAUSTICS)\r\n    x = CalculateCausticsTerm(vWorldPosition.stp, F, e);\r\n#endif\r\n\r\n#if defined(AMBIENT_LIGHTING)\r\n    c.stp += m.Diffuse;\r\n#endif\r\n    c.stp += R.Diffuse;\r\n#if defined(SPECULAR_LIGHTING)\r\n    c.stp += R.Specular * i;\r\n#endif\r\n\r\n#if defined(CAUSTICS)\r\n    c.stp += uSunColour * x;\r\n#endif\r\n\r\n#if defined(ALBEDO_LIGHTING)\r\n    c.stp *= f.stp;\r\n#endif\r\n\r\n#if defined(DEBUG_EMISSIVE_MAP)\r\n    c.stp = vec3(g);\r\n#else\r\n    if (g > 0.)\r\n        c.q *= c.q;\r\n    c.stp = mix(c.stp, f.stp, g);\r\n#endif\r\n\r\n#if defined(REFRACTION)\r\n    if (D.refraction.s > 0. || D.refraction.p > 0.)\r\n        c.stp = CalculateRefractionColour(vWorldPosition.stp, e, -a, D.specular, D.refraction, e.sp, c);\r\n#endif\r\n\r\n#if defined(LIGHT_SCATTERING) || defined(FOG_DISTANCE)\r\n    c.stp = ApplyInOutScattering(c.stp, vOutScattering, vInScattering);\r\n#endif\r\n\r\n#if defined(VOLUMETRIC_SCATTERING_SUPPORTED)\r\n    vec4 Y = GetScatteredInRay2(8, a, V, CalculateScatteringOffset(gl_FragCoord.st));\r\n    c = ApplyVolumetricScattering(c, Y);\r\n#endif\r\n\r\n#if defined(TINT) && defined(PUSH_TO_FARPLANE)\r\n    c.stp += uTint.stp;\r\n#endif\r\n\r\n#if defined(DEBUG_ALBEDO)\r\n    c = f;\r\n#endif\r\n\r\n#if defined(DEBUG_NORMALS)\r\n    c.stp = e * .5 + .5;\r\n    c.q = 1.;\r\n#endif\r\n\r\n#if defined(DEBUG_FRESNEL)\r\n    c.stp = vec3(N, N, N);\r\n    c.q = 1.;\r\n#endif\r\n\r\n#if defined(DEBUG_SPECULAR_MAP)\r\n    c.stp = vec3(max(0., (i - .5) / 4.));\r\n#endif\r\n\r\n#if defined(SUNLIGHT_SHADOWS) && defined(DEBUG_SUNLIGHT_SHADOW_CASCADE) && !defined(DEFERRED_SHADOWS)\r\n    c.stp = ShadowMapCascadeColour(I, int(uMappingParams.q)).stp;\r\n#endif\r\n\r\n#if defined(DEBUG_RT7_EMISSIVE) || defined(DEBUG_RT7_METALNESS) || defined(DEBUG_RT7_ROUGHNESS)\r\n    c = vec4(1., 0., 1., 1.);\r\n#endif\r\n\r\n#if defined(FORCE_OPAQUE)\r\n    c.q = 1.;\r\n#endif\r\n\r\n#if defined(PREMULTIPLY_ALPHA)\r\n    c.stp *= c.q;\r\n#endif\r\n    gl_FragColor = c;\r\n}\r\n";
  }
});

// rsmv/src/rs3shaders/minimap-floor-vert.glsl.c
var require_minimap_floor_vert_glsl = __commonJS({
  "rsmv/src/rs3shaders/minimap-floor-vert.glsl.c"(exports, module) {
    module.exports = "\r\n#version 460\r\n\r\n/***************************************************/\r\n/***************** GLSL Header *********************/\r\n/***************************************************/\r\n#ifdef GL_EXT_gpu_shader4\r\n#extension GL_EXT_gpu_shader4 : enable\r\n#endif\r\n#ifdef GL_ARB_gpu_shader5\r\n#extension GL_ARB_gpu_shader5 : enable\r\n#endif\r\n#ifdef GL_ARB_derivative_control\r\n#extension GL_ARB_derivative_control : enable\r\n#endif\r\n\r\n#ifdef GL_ARB_texture_gather\r\n#extension GL_ARB_texture_gather : enable\r\n#endif\r\n\r\n#define OGL_BACKEND\r\n\r\n#undef attribute\r\n#define attribute in\r\n\r\n#undef gl_FragColor\r\n#define gl_FragColor FragColor\r\n\r\n#define shadow2DCompat texture\r\n\r\n#undef textureCube\r\n#define textureCube texture\r\n\r\n#undef texture2D\r\n#define texture2D texture\r\n\r\n#undef texture3D\r\n#define texture3D texture\r\n\r\n#undef texture2DLod\r\n#define texture2DLod textureLod\r\n\r\n#undef textureCubeLod\r\n#define textureCubeLod textureLod\r\n\r\n#undef texture2DGrad\r\n#define texture2DGrad textureGrad\r\n\r\n#define MSAA_AVAILABLE\r\n\r\n#define TEXTURE_OFFSET_AVAILABLE\r\n#if !defined(lowp)\r\n#define lowp\r\n#endif\r\n#if !defined(mediump)\r\n#define mediump\r\n#endif\r\n#if !defined(highp)\r\n#define highp\r\n#endif\r\n\r\n#define GRAPHICS_QUALITY_LOW 0\r\n#define GRAPHICS_QUALITY_MEDIUM 1\r\n#define GRAPHICS_QUALITY_HIGH 2\r\n#define GRAPHICS_QUALITY_ULTRA 3\r\n\r\n#define shadow2DLodCompat texture2DLod\r\n\r\n#define texture2DLodCompat texture2DLod\r\n\r\n#define textureCubeLodCompat textureCubeLod\r\n\r\n#define textureGatherCompat(sampler, texCoord, viewportScale) textureGather(sampler, texCoord).wzxy\r\n\r\n#define UNIFORM_BUFFER_BEGIN(name) \\\r\n    layout(std140) uniform name    \\\r\n    {\r\n#define UNIFORM_BUFFER_END \\\r\n    }                      \\\r\n    ;\r\n\r\nmat3 Mat4ToMat3(const mat4 inputMatrix)\r\n{\r\n    return mat3(inputMatrix);\r\n}\r\n\r\n#define isNaN isnan\r\n\r\n#ifndef GL_ARB_derivative_control\r\n#define dFdxFine dFdx\r\n#define dFdyFine dFdy\r\n#define fwidthFine fwidth\r\n#endif\r\n\r\n/***************************************************/\r\n\r\n/***************************************************/\r\n/***************** Effect Defines ******************/\r\n/***************************************************/\r\n#define SUNLIGHT_DIRECT_LIGHTING\r\n#define TEXTURE_ATLAS\r\n#define VIEW_TRANSFORMS\r\n\r\n/*************************************************/\r\n\r\n/***************************************************/\r\n/********** Mandatory Shader Fragments *************/\r\n/***************************************************/\r\n\r\n#define GRAPHICS_QUALITY_LOW 0\r\n#define GRAPHICS_QUALITY_MEDIUM 1\r\n#define GRAPHICS_QUALITY_HIGH 2\r\n#define GRAPHICS_QUALITY_ULTRA 3\r\n\r\n#define MATERIAL_SETTINGS_SLOT_PIXEL_RESOLUTION_X 3.0\r\n#define MATERIAL_SETTINGS_SLOT_PIXEL_RESOLUTION_Y 4.0\r\n#define MATERIAL_SETTINGS_SLOTS_DIMENSION_COUNT_X 42.0\r\n#define MATERIAL_SETTINGS_SLOTS_DIMENSION_COUNT_Y 32.0\r\n#define MATERIAL_SETTINGS_TEXTURE_RESOLUTION 128.0\r\n#ifndef MATH_UTILS_INC\r\n#define MATH_UTILS_INC\r\nconst float PI = 3.14159, INV_PI = .31831, TWOPI = PI * 2., INV_TWOPI = 1. / TWOPI, PI_OVER_4 = PI / 4., PI_OVER_2 = PI / 2., SQRT_2_PI = .797885, INV_EIGHT = .125;\r\nfloat SpecPowToBeckmannRoughness(float f) { return sqrt(2. / (f + 2.)); }\r\nfloat PerceptualRoughnessToRoughness(float f) { return f * f; }\r\nfloat RoughnessToPerceptualRoughness(float f) { return sqrt(f); }\r\n#endif\r\n#ifndef CONVERSION_UTILS_INC\r\n#define CONVERSION_UTILS_INC\r\nvec3 SRGBToLinear(vec3 srgbColour)\r\n{\r\n#if defined(GAMMA_CORRECT_INPUTS)\r\n    return srgbColour * srgbColour;\r\n#else\r\n    return pow(srgbColour, vec3(2.2, 2.2, 2.2));\r\n#endif\r\n}\r\nvec3 LinearToSRGB(vec3 s) { return max(vec3(1.055) * pow(s, vec3(.416667)) - vec3(.055), vec3(0.)); }\r\nfloat LinearToSRGB(float s)\r\n{\r\n    const float p = 1. / 2.2;\r\n    return pow(s, p);\r\n}\r\nvec3 LinearToSRGBRunescape(vec3 s) { return sqrt(s); }\r\nfloat LinearToSRGBRunescape(float s) { return sqrt(s); }\r\nvec4 convertRGBtoHSL(vec4 s)\r\n{\r\n    const float p = 1. / 6.;\r\n    float v = s.s, m = s.t, t = s.p, f = min(min(s.s, s.t), s.p), q = max(max(s.s, s.t), s.p), r = q - f, G = (f + q) * .5, i = 0., e = 0.;\r\n    if (G > 0. && G < 1.)\r\n    {\r\n        float L = G < .5 ? G : 1. - G;\r\n        i = r / (L * 2.);\r\n    }\r\n    if (r > 0.)\r\n    {\r\n        vec3 L = vec3(q == v && q != m ? 1. : 0., q == m && q != t ? 1. : 0., q == t && q != v ? 1. : 0.), o = vec3((m - t) / r, 2. + (t - v) / r, 4. + (v - m) / r);\r\n        e += dot(o, L);\r\n        e *= p;\r\n        if (e < 0.)\r\n            e += 1.;\r\n    }\r\n    return vec4(e, i, G, s.q);\r\n}\r\nvec4 convertHSLtoRGB(vec4 s)\r\n{\r\n    const float v = 1. / 3., q = 2. / 3., m = 6.;\r\n    float p = s.s, t = s.t, r = s.p;\r\n    vec3 f = vec3(m * (p - q), 0., m * (1. - p));\r\n    if (p < q)\r\n        f.s = 0., f.t = m * (q - p), f.p = m * (p - v);\r\n    if (p < v)\r\n        f.s = m * (v - p), f.t = m * p, f.p = 0.;\r\n    f = min(f, 1.);\r\n    float L = 2. * t, i = 1. - t, G = 1. - r, e = 2. * r - 1.;\r\n    vec3 c = L * f + i, o;\r\n    if (r >= .5)\r\n        o = G * c + e;\r\n    else\r\n        o = r * c;\r\n    return vec4(o, s.q);\r\n}\r\n#endif\r\n#ifndef PACK_UTILS_INC\r\n#define PACK_UTILS_INC\r\n#ifndef SHADER_LIB_COMMON_INC\r\n#define SHADER_LIB_COMMON_INC\r\n#define USE_MOD_PACK\r\n#endif\r\n\r\nvec4 PackFloatToRGBA(highp float valueToPack)\r\n{\r\n#if defined(USE_MOD_PACK) || defined(USE_FRACT_PACK)\r\n    const highp vec4 bitShift = vec4(256 * 256 * 256, 256 * 256, 256, 1.0);\r\n    const highp vec4 bitMask = vec4(0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\r\n    highp vec4 fragColour = mod(valueToPack * bitShift * vec4(255), vec4(256)) / vec4(255);\r\n    return fragColour - fragColour.xxyz * bitMask;\r\n#endif\r\n#ifdef USE_ARAS_PACK\r\n    const highp vec4 bitShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\r\n    const highp vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\r\n    highp vec4 fragColour = fract(valueToPack * bitShift);\r\n    return fragColour - (fragColour.xxyz * bitMask);\r\n#endif\r\n}\r\nvec2 NormalPackSphereMap(vec3 v)\r\n{\r\n    vec2 f = normalize(v.st) * sqrt(-v.p * .5 + .5);\r\n    f = f * .5 + .5;\r\n    return f * 65535.;\r\n}\r\nvec2 PackFloatToVec2(float v)\r\n{\r\n    vec2 f;\r\n    const float b = 1. / 255.;\r\n    vec2 h = vec2(1., 255.), r = fract(h * v);\r\n    r.s -= r.t * b;\r\n    return r.st;\r\n}\r\n#endif\r\n#ifndef UNPACK_UTILS_INC\r\n#define UNPACK_UTILS_INC\r\n#ifndef SHADER_LIB_COMMON_INC\r\n#define SHADER_LIB_COMMON_INC\r\n#define USE_MOD_PACK\r\n#endif\r\n\r\nhighp float UnpackRGBAToFloat(highp vec4 valueToUnpack)\r\n{\r\n#if defined(USE_MOD_PACK) || defined(USE_FRACT_PACK)\r\n    const highp vec4 bitShifts = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\r\n    return dot(valueToUnpack, bitShifts);\r\n#endif\r\n#ifdef USE_ARAS_PACK\r\n    const highp vec4 bitShifts = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);\r\n    return dot(valueToUnpack, bitShifts);\r\n#endif\r\n}\r\nvec3 ColourUnpack(highp float v)\r\n{\r\n    vec3 f;\r\n    f.s = floor(v / 256. / 256.);\r\n    f.t = floor((v - f.s * 256. * 256.) / 256.);\r\n    f.p = floor(v - f.s * 256. * 256. - f.t * 256.);\r\n    return f / 256.;\r\n}\r\nvec3 NormalUnpackSphereMap(vec2 v)\r\n{\r\n    vec4 f = vec4(v.s / 32767. - 1., v.t / 32767. - 1., 1., -1.);\r\n    float U = dot(f.stp, -f.stq);\r\n    f.st *= sqrt(U);\r\n    f.p = U;\r\n    return f.stp * 2. + vec3(0., 0., -1.);\r\n}\r\nhighp float UnpackRGBAToIntegerFloat(highp vec4 f) { return floor(f.s * 255. + .5) * 256. * 256. * 256. + floor(f.t * 255. + .5) * 256. * 256. + floor(f.p * 255. + .5) * 256. + floor(f.q * 255. + .5); }\r\nhighp float UnpackRGBAToIntegerFloat16(highp vec2 f) { return floor(f.s * 255. + .5) * 256. + floor(f.t * 255. + .5); }\r\nhighp int UnpackRGBAToInt(vec4 f) { return int(UnpackRGBAToIntegerFloat(f)); }\r\nhighp vec4 UnpackFloatToRGBA(highp float f)\r\n{\r\n    const highp vec4 v = vec4(1., 255., 65025., 1.65814e+07), s = vec4(vec3(1. / 255.), 0.);\r\n    highp vec4 U = fract(f * v);\r\n    U -= U.sstp * s;\r\n    return U;\r\n}\r\nhighp float UnpackVec2ToFloat(highp vec2 f) { return floor(f.s * 255. + .5) * 256. + floor(f.t * 255. + .5); }\r\n#endif\r\n#if defined(MSAA) && defined(MSAA_AVAILABLE)\r\n#define SAMPLER_2D_AUTO_MULTISAMPLE sampler2DMS\r\n#define MSAA_SAMPLERS_ENABLED 1\r\n#define texture2DMultisample(sampler, texCoord, texSize) texelFetch(sampler, ivec2((texCoord)*texSize), 0)\r\n#else\r\n#define SAMPLER_2D_AUTO_MULTISAMPLE sampler2D\r\n#define MSAA_SAMPLERS_ENABLED 0\r\n#define texture2DMultisample(sampler, texCoord, texSize) texture2DLodCompat(sampler, texCoord, 0.0)\r\n#endif\r\nUNIFORM_BUFFER_BEGIN(ViewportLookupScale)\r\nuniform highp vec4 uViewportLookupScale;\r\nuniform highp vec4 uViewportOffsetScale;\r\nuniform highp vec4 uFullScreenLookupScale;\r\nUNIFORM_BUFFER_END\r\n\r\n/***************************************************/\r\n\r\nattribute vec3 aVertexPosition;\r\nattribute vec4 aVertexNormal_FogProportion;\r\nattribute vec4 aMaterialSettingsSlotXY_MaterialSettingsSlotXY2;\r\nattribute vec2 aMaterialSettingsSlotXY3;\r\nattribute vec4 aTextureScale;\r\nattribute vec4 aVertexColour;\r\nattribute vec4 aTextureWeight;\r\nattribute vec4 aMaterialProperties;\r\nuniform mat4 uModelMatrix;\r\n\r\nUNIFORM_BUFFER_BEGIN(ViewTransforms)\r\nuniform highp vec3 uCameraPosition;\r\nuniform highp mat4 uViewMatrix;\r\nuniform highp mat4 uProjectionMatrix;\r\nuniform highp mat4 uViewProjMatrix;\r\nuniform highp vec4 uZBufferParams;\r\nUNIFORM_BUFFER_END\r\nuniform mediump vec4 uAtlasMeta;\r\nuniform float uFade;\r\nout highp vec4 vWorldPos_ViewSpaceDepth;\r\nout vec4 vVertexAlbedo;\r\nout vec3 vWorldNormal;\r\nflat out highp vec4 vMaterialSettingsSlots1D;\r\nflat out highp vec4 vTextureScale;\r\nout vec4 vTextureWeight;\r\nflat out vec4 vMaterialProperties;\r\n#ifndef DISTANCE_FOG_UNIFORMS\r\n#define DISTANCE_FOG_UNIFORMS\r\n#if defined(FOG_DISTANCE)\r\nUNIFORM_BUFFER_BEGIN(DistanceFog)\r\nuniform mediump vec4 uFogColour;\r\nuniform highp vec4 uFogParams;\r\nUNIFORM_BUFFER_END\r\n#endif\r\n#endif\r\n\r\n#ifndef DISTANCE_FOG_FUNCTIONS\r\n#define DISTANCE_FOG_FUNCTIONS\r\n#if defined(FOG_DISTANCE)\r\nfloat FogBasedOnDistance(highp float f)\r\n{\r\n    highp float F = (uFogParams.t - f) * uFogParams.s;\r\n    return 1. - clamp(F, 0., 1.);\r\n}\r\nfloat FogBasedOnAngle(highp vec3 f)\r\n{\r\n    highp float F = 1. - clamp(f.t + uFogParams.q, 0., 1.);\r\n    F = pow(F, uFogParams.p);\r\n    return clamp(F, 0., 1.);\r\n}\r\n#endif\r\n#endif\r\n\r\nvoid main()\r\n{\r\n    vec4 d = uModelMatrix * vec4(aVertexPosition, 1.);\r\n    gl_Position = uViewProjMatrix * d;\r\n    vWorldPos_ViewSpaceDepth.stp = d.stp;\r\n    vVertexAlbedo = aVertexColour;\r\n#if defined(GAMMA_CORRECT_INPUTS) && !defined(TEXTURE_ATLAS)\r\n    vVertexAlbedo.stp = SRGBToLinear(vVertexAlbedo.stp);\r\n#endif\r\n    vVertexAlbedo.q += uFade;\r\n#if defined(SUNLIGHT_DIRECT_LIGHTING) || defined(DEBUG_NORMALS)\r\n    vWorldNormal = normalize(Mat4ToMat3(uModelMatrix) * aVertexNormal_FogProportion.stp);\r\n#endif\r\n\r\n#if defined(IRRADIANCE_LIGHTING) && !defined(NORMAL_MAP)\r\n    vAmbientColour = uAmbientColour * EvaluateSHLighting2ndOrder(vWorldNormal, uIrradianceSHCoefs);\r\n#endif\r\n\r\n#if defined(TEXTURE_ATLAS)\r\n    vMaterialSettingsSlots1D = vec4(aMaterialSettingsSlotXY_MaterialSettingsSlotXY2.s + aMaterialSettingsSlotXY_MaterialSettingsSlotXY2.t * MATERIAL_SETTINGS_SLOTS_DIMENSION_COUNT_X, aMaterialSettingsSlotXY_MaterialSettingsSlotXY2.p + aMaterialSettingsSlotXY_MaterialSettingsSlotXY2.q * MATERIAL_SETTINGS_SLOTS_DIMENSION_COUNT_X, aMaterialSettingsSlotXY3.s + aMaterialSettingsSlotXY3.t * MATERIAL_SETTINGS_SLOTS_DIMENSION_COUNT_X, 0.);\r\n    vTextureScale = aTextureScale;\r\n    vTextureWeight = aTextureWeight;\r\n#endif\r\n    vMaterialProperties = aMaterialProperties + vec4(.25);\r\n#if defined(LIGHT_SCATTERING) || defined(SUNLIGHT_SHADOWS) || defined(FOG_DISTANCE)\r\n    vec3 S = d.stp - uCameraPosition;\r\n    float G = length(S);\r\n    vec3 g = S / G;\r\n#endif\r\n\r\n#if defined(SUNLIGHT_SHADOWS)\r\n    vec3 u = vec3(uViewMatrix[0][2], uViewMatrix[1][2], uViewMatrix[2][2]);\r\n    vWorldPos_ViewSpaceDepth.q = abs(dot(S.stp, u));\r\n#endif\r\n\r\n#if (defined(FOG_DISTANCE) || (defined(SUNLIGHT_DIRECT_LIGHTING) && defined(LIGHT_SCATTERING))) && !defined(OGLES2_BACKEND)\r\n\r\n#if defined(LIGHT_SCATTERING) && defined(SUNLIGHT_DIRECT_LIGHTING)\r\n    ComputeInOutScattering(g, G, uInvSunDirection, vOutScattering, vInScattering);\r\n#else\r\n    vOutScattering = vec3(1.);\r\n    vInScattering = vec3(0.);\r\n#endif\r\n\r\n#if defined(FOG_DISTANCE)\r\n    float p = FogBasedOnDistance(G);\r\n    vInScattering = mix(vInScattering, uFogColour.stp, p);\r\n    vOutScattering *= 1. - p;\r\n#endif\r\n\r\n#endif\r\n}\r\n";
  }
});

// rsmv/src/rs3shaders/minimap-floor-frag.glsl.c
var require_minimap_floor_frag_glsl = __commonJS({
  "rsmv/src/rs3shaders/minimap-floor-frag.glsl.c"(exports, module) {
    module.exports = "\r\n#version 460\r\n\r\n/***************************************************/\r\n/***************** GLSL Header *********************/\r\n/***************************************************/\r\n#ifdef GL_EXT_gpu_shader4\r\n#extension GL_EXT_gpu_shader4 : enable\r\n#endif\r\n#ifdef GL_ARB_gpu_shader5\r\n#extension GL_ARB_gpu_shader5 : enable\r\n#endif\r\n#ifdef GL_ARB_derivative_control\r\n#extension GL_ARB_derivative_control : enable\r\n#endif\r\n\r\n#ifdef GL_ARB_texture_gather\r\n#extension GL_ARB_texture_gather : enable\r\n#endif\r\n\r\n#define OGL_BACKEND\r\n\r\n#undef attribute\r\n#define attribute in\r\n\r\n#undef gl_FragColor\r\n#define gl_FragColor FragColor\r\n\r\n#define shadow2DCompat texture\r\n\r\n#undef textureCube\r\n#define textureCube texture\r\n\r\n#undef texture2D\r\n#define texture2D texture\r\n\r\n#undef texture3D\r\n#define texture3D texture\r\n\r\n#undef texture2DLod\r\n#define texture2DLod textureLod\r\n\r\n#undef textureCubeLod\r\n#define textureCubeLod textureLod\r\n\r\n#undef texture2DGrad\r\n#define texture2DGrad textureGrad\r\n\r\n#define MSAA_AVAILABLE\r\n\r\n#define TEXTURE_OFFSET_AVAILABLE\r\n#if !defined(lowp)\r\n#define lowp\r\n#endif\r\n#if !defined(mediump)\r\n#define mediump\r\n#endif\r\n#if !defined(highp)\r\n#define highp\r\n#endif\r\n\r\n#define GRAPHICS_QUALITY_LOW 0\r\n#define GRAPHICS_QUALITY_MEDIUM 1\r\n#define GRAPHICS_QUALITY_HIGH 2\r\n#define GRAPHICS_QUALITY_ULTRA 3\r\n\r\n#define shadow2DLodCompat texture2DLod\r\n\r\n#define texture2DLodCompat texture2DLod\r\n\r\n#define textureCubeLodCompat textureCubeLod\r\n\r\n#define textureGatherCompat(sampler, texCoord, viewportScale) textureGather(sampler, texCoord).wzxy\r\n\r\n#define SHADER_TYPE_PIXEL\r\n\r\nout vec4 gl_FragColor;\r\n\r\n#define UNIFORM_BUFFER_BEGIN(name) \\\r\n    layout(std140) uniform name    \\\r\n    {\r\n#define UNIFORM_BUFFER_END \\\r\n    }                      \\\r\n    ;\r\n\r\nmat3 Mat4ToMat3(const mat4 inputMatrix)\r\n{\r\n    return mat3(inputMatrix);\r\n}\r\n\r\n#define isNaN isnan\r\n\r\n#ifndef GL_ARB_derivative_control\r\n#define dFdxFine dFdx\r\n#define dFdyFine dFdy\r\n#define fwidthFine fwidth\r\n#endif\r\n\r\n/***************************************************/\r\n\r\n/***************************************************/\r\n/***************** Effect Defines ******************/\r\n/***************************************************/\r\n#define AMBIENT_LIGHTING\r\n#define DIFFUSE_LIGHTING\r\n#define ALBEDO_LIGHTING\r\n#define SUNLIGHT_DIRECT_LIGHTING\r\n#define TEXTURE_ATLAS\r\n#define TEXTURE_FORCED_FLAG\r\n\r\n/*************************************************/\r\n\r\n/***************************************************/\r\n/********** Mandatory Shader Fragments *************/\r\n/***************************************************/\r\n\r\n#define GRAPHICS_QUALITY_LOW 0\r\n#define GRAPHICS_QUALITY_MEDIUM 1\r\n#define GRAPHICS_QUALITY_HIGH 2\r\n#define GRAPHICS_QUALITY_ULTRA 3\r\n\r\n#define MATERIAL_SETTINGS_SLOT_PIXEL_RESOLUTION_X 3.0\r\n#define MATERIAL_SETTINGS_SLOT_PIXEL_RESOLUTION_Y 4.0\r\n#define MATERIAL_SETTINGS_SLOTS_DIMENSION_COUNT_X 42.0\r\n#define MATERIAL_SETTINGS_SLOTS_DIMENSION_COUNT_Y 32.0\r\n#define MATERIAL_SETTINGS_TEXTURE_RESOLUTION 128.0\r\n#ifndef MATH_UTILS_INC\r\n#define MATH_UTILS_INC\r\nconst float PI = 3.14159, INV_PI = .31831, TWOPI = PI * 2., INV_TWOPI = 1. / TWOPI, PI_OVER_4 = PI / 4., PI_OVER_2 = PI / 2., SQRT_2_PI = .797885, INV_EIGHT = .125;\r\nfloat SpecPowToBeckmannRoughness(float f) { return sqrt(2. / (f + 2.)); }\r\nfloat PerceptualRoughnessToRoughness(float f) { return f * f; }\r\nfloat RoughnessToPerceptualRoughness(float f) { return sqrt(f); }\r\n#endif\r\n#ifndef CONVERSION_UTILS_INC\r\n#define CONVERSION_UTILS_INC\r\nvec3 SRGBToLinear(vec3 srgbColour)\r\n{\r\n#if defined(GAMMA_CORRECT_INPUTS)\r\n    return srgbColour * srgbColour;\r\n#else\r\n    return pow(srgbColour, vec3(2.2, 2.2, 2.2));\r\n#endif\r\n}\r\nvec3 LinearToSRGB(vec3 s) { return max(vec3(1.055) * pow(s, vec3(.416667)) - vec3(.055), vec3(0.)); }\r\nfloat LinearToSRGB(float s)\r\n{\r\n    const float p = 1. / 2.2;\r\n    return pow(s, p);\r\n}\r\nvec3 LinearToSRGBRunescape(vec3 s) { return sqrt(s); }\r\nfloat LinearToSRGBRunescape(float s) { return sqrt(s); }\r\nvec4 convertRGBtoHSL(vec4 s)\r\n{\r\n    const float p = 1. / 6.;\r\n    float v = s.s, m = s.t, t = s.p, f = min(min(s.s, s.t), s.p), q = max(max(s.s, s.t), s.p), r = q - f, G = (f + q) * .5, i = 0., e = 0.;\r\n    if (G > 0. && G < 1.)\r\n    {\r\n        float L = G < .5 ? G : 1. - G;\r\n        i = r / (L * 2.);\r\n    }\r\n    if (r > 0.)\r\n    {\r\n        vec3 L = vec3(q == v && q != m ? 1. : 0., q == m && q != t ? 1. : 0., q == t && q != v ? 1. : 0.), o = vec3((m - t) / r, 2. + (t - v) / r, 4. + (v - m) / r);\r\n        e += dot(o, L);\r\n        e *= p;\r\n        if (e < 0.)\r\n            e += 1.;\r\n    }\r\n    return vec4(e, i, G, s.q);\r\n}\r\nvec4 convertHSLtoRGB(vec4 s)\r\n{\r\n    const float v = 1. / 3., q = 2. / 3., m = 6.;\r\n    float p = s.s, t = s.t, r = s.p;\r\n    vec3 f = vec3(m * (p - q), 0., m * (1. - p));\r\n    if (p < q)\r\n        f.s = 0., f.t = m * (q - p), f.p = m * (p - v);\r\n    if (p < v)\r\n        f.s = m * (v - p), f.t = m * p, f.p = 0.;\r\n    f = min(f, 1.);\r\n    float L = 2. * t, i = 1. - t, G = 1. - r, e = 2. * r - 1.;\r\n    vec3 c = L * f + i, o;\r\n    if (r >= .5)\r\n        o = G * c + e;\r\n    else\r\n        o = r * c;\r\n    return vec4(o, s.q);\r\n}\r\n#endif\r\n#ifndef PACK_UTILS_INC\r\n#define PACK_UTILS_INC\r\n#ifndef SHADER_LIB_COMMON_INC\r\n#define SHADER_LIB_COMMON_INC\r\n#define USE_MOD_PACK\r\n#endif\r\n\r\nvec4 PackFloatToRGBA(highp float valueToPack)\r\n{\r\n#if defined(USE_MOD_PACK) || defined(USE_FRACT_PACK)\r\n    const highp vec4 bitShift = vec4(256 * 256 * 256, 256 * 256, 256, 1.0);\r\n    const highp vec4 bitMask = vec4(0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\r\n    highp vec4 fragColour = mod(valueToPack * bitShift * vec4(255), vec4(256)) / vec4(255);\r\n    return fragColour - fragColour.xxyz * bitMask;\r\n#endif\r\n#ifdef USE_ARAS_PACK\r\n    const highp vec4 bitShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\r\n    const highp vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\r\n    highp vec4 fragColour = fract(valueToPack * bitShift);\r\n    return fragColour - (fragColour.xxyz * bitMask);\r\n#endif\r\n}\r\nvec2 NormalPackSphereMap(vec3 v)\r\n{\r\n    vec2 f = normalize(v.st) * sqrt(-v.p * .5 + .5);\r\n    f = f * .5 + .5;\r\n    return f * 65535.;\r\n}\r\nvec2 PackFloatToVec2(float v)\r\n{\r\n    vec2 f;\r\n    const float b = 1. / 255.;\r\n    vec2 h = vec2(1., 255.), r = fract(h * v);\r\n    r.s -= r.t * b;\r\n    return r.st;\r\n}\r\n#endif\r\n#ifndef UNPACK_UTILS_INC\r\n#define UNPACK_UTILS_INC\r\n#ifndef SHADER_LIB_COMMON_INC\r\n#define SHADER_LIB_COMMON_INC\r\n#define USE_MOD_PACK\r\n#endif\r\n\r\nhighp float UnpackRGBAToFloat(highp vec4 valueToUnpack)\r\n{\r\n#if defined(USE_MOD_PACK) || defined(USE_FRACT_PACK)\r\n    const highp vec4 bitShifts = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\r\n    return dot(valueToUnpack, bitShifts);\r\n#endif\r\n#ifdef USE_ARAS_PACK\r\n    const highp vec4 bitShifts = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);\r\n    return dot(valueToUnpack, bitShifts);\r\n#endif\r\n}\r\nvec3 ColourUnpack(highp float v)\r\n{\r\n    vec3 f;\r\n    f.s = floor(v / 256. / 256.);\r\n    f.t = floor((v - f.s * 256. * 256.) / 256.);\r\n    f.p = floor(v - f.s * 256. * 256. - f.t * 256.);\r\n    return f / 256.;\r\n}\r\nvec3 NormalUnpackSphereMap(vec2 v)\r\n{\r\n    vec4 f = vec4(v.s / 32767. - 1., v.t / 32767. - 1., 1., -1.);\r\n    float U = dot(f.stp, -f.stq);\r\n    f.st *= sqrt(U);\r\n    f.p = U;\r\n    return f.stp * 2. + vec3(0., 0., -1.);\r\n}\r\nhighp float UnpackRGBAToIntegerFloat(highp vec4 f) { return floor(f.s * 255. + .5) * 256. * 256. * 256. + floor(f.t * 255. + .5) * 256. * 256. + floor(f.p * 255. + .5) * 256. + floor(f.q * 255. + .5); }\r\nhighp float UnpackRGBAToIntegerFloat16(highp vec2 f) { return floor(f.s * 255. + .5) * 256. + floor(f.t * 255. + .5); }\r\nhighp int UnpackRGBAToInt(vec4 f) { return int(UnpackRGBAToIntegerFloat(f)); }\r\nhighp vec4 UnpackFloatToRGBA(highp float f)\r\n{\r\n    const highp vec4 v = vec4(1., 255., 65025., 1.65814e+07), s = vec4(vec3(1. / 255.), 0.);\r\n    highp vec4 U = fract(f * v);\r\n    U -= U.sstp * s;\r\n    return U;\r\n}\r\nhighp float UnpackVec2ToFloat(highp vec2 f) { return floor(f.s * 255. + .5) * 256. + floor(f.t * 255. + .5); }\r\n#endif\r\n#if defined(MSAA) && defined(MSAA_AVAILABLE)\r\n#define SAMPLER_2D_AUTO_MULTISAMPLE sampler2DMS\r\n#define MSAA_SAMPLERS_ENABLED 1\r\n#define texture2DMultisample(sampler, texCoord, texSize) texelFetch(sampler, ivec2((texCoord)*texSize), 0)\r\n#else\r\n#define SAMPLER_2D_AUTO_MULTISAMPLE sampler2D\r\n#define MSAA_SAMPLERS_ENABLED 0\r\n#define texture2DMultisample(sampler, texCoord, texSize) texture2DLodCompat(sampler, texCoord, 0.0)\r\n#endif\r\nUNIFORM_BUFFER_BEGIN(ViewportLookupScale)\r\nuniform highp vec4 uViewportLookupScale;\r\nuniform highp vec4 uViewportOffsetScale;\r\nuniform highp vec4 uFullScreenLookupScale;\r\nUNIFORM_BUFFER_END\r\n\r\n/***************************************************/\r\n\r\nUNIFORM_BUFFER_BEGIN(ViewTransforms)\r\nuniform highp vec3 uCameraPosition;\r\nuniform highp mat4 uViewMatrix;\r\nuniform highp mat4 uProjectionMatrix;\r\nuniform highp mat4 uViewProjMatrix;\r\nuniform highp vec4 uZBufferParams;\r\nUNIFORM_BUFFER_END\r\n\r\nUNIFORM_BUFFER_BEGIN(Sunlight)\r\nuniform highp vec3 uInvSunDirection;\r\nuniform mediump vec3 uAmbientColour;\r\nuniform mediump vec3 uSunColour;\r\nuniform mediump float uDummy;\r\nUNIFORM_BUFFER_END\r\n#ifndef LIGHT_SCATTERING_VS_UNIFORMS\r\n#define LIGHT_SCATTERING_VS_UNIFORMS\r\nUNIFORM_BUFFER_BEGIN(SimpleScattering)\r\nuniform mediump vec3 uOutscatteringAmount;\r\nuniform mediump vec3 uInscatteringAmount;\r\nuniform mediump vec3 uScatteringTintColour;\r\nuniform highp vec4 uScatteringParameters;\r\nUNIFORM_BUFFER_END\r\n#endif\r\n#ifndef BRDF_INC\r\n#define BRDF_INC\r\n#ifndef NDF_INC\r\n#define NDF_INC\r\n#ifndef MATH_UTILS_INC\r\n#define MATH_UTILS_INC\r\nconst float PI = 3.14159, INV_PI = .31831, TWOPI = PI * 2., INV_TWOPI = 1. / TWOPI, PI_OVER_4 = PI / 4., PI_OVER_2 = PI / 2., SQRT_2_PI = .797885, INV_EIGHT = .125;\r\nfloat SpecPowToBeckmannRoughness(float f) { return sqrt(2. / (f + 2.)); }\r\nfloat PerceptualRoughnessToRoughness(float f) { return f * f; }\r\nfloat RoughnessToPerceptualRoughness(float f) { return sqrt(f); }\r\n#endif\r\n\r\nfloat BlinnPhongNDF(float f, float N)\r\n{\r\n    return (f + 2.) * INV_EIGHT * pow(N, f);\r\n}\r\nfloat GGXTrowbridgeReitzNDF(float N, float f)\r\n{\r\n    float P = N * N, I = f * f, T = I * (P - 1.) + 1.;\r\n    return P / (PI * (T * T + .0001));\r\n}\r\nfloat BeckmannNDF(float N, float f)\r\n{\r\n    float P = N * N, I = f * f;\r\n    return exp((I - 1.) / (P * I)) / (PI * P * (I * I));\r\n}\r\n#endif\r\n\r\n#ifndef VISIBILITY_FUNC_INC\r\n#define VISIBILITY_FUNC_INC\r\n#ifndef MATH_UTILS_INC\r\n#define MATH_UTILS_INC\r\nconst float PI = 3.14159, INV_PI = .31831, TWOPI = PI * 2., INV_TWOPI = 1. / TWOPI, PI_OVER_4 = PI / 4., PI_OVER_2 = PI / 2., SQRT_2_PI = .797885, INV_EIGHT = .125;\r\nfloat SpecPowToBeckmannRoughness(float f) { return sqrt(2. / (f + 2.)); }\r\nfloat PerceptualRoughnessToRoughness(float f) { return f * f; }\r\nfloat RoughnessToPerceptualRoughness(float f) { return sqrt(f); }\r\n#endif\r\n\r\nfloat SchlickSmithVis(float V, float f, float S)\r\n{\r\n    float P = 1. / sqrt(PI_OVER_4 * V + PI_OVER_2), d = 1. - P, v = (f * d + P) * (S * d + P);\r\n    return 1. / (v + .0001);\r\n}\r\nfloat KelemenSzirmayKalosVis(vec3 V, vec3 P)\r\n{\r\n    vec3 f = V + P;\r\n    return 4. / max(0., dot(f, f));\r\n}\r\n#endif\r\n\r\n#define GGX_NDF\r\n#define SCHLICK_SMITH_VIS\r\nvec3 CookTorranceBRDF(float d, float S, vec3 n, vec3 v, vec3 f, vec3 B, vec3 R, float F)\r\n{\r\n    float m = max(0., dot(v, f)), r = 1.;\r\n#if defined(BLINN_PHONG_NDF)\r\n    r = BlinnPhongNDF(d, m);\r\n#elif defined(GGX_NDF)\r\n    r = GGXTrowbridgeReitzNDF(PerceptualRoughnessToRoughness(S), m);\r\n#elif defined(BECKMANN_NDF)\r\n    r = max(0.f, BeckmannNDF(SpecPowToBeckmannRoughness(d), m));\r\n#else\r\n\r\n#error CookTorranceBRDF normal distribution function not specified\r\n\r\n#endif\r\n    float C = 1.;\r\n#if defined(SCHLICK_SMITH_VIS)\r\n    C = SchlickSmithVis(d, F, max(0., dot(v, B)));\r\n#elif defined(KELEMEN_SZIRMAY_KALOS_VIS)\r\n    C = KelemenSzirmayKalosVis(R, B);\r\n#endif\r\n    return n * (r * C);\r\n}\r\nfloat RunescapeLegacyBRDF(vec3 d, vec3 v, vec3 f, float B, float S)\r\n{\r\n    vec3 n = reflect(-d, f);\r\n    float C = pow(max(0., dot(n, v)), B);\r\n    return C * S;\r\n}\r\nfloat RunescapeRT5BRDF(vec3 d, vec3 v, float S) { return BlinnPhongNDF(S, max(0., dot(d, v))); }\r\nvec3 ShiftTangent(vec3 d, vec3 S, float B) { return normalize(d + B * S); }\r\nvec3 AnisotropicBRDF(vec3 v, vec3 d, vec3 S, vec3 f, vec3 B, float n, float m, float R, float C)\r\n{\r\n    const float F = 7.5, r = 1., e = .5, o = 1.;\r\n    float s = R - .5;\r\n    S = ShiftTangent(S, d, e + (C * 2. - 1.) * o + s);\r\n    float p = abs(dot(S, f)), a = 1. - p, t = 1. - abs(dot(S, B)), K = p * dot(d, B);\r\n    K += a * t;\r\n    K = pow(K, F) * n;\r\n    K = mix(K, K * C, o);\r\n    float G = pow(dot(d, v), m), P = mix(G, K, r);\r\n    return vec3(P, P, P);\r\n}\r\n#endif\r\nuniform highp float uGridSize;\r\nuniform mediump vec4 uAtlasMeta;\r\nuniform sampler2D uTextureAtlas;\r\nuniform sampler2D uTextureAtlasSettings;\r\nin highp vec4 vWorldPos_ViewSpaceDepth;\r\nin vec4 vVertexAlbedo;\r\nin vec3 vWorldNormal;\r\nflat in highp vec4 vMaterialSettingsSlots1D;\r\nflat in highp vec4 vTextureScale;\r\nin vec4 vTextureWeight;\r\nflat in vec4 vMaterialProperties;\r\n#define SRGB_TEXTURES\r\n#define STANDARD_DERIVATIVES\r\n#define TEXTURE_LOD\r\n#define TEXTURE_GRAD\r\n#define TEXTURE_MIP_LIMIT\r\n#define LOOKUP_MODE_REPEAT\r\n\r\n#define TEXTURE_SETTINGS_USE_TEXEL_OFFSETS\r\n#ifndef CONVERSION_UTILS_INC\r\n#define CONVERSION_UTILS_INC\r\nvec3 SRGBToLinear(vec3 srgbColour)\r\n{\r\n#if defined(GAMMA_CORRECT_INPUTS)\r\n    return srgbColour * srgbColour;\r\n#else\r\n    return pow(srgbColour, vec3(2.2, 2.2, 2.2));\r\n#endif\r\n}\r\nvec3 LinearToSRGB(vec3 s) { return max(vec3(1.055) * pow(s, vec3(.416667)) - vec3(.055), vec3(0.)); }\r\nfloat LinearToSRGB(float s)\r\n{\r\n    const float p = 1. / 2.2;\r\n    return pow(s, p);\r\n}\r\nvec3 LinearToSRGBRunescape(vec3 s) { return sqrt(s); }\r\nfloat LinearToSRGBRunescape(float s) { return sqrt(s); }\r\nvec4 convertRGBtoHSL(vec4 s)\r\n{\r\n    const float p = 1. / 6.;\r\n    float v = s.s, m = s.t, t = s.p, f = min(min(s.s, s.t), s.p), q = max(max(s.s, s.t), s.p), r = q - f, G = (f + q) * .5, i = 0., e = 0.;\r\n    if (G > 0. && G < 1.)\r\n    {\r\n        float L = G < .5 ? G : 1. - G;\r\n        i = r / (L * 2.);\r\n    }\r\n    if (r > 0.)\r\n    {\r\n        vec3 L = vec3(q == v && q != m ? 1. : 0., q == m && q != t ? 1. : 0., q == t && q != v ? 1. : 0.), o = vec3((m - t) / r, 2. + (t - v) / r, 4. + (v - m) / r);\r\n        e += dot(o, L);\r\n        e *= p;\r\n        if (e < 0.)\r\n            e += 1.;\r\n    }\r\n    return vec4(e, i, G, s.q);\r\n}\r\nvec4 convertHSLtoRGB(vec4 s)\r\n{\r\n    const float v = 1. / 3., q = 2. / 3., m = 6.;\r\n    float p = s.s, t = s.t, r = s.p;\r\n    vec3 f = vec3(m * (p - q), 0., m * (1. - p));\r\n    if (p < q)\r\n        f.s = 0., f.t = m * (q - p), f.p = m * (p - v);\r\n    if (p < v)\r\n        f.s = m * (v - p), f.t = m * p, f.p = 0.;\r\n    f = min(f, 1.);\r\n    float L = 2. * t, i = 1. - t, G = 1. - r, e = 2. * r - 1.;\r\n    vec3 c = L * f + i, o;\r\n    if (r >= .5)\r\n        o = G * c + e;\r\n    else\r\n        o = r * c;\r\n    return vec4(o, s.q);\r\n}\r\n#endif\r\n\r\nfloat getMipMapLevel(vec2 v, vec2 p)\r\n{\r\n    float d = 0.;\r\n#if defined(STANDARD_DERIVATIVES)\r\n    float L = max(dot(v, v), dot(p, p));\r\n    d = .5 * log2(L);\r\n    d = max(0., d);\r\n#endif\r\n    return d;\r\n}\r\n#if defined(DEBUG_TEXEL_DENSITY)\r\nvec3 GetTexelDensityDebugColour(vec2 v, float p, vec3 d)\r\n{\r\n    float t = length(fwidth(v) * p), s = length(fwidth(d)), L = t / s, h = uDebugTexelDensity.s, f = uDebugTexelDensity.t, o = uDebugTexelDensity.p, T = uDebugTexelDensity.q;\r\n    vec3 c;\r\n    c.s = smoothstep(f / (T + 1.), h, L);\r\n    c.t = 1. - smoothstep(0., f * (T + 1.), abs(L - f));\r\n    c.p = smoothstep(1. - (f + o * T), 1. - o, 1. - L);\r\n    c *= c;\r\n    return c;\r\n}\r\n#endif\r\n#if defined(LOOKUP_MODE_DYNAMIC) && !defined(NO_SAMPLER_WRAP)\r\nflat in mediump float vSamplerWrap;\r\n#endif\r\n#if __VERSION__ <= 120\r\n#ifdef in\r\n#undef in\r\n#endif\r\n#ifdef out\r\n#undef out\r\n#endif\r\n#endif\r\n\r\nvoid getTexelBias_inner(float v, highp vec2 t, highp vec3 d, highp vec3 p, highp vec3 s, vec4 c, vec2 m, vec2 g, float L, sampler2D f, out vec4 i, out vec4 h, out vec4 o)\r\n{\r\n    float T = c.s;\r\n    highp float q = c.t, l = c.p;\r\n    float P = c.q;\r\n    highp vec3 S = vec3(d.s, p.s, s.s), y = vec3(d.t, p.t, s.t), a = vec3(d.p, p.p, s.p);\r\n    const vec2 u = vec2(1.);\r\n    vec3 D = .5 / a;\r\n    highp vec2 r, C, Y;\r\n#if !defined(LOOKUP_MODE_CLAMP) && !defined(LOOKUP_MODE_REPEAT)\r\n    const float G = .5, e = .25, n = .125, E = .0625;\r\n    vec4 O = step(.5, fract(L * vec4(G, e, n, E)));\r\n#endif\r\n\r\n#if defined(LOOKUP_MODE_CLAMP)\r\n    r = clamp(t, vec2(D.s), u - vec2(D.s));\r\n#elif defined(LOOKUP_MODE_REPEAT)\r\n    r = mod(t, u);\r\n#else\r\n    const vec2 N = vec2(.5), M = vec2(2.);\r\n    vec2 x = clamp(t, vec2(D.s), u - vec2(D.s)), R = mod(t, u), A = t - M * floor(N * t), U = u - abs(u - A);\r\n    r = O.st * x + O.pq * R + (u - O.st - O.pq) * U;\r\n#endif\r\n    r = r * a.s * l;\r\n    r += vec2(S.s, y.s) * q * l;\r\n    if (v > 1.)\r\n    {\r\n#if defined(LOOKUP_MODE_CLAMP)\r\n        C = clamp(t, vec2(D.t), u - vec2(D.t));\r\n#elif defined(LOOKUP_MODE_REPEAT)\r\n        C = mod(t, u);\r\n#else\r\n        vec2 I = clamp(t, vec2(D.t), u - vec2(D.t)), K = R, B = U;\r\n        C = O.st * I + O.pq * K + (u - O.st - O.pq) * B;\r\n#endif\r\n        C = C * a.t * l;\r\n        C += vec2(S.t, y.t) * q * l;\r\n        if (v > 2.)\r\n        {\r\n#if defined(LOOKUP_MODE_CLAMP)\r\n            Y = clamp(t, vec2(D.p), u - vec2(D.p));\r\n#elif defined(LOOKUP_MODE_REPEAT)\r\n            Y = mod(t, u);\r\n#else\r\n            vec2 b = clamp(t, vec2(D.p), u - vec2(D.p)), X = R, V = U;\r\n            Y = O.st * b + O.pq * X + (u - O.st - O.pq) * V;\r\n#endif\r\n            Y = Y * a.p * l;\r\n            Y += vec2(S.p, y.p) * q * l;\r\n        }\r\n    }\r\n    h = vec4(0.);\r\n    o = vec4(0.);\r\n#if defined(TEXTURE_MIP_LIMIT)\r\n\r\n#if defined(TEXTURE_GRAD)\r\n    highp vec2 I = m * l, K = g * l, B = I * a.s, X = K * a.s;\r\n    const vec2 b = vec2(.025);\r\n    B = clamp(B, -b, b);\r\n    X = clamp(X, -b, b);\r\n    i = texture2DGrad(f, r, B, X);\r\n    if (v > 1.)\r\n    {\r\n        B = I * a.t;\r\n        X = K * a.t;\r\n        B = clamp(B, -b, b);\r\n        X = clamp(X, -b, b);\r\n        h = texture2DGrad(f, C, B, X);\r\n        if (v > 2.)\r\n            B = I * a.p, X = K * a.p, B = clamp(B, -b, b), X = clamp(X, -b, b), o = texture2DGrad(f, Y, B, X);\r\n    }\r\n#else\r\n    i = texture2D(f, r);\r\n    if (v > 1.)\r\n    {\r\n        h = texture2D(f, C);\r\n        if (v > 2.)\r\n            o = texture2D(f, Y);\r\n    }\r\n#endif\r\n\r\n#else\r\n\r\n#if defined(TEXTURE_LOD)\r\n    vec2 V = m * a.s, W = g * a.s;\r\n    float F = getMipMapLevel(V, W);\r\n    F = min(F, P);\r\n    i = texture2DLod(f, r, F);\r\n    if (v > 1.)\r\n    {\r\n        V = m * a.t;\r\n        W = g * a.t;\r\n        F = getMipMapLevel(V, W);\r\n        F = min(F, P);\r\n        h = texture2DLod(f, C, F);\r\n        if (v > 2.)\r\n            V = m * a.p, W = g * a.p, F = getMipMapLevel(V, W), F = min(F, P), o = texture2DLod(f, Y, F);\r\n    }\r\n#else\r\n    i = texture2D(f, r);\r\n    if (v > 1.)\r\n    {\r\n        h = texture2D(f, C);\r\n        if (v > 2.)\r\n            o = texture2D(f, Y);\r\n    }\r\n#endif\r\n\r\n#endif\r\n}\r\nvoid getTexel_inner(float v, vec2 f, highp vec3 d, highp vec3 t, highp vec3 p, vec4 s, vec2 h, vec2 o, float b, sampler2D B, out vec4 D, out vec4 L, out vec4 u)\r\n{\r\n    getTexelBias_inner(v, f, d, t, p, s, h, o, b, B, D, L, u);\r\n#if defined(SRGB_TEXTURES)\r\n    if (v > 1.)\r\n        L = vec4(LinearToSRGB(L.stp), L.q);\r\n    if (v > 2.)\r\n        u = vec4(LinearToSRGB(u.stp), u.q);\r\n#else\r\n    D = vec4(SRGBToLinear(D.stp), D.q);\r\n#endif\r\n}\r\nvoid getTexel_inner(float v, vec2 f, highp vec3 d, highp vec3 t, highp vec3 p, vec4 s, float h, sampler2D o, out vec4 b, out vec4 B, out vec4 u)\r\n{\r\n    vec2 X = vec2(0.), i = vec2(0.);\r\n#if defined(STANDARD_DERIVATIVES)\r\n    X = dFdx(f);\r\n    i = dFdy(f);\r\n#endif\r\n    getTexel_inner(v, f, d, t, p, s, X, i, h, o, b, B, u);\r\n}\r\nvoid getTexel(vec2 v, highp vec3 o, vec4 h, vec2 g, vec2 s, float f, sampler2D e, out vec4 c)\r\n{\r\n    vec3 t = vec3(1.), l = vec3(1.);\r\n    vec4 i = vec4(0.), p = vec4(0.);\r\n    getTexel_inner(1., v, o, t, l, h, g, s, f, e, c, i, p);\r\n}\r\nvoid getTexel(vec2 v, highp vec3 o, vec4 h, float g, sampler2D s, out vec4 f)\r\n{\r\n    vec3 e = vec3(1.), l = vec3(1.);\r\n    vec4 t = vec4(0.), p = vec4(0.);\r\n    getTexel_inner(1., v, o, e, l, h, g, s, f, t, p);\r\n}\r\nvoid getTexel(vec2 v, highp vec3 o, highp vec3 h, vec4 g, vec2 s, vec2 f, float e, sampler2D t, out vec4 l, out vec4 p)\r\n{\r\n    vec3 i = vec3(1.);\r\n    vec4 c = vec4(0.);\r\n    getTexel_inner(2., v, o, h, i, g, s, f, e, t, l, p, c);\r\n}\r\nvoid getTexel(vec2 v, highp vec3 o, highp vec3 h, vec4 g, float s, sampler2D f, out vec4 e, out vec4 t)\r\n{\r\n    vec3 l = vec3(1.);\r\n    vec4 p = vec4(0.);\r\n    getTexel_inner(2., v, o, h, l, g, s, f, e, t, p);\r\n}\r\nvoid getTexel(vec2 v, highp vec3 o, highp vec3 h, highp vec3 g, vec4 s, vec2 f, vec2 e, float t, sampler2D l, out vec4 p, out vec4 i, out vec4 c) { getTexel_inner(3., v, o, h, g, s, f, e, t, l, p, i, c); }\r\nvoid getTexel(vec2 v, highp vec3 o, highp vec3 h, highp vec3 g, vec4 s, float f, sampler2D e, out vec4 t, out vec4 l, out vec4 p) { getTexel_inner(3., v, o, h, g, s, f, e, t, l, p); }\r\n\r\n#if __VERSION__ <= 120\r\n#define in varying\r\n#define out varying\r\n#endif\r\n\r\n#ifndef TEXTURE_SETTINGS_INC\r\n#define TEXTURE_SETTINGS_INC\r\nstruct TextureSettings\r\n{\r\n    highp vec3 textureMeta1;\r\n    highp vec3 textureMeta2;\r\n    highp vec2 uvAnim;\r\n    float wrapping;\r\n    float specular;\r\n    float normalScale;\r\n#if defined(REFRACTION)\r\n    vec4 refraction;\r\n#endif\r\n#if defined(VIEWPORTMAP)\r\n    vec4 viewportMapUVScaleAndAnim;\r\n#endif\r\n#if defined(DEBUG_MATERIAL_HIGHLIGHT)\r\n    highp float materialID;\r\n#endif\r\n};\r\n#if __VERSION__ <= 120\r\n#ifdef in\r\n#undef in\r\n#endif\r\n#ifdef out\r\n#undef out\r\n#endif\r\n#endif\r\n\r\nvoid getTextureSettings(vec2 s, out TextureSettings v)\r\n{\r\n    const highp float d = 1. / 255., S = 1. / 65535., e = 32767., t = 1. / 32767.;\r\n    const float f = 1. / MATERIAL_SETTINGS_TEXTURE_RESOLUTION;\r\n    vec2 i = (floor(s + .5) * vec2(MATERIAL_SETTINGS_SLOT_PIXEL_RESOLUTION_X, MATERIAL_SETTINGS_SLOT_PIXEL_RESOLUTION_Y) + .5) * f;\r\n    const float u = f;\r\n    vec4 T = texture2DLodCompat(uTextureAtlasSettings, i, 0.), U, n, D, m, a, R;\r\n    float h;\r\n    vec4 r;\r\n#if defined(TEXTURE_SETTINGS_USE_TEXEL_OFFSETS)\r\n\r\n#define SAMPLE_OFFSET_SLOTSIZES_AND_WRAPPING ivec2(2, 0)\r\n\r\n#define SAMPLE_OFFSET_UV_ANIM ivec2(0, 1)\r\n\r\n#define SAMPLE_OFFSET_SPECULAR_NORMAL_SCALE ivec2(1, 1)\r\n\r\n#define SAMPLE_OFFSET_REFRACTION ivec2(0, 2)\r\n\r\n#define SAMPLE_OFFSET_SLOTETC ivec2(1, 2)\r\n\r\n#define SAMPLE_OFFSET_VIEWPORTMAP_UVSCALE ivec2(2, 2)\r\n\r\n#define SAMPLE_OFFSET_VIEWPORTMAP_UVANIMATION ivec2(0, 3)\r\n\r\n#define SAMPLE_OFFSET_DEBUG ivec2(2, 3)\r\n    U = textureLodOffset(uTextureAtlasSettings, i, 0., SAMPLE_OFFSET_SLOTSIZES_AND_WRAPPING);\r\n    n = textureLodOffset(uTextureAtlasSettings, i, 0., SAMPLE_OFFSET_UV_ANIM);\r\n#if defined(SPECULAR_LIGHTING) || defined(USE_NORMAL_MAP)\r\n    D = textureLodOffset(uTextureAtlasSettings, i, 0., SAMPLE_OFFSET_SPECULAR_NORMAL_SCALE);\r\n#endif\r\n\r\n#if defined(REFRACTION)\r\n    m = textureLodOffset(uTextureAtlasSettings, i, 0., SAMPLE_OFFSET_REFRACTION);\r\n#endif\r\n    h = textureLodOffset(uTextureAtlasSettings, i, 0., SAMPLE_OFFSET_SLOTETC).q;\r\n#if defined(VIEWPORTMAP)\r\n    a = textureLodOffset(uTextureAtlasSettings, i, 0., SAMPLE_OFFSET_VIEWPORTMAP_UVSCALE);\r\n    R = textureLodOffset(uTextureAtlasSettings, i, 0., SAMPLE_OFFSET_VIEWPORTMAP_UVANIMATION);\r\n#endif\r\n\r\n#if defined(DEBUG_MATERIAL_HIGHLIGHT)\r\n    r = textureLodOffset(uTextureAtlasSettings, i, 0., SAMPLE_OFFSET_DEBUG);\r\n#endif\r\n\r\n#else\r\n    vec2 g = vec2(u * 2., 0.), o = vec2(0., u), M = vec2(u, u), p = vec2(0., u * 2.), X = vec2(u, u * 2.), q = vec2(u * 2., u * 2.), E = vec2(0., u * 3.), A = vec2(u * 2., u * 3.);\r\n    U = texture2DLodCompat(uTextureAtlasSettings, i + g, 0.);\r\n    n = texture2DLodCompat(uTextureAtlasSettings, i + o, 0.);\r\n#if defined(SPECULAR_LIGHTING) || defined(USE_NORMAL_MAP)\r\n    D = texture2DLodCompat(uTextureAtlasSettings, i + M, 0.);\r\n#endif\r\n\r\n#if defined(REFRACTION)\r\n    m = texture2DLodCompat(uTextureAtlasSettings, i + p, 0.);\r\n#endif\r\n    h = texture2DLodCompat(uTextureAtlasSettings, i + X, 0.).q;\r\n#if defined(VIEWPORTMAP)\r\n    a = texture2DLodCompat(uTextureAtlasSettings, i + q, 0.);\r\n    R = texture2DLodCompat(uTextureAtlasSettings, i + E, 0.);\r\n#endif\r\n\r\n#if defined(DEBUG_MATERIAL_HIGHLIGHT)\r\n    r = texture2DLodCompat(uTextureAtlasSettings, i + A, 0.);\r\n#endif\r\n\r\n#endif\r\n    T = floor(T * 255. + .5);\r\n    U = floor(U * 255. + .5);\r\n    h = floor(h * 255. + .5);\r\n    const float V = .5, c = .25, L = .125, P = .0625;\r\n    vec4 N = step(.5, fract(h * vec4(V, c, L, P)));\r\n    T += vec4(256.) * N;\r\n    vec2 w = U.st * uAtlasMeta.t;\r\n    v.textureMeta1 = vec3(T.st, w.s);\r\n    v.textureMeta2 = vec3(T.pq, w.t);\r\n    v.wrapping = U.q;\r\n#if defined(SPECULAR_LIGHTING) || defined(USE_NORMAL_MAP)\r\n    v.specular = UnpackVec2ToFloat(D.st) * d;\r\n    v.normalScale = UnpackVec2ToFloat(D.pq) * d;\r\n    v.normalScale = v.normalScale * .1 - 8.;\r\n#else\r\n    v.specular = 0.;\r\n    v.normalScale = 0.;\r\n#endif\r\n    highp vec2 G = vec2(UnpackVec2ToFloat(n.st), UnpackVec2ToFloat(n.pq)) - e;\r\n    G *= step(1.5, abs(G));\r\n    v.uvAnim = G * t * 2.;\r\n#if defined(REFRACTION)\r\n    v.refraction = m;\r\n    v.refraction.t = v.refraction.t * 2. + 1.;\r\n    v.refraction.p = UnpackVec2ToFloat(v.refraction.pq) * S * 10.;\r\n#endif\r\n\r\n#if defined(VIEWPORTMAP)\r\n    highp vec2 C = vec2(UnpackVec2ToFloat(a.st), UnpackVec2ToFloat(a.pq)) - e, Y = vec2(UnpackVec2ToFloat(R.st), UnpackVec2ToFloat(R.pq)) - e;\r\n    C *= step(1.5, abs(C));\r\n    Y *= step(1.5, abs(Y));\r\n    v.viewportMapUVScaleAndAnim = vec4(C * t * 2., Y * t * 2.);\r\n#endif\r\n\r\n#if defined(DEBUG_MATERIAL_HIGHLIGHT)\r\n    v.materialID = UnpackVec2ToFloat(r.st);\r\n#endif\r\n}\r\nvoid getTextureSettings1D(float v, out TextureSettings i)\r\n{\r\n    const float d = 1. / MATERIAL_SETTINGS_SLOTS_DIMENSION_COUNT_X;\r\n    float S = floor((v + .5) * d), u = v - S * MATERIAL_SETTINGS_SLOTS_DIMENSION_COUNT_X;\r\n    getTextureSettings(vec2(u, S), i);\r\n}\r\n#if __VERSION__ <= 120\r\n#define in varying\r\n#define out varying\r\n#endif\r\n\r\n#endif\r\n#ifndef DISTANCE_FOG_UNIFORMS\r\n#define DISTANCE_FOG_UNIFORMS\r\n#if defined(FOG_DISTANCE)\r\nUNIFORM_BUFFER_BEGIN(DistanceFog)\r\nuniform mediump vec4 uFogColour;\r\nuniform highp vec4 uFogParams;\r\nUNIFORM_BUFFER_END\r\n#endif\r\n#endif\r\n\r\n#ifndef DISTANCE_FOG_FUNCTIONS\r\n#define DISTANCE_FOG_FUNCTIONS\r\n#if defined(FOG_DISTANCE)\r\nfloat FogBasedOnDistance(highp float f)\r\n{\r\n    highp float F = (uFogParams.t - f) * uFogParams.s;\r\n    return 1. - clamp(F, 0., 1.);\r\n}\r\nfloat FogBasedOnAngle(highp vec3 f)\r\n{\r\n    highp float F = 1. - clamp(f.t + uFogParams.q, 0., 1.);\r\n    F = pow(F, uFogParams.p);\r\n    return clamp(F, 0., 1.);\r\n}\r\n#endif\r\n#endif\r\n\r\n#if defined(TEXTURE_ATLAS)\r\nvoid ComputeTangentBitangentFromDerivatives(inout vec3 v, inout vec3 p, highp vec3 h, highp vec3 d, highp vec3 A, highp vec2 r, highp vec2 S)\r\n{\r\n    highp vec3 q = cross(h, d), c = cross(A, h), n = c * r.s + q * S.s, s = c * r.t + q * S.t;\r\n    highp float D = dot(n, n), a = dot(s, s), i = max(D, a), t = inversesqrt(i);\r\n    n *= t;\r\n    s *= t;\r\n    if (isNaN(D + a) || i <= 0.)\r\n        n = s = h;\r\n    v = n;\r\n    p = s;\r\n}\r\nvec3 ComputeBitangent(vec3 v, vec4 h)\r\n{\r\n    highp vec3 p = cross(v, h.stp);\r\n    p *= h.q;\r\n    return p;\r\n}\r\nvec3 ApplyNormalMap(highp vec3 v, highp vec3 h, highp vec3 d, highp vec3 A, highp vec2 p, highp vec2 S)\r\n{\r\n    highp vec3 D, s;\r\n    ComputeTangentBitangentFromDerivatives(D, s, h, d, A, p, S);\r\n#if defined(DEBUG_TANGENTS)\r\n    gl_FragColor.stp = normalize(D) * .5 + .5;\r\n    gl_FragColor.q = 1.;\r\n#endif\r\n\r\n#if defined(DEBUG_BITANGENTS)\r\n    gl_FragColor.stp = normalize(s) * .5 + .5;\r\n    gl_FragColor.q = 1.;\r\n#endif\r\n    highp vec3 r = v.s * D + v.t * s + v.p * h;\r\n    r = normalize(r);\r\n    return abs(r.s) + abs(r.t) + abs(r.p) < .5 ? h : r;\r\n}\r\nvec3 ApplyNormalMap(vec3 v, vec3 A, vec3 s, vec3 S)\r\n{\r\n#if defined(DEBUG_TANGENTS)\r\n    gl_FragColor.stp = s * .5 + .5;\r\n    gl_FragColor.q = 1.;\r\n#endif\r\n\r\n#if defined(DEBUG_BITANGENTS)\r\n    gl_FragColor.stp = S * .5 + .5;\r\n    gl_FragColor.q = 1.;\r\n#endif\r\n    highp vec3 p = v.s * s + v.t * S + v.p * A;\r\n    p = normalize(p);\r\n    return p;\r\n}\r\nvec3 ApplyNormalMap(vec3 v, vec3 h, vec4 r)\r\n{\r\n    vec3 p = ComputeBitangent(h, r);\r\n    return ApplyNormalMap(v, h, r.stp, p);\r\n}\r\nvec3 ApplyNormalMapTerrain(vec3 v, highp vec3 h, highp vec3 r, highp vec3 S)\r\n{\r\n    highp vec3 p = cross(h, r), s = cross(S, h), D = s * r.s + p * S.s, n = s * r.p + p * S.p;\r\n    highp float A = inversesqrt(max(dot(D, D), dot(n, n)));\r\n    D *= A;\r\n    n *= A;\r\n#if defined(DEBUG_TANGENTS)\r\n    gl_FragColor.stp = normalize(D) * .5 + .5;\r\n    gl_FragColor.q = 1.;\r\n#endif\r\n\r\n#if defined(DEBUG_BITANGENTS)\r\n    gl_FragColor.stp = normalize(n) * .5 + .5;\r\n    gl_FragColor.q = 1.;\r\n#endif\r\n    highp vec3 d = v.s * D + v.t * n + v.p * h;\r\n    d = normalize(d);\r\n    return isNaN(d.s) ? h : d;\r\n}\r\nvec3 ApplyNormalMapTerrain(vec3 v, vec3 h)\r\n{\r\n    const vec3 p = vec3(0., 0., 1.);\r\n    vec3 D = cross(p, h), s = cross(D, h);\r\n    return ApplyNormalMap(v, h, D, s);\r\n}\r\n\r\nvec3 UnpackCompressedNormal(vec3 U)\r\n{\r\n    vec3 v = vec3(U.ps * 255. / 127. - 1.00787, 0.);\r\n    v.p = sqrt(1. - min(1., dot(v.st, v.st)));\r\n    v.t = -v.t;\r\n    return v;\r\n}\r\nvec3 UnpackNormal(vec3 v, float U)\r\n{\r\n    vec3 t;\r\n#if defined(COMPRESSED_NORMALS)\r\n    t = UnpackCompressedNormal(v);\r\n#else\r\n    t = v.pst * 255. / 127. - 1.00787;\r\n    t.t = -t.t;\r\n#endif\r\n    t.st *= U;\r\n    return t;\r\n}\r\nvec3 UnpackNormal(vec3 U) { return UnpackNormal(U, 1.); }\r\nvec3 UnpackNormal(vec4 v) { return UnpackNormal(v.tpq, 1.); }\r\nvec3 UnpackNormal(vec4 v, float U) { return UnpackNormal(v.tpq, U); }\r\n\r\n#if defined(VIEWPORTMAP)\r\nvec3 SampleViewportMapColour(highp vec2 v, highp vec4 e)\r\n{\r\n    v = v * uViewportLookupScale.st;\r\n    vec2 t;\r\n#if defined(OGLES2_BACKEND)\r\n    t = uViewportMapTextureSize.st;\r\n#else\r\n    t = vec2(textureSize(uViewportMap, 0));\r\n#endif\r\n    v.s *= uViewportLookupScale.p * uViewportLookupScale.t / (t.s / t.t);\r\n    v *= e.st;\r\n    highp float u = uTextureAnimationTime;\r\n    v += e.pq * u;\r\n    return texture2DLodCompat(uViewportMap, v, 0.).stp;\r\n}\r\n#endif\r\n\r\n#if __VERSION__ <= 120\r\n#ifdef in\r\n#undef in\r\n#endif\r\n#ifdef out\r\n#undef out\r\n#endif\r\n#endif\r\n\r\n#if defined(TEXTURE_ATLAS)\r\nvoid SampleTerrainTextures(out vec4 t, out vec2 d, out float p, inout vec3 s, highp vec3 v, highp vec3 u, vec4 a, vec4 r, inout float g)\r\n{\r\n    TextureSettings S;\r\n    getTextureSettings1D(vMaterialSettingsSlots1D[0], S);\r\n    TextureSettings m;\r\n    getTextureSettings1D(vMaterialSettingsSlots1D[1], m);\r\n    TextureSettings e;\r\n    getTextureSettings1D(vMaterialSettingsSlots1D[2], e);\r\n    highp vec3 D = vTextureScale.stp, i = 8. / (D * uGridSize);\r\n    highp vec2 T = v.sp * i[0], h = v.sp * i[1], o = v.sp * i[2];\r\n#if defined(DEBUG_TEXEL_DENSITY)\r\n    gl_FragColor = vec4(0., 0., 0., 1.);\r\n    gl_FragColor.stp += GetTexelDensityDebugColour(T, S.textureMeta1.p, u) * vTextureWeight.s;\r\n    gl_FragColor.stp += GetTexelDensityDebugColour(h, m.textureMeta1.p, u) * vTextureWeight.t;\r\n    gl_FragColor.stp += GetTexelDensityDebugColour(o, e.textureMeta1.p, u) * vTextureWeight.p;\r\n#endif\r\n    T = mod(T, 1.);\r\n    h = mod(h, 1.);\r\n    o = mod(o, 1.);\r\n    highp vec3 f = vec3(0.), G = vec3(0.);\r\n#if defined(STANDARD_DERIVATIVES) && (defined(TEXTURE_LOD) || defined(NORMAL_MAP))\r\n    f = dFdx(u);\r\n    G = dFdy(u);\r\n#endif\r\n    vec2 q = f.sp * i[0], l = G.sp * i[0], n = f.sp * i[1], c = G.sp * i[1], x = f.sp * i[2], M = G.sp * i[2];\r\n    vec3 P = mod(r.stp, vec3(16.)) - vec3(.25),\r\n         A = (r.stp - vec3(.25) - P) / vec3(255.);\r\n    P *= vec3(1. / 15.);\r\n    vec4 E = vec4(vec3(.580392), a.q),\r\n         H = mix(a, E, A.s) * (1. + P.s),\r\n         N = mix(a, E, A.t) * (1. + P.t),\r\n         U = mix(a, E, A.p) * (1. + P.p);\r\n#if defined(GAMMA_CORRECT_INPUTS)\r\n    H.stp = SRGBToLinear(H.stp);\r\n    N.stp = SRGBToLinear(N.stp);\r\n    U.stp = SRGBToLinear(U.stp);\r\n#endif\r\n    vec4 C, V, Y;\r\n#if defined(HDR_SCALE) || defined(NORMAL_MAP)\r\n    vec4 R, W, L;\r\n#if defined(COMPRESSED_NORMALS)\r\n    R = vec4(0., .5, 0., .5);\r\n    W = vec4(0., .5, 0., .5);\r\n    L = vec4(0., .5, 0., .5);\r\n#else\r\n    R = vec4(0., .5, 1., .5);\r\n    W = vec4(0., .5, 1., .5);\r\n    L = vec4(0., .5, 1., .5);\r\n#endif\r\n    getTexel(T, S.textureMeta1, S.textureMeta2, uAtlasMeta, q, l, 0., uTextureAtlas, C, R);\r\n    getTexel(h, m.textureMeta1, m.textureMeta2, uAtlasMeta, n, c, 0., uTextureAtlas, V, W);\r\n    getTexel(o, e.textureMeta1, e.textureMeta2, uAtlasMeta, x, M, 0., uTextureAtlas, Y, L);\r\n#if defined(ETC_CHANNEL_SWIZZLE)\r\n    R = R.qtps;\r\n    W = W.qtps;\r\n    L = L.qtps;\r\n#endif\r\n\r\n#if defined(HDR_SCALE)\r\n    C = HDRScale(C, R.s);\r\n    V = HDRScale(V, W.s);\r\n    Y = HDRScale(Y, L.s);\r\n#endif\r\n\r\n#if defined(NORMAL_MAP)\r\n    vec3 I = UnpackNormal(R, S.normalScale), F = UnpackNormal(W, m.normalScale), O = UnpackNormal(L, e.normalScale), w = I * vTextureWeight.s + F * vTextureWeight.t + O * vTextureWeight.p;\r\n#if defined(PER_FRAGMENT_TANGENTS)\r\n    s = ApplyNormalMapTerrain(w, s, f, G);\r\n#else\r\n    s = ApplyNormalMapTerrain(w, s);\r\n#endif\r\n\r\n#endif\r\n\r\n#else\r\n    getTexel(T, S.textureMeta1, uAtlasMeta, q, l, 0., uTextureAtlas, C);\r\n    getTexel(h, m.textureMeta1, uAtlasMeta, n, c, 0., uTextureAtlas, V);\r\n    getTexel(o, e.textureMeta1, uAtlasMeta, x, M, 0., uTextureAtlas, Y);\r\n#endif\r\n    C *= H;\r\n    V *= N;\r\n    Y *= U;\r\n#if defined(VIEWPORTMAP)\r\n    float y = step(.001, S.viewportMapUVScaleAndAnim.s), b = step(.001, m.viewportMapUVScaleAndAnim.s), B = step(.001, e.viewportMapUVScaleAndAnim.s);\r\n    C.stp = mix(C.stp, SampleViewportMapColour(gl_FragCoord.st, S.viewportMapUVScaleAndAnim), y);\r\n    V.stp = mix(V.stp, SampleViewportMapColour(gl_FragCoord.st, m.viewportMapUVScaleAndAnim), b);\r\n    Y.stp = mix(Y.stp, SampleViewportMapColour(gl_FragCoord.st, e.viewportMapUVScaleAndAnim), B);\r\n    g = mix(g, 1., y * vTextureWeight.s + b * vTextureWeight.t + B * vTextureWeight.p);\r\n#endif\r\n\r\n#if defined(TEXTURE_FORCED_FLAG)\r\n    C = mix(H, sqrt(C), A.s);\r\n    V = mix(N, sqrt(V), A.t);\r\n    Y = mix(U, sqrt(Y), A.p);\r\n#endif\r\n    t = C * vTextureWeight.s + V * vTextureWeight.t + Y * vTextureWeight.p;\r\n    t.q = 1.;\r\n    vec3 X = step(vec3(.5), fract(r.q * vec3(.25, .125, .0625))), k = vec3(C.q, V.q, Y.q) * vTextureWeight.stp, Z = k * X;\r\n    d.s = Z.s + Z.t + Z.p;\r\n    d.t = max(S.specular, max(m.specular, e.specular));\r\n#if defined(DEBUG_MATERIAL_HIGHLIGHT)\r\n    p = (S.materialID == uDebugMaterialHighlight ? 1 : 0) * vTextureWeight.s + (m.materialID == uDebugMaterialHighlight ? 1 : 0) * vTextureWeight.t + (e.materialID == uDebugMaterialHighlight ? 1 : 0) * vTextureWeight.p;\r\n#else\r\n    p = 0.;\r\n#endif\r\n}\r\n#endif\r\n#if __VERSION__ <= 120\r\n#define in varying\r\n#define out varying\r\n#endif\r\n\r\n#endif\r\nconst highp float CAUSTICS_FIXED_POINT_SCALE = 10000.;\r\n#if defined(CAUSTICS) && !defined(CAUSTICS_COMPUTE) && !defined(CAUSTICS_STENCIL)\r\nfloat CalculateCausticsTerm(highp vec3 u, float t, vec3 e)\r\n{\r\n    float i = 0., s = 0.;\r\n    if (u.t <= uCausticsPlaneHeight)\r\n        s = step(1., t);\r\n    else\r\n    {\r\n#if defined(CAUSTICS_OVERWATER)\r\n        s = clamp(e.t * -1., 0., 1.);\r\n        float d = smoothstep(uCausticsOverWaterFade.s, uCausticsOverWaterFade.t, u.t - uCausticsPlaneHeight);\r\n        s *= 1. - d;\r\n#else\r\n        return 0.0;\r\n#endif\r\n    }\r\n    if (s > 0.)\r\n    {\r\n        highp vec4 C = uCausticsViewProjMatrix * vec4(u, 1.);\r\n        C.st /= 2. * C.q;\r\n        vec2 f = abs(C.st);\r\n        C.st += .5;\r\n        f = smoothstep(.4, .5, f);\r\n        s *= max(0., 1. - (f.s + f.t));\r\n        if (s > 0.)\r\n            i += textureOffset(uCausticsMap, C.st, ivec2(-1, -1)).s, i += textureOffset(uCausticsMap, C.st, ivec2(-1, 0)).s, i += textureOffset(uCausticsMap, C.st, ivec2(-1, 1)).s, i += textureOffset(uCausticsMap, C.st, ivec2(0, -1)).s, i += texture2D(uCausticsMap, C.st).s * 5., i += textureOffset(uCausticsMap, C.st, ivec2(0, 1)).s, i += textureOffset(uCausticsMap, C.st, ivec2(1, -1)).s, i += textureOffset(uCausticsMap, C.st, ivec2(1, 0)).s, i += textureOffset(uCausticsMap, C.st, ivec2(1, 1)).s, i *= s / 12.;\r\n    }\r\n    return i;\r\n}\r\n#endif\r\n#if defined(CAUSTICS_COMPUTE)\r\nvoid WriteCausticsRay(vec3 t, float i)\r\n{\r\n    vec2 s = t.sp * i * uCausticsRefractionScale, C = (gl_FragCoord.st + s * 2.) / uCausticsComputeResolution * uCausticsMapSize;\r\n    highp float u = min(uCausticsFade.s / i * uCausticsFade.t, 7. * uCausticsFade.t), f = smoothstep(uCausticsFade.p, uCausticsFade.q, i), E = f * u * CAUSTICS_FIXED_POINT_SCALE;\r\n    if (E >= 1.f)\r\n        imageAtomicAdd(uCausticsIntegerMap, ivec2(C.st), uint(E));\r\n}\r\n#endif\r\n\r\n#ifndef LIGHTING_UTILS_H\r\n#define LIGHTING_UTILS_H\r\n#ifndef LIGHTING_INC\r\n#define LIGHTING_INC\r\n#if __VERSION__ <= 120\r\n#ifdef in\r\n#undef in\r\n#endif\r\n#ifdef out\r\n#undef out\r\n#endif\r\n#endif\r\n\r\n#ifndef FRESNEL_INC\r\n#define FRESNEL_INC\r\nvec3 FresnelSchlick(vec3 F, float f, highp float h)\r\n{\r\n    vec3 c = F + (1. - F) * pow(1. - f, h);\r\n    return c;\r\n}\r\nvec3 FresnelSchlickRoughness(vec3 f, float F, highp float h, float v)\r\n{\r\n    vec3 c = f + (max(vec3(v), f) - f) * pow(1. - F, h);\r\n    return c;\r\n}\r\nfloat FresnelSchlick(float F, float f, highp float h)\r\n{\r\n    float c = F + (1. - F) * pow(1. - f, h);\r\n    return c;\r\n}\r\nfloat FresnelSchlickRoughness(float f, float F, highp float h, float v)\r\n{\r\n    float c = f + (max(v, f) - f) * pow(1. - F, h);\r\n    return c;\r\n}\r\nfloat FresnelSchlick(vec3 F, vec3 f, float c)\r\n{\r\n    float h = max(0., dot(F, f));\r\n    return c + (1. - c) * pow(1. - h, 5.);\r\n}\r\nfloat Fresnel(vec3 F, vec3 f, float c, float h)\r\n{\r\n    float p = 1. - max(0., dot(F, f)), v = p * p;\r\n    v = v * v;\r\n    v = v * p;\r\n    return clamp(v * (1. - clamp(h, 0., 1.)) + h - c, 0., 1.);\r\n}\r\n#endif\r\n\r\n#ifndef BRDF_INC\r\n#define BRDF_INC\r\n#ifndef NDF_INC\r\n#define NDF_INC\r\n#ifndef MATH_UTILS_INC\r\n#define MATH_UTILS_INC\r\nconst float PI = 3.14159, INV_PI = .31831, TWOPI = PI * 2., INV_TWOPI = 1. / TWOPI, PI_OVER_4 = PI / 4., PI_OVER_2 = PI / 2., SQRT_2_PI = .797885, INV_EIGHT = .125;\r\nfloat SpecPowToBeckmannRoughness(float f) { return sqrt(2. / (f + 2.)); }\r\nfloat PerceptualRoughnessToRoughness(float f) { return f * f; }\r\nfloat RoughnessToPerceptualRoughness(float f) { return sqrt(f); }\r\n#endif\r\n\r\nfloat BlinnPhongNDF(float f, float N)\r\n{\r\n    return (f + 2.) * INV_EIGHT * pow(N, f);\r\n}\r\nfloat GGXTrowbridgeReitzNDF(float N, float f)\r\n{\r\n    float P = N * N, I = f * f, T = I * (P - 1.) + 1.;\r\n    return P / (PI * (T * T + .0001));\r\n}\r\nfloat BeckmannNDF(float N, float f)\r\n{\r\n    float P = N * N, I = f * f;\r\n    return exp((I - 1.) / (P * I)) / (PI * P * (I * I));\r\n}\r\n#endif\r\n\r\n#ifndef VISIBILITY_FUNC_INC\r\n#define VISIBILITY_FUNC_INC\r\n#ifndef MATH_UTILS_INC\r\n#define MATH_UTILS_INC\r\nconst float PI = 3.14159, INV_PI = .31831, TWOPI = PI * 2., INV_TWOPI = 1. / TWOPI, PI_OVER_4 = PI / 4., PI_OVER_2 = PI / 2., SQRT_2_PI = .797885, INV_EIGHT = .125;\r\nfloat SpecPowToBeckmannRoughness(float f) { return sqrt(2. / (f + 2.)); }\r\nfloat PerceptualRoughnessToRoughness(float f) { return f * f; }\r\nfloat RoughnessToPerceptualRoughness(float f) { return sqrt(f); }\r\n#endif\r\n\r\nfloat SchlickSmithVis(float V, float f, float S)\r\n{\r\n    float P = 1. / sqrt(PI_OVER_4 * V + PI_OVER_2), d = 1. - P, v = (f * d + P) * (S * d + P);\r\n    return 1. / (v + .0001);\r\n}\r\nfloat KelemenSzirmayKalosVis(vec3 V, vec3 P)\r\n{\r\n    vec3 f = V + P;\r\n    return 4. / max(0., dot(f, f));\r\n}\r\n#endif\r\n\r\n#define GGX_NDF\r\n#define SCHLICK_SMITH_VIS\r\nvec3 CookTorranceBRDF(float d, float S, vec3 n, vec3 v, vec3 f, vec3 B, vec3 R, float F)\r\n{\r\n    float m = max(0., dot(v, f)), r = 1.;\r\n#if defined(BLINN_PHONG_NDF)\r\n    r = BlinnPhongNDF(d, m);\r\n#elif defined(GGX_NDF)\r\n    r = GGXTrowbridgeReitzNDF(PerceptualRoughnessToRoughness(S), m);\r\n#elif defined(BECKMANN_NDF)\r\n    r = max(0.f, BeckmannNDF(SpecPowToBeckmannRoughness(d), m));\r\n#else\r\n\r\n#error CookTorranceBRDF normal distribution function not specified\r\n\r\n#endif\r\n    float C = 1.;\r\n#if defined(SCHLICK_SMITH_VIS)\r\n    C = SchlickSmithVis(d, F, max(0., dot(v, B)));\r\n#elif defined(KELEMEN_SZIRMAY_KALOS_VIS)\r\n    C = KelemenSzirmayKalosVis(R, B);\r\n#endif\r\n    return n * (r * C);\r\n}\r\nfloat RunescapeLegacyBRDF(vec3 d, vec3 v, vec3 f, float B, float S)\r\n{\r\n    vec3 n = reflect(-d, f);\r\n    float C = pow(max(0., dot(n, v)), B);\r\n    return C * S;\r\n}\r\nfloat RunescapeRT5BRDF(vec3 d, vec3 v, float S) { return BlinnPhongNDF(S, max(0., dot(d, v))); }\r\nvec3 ShiftTangent(vec3 d, vec3 S, float B) { return normalize(d + B * S); }\r\nvec3 AnisotropicBRDF(vec3 v, vec3 d, vec3 S, vec3 f, vec3 B, float n, float m, float R, float C)\r\n{\r\n    const float F = 7.5, r = 1., e = .5, o = 1.;\r\n    float s = R - .5;\r\n    S = ShiftTangent(S, d, e + (C * 2. - 1.) * o + s);\r\n    float p = abs(dot(S, f)), a = 1. - p, t = 1. - abs(dot(S, B)), K = p * dot(d, B);\r\n    K += a * t;\r\n    K = pow(K, F) * n;\r\n    K = mix(K, K * C, o);\r\n    float G = pow(dot(d, v), m), P = mix(G, K, r);\r\n    return vec3(P, P, P);\r\n}\r\n#endif\r\n\r\nstruct LightingTerms\r\n{\r\n    vec3 Diffuse;\r\n    vec3 Specular;\r\n};\r\nvoid ClearLightingTerms(inout LightingTerms v) { v.Diffuse = vec3(0., 0., 0.), v.Specular = vec3(0., 0., 0.); }\r\nvoid AddLightingTerms(inout LightingTerms v, LightingTerms L) { v.Diffuse += L.Diffuse, v.Specular += L.Specular; }\r\nvoid EvaluateDirLightRT5(inout LightingTerms v, vec3 f, vec3 L, vec3 d, vec3 i, float S, float c, float F, float e, float E, vec3 A)\r\n{\r\n    v.Diffuse += A * e;\r\n#if defined(SPECULAR_LIGHTING)\r\n    vec3 G = normalize(d + i);\r\n    float r = FresnelSchlick(S, clamp(dot(i, G), 0., 1.), F);\r\n#if defined(ANISOTROPY_BRDF)\r\n    vec3 D = AnisotropicBRDF(G, f, L, i, d, E, c, .5, .5);\r\n#else\r\n    vec3 n = vec3(r) * vec3(RunescapeRT5BRDF(G, f, c));\r\n#endif\r\n    n *= A * e;\r\n    v.Specular += n;\r\n#endif\r\n}\r\nvoid EvaluateDirLightRT7(inout LightingTerms v, vec3 f, vec3 L, vec3 d, vec3 i, vec3 S, float c, float E, float G, float e, float F, vec3 A)\r\n{\r\n    v.Diffuse += A * e;\r\n#if defined(SPECULAR_LIGHTING)\r\n    vec3 r = normalize(d + i), n = FresnelSchlick(S, clamp(dot(i, r), 0., 1.), G);\r\n#if defined(ANISOTROPY_BRDF)\r\n    vec3 D = AnisotropicBRDF(r, f, L, i, d, F, c, .5, .5);\r\n#else\r\n    vec3 C = CookTorranceBRDF(c, E, n, f, r, d, i, F);\r\n#endif\r\n    C *= A * e;\r\n    v.Specular += C;\r\n#endif\r\n}\r\nfloat SpecularHorizonOcclusion(float L, vec3 i, vec3 v)\r\n{\r\n    vec3 d = reflect(i, v);\r\n    float A = clamp(1. + L * dot(d, v), 0., 1.);\r\n    A *= A;\r\n    return A;\r\n}\r\n#if __VERSION__ <= 120\r\n#define in varying\r\n#define out varying\r\n#endif\r\n\r\n#endif\r\n\r\n#if !defined(DEFERRED_SHADOWS)\r\nLightingTerms EvaluateSunlightRT5(inout int i, inout float E, highp vec4 v, vec3 u, vec3 f, float d, vec3 n, float p, float S, float r)\r\n{\r\n    float t = max(0., dot(u, uInvSunDirection)), L = t;\r\n    E = 1.;\r\n#if defined(SUNLIGHT_SHADOWS)\r\n    if (S == 0. && uMappingParams.p != 0.)\r\n    {\r\n        if (L > 0.)\r\n        {\r\n            highp vec4 h = uSunlightViewMatrix * v, e = vec4(u.st, 0., 0.) * 32.;\r\n            E = DirLightShadowAtten(i, v + e, h + e, d, uSunlightShadowMap, uSunlightShadowTranslucencyMap, r);\r\n        }\r\n    }\r\n#endif\r\n    L *= E;\r\n    float h = .65;\r\n    LightingTerms D;\r\n    ClearLightingTerms(D);\r\n    EvaluateDirLightRT5(D, u, f, n, uInvSunDirection, h, p, 5., L, t, uSunColour);\r\n    return D;\r\n}\r\n#else\r\nLightingTerms EvaluateSunlightRT5(inout float E, vec3 u, vec3 v, vec3 f, vec2 d, float n, float S)\r\n{\r\n    float t = max(0., dot(u, uInvSunDirection)), L = t;\r\n    E = 1.;\r\n#if defined(SUNLIGHT_SHADOWS) && defined(DEFERRED_SHADOWS)\r\n    if (S == 0. && uMappingParams.p != 0.)\r\n        E = texture2DLod(uShadowBuffer, d, 0.).s;\r\n#endif\r\n    L *= E;\r\n    float h = .65;\r\n    LightingTerms D;\r\n    ClearLightingTerms(D);\r\n    EvaluateDirLightRT5(D, u, v, f, uInvSunDirection, h, n, 5., L, uSunColour);\r\n    return D;\r\n}\r\n#endif\r\n#if !defined(DEFERRED_SHADOWS)\r\nLightingTerms EvaluateSunlightRT7(inout int u, inout float E, highp vec4 v, vec3 f, vec3 d, float n, vec3 h, vec3 L, float p, float i, float t, float S)\r\n{\r\n    float D = max(0., dot(f, uInvSunDirection)), e = D;\r\n    E = 1.;\r\n#if defined(SUNLIGHT_SHADOWS)\r\n    if (uMappingParams.p != 0.)\r\n    {\r\n        if (D > 0.)\r\n        {\r\n            highp vec4 r = uSunlightViewMatrix * v, a = vec4(f.st, 0., 0.) * 32.;\r\n            E = DirLightShadowAtten(u, v + a, r + a, n, uSunlightShadowMap, uSunlightShadowTranslucencyMap, S);\r\n        }\r\n    }\r\n#endif\r\n    e *= E;\r\n    LightingTerms r;\r\n    ClearLightingTerms(r);\r\n    EvaluateDirLightRT7(r, f, d, h, uInvSunDirection, L, p, i, t, e, D, uSunColour);\r\n    return r;\r\n}\r\n#else\r\nLightingTerms EvaluateSunlightRT7(inout float E, vec3 u, vec3 v, vec3 f, vec2 d, vec3 n, float h, float L, float r)\r\n{\r\n    float t = max(0., dot(u, uInvSunDirection)), p = t;\r\n    E = 1.;\r\n#if defined(SUNLIGHT_SHADOWS) && defined(DEFERRED_SHADOWS)\r\n    if (uMappingParams.p != 0.)\r\n        E = texture2DLod(uShadowBuffer, d, 0.).s;\r\n#endif\r\n    LightingTerms D;\r\n    ClearLightingTerms(D);\r\n    EvaluateDirLightRT7(D, u, v, f, uInvSunDirection, n, h, L, r, t, p, uSunColour);\r\n    return D;\r\n}\r\n#endif\r\n#endif\r\n\r\n#ifndef STIPPLE_TRANSPARENCY_UTILS_INC\r\n#define STIPPLE_TRANSPARENCY_UTILS_INC\r\n#if defined(STIPPLE_TRANSPARENCY_CLIP_NEAR) || defined(STIPPLE_TRANSPARENCY_CLIP_FAR) || defined(STIPPLE_TRANSPARENCY_ALPHA)\r\n#ifndef STIPPLE_COMMON_INC\r\n#define STIPPLE_COMMON_INC\r\nhighp float GetStippleViewSpaceDepthFromPos(vec3 S)\r\n{\r\n    vec3 u = vec3(uViewMatrix[0][2], uViewMatrix[1][2], uViewMatrix[2][2]);\r\n    return dot(S, u);\r\n}\r\n#endif\r\n\r\n#ifndef NOISE_UTILS_INC\r\n#define NOISE_UTILS_INC\r\nvec4 permute(vec4 t)\r\n{\r\n    return mod((t * 34. + 1.) * t, 289.);\r\n}\r\nvec2 fade(vec2 t) { return t * t * t * (t * (t * 6. - 15.) + 10.); }\r\nfloat cnoise(highp vec2 t)\r\n{\r\n    highp vec4 v = floor(t.stst) + vec4(0., 0., 1., 1.), d = fract(t.stst) - vec4(0., 0., 1., 1.);\r\n    v = mod(v, 289.);\r\n    vec4 p = v.spsp, s = v.ttqq, h = d.spsp, e = d.ttqq, f = permute(permute(p) + s), m = 2. * fract(f * .0243902) - 1., c = abs(m) - .5, q = floor(m + .5);\r\n    m = m - q;\r\n    vec2 N = vec2(m.s, c.s), r = vec2(m.t, c.t), o = vec2(m.p, c.p), a = vec2(m.q, c.q);\r\n    vec4 G = 1.79284 - .853735 * vec4(dot(N, N), dot(o, o), dot(r, r), dot(a, a));\r\n    N *= G.s;\r\n    o *= G.t;\r\n    r *= G.p;\r\n    a *= G.q;\r\n    float i = dot(N, vec2(h.s, e.s)), n = dot(r, vec2(h.t, e.t)), l = dot(o, vec2(h.p, e.p)), I = dot(a, vec2(h.q, e.q));\r\n    vec2 u = fade(d.st), S = mix(vec2(i, l), vec2(n, I), u.s);\r\n    float g = mix(S.s, S.t, u.t);\r\n    return 2.3 * g;\r\n}\r\nhighp float GetInterleavedGradientNoise(highp vec2 t) { return clamp(fract(52.9829 * fract(.0671106 * t.s + .00583715 * t.t)), 0., .999); }\r\n#endif\r\n\r\n#define STIPPLE_TRANSPARENCY_ENABLED\r\n#if defined(STIPPLE_TRANSPARENCY_CLIP_NEAR) || defined(STIPPLE_TRANSPARENCY_CLIP_FAR)\r\nuniform vec4 uStippleTransparencyClipParams;\r\n#endif\r\n#if __VERSION__ <= 120\r\n#ifdef in\r\n#undef in\r\n#endif\r\n#ifdef out\r\n#undef out\r\n#endif\r\n#endif\r\n\r\nfloat GetStippleTransparencyAlpha(float S, inout float R)\r\n{\r\n    float f = 1.;\r\n#if defined(STIPPLE_TRANSPARENCY_CLIP_NEAR)\r\n    float d = (S - (uZBufferParams.q + uStippleTransparencyClipParams.s)) * uStippleTransparencyClipParams.t;\r\n    f *= clamp(d, 0., 1.);\r\n#endif\r\n\r\n#if defined(STIPPLE_TRANSPARENCY_CLIP_FAR)\r\n    float u = 1. - (S - (abs(uZBufferParams.p) - uStippleTransparencyClipParams.p)) * uStippleTransparencyClipParams.q;\r\n    f *= clamp(u, 0., 1.);\r\n#endif\r\n\r\n#if defined(STIPPLE_TRANSPARENCY_ALPHA)\r\n    f *= clamp(R + .005, 0., 1.);\r\n    R = 1.;\r\n#endif\r\n    return f;\r\n}\r\nbool IsStipplePixelVisible(highp vec3 S, highp vec2 R, inout float d)\r\n{\r\n    float u = GetStippleViewSpaceDepthFromPos(S);\r\n    return GetStippleTransparencyAlpha(u, d) > GetInterleavedGradientNoise(R);\r\n}\r\n#if __VERSION__ <= 120\r\n#define in varying\r\n#define out varying\r\n#endif\r\n\r\n#endif\r\n#endif\r\n\r\nvoid main()\r\n{\r\n    highp vec3 d = vWorldPos_ViewSpaceDepth.stp;\r\n#if defined(CLIP_PLANE)\r\n    if (dot(vec4(d, 1.), uClipPlane) < 0.)\r\n    {\r\n        discard;\r\n        return;\r\n    }\r\n#if defined(CLIP_PLANE_CLAMP)\r\n    gl_FragDepth = 0.;\r\n    return;\r\n#endif\r\n\r\n#endif\r\n    vec3 v = normalize(vWorldNormal.stp);\r\n    highp vec3 S = d - uCameraPosition;\r\n    float D = step(.5, fract(vMaterialProperties.q * .5)), p;\r\n    vec4 u = vec4(0., 0., 0., 1.);\r\n    vec2 r = vec2(0.);\r\n#if defined(TEXTURE_ATLAS)\r\n    SampleTerrainTextures(u, r, p, v, d, S, vVertexAlbedo, vMaterialProperties, D);\r\n#else\r\n\r\n#if defined(DEBUG_TEXEL_DENSITY)\r\n    gl_FragColor = vec4(1.);\r\n#endif\r\n    u = vVertexAlbedo;\r\n#endif\r\n\r\n#if defined(DEBUG_TERRAIN_SPECULAR_MAX)\r\n    if (uDebugTerrainSpecular.s >= 0.)\r\n        r.t = max(r.t, uDebugTerrainSpecular.s);\r\n    if (uDebugTerrainSpecular.t >= 0.)\r\n        r.t = uDebugTerrainSpecular.t;\r\n#endif\r\n\r\n#if defined(DEBUG_TEXEL_DENSITY) || defined(DEBUG_TANGENTS) || defined(DEBUG_BITANGENTS)\r\n    if (uDebugReturn != 0.)\r\n    {\r\n        return;\r\n    }\r\n#endif\r\n\r\n#if defined(STIPPLE_TRANSPARENCY_ENABLED)\r\n    if (!IsStipplePixelVisible(S, gl_FragCoord.st, u.q))\r\n    {\r\n        discard;\r\n    }\r\n#endif\r\n    float n = 1.;\r\n#if defined(TEXTURE_ATLAS)\r\n    n += r.s * 4.;\r\n#endif\r\n\r\n#if defined(VIEWPORTLOOKUPSCALE)\r\n    vec2 G = gl_FragCoord.st * uFullScreenLookupScale.st;\r\n#endif\r\n    float g = 1.;\r\n#if defined(SSAO)\r\n    g = texture2D(uSSAOMap, G).s;\r\n#endif\r\n    vec3 m;\r\n#if defined(IRRADIANCE_LIGHTING)\r\n\r\n#if defined(NORMAL_MAP)\r\n    m = uAmbientColour * EvaluateSHLighting2ndOrder(v, uIrradianceSHCoefs);\r\n#else\r\n    m = vAmbientColour;\r\n#endif\r\n\r\n#else\r\n    m = uAmbientColour;\r\n#endif\r\n\r\n#if defined(SSAO)\r\n    m *= g;\r\n#endif\r\n    highp float t = length(S);\r\n    highp vec3 T = S / t;\r\n    LightingTerms s;\r\n    ClearLightingTerms(s);\r\n#if defined(SUNLIGHT_DIRECT_LIGHTING)\r\n    int A = -1;\r\n    float C = 0.;\r\n#if defined(DEFERRED_SHADOWS)\r\n    s = EvaluateSunlightRT5(C, v, v, -T, G, r.t, D);\r\n#else\r\n    s = EvaluateSunlightRT5(A, C, vec4(d, 1.), v, v, vWorldPos_ViewSpaceDepth.q, -T, r.t, D, 1.);\r\n#endif\r\n\r\n#else\r\n    s.Diffuse = vec3(1.);\r\n#endif\r\n\r\n#if defined(TEXTURE_ATLAS) && defined(DEBUG_MATERIAL_HIGHLIGHT)\r\n    if (uDebugMaterialHighlight != -1.)\r\n    {\r\n        float e = mix(.1, 1., length(s.Diffuse)), P = .1;\r\n        vec3 q = mix(vec3(P) * e, vec3(0, 1, 0), p);\r\n        gl_FragColor = vec4(q, 1);\r\n        if (uDebugReturn != 0.)\r\n        {\r\n            return;\r\n        }\r\n    }\r\n#endif\r\n    vec4 i = vec4(0., 0., 0., u.q);\r\n#if defined(POINT_LIGHTING)\r\n    vec3 e = vec3(0., 0., 0.), q = vec3(0., 0., 0.);\r\n    const vec3 f = vec3(.65, .65, .65);\r\n    const float P = 1., l = 5.;\r\n    EvaluatePointLights(e, q, f, r.t, P, l, -T, d, v, vWorldPos_ViewSpaceDepth.q, vec3(0.));\r\n#if defined(DEBUG_POINTLIGHTS)\r\n    gl_FragColor = vec4(e, i.q);\r\n    if (uDebugReturn != 0.)\r\n    {\r\n        return;\r\n    }\r\n#endif\r\n\r\n#if defined(DEBUG_POINTLIGHTS_SPECULAR)\r\n    gl_FragColor = vec4(q, i.q);\r\n    if (uDebugReturn != 0.)\r\n    {\r\n        return;\r\n    }\r\n#endif\r\n\r\n#if defined(DIFFUSE_LIGHTING)\r\n    s.Diffuse += e;\r\n#else\r\n    s.Diffuse = e;\r\n#endif\r\n\r\n#if defined(POINT_LIGHTING_SPECULAR)\r\n    s.Specular += q;\r\n#endif\r\n\r\n#else\r\n\r\n#if defined(DEBUG_POINTLIGHTS)\r\n    gl_FragColor = vec4(0., 0., 0., 1.);\r\n    if (uDebugReturn != 0.)\r\n    {\r\n        return;\r\n    }\r\n#endif\r\n\r\n#if defined(DEBUG_POINTLIGHTS_SPECULAR)\r\n    gl_FragColor = vec4(0., 0., 0., 1.);\r\n    if (uDebugReturn != 0.)\r\n    {\r\n        return;\r\n    }\r\n#endif\r\n\r\n#if !defined(DIFFUSE_LIGHTING)\r\n    s.Diffuse = vec3(0.);\r\n#endif\r\n\r\n#endif\r\n    float h = 0.;\r\n#if defined(CAUSTICS)\r\n    h = CalculateCausticsTerm(d, C, v);\r\n#endif\r\n\r\n#if defined(AMBIENT_LIGHTING)\r\n    i.stp += m;\r\n#endif\r\n    i.stp += s.Diffuse;\r\n#if defined(SPECULAR_LIGHTING)\r\n    i.stp += s.Specular * n;\r\n#endif\r\n\r\n#if defined(CAUSTICS)\r\n    i.stp += uSunColour * h;\r\n#endif\r\n\r\n#if defined(ALBEDO_LIGHTING)\r\n    i.stp *= u.stp;\r\n#endif\r\n\r\n#if defined(TEXTURE_ATLAS) && defined(SUNLIGHT_SHADOWS)\r\n\r\n#if defined(DEBUG_EMISSIVE_MAP)\r\n    i.stp = vec3(D);\r\n#endif\r\n\r\n#elif defined(DEBUG_EMISSIVE_MAP)\r\n    i.stp = vec3(0.);\r\n#endif\r\n\r\n#if defined(TEXTURE_ATLAS) && !defined(DEBUG_EMISSIVE_MAP)\r\n    i.stp = mix(i.stp, u.stp, D);\r\n#endif\r\n\r\n#if defined(FOG_DISTANCE) || (defined(SUNLIGHT_DIRECT_LIGHTING) && defined(LIGHT_SCATTERING))\r\n\r\n#if defined(OGLES2_BACKEND)\r\n    vec3 c, E;\r\n#if defined(LIGHT_SCATTERING)\r\n    ComputeInOutScattering(T, t, uInvSunDirection, c, E);\r\n#else\r\n    c = vec3(1.);\r\n    E = vec3(0.);\r\n#endif\r\n\r\n#if defined(FOG_DISTANCE)\r\n    float R = FogBasedOnDistance(t) * FogBasedOnAngle(T);\r\n    E = mix(E, uFogColour.stp, R);\r\n    c *= 1. - R;\r\n#endif\r\n    i.stp = mix(ApplyInOutScattering(i.stp, c, E), i.stp, D);\r\n#else\r\n    i.stp = mix(ApplyInOutScattering(i.stp, vOutScattering, vInScattering), i.stp, D);\r\n#endif\r\n\r\n#endif\r\n\r\n#if defined(DEBUG_ALBEDO)\r\n    i = u;\r\n#endif\r\n\r\n#if defined(DEBUG_NORMALS)\r\n    i.stp = v * .5 + .5;\r\n    i.q = 1.;\r\n#endif\r\n\r\n#if defined(DEBUG_SPECULAR_MAP)\r\n\r\n#if defined(TEXTURE_ATLAS)\r\n    i.stp = vec3(max(0., (n - .5) / 4.));\r\n#else\r\n    i.stp = vec3(0.);\r\n#endif\r\n\r\n#endif\r\n\r\n#if defined(SUNLIGHT_SHADOWS) && defined(DEBUG_SUNLIGHT_SHADOW_CASCADE) && !defined(DEFERRED_SHADOWS)\r\n    i.stp *= ShadowMapCascadeColour(A, int(uMappingParams.q)).stp;\r\n#endif\r\n\r\n#if defined(DEBUG_RT7_EMISSIVE) || defined(DEBUG_RT7_METALNESS) || defined(DEBUG_RT7_ROUGHNESS)\r\n    i = vec4(1., 0., 1., 1.);\r\n#endif\r\n    gl_FragColor = i;\r\n}\r\n";
  }
});

// rsmv/src/rs3shaders/minimap-water-vert.glsl.c
var require_minimap_water_vert_glsl = __commonJS({
  "rsmv/src/rs3shaders/minimap-water-vert.glsl.c"(exports, module) {
    module.exports = "\r\n#version 460\r\n\r\n/***************************************************/\r\n/***************** GLSL Header *********************/\r\n/***************************************************/\r\n#ifdef GL_EXT_gpu_shader4\r\n#extension GL_EXT_gpu_shader4 : enable\r\n#endif\r\n#ifdef GL_ARB_gpu_shader5\r\n#extension GL_ARB_gpu_shader5 : enable\r\n#endif\r\n#ifdef GL_ARB_derivative_control\r\n#extension GL_ARB_derivative_control : enable\r\n#endif\r\n\r\n#ifdef GL_ARB_texture_gather\r\n#extension GL_ARB_texture_gather : enable\r\n#endif\r\n\r\n#define OGL_BACKEND\r\n\r\n#undef attribute\r\n#define attribute in\r\n\r\n#undef gl_FragColor\r\n#define gl_FragColor FragColor\r\n\r\n#define shadow2DCompat texture\r\n\r\n#undef textureCube\r\n#define textureCube texture\r\n\r\n#undef texture2D\r\n#define texture2D texture\r\n\r\n#undef texture3D\r\n#define texture3D texture\r\n\r\n#undef texture2DLod\r\n#define texture2DLod textureLod\r\n\r\n#undef textureCubeLod\r\n#define textureCubeLod textureLod\r\n\r\n#undef texture2DGrad\r\n#define texture2DGrad textureGrad\r\n\r\n#define MSAA_AVAILABLE\r\n\r\n#define TEXTURE_OFFSET_AVAILABLE\r\n#if !defined(lowp)\r\n#define lowp\r\n#endif\r\n#if !defined(mediump)\r\n#define mediump\r\n#endif\r\n#if !defined(highp)\r\n#define highp\r\n#endif\r\n\r\n#define GRAPHICS_QUALITY_LOW 0\r\n#define GRAPHICS_QUALITY_MEDIUM 1\r\n#define GRAPHICS_QUALITY_HIGH 2\r\n#define GRAPHICS_QUALITY_ULTRA 3\r\n\r\n#define shadow2DLodCompat texture2DLod\r\n\r\n#define texture2DLodCompat texture2DLod\r\n\r\n#define textureCubeLodCompat textureCubeLod\r\n\r\n#define textureGatherCompat(sampler, texCoord, viewportScale) textureGather(sampler, texCoord).wzxy\r\n\r\n#define UNIFORM_BUFFER_BEGIN(name) \\\r\n    layout(std140) uniform name    \\\r\n    {\r\n#define UNIFORM_BUFFER_END \\\r\n    }                      \\\r\n    ;\r\n\r\nmat3 Mat4ToMat3(const mat4 inputMatrix)\r\n{\r\n    return mat3(inputMatrix);\r\n}\r\n\r\n#define isNaN isnan\r\n\r\n#ifndef GL_ARB_derivative_control\r\n#define dFdxFine dFdx\r\n#define dFdyFine dFdy\r\n#define fwidthFine fwidth\r\n#endif\r\n\r\n/***************************************************/\r\n\r\n/***************************************************/\r\n/***************** Effect Defines ******************/\r\n/***************************************************/\r\n#define VIEW_TRANSFORMS\r\n#define WATER_COMMON\r\n\r\n/*************************************************/\r\n\r\n/***************************************************/\r\n/********** Mandatory Shader Fragments *************/\r\n/***************************************************/\r\n\r\n#define GRAPHICS_QUALITY_LOW 0\r\n#define GRAPHICS_QUALITY_MEDIUM 1\r\n#define GRAPHICS_QUALITY_HIGH 2\r\n#define GRAPHICS_QUALITY_ULTRA 3\r\n\r\n#define MATERIAL_SETTINGS_SLOT_PIXEL_RESOLUTION_X 3.0\r\n#define MATERIAL_SETTINGS_SLOT_PIXEL_RESOLUTION_Y 4.0\r\n#define MATERIAL_SETTINGS_SLOTS_DIMENSION_COUNT_X 42.0\r\n#define MATERIAL_SETTINGS_SLOTS_DIMENSION_COUNT_Y 32.0\r\n#define MATERIAL_SETTINGS_TEXTURE_RESOLUTION 128.0\r\n#ifndef MATH_UTILS_INC\r\n#define MATH_UTILS_INC\r\nconst float PI = 3.14159, INV_PI = .31831, TWOPI = PI * 2., INV_TWOPI = 1. / TWOPI, PI_OVER_4 = PI / 4., PI_OVER_2 = PI / 2., SQRT_2_PI = .797885, INV_EIGHT = .125;\r\nfloat SpecPowToBeckmannRoughness(float f) { return sqrt(2. / (f + 2.)); }\r\nfloat PerceptualRoughnessToRoughness(float f) { return f * f; }\r\nfloat RoughnessToPerceptualRoughness(float f) { return sqrt(f); }\r\n#endif\r\n#ifndef CONVERSION_UTILS_INC\r\n#define CONVERSION_UTILS_INC\r\nvec3 SRGBToLinear(vec3 srgbColour)\r\n{\r\n#if defined(GAMMA_CORRECT_INPUTS)\r\n    return srgbColour * srgbColour;\r\n#else\r\n    return pow(srgbColour, vec3(2.2, 2.2, 2.2));\r\n#endif\r\n}\r\nvec3 LinearToSRGB(vec3 s) { return max(vec3(1.055) * pow(s, vec3(.416667)) - vec3(.055), vec3(0.)); }\r\nfloat LinearToSRGB(float s)\r\n{\r\n    const float p = 1. / 2.2;\r\n    return pow(s, p);\r\n}\r\nvec3 LinearToSRGBRunescape(vec3 s) { return sqrt(s); }\r\nfloat LinearToSRGBRunescape(float s) { return sqrt(s); }\r\nvec4 convertRGBtoHSL(vec4 s)\r\n{\r\n    const float p = 1. / 6.;\r\n    float v = s.s, m = s.t, t = s.p, f = min(min(s.s, s.t), s.p), q = max(max(s.s, s.t), s.p), r = q - f, G = (f + q) * .5, i = 0., e = 0.;\r\n    if (G > 0. && G < 1.)\r\n    {\r\n        float L = G < .5 ? G : 1. - G;\r\n        i = r / (L * 2.);\r\n    }\r\n    if (r > 0.)\r\n    {\r\n        vec3 L = vec3(q == v && q != m ? 1. : 0., q == m && q != t ? 1. : 0., q == t && q != v ? 1. : 0.), o = vec3((m - t) / r, 2. + (t - v) / r, 4. + (v - m) / r);\r\n        e += dot(o, L);\r\n        e *= p;\r\n        if (e < 0.)\r\n            e += 1.;\r\n    }\r\n    return vec4(e, i, G, s.q);\r\n}\r\nvec4 convertHSLtoRGB(vec4 s)\r\n{\r\n    const float v = 1. / 3., q = 2. / 3., m = 6.;\r\n    float p = s.s, t = s.t, r = s.p;\r\n    vec3 f = vec3(m * (p - q), 0., m * (1. - p));\r\n    if (p < q)\r\n        f.s = 0., f.t = m * (q - p), f.p = m * (p - v);\r\n    if (p < v)\r\n        f.s = m * (v - p), f.t = m * p, f.p = 0.;\r\n    f = min(f, 1.);\r\n    float L = 2. * t, i = 1. - t, G = 1. - r, e = 2. * r - 1.;\r\n    vec3 c = L * f + i, o;\r\n    if (r >= .5)\r\n        o = G * c + e;\r\n    else\r\n        o = r * c;\r\n    return vec4(o, s.q);\r\n}\r\n#endif\r\n#ifndef PACK_UTILS_INC\r\n#define PACK_UTILS_INC\r\n#ifndef SHADER_LIB_COMMON_INC\r\n#define SHADER_LIB_COMMON_INC\r\n#define USE_MOD_PACK\r\n#endif\r\n\r\nvec4 PackFloatToRGBA(highp float valueToPack)\r\n{\r\n#if defined(USE_MOD_PACK) || defined(USE_FRACT_PACK)\r\n    const highp vec4 bitShift = vec4(256 * 256 * 256, 256 * 256, 256, 1.0);\r\n    const highp vec4 bitMask = vec4(0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\r\n    highp vec4 fragColour = mod(valueToPack * bitShift * vec4(255), vec4(256)) / vec4(255);\r\n    return fragColour - fragColour.xxyz * bitMask;\r\n#endif\r\n#ifdef USE_ARAS_PACK\r\n    const highp vec4 bitShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\r\n    const highp vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\r\n    highp vec4 fragColour = fract(valueToPack * bitShift);\r\n    return fragColour - (fragColour.xxyz * bitMask);\r\n#endif\r\n}\r\nvec2 NormalPackSphereMap(vec3 v)\r\n{\r\n    vec2 f = normalize(v.st) * sqrt(-v.p * .5 + .5);\r\n    f = f * .5 + .5;\r\n    return f * 65535.;\r\n}\r\nvec2 PackFloatToVec2(float v)\r\n{\r\n    vec2 f;\r\n    const float b = 1. / 255.;\r\n    vec2 h = vec2(1., 255.), r = fract(h * v);\r\n    r.s -= r.t * b;\r\n    return r.st;\r\n}\r\n#endif\r\n#ifndef UNPACK_UTILS_INC\r\n#define UNPACK_UTILS_INC\r\n#ifndef SHADER_LIB_COMMON_INC\r\n#define SHADER_LIB_COMMON_INC\r\n#define USE_MOD_PACK\r\n#endif\r\n\r\nhighp float UnpackRGBAToFloat(highp vec4 valueToUnpack)\r\n{\r\n#if defined(USE_MOD_PACK) || defined(USE_FRACT_PACK)\r\n    const highp vec4 bitShifts = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\r\n    return dot(valueToUnpack, bitShifts);\r\n#endif\r\n#ifdef USE_ARAS_PACK\r\n    const highp vec4 bitShifts = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);\r\n    return dot(valueToUnpack, bitShifts);\r\n#endif\r\n}\r\nvec3 ColourUnpack(highp float v)\r\n{\r\n    vec3 f;\r\n    f.s = floor(v / 256. / 256.);\r\n    f.t = floor((v - f.s * 256. * 256.) / 256.);\r\n    f.p = floor(v - f.s * 256. * 256. - f.t * 256.);\r\n    return f / 256.;\r\n}\r\nvec3 NormalUnpackSphereMap(vec2 v)\r\n{\r\n    vec4 f = vec4(v.s / 32767. - 1., v.t / 32767. - 1., 1., -1.);\r\n    float U = dot(f.stp, -f.stq);\r\n    f.st *= sqrt(U);\r\n    f.p = U;\r\n    return f.stp * 2. + vec3(0., 0., -1.);\r\n}\r\nhighp float UnpackRGBAToIntegerFloat(highp vec4 f) { return floor(f.s * 255. + .5) * 256. * 256. * 256. + floor(f.t * 255. + .5) * 256. * 256. + floor(f.p * 255. + .5) * 256. + floor(f.q * 255. + .5); }\r\nhighp float UnpackRGBAToIntegerFloat16(highp vec2 f) { return floor(f.s * 255. + .5) * 256. + floor(f.t * 255. + .5); }\r\nhighp int UnpackRGBAToInt(vec4 f) { return int(UnpackRGBAToIntegerFloat(f)); }\r\nhighp vec4 UnpackFloatToRGBA(highp float f)\r\n{\r\n    const highp vec4 v = vec4(1., 255., 65025., 1.65814e+07), s = vec4(vec3(1. / 255.), 0.);\r\n    highp vec4 U = fract(f * v);\r\n    U -= U.sstp * s;\r\n    return U;\r\n}\r\nhighp float UnpackVec2ToFloat(highp vec2 f) { return floor(f.s * 255. + .5) * 256. + floor(f.t * 255. + .5); }\r\n#endif\r\n#if defined(MSAA) && defined(MSAA_AVAILABLE)\r\n#define SAMPLER_2D_AUTO_MULTISAMPLE sampler2DMS\r\n#define MSAA_SAMPLERS_ENABLED 1\r\n#define texture2DMultisample(sampler, texCoord, texSize) texelFetch(sampler, ivec2((texCoord)*texSize), 0)\r\n#else\r\n#define SAMPLER_2D_AUTO_MULTISAMPLE sampler2D\r\n#define MSAA_SAMPLERS_ENABLED 0\r\n#define texture2DMultisample(sampler, texCoord, texSize) texture2DLodCompat(sampler, texCoord, 0.0)\r\n#endif\r\nUNIFORM_BUFFER_BEGIN(ViewportLookupScale)\r\nuniform highp vec4 uViewportLookupScale;\r\nuniform highp vec4 uViewportOffsetScale;\r\nuniform highp vec4 uFullScreenLookupScale;\r\nUNIFORM_BUFFER_END\r\n\r\n/***************************************************/\r\n\r\nuniform lowp vec4 uWaterFeatureFlags;\r\nuniform highp vec4 uWaterNormalMapTextureScales_FlowNoiseScale;\r\nuniform highp vec2 uWaterTickFade;\r\nuniform mat4 uModelMatrix;\r\n\r\nUNIFORM_BUFFER_BEGIN(ViewTransforms)\r\nuniform highp vec3 uCameraPosition;\r\nuniform highp mat4 uViewMatrix;\r\nuniform highp mat4 uProjectionMatrix;\r\nuniform highp mat4 uViewProjMatrix;\r\nuniform highp vec4 uZBufferParams;\r\nUNIFORM_BUFFER_END\r\nout highp vec4 vPosition_WaterDepth;\r\nout vec4 vColour;\r\nout highp vec4 vFlowControlMask_ViewSpaceDepth;\r\nout highp vec4 vNoisyPatchFlow0_NoisyPatchFlow1;\r\nout highp vec4 vNoisyPatchFlow2_UVPack_NormalsFlow0Map0;\r\nout highp vec4 vUVPack_NormalsFlow0Map1_NormalsFlow0Map2;\r\nout highp vec4 vUVPack_NormalsFlow1Map0_NormalsFlow1Map1;\r\nout highp vec4 vUVPack_NormalsFlow1Map2_NormalsFlow2Map0;\r\nout highp vec4 vUVPack_NormalsFlow2Map1_NormalsFlow2Map2;\r\nout highp vec4 vUVPack_NormalMapMacroUV_EmissiveUV[3];\r\nout highp vec2 vUVPack_FoamUV;\r\nattribute vec4 aWaterPosition_Depth, aVertexColour;\r\nattribute vec2 aWaterFlowDataPatchFlow0, aWaterFlowDataPatchFlow1, aWaterFlowDataPatchFlow2;\r\nattribute vec4 aWaterFlowDataFlowNoise0_FlowNoise1, aWaterFlowDataFlowNoise2_FlowIndex_Spare;\r\n#ifndef DISTANCE_FOG_UNIFORMS\r\n#define DISTANCE_FOG_UNIFORMS\r\n#if defined(FOG_DISTANCE)\r\nUNIFORM_BUFFER_BEGIN(DistanceFog)\r\nuniform mediump vec4 uFogColour;\r\nuniform highp vec4 uFogParams;\r\nUNIFORM_BUFFER_END\r\n#endif\r\n#endif\r\n\r\n#ifndef DISTANCE_FOG_FUNCTIONS\r\n#define DISTANCE_FOG_FUNCTIONS\r\n#if defined(FOG_DISTANCE)\r\nfloat FogBasedOnDistance(highp float f)\r\n{\r\n    highp float F = (uFogParams.t - f) * uFogParams.s;\r\n    return 1. - clamp(F, 0., 1.);\r\n}\r\nfloat FogBasedOnAngle(highp vec3 f)\r\n{\r\n    highp float F = 1. - clamp(f.t + uFogParams.q, 0., 1.);\r\n    F = pow(F, uFogParams.p);\r\n    return clamp(F, 0., 1.);\r\n}\r\n#endif\r\n#endif\r\n\r\n#ifndef VOLUMETRIC_FUNCTIONS_INC\r\n#define VOLUMETRIC_FUNCTIONS_INC\r\n#if defined(SUNLIGHT_SHADOWS) && defined(VOLUMETRIC_SCATTERING) && defined(SUNLIGHT_DIRECT_LIGHTING)\r\n#define VOLUMETRIC_SCATTERING_SUPPORTED\r\nuniform vec4 uMieG, uVolumetricScatteringParameters;\r\n#if defined(VOLUMETRIC_GROUND_FOG)\r\nuniform vec4 uGroundFogHeight_Falloff;\r\n#endif\r\n#if defined(VOLUMETRIC_SCATTERING_NOISE)\r\nuniform sampler3D sNoiseTex;\r\nuniform vec4 u3DNoiseFrequency_Strength, u3DNoiseWind_Power;\r\n#endif\r\nuniform float uTime;\r\nfloat ShadowSample(vec4 u, vec4 v, float s)\r\n{\r\n    int d = int(uMappingParams.q);\r\n    vec4 f;\r\n    int G;\r\n#if defined(CASCADE_SPLIT_SELECTION)\r\n    G = ShadowMapSelectCascadeBySplit(s, uCascadeFrustumViewDepths, uCascadeSplitSelectionFlags);\r\n#if defined(USE_LIGHT_VIEW_PROJ_TEX_MATRIX)\r\n    f = uSunlightViewProjTexMatrix[G] * u;\r\n#else\r\n    f = v * uSunlightProjTexMatScale[G] + uSunlightProjTexMatOffset[G];\r\n#endif\r\n\r\n#else\r\n\r\n#if defined(USE_LIGHT_VIEW_PROJ_TEX_MATRIX)\r\n    G = ShadowMapSelectCascadeByMap(f, u, uSunlightViewProjTexMatrix, uCascadeMinAtlasExtents);\r\n#else\r\n    G = ShadowMapSelectCascadeByMap(f, v, uSunlightProjTexMatScale, uSunlightProjTexMatOffset, uCascadeMinAtlasExtents);\r\n#endif\r\n\r\n#endif\r\n    return G >= d ? 1. : ShadowDepthMapFilter1x1(uSunlightShadowMap, f);\r\n}\r\nfloat PhaseFunction(float v, vec4 s) { return s.q * (s.s / pow(s.t - s.p * v, 1.5)); }\r\nvec4 GetScatteredInRay(int s, vec3 u, float v, float d, vec4 f)\r\n{\r\n    float G = uSunlightFadeAttenParams.t * 1.4, m = min(G, v);\r\n    vec3 V = uCameraPosition, t = V + u * m;\r\n    vec4 x = uSunlightViewMatrix * vec4(V, 1.), e = uSunlightViewMatrix * vec4(t, 1.), i = uSunlightViewMatrix * vec4(V, 0.), n = uSunlightViewMatrix * vec4(t, 0.);\r\n    vec3 E = vec3(uViewMatrix[0][2], uViewMatrix[1][2], uViewMatrix[2][2]);\r\n    int S = int(uMappingParams.q);\r\n    float q = 0., p = 1. / float(s), N = d * p, h = m * p;\r\n    vec2 r = vec2(0., 0.);\r\n#if defined(VOLUMETRIC_SCATTERING_NOISE)\r\n    vec3 P = vec3(.05 * uTime), a = u3DNoiseWind_Power.stp * uTime;\r\n    const float o = .31;\r\n    float c = u3DNoiseFrequency_Strength.s * o;\r\n    vec3 l = a * u3DNoiseFrequency_Strength.s, T = a * c;\r\n#endif\r\n    for (int X = 0; X < s; ++X)\r\n    {\r\n        vec3 U = mix(V, t, N);\r\n        vec4 I = mix(x, e, N);\r\n#if defined(VOLUMETRIC_SCATTERING_NOISE)\r\n        vec4 M = mix(i, n, N);\r\n        vec3 C = M.sts * vec3(.001) + P, g = M.sts * vec3(.001) - P;\r\n        I.sp += vec2(texture3D(sNoiseTex, g).s, texture3D(sNoiseTex, g).s) * 128. - 64.;\r\n#endif\r\n        float R = 0.;\r\n#if defined(USE_CASCADE_SPLIT_SELECTION)\r\n        vec3 O = U.stp - uCameraPosition;\r\n        R = abs(dot(O, E));\r\n#endif\r\n        float F = ShadowSample(vec4(U, 1.f), I, R), D = 1., w = 1.;\r\n#if defined(VOLUMETRIC_GROUND_FOG)\r\n        if (uGroundFogHeight_Falloff.t != 0.)\r\n        {\r\n            float L = max(0., (U.t - uGroundFogHeight_Falloff.s) * uGroundFogHeight_Falloff.t);\r\n            w = exp(-L) * 100.;\r\n        }\r\n#endif\r\n\r\n#if defined(VOLUMETRIC_SCATTERING_NOISE)\r\n        if (u3DNoiseFrequency_Strength.t != 0.)\r\n        {\r\n            vec3 L = U * u3DNoiseFrequency_Strength.s + l;\r\n            float y = float(texture3D(sNoiseTex, L));\r\n            vec3 A = U * c + T;\r\n            float H = float(texture3D(sNoiseTex, A)), W = pow(mix(y, H, .8) + .5, u3DNoiseWind_Power.q);\r\n            w *= max(0, mix(1., W, u3DNoiseFrequency_Strength.t));\r\n        }\r\n#endif\r\n        D += w;\r\n        float L = D * h, W = uVolumetricScatteringParameters.s * L;\r\n        q += uVolumetricScatteringParameters.t * L;\r\n        r += W * exp(-q) * vec2(F, 1. - F);\r\n        N += p;\r\n    }\r\n    if (v > G)\r\n    {\r\n        float L = v - G, U = uVolumetricScatteringParameters.s * L;\r\n        q += uVolumetricScatteringParameters.t * L;\r\n        r += vec2(U * exp(-q), 0.);\r\n    }\r\n    float U = r.s + r.t;\r\n    if (U > 0.)\r\n    {\r\n        float L = r.s / U, g = uVolumetricScatteringParameters.q;\r\n        L = pow(L, g);\r\n        r.st = U * vec2(L, 1. - L);\r\n        r.s = r.s * PhaseFunction(dot(u, uInvSunDirection), f);\r\n    }\r\n    return vec4(r.s, q, r.t, 1.);\r\n}\r\nvec4 GetScatteredInRay2(int s, vec3 u, float v, float f) { return GetScatteredInRay(s, u, v, f, uMieG); }\r\nvec4 GetScatteredInRayLine(int s, vec3 u, float v, vec3 f, float d, float G)\r\n{\r\n    vec4 L = GetScatteredInRay2(s, u, v, G), t = GetScatteredInRay2(s, mix(u, f, .33), mix(v, d, .33), G), m = GetScatteredInRay2(s, mix(u, f, .66), mix(v, d, .66), G), U = GetScatteredInRay2(s, f, d, G);\r\n    return L * .15 + t * .2 + m * .3 + U * .35;\r\n}\r\n#endif\r\n#endif\r\n\r\n#ifndef APPLY_VOLUMETRICS_INC\r\n#define APPLY_VOLUMETRICS_INC\r\n#ifndef VOLUMETRIC_FUNCTIONS_INC\r\n#define VOLUMETRIC_FUNCTIONS_INC\r\n#if defined(SUNLIGHT_SHADOWS) && defined(VOLUMETRIC_SCATTERING) && defined(SUNLIGHT_DIRECT_LIGHTING)\r\n#define VOLUMETRIC_SCATTERING_SUPPORTED\r\nuniform vec4 uMieG, uVolumetricScatteringParameters;\r\n#if defined(VOLUMETRIC_GROUND_FOG)\r\nuniform vec4 uGroundFogHeight_Falloff;\r\n#endif\r\n#if defined(VOLUMETRIC_SCATTERING_NOISE)\r\nuniform sampler3D sNoiseTex;\r\nuniform vec4 u3DNoiseFrequency_Strength, u3DNoiseWind_Power;\r\n#endif\r\nuniform float uTime;\r\nfloat ShadowSample(vec4 u, vec4 v, float s)\r\n{\r\n    int d = int(uMappingParams.q);\r\n    vec4 f;\r\n    int G;\r\n#if defined(CASCADE_SPLIT_SELECTION)\r\n    G = ShadowMapSelectCascadeBySplit(s, uCascadeFrustumViewDepths, uCascadeSplitSelectionFlags);\r\n#if defined(USE_LIGHT_VIEW_PROJ_TEX_MATRIX)\r\n    f = uSunlightViewProjTexMatrix[G] * u;\r\n#else\r\n    f = v * uSunlightProjTexMatScale[G] + uSunlightProjTexMatOffset[G];\r\n#endif\r\n\r\n#else\r\n\r\n#if defined(USE_LIGHT_VIEW_PROJ_TEX_MATRIX)\r\n    G = ShadowMapSelectCascadeByMap(f, u, uSunlightViewProjTexMatrix, uCascadeMinAtlasExtents);\r\n#else\r\n    G = ShadowMapSelectCascadeByMap(f, v, uSunlightProjTexMatScale, uSunlightProjTexMatOffset, uCascadeMinAtlasExtents);\r\n#endif\r\n\r\n#endif\r\n    return G >= d ? 1. : ShadowDepthMapFilter1x1(uSunlightShadowMap, f);\r\n}\r\nfloat PhaseFunction(float v, vec4 s) { return s.q * (s.s / pow(s.t - s.p * v, 1.5)); }\r\nvec4 GetScatteredInRay(int s, vec3 u, float v, float d, vec4 f)\r\n{\r\n    float G = uSunlightFadeAttenParams.t * 1.4, m = min(G, v);\r\n    vec3 V = uCameraPosition, t = V + u * m;\r\n    vec4 x = uSunlightViewMatrix * vec4(V, 1.), e = uSunlightViewMatrix * vec4(t, 1.), i = uSunlightViewMatrix * vec4(V, 0.), n = uSunlightViewMatrix * vec4(t, 0.);\r\n    vec3 E = vec3(uViewMatrix[0][2], uViewMatrix[1][2], uViewMatrix[2][2]);\r\n    int S = int(uMappingParams.q);\r\n    float q = 0., p = 1. / float(s), N = d * p, h = m * p;\r\n    vec2 r = vec2(0., 0.);\r\n#if defined(VOLUMETRIC_SCATTERING_NOISE)\r\n    vec3 P = vec3(.05 * uTime), a = u3DNoiseWind_Power.stp * uTime;\r\n    const float o = .31;\r\n    float c = u3DNoiseFrequency_Strength.s * o;\r\n    vec3 l = a * u3DNoiseFrequency_Strength.s, T = a * c;\r\n#endif\r\n    for (int X = 0; X < s; ++X)\r\n    {\r\n        vec3 U = mix(V, t, N);\r\n        vec4 I = mix(x, e, N);\r\n#if defined(VOLUMETRIC_SCATTERING_NOISE)\r\n        vec4 M = mix(i, n, N);\r\n        vec3 C = M.sts * vec3(.001) + P, g = M.sts * vec3(.001) - P;\r\n        I.sp += vec2(texture3D(sNoiseTex, g).s, texture3D(sNoiseTex, g).s) * 128. - 64.;\r\n#endif\r\n        float R = 0.;\r\n#if defined(USE_CASCADE_SPLIT_SELECTION)\r\n        vec3 O = U.stp - uCameraPosition;\r\n        R = abs(dot(O, E));\r\n#endif\r\n        float F = ShadowSample(vec4(U, 1.f), I, R), D = 1., w = 1.;\r\n#if defined(VOLUMETRIC_GROUND_FOG)\r\n        if (uGroundFogHeight_Falloff.t != 0.)\r\n        {\r\n            float L = max(0., (U.t - uGroundFogHeight_Falloff.s) * uGroundFogHeight_Falloff.t);\r\n            w = exp(-L) * 100.;\r\n        }\r\n#endif\r\n\r\n#if defined(VOLUMETRIC_SCATTERING_NOISE)\r\n        if (u3DNoiseFrequency_Strength.t != 0.)\r\n        {\r\n            vec3 L = U * u3DNoiseFrequency_Strength.s + l;\r\n            float y = float(texture3D(sNoiseTex, L));\r\n            vec3 A = U * c + T;\r\n            float H = float(texture3D(sNoiseTex, A)), W = pow(mix(y, H, .8) + .5, u3DNoiseWind_Power.q);\r\n            w *= max(0, mix(1., W, u3DNoiseFrequency_Strength.t));\r\n        }\r\n#endif\r\n        D += w;\r\n        float L = D * h, W = uVolumetricScatteringParameters.s * L;\r\n        q += uVolumetricScatteringParameters.t * L;\r\n        r += W * exp(-q) * vec2(F, 1. - F);\r\n        N += p;\r\n    }\r\n    if (v > G)\r\n    {\r\n        float L = v - G, U = uVolumetricScatteringParameters.s * L;\r\n        q += uVolumetricScatteringParameters.t * L;\r\n        r += vec2(U * exp(-q), 0.);\r\n    }\r\n    float U = r.s + r.t;\r\n    if (U > 0.)\r\n    {\r\n        float L = r.s / U, g = uVolumetricScatteringParameters.q;\r\n        L = pow(L, g);\r\n        r.st = U * vec2(L, 1. - L);\r\n        r.s = r.s * PhaseFunction(dot(u, uInvSunDirection), f);\r\n    }\r\n    return vec4(r.s, q, r.t, 1.);\r\n}\r\nvec4 GetScatteredInRay2(int s, vec3 u, float v, float f) { return GetScatteredInRay(s, u, v, f, uMieG); }\r\nvec4 GetScatteredInRayLine(int s, vec3 u, float v, vec3 f, float d, float G)\r\n{\r\n    vec4 L = GetScatteredInRay2(s, u, v, G), t = GetScatteredInRay2(s, mix(u, f, .33), mix(v, d, .33), G), m = GetScatteredInRay2(s, mix(u, f, .66), mix(v, d, .66), G), U = GetScatteredInRay2(s, f, d, G);\r\n    return L * .15 + t * .2 + m * .3 + U * .35;\r\n}\r\n#endif\r\n#endif\r\n\r\n#if defined(VOLUMETRIC_SCATTERING) && defined(SUNLIGHT_DIRECT_LIGHTING)\r\nuniform vec3 uVolumetricLitFogColour, uVolumetricUnlitFogColour;\r\nuniform mat4 uVolumetricDitherMat;\r\n#if __VERSION__ <= 120\r\n#ifdef in\r\n#undef in\r\n#endif\r\n#ifdef out\r\n#undef out\r\n#endif\r\n#endif\r\n\r\nvoid GetInAndOutScattering(vec4 v, out vec3 u, out vec3 G)\r\n{\r\n    vec3 A = uSunColour * uVolumetricLitFogColour, o = uAmbientColour * uVolumetricUnlitFogColour;\r\n    u = vec3(exp(-v.t));\r\n    G = v.s * A + v.p * o;\r\n}\r\n#if __VERSION__ <= 120\r\n#define in varying\r\n#define out varying\r\n#endif\r\n\r\nvec4 ApplyVolumetricScattering(vec4 v, vec4 u)\r\n{\r\n    vec3 A = vec3(1.), o = vec3(0.);\r\n    GetInAndOutScattering(u, A, o);\r\n    return vec4(v.stp * A + o, v.q);\r\n}\r\nfloat CalculateScatteringOffset(vec2 v)\r\n{\r\n    vec2 u = vec2(floor(mod(v.st, 4.)));\r\n    return uVolumetricDitherMat[int(u.s)][int(u.t)];\r\n}\r\n#endif\r\n#endif\r\n\r\n#if __VERSION__ <= 120\r\n#ifdef in\r\n#undef in\r\n#endif\r\n#ifdef out\r\n#undef out\r\n#endif\r\n#endif\r\n\r\nvec2 GetFlowOrientedUV(vec2 v, vec2 u, float d, float E)\r\n{\r\n    float T = dot(u, u);\r\n    const float q = 1e-06;\r\n    vec2 e = T < q ? vec2(0., 1.) : normalize(u), t = vec2(e.t, -e.s);\r\n    highp float f = length(u * d * E);\r\n    return vec2(dot(t, v), dot(e, v) + f);\r\n}\r\nvec2 GetFlowOrientedUV(vec4 e, vec2 v, float d, vec2 u, float f)\r\n{\r\n    vec2 q = vec2(e.sp);\r\n    float t = sign(u.t);\r\n    return GetFlowOrientedUV(q, v * t, d, f) * u;\r\n}\r\n#if defined(WATER_NORMAL_MAPS)\r\nvec2 TransformNormalMapTexCoordFlowAligned(in NormalMapTexCoordParams v, vec2 u, vec2 d, vec2 f)\r\n{\r\n    const float q = .5;\r\n    highp float E = uWaterTickFade.s * q;\r\n    float t = v.flowSpeed_spareyzw.s;\r\n    vec2 T = GetFlowOrientedUV(u, v.flowRotation * d, t, E), a = (v.uvRotation * T + f * t * E) * v.uvScale_uvOffset.st + v.uvScale_uvOffset.pq;\r\n    return a;\r\n}\r\nvec2 TransformNormalMapTexCoordAxisAligned(in NormalMapTexCoordParams v, vec2 u, vec2 d, vec2 f)\r\n{\r\n    const float q = .5;\r\n    highp float t = uWaterTickFade.s * q;\r\n    vec2 p = (d + f) * v.flowSpeed_spareyzw.s, E = v.flowRotation * p * t, a = v.uvRotation * (u + E) * v.uvScale_uvOffset.st + v.uvScale_uvOffset.pq;\r\n    return a;\r\n}\r\n#if !defined(GLES2_COMPAT_MODE)\r\nvoid ComputeNormalMapDetailTexCoords(vec2 v, vec2 d, vec2 f, vec2 u, vec2 t, vec2 a, vec2 p, vec2 s, vec2 E)\r\n{\r\n    vec2 q = vec2(1.), S = vec2(-1.), g = vec2(1., -1.), T = TransformNormalMapTexCoordFlowAligned(uWaterNormalMapTexCoordParams[0], v, u, p * q), e = TransformNormalMapTexCoordFlowAligned(uWaterNormalMapTexCoordParams[1], d, u, p * S), G = TransformNormalMapTexCoordFlowAligned(uWaterNormalMapTexCoordParams[2], f, u, p * g), C = TransformNormalMapTexCoordFlowAligned(uWaterNormalMapTexCoordParams[0], v, t, s * q), P = TransformNormalMapTexCoordFlowAligned(uWaterNormalMapTexCoordParams[1], d, t, s * S), W = TransformNormalMapTexCoordFlowAligned(uWaterNormalMapTexCoordParams[2], f, t, s * g), D = TransformNormalMapTexCoordFlowAligned(uWaterNormalMapTexCoordParams[0], v, a, E * q), o = TransformNormalMapTexCoordFlowAligned(uWaterNormalMapTexCoordParams[1], d, a, E * S), r = TransformNormalMapTexCoordFlowAligned(uWaterNormalMapTexCoordParams[2], f, a, E * g);\r\n    vNoisyPatchFlow2_UVPack_NormalsFlow0Map0.pq = T;\r\n    vUVPack_NormalsFlow0Map1_NormalsFlow0Map2 = vec4(e, G);\r\n    vUVPack_NormalsFlow1Map0_NormalsFlow1Map1 = vec4(C, P);\r\n    vUVPack_NormalsFlow1Map2_NormalsFlow2Map0 = vec4(W, D);\r\n    vUVPack_NormalsFlow2Map1_NormalsFlow2Map2 = vec4(o, r);\r\n}\r\nvoid ComputeNormalMapMacroTexCoords(vec2 v, vec2 d, vec2 f)\r\n{\r\n    const float q = .25;\r\n    const vec2 t = vec2(.1, -.13) * q;\r\n    const float u = .1;\r\n    vUVPack_NormalMapMacroUV_EmissiveUV[0].st = TransformNormalMapTexCoordAxisAligned(uWaterNormalMapMacroTexCoordParams[0], v * u, t, vec2(0.));\r\n    vUVPack_NormalMapMacroUV_EmissiveUV[1].st = TransformNormalMapTexCoordAxisAligned(uWaterNormalMapMacroTexCoordParams[1], d * u, t, vec2(0.));\r\n    vUVPack_NormalMapMacroUV_EmissiveUV[2].st = TransformNormalMapTexCoordAxisAligned(uWaterNormalMapMacroTexCoordParams[2], f * u, t, vec2(0.));\r\n}\r\n#else\r\nvoid ComputeNormalMapDetailTexCoords(vec2 v, vec2 d, vec2 f, vec2 t, vec2 u, vec2 E, vec2 a)\r\n{\r\n    vec2 q = TransformNormalMapTexCoordFlowAligned(uWaterNormalMapTexCoordParams[0], v, d, u), e = TransformNormalMapTexCoordFlowAligned(uWaterNormalMapTexCoordParams[0], v, f, E), S = TransformNormalMapTexCoordFlowAligned(uWaterNormalMapTexCoordParams[0], v, t, a);\r\n    vNoisyPatchFlow2_UVPack_NormalsFlow0Map0.pq = q;\r\n    vUVPack_NormalsFlow1Map0_NormalsFlow2Map0 = vec4(e, S);\r\n}\r\n#endif\r\n#endif\r\n#if defined(WATER_EMISSIVE) && !defined(GLES2_COMPAT_MODE)\r\n#define EMISSIVE_UV_MODE_AXIS_ALIGNED (0)\r\n#define EMISSIVE_UV_MODE_FLOW_ALIGNED (1)\r\nvoid GetEmissiveFlow(out vec2 v, out vec2 d, out vec2 t, vec2 u, vec2 f, vec2 q, float E)\r\n{\r\n    float a = cos(E), S = sin(E);\r\n    mat2 T = mat2(vec2(a, -S), vec2(S, a));\r\n    vec2 G = T * u, e = T * f, p = T * q;\r\n    const float g = 1e-06;\r\n    vec3 C = vec3(G, dot(G, G)), s = vec3(e, dot(e, e)), r = vec3(p, dot(p, p));\r\n    if (C.p < g)\r\n        C = s.p > r.p ? s : r;\r\n    if (s.p < g)\r\n        s = r.p > C.p ? r : C;\r\n    if (r.p < g)\r\n        r = C.p > s.p ? C : s;\r\n    v = C.st;\r\n    d = s.st;\r\n    t = r.st;\r\n}\r\nvoid ComputeEmissiveTexCoords(vec4 v, vec2 d, vec2 f, vec2 E)\r\n{\r\n    float t = uEmissiveFlowSpeed_EmissiveFlowRotation_EmissiveUVScale.s, q = uEmissiveFlowSpeed_EmissiveFlowRotation_EmissiveUVScale.t, u = uEmissiveMapScale_EmissiveUVMode.s;\r\n    vec2 a = uEmissiveFlowSpeed_EmissiveFlowRotation_EmissiveUVScale.pq, p = vec2(0., 0.), s = vec2(0., 0.), e = vec2(0., 0.);\r\n    GetEmissiveFlow(p, s, e, d, f, E, q);\r\n    const float T = .5;\r\n    highp float S = uWaterTickFade.s * T;\r\n    vec2 G = v.sp * u;\r\n    if (int(uEmissiveMapScale_EmissiveUVMode.t) == EMISSIVE_UV_MODE_FLOW_ALIGNED)\r\n        vUVPack_NormalMapMacroUV_EmissiveUV[0].pq = GetFlowOrientedUV(G, p, t, S) * a, vUVPack_NormalMapMacroUV_EmissiveUV[1].pq = GetFlowOrientedUV(G, s, t, S) * a, vUVPack_NormalMapMacroUV_EmissiveUV[2].pq = GetFlowOrientedUV(G, e, t, S) * a;\r\n    else\r\n    {\r\n        vec2 g = sign(a);\r\n        vUVPack_NormalMapMacroUV_EmissiveUV[0].pq = G * a + p * g * t * S;\r\n        vUVPack_NormalMapMacroUV_EmissiveUV[1].pq = G * a + s * g * t * S;\r\n        vUVPack_NormalMapMacroUV_EmissiveUV[2].pq = G * a + e * g * t * S;\r\n    }\r\n}\r\n#endif\r\nvoid main()\r\n{\r\n    vec3 u = aWaterPosition_Depth.stp;\r\n    vec4 v = uModelMatrix * vec4(u, 1.);\r\n    vPosition_WaterDepth.stp = v.stp;\r\n    vPosition_WaterDepth.q = aWaterPosition_Depth.q;\r\n#if defined(CLIP_PLANE_CLAMP) && defined(CLIP_PLANE)\r\n    v.t = -uClipPlane.q;\r\n#endif\r\n    gl_Position = uViewProjMatrix * v;\r\n#if defined(CLIP_PLANE_CLAMP) && defined(CLIP_PLANE)\r\n    return;\r\n#endif\r\n\r\n#if defined(CAUSTICS_COMPUTE) || defined(CAUSTICS_STENCIL)\r\n    const float E = 256.;\r\n    if (abs(vPosition_WaterDepth.t - uCausticsPlaneHeight) > E)\r\n    {\r\n        gl_Position.q = -1.;\r\n        return;\r\n    }\r\n#endif\r\n    vColour = aVertexColour;\r\n#if defined(LIGHT_SCATTERING) || defined(FOG_DISTANCE) || defined(SUNLIGHT_SHADOWS) || defined(VOLUMETRIC_SCATTERING_SUPPORTED)\r\n    vec3 t = v.stp - uCameraPosition;\r\n    float d = length(t);\r\n#endif\r\n\r\n#if defined(SUNLIGHT_SHADOWS)\r\n    vec3 f = vec3(uViewMatrix[0][2], uViewMatrix[1][2], uViewMatrix[2][2]);\r\n    vFlowControlMask_ViewSpaceDepth.q = abs(dot(t.stp, f));\r\n#endif\r\n\r\n#if defined(LIGHT_SCATTERING) || defined(FOG_DISTANCE)\r\n    t /= d;\r\n#if defined(LIGHT_SCATTERING) && defined(SUNLIGHT_DIRECT_LIGHTING)\r\n    ComputeInOutScattering(t, d, uInvSunDirection, vOutScattering, vInScattering);\r\n#else\r\n    vOutScattering = vec3(1.);\r\n    vInScattering = vec3(0.);\r\n#endif\r\n\r\n#if defined(FOG_DISTANCE)\r\n    float q = FogBasedOnDistance(d);\r\n    q = q + q * uWaterTickFade.t - uWaterTickFade.t;\r\n    vInScattering = mix(vInScattering, uFogColour.stp, q);\r\n    vOutScattering *= 1. - q;\r\n    vColour.q = q;\r\n#else\r\n    vColour.q = 0.;\r\n#endif\r\n\r\n#endif\r\n\r\n#if defined(VOLUMETRIC_SCATTERING_SUPPORTED)\r\n    vec4 a = GetScatteredInRay2(8, t, d, 100.);\r\n    vec3 T = vec3(1.), S = vec3(0.);\r\n    GetInAndOutScattering(a, T, S);\r\n    vInScattering += S;\r\n    vOutScattering *= T;\r\n#endif\r\n    float g = uWaterNormalMapTextureScales_FlowNoiseScale.q;\r\n    vec2 p = aWaterFlowDataFlowNoise0_FlowNoise1.st / 127. * g, e = aWaterFlowDataFlowNoise0_FlowNoise1.pq / 127. * g, s = aWaterFlowDataFlowNoise2_FlowIndex_Spare.st / 127. * g, G = -aWaterFlowDataPatchFlow0 * (1. / 4095.), r = -aWaterFlowDataPatchFlow1 * (1. / 4095.), C = -aWaterFlowDataPatchFlow2 * (1. / 4095.);\r\n    int W = int(aWaterFlowDataFlowNoise2_FlowIndex_Spare.p);\r\n    vFlowControlMask_ViewSpaceDepth.stp = vec3(W == 0 ? 1. : 0., W == 1 ? 1. : 0., W == 2 ? 1. : 0.);\r\n    vNoisyPatchFlow0_NoisyPatchFlow1.st = G + p;\r\n    vNoisyPatchFlow0_NoisyPatchFlow1.pq = r + e;\r\n    vNoisyPatchFlow2_UVPack_NormalsFlow0Map0.st = C + s;\r\n#if defined(WATER_NORMAL_MAPS) || defined(WATER_FOAM_MAP)\r\n\r\n#if !defined(GLES2_COMPAT_MODE)\r\n    vUVPack_FoamUV = v.sp * uWaterNormalMapTextureScales_FlowNoiseScale.s;\r\n#endif\r\n    vec2 o = v.sp * uWaterNormalMapTextureScales_FlowNoiseScale.s, P = v.sp * uWaterNormalMapTextureScales_FlowNoiseScale.t, D = v.sp * uWaterNormalMapTextureScales_FlowNoiseScale.p;\r\n#if defined(WATER_NORMAL_MAPS)\r\n\r\n#if !defined(GLES2_COMPAT_MODE)\r\n    ComputeNormalMapDetailTexCoords(o, P, D, G, r, C, p, e, s);\r\n    ComputeNormalMapMacroTexCoords(o, P, D);\r\n#else\r\n    ComputeNormalMapDetailTexCoords(o, G, r, C, p, e, s);\r\n#endif\r\n\r\n#endif\r\n\r\n#endif\r\n\r\n#if defined(WATER_EMISSIVE) && !defined(GLES2_COMPAT_MODE)\r\n    ComputeEmissiveTexCoords(v, G, r, C);\r\n#endif\r\n}\r\n";
  }
});

// rsmv/src/rs3shaders/minimap-water-frag.glsl.c
var require_minimap_water_frag_glsl = __commonJS({
  "rsmv/src/rs3shaders/minimap-water-frag.glsl.c"(exports, module) {
    module.exports = "\r\n#version 460\r\n\r\n/***************************************************/\r\n/***************** GLSL Header *********************/\r\n/***************************************************/\r\n#ifdef GL_EXT_gpu_shader4\r\n#extension GL_EXT_gpu_shader4 : enable\r\n#endif\r\n#ifdef GL_ARB_gpu_shader5\r\n#extension GL_ARB_gpu_shader5 : enable\r\n#endif\r\n#ifdef GL_ARB_derivative_control\r\n#extension GL_ARB_derivative_control : enable\r\n#endif\r\n\r\n#ifdef GL_ARB_texture_gather\r\n#extension GL_ARB_texture_gather : enable\r\n#endif\r\n\r\n#define OGL_BACKEND\r\n\r\n#undef attribute\r\n#define attribute in\r\n\r\n#undef gl_FragColor\r\n#define gl_FragColor FragColor\r\n\r\n#define shadow2DCompat texture\r\n\r\n#undef textureCube\r\n#define textureCube texture\r\n\r\n#undef texture2D\r\n#define texture2D texture\r\n\r\n#undef texture3D\r\n#define texture3D texture\r\n\r\n#undef texture2DLod\r\n#define texture2DLod textureLod\r\n\r\n#undef textureCubeLod\r\n#define textureCubeLod textureLod\r\n\r\n#undef texture2DGrad\r\n#define texture2DGrad textureGrad\r\n\r\n#define MSAA_AVAILABLE\r\n\r\n#define TEXTURE_OFFSET_AVAILABLE\r\n#if !defined(lowp)\r\n#define lowp\r\n#endif\r\n#if !defined(mediump)\r\n#define mediump\r\n#endif\r\n#if !defined(highp)\r\n#define highp\r\n#endif\r\n\r\n#define GRAPHICS_QUALITY_LOW 0\r\n#define GRAPHICS_QUALITY_MEDIUM 1\r\n#define GRAPHICS_QUALITY_HIGH 2\r\n#define GRAPHICS_QUALITY_ULTRA 3\r\n\r\n#define shadow2DLodCompat texture2DLod\r\n\r\n#define texture2DLodCompat texture2DLod\r\n\r\n#define textureCubeLodCompat textureCubeLod\r\n\r\n#define textureGatherCompat(sampler, texCoord, viewportScale) textureGather(sampler, texCoord).wzxy\r\n\r\n#define SHADER_TYPE_PIXEL\r\n\r\nout vec4 gl_FragColor;\r\n\r\n#define UNIFORM_BUFFER_BEGIN(name) \\\r\n    layout(std140) uniform name    \\\r\n    {\r\n#define UNIFORM_BUFFER_END \\\r\n    }                      \\\r\n    ;\r\n\r\nmat3 Mat4ToMat3(const mat4 inputMatrix)\r\n{\r\n    return mat3(inputMatrix);\r\n}\r\n\r\n#define isNaN isnan\r\n\r\n#ifndef GL_ARB_derivative_control\r\n#define dFdxFine dFdx\r\n#define dFdyFine dFdy\r\n#define fwidthFine fwidth\r\n#endif\r\n\r\n/***************************************************/\r\n\r\n/***************************************************/\r\n/***************** Effect Defines ******************/\r\n/***************************************************/\r\n#define VIEW_TRANSFORMS\r\n\r\n/*************************************************/\r\n\r\n/***************************************************/\r\n/********** Mandatory Shader Fragments *************/\r\n/***************************************************/\r\n\r\n#define GRAPHICS_QUALITY_LOW 0\r\n#define GRAPHICS_QUALITY_MEDIUM 1\r\n#define GRAPHICS_QUALITY_HIGH 2\r\n#define GRAPHICS_QUALITY_ULTRA 3\r\n\r\n#define MATERIAL_SETTINGS_SLOT_PIXEL_RESOLUTION_X 3.0\r\n#define MATERIAL_SETTINGS_SLOT_PIXEL_RESOLUTION_Y 4.0\r\n#define MATERIAL_SETTINGS_SLOTS_DIMENSION_COUNT_X 42.0\r\n#define MATERIAL_SETTINGS_SLOTS_DIMENSION_COUNT_Y 32.0\r\n#define MATERIAL_SETTINGS_TEXTURE_RESOLUTION 128.0\r\n#ifndef MATH_UTILS_INC\r\n#define MATH_UTILS_INC\r\nconst float PI = 3.14159, INV_PI = .31831, TWOPI = PI * 2., INV_TWOPI = 1. / TWOPI, PI_OVER_4 = PI / 4., PI_OVER_2 = PI / 2., SQRT_2_PI = .797885, INV_EIGHT = .125;\r\nfloat SpecPowToBeckmannRoughness(float f) { return sqrt(2. / (f + 2.)); }\r\nfloat PerceptualRoughnessToRoughness(float f) { return f * f; }\r\nfloat RoughnessToPerceptualRoughness(float f) { return sqrt(f); }\r\n#endif\r\n#ifndef CONVERSION_UTILS_INC\r\n#define CONVERSION_UTILS_INC\r\nvec3 SRGBToLinear(vec3 srgbColour)\r\n{\r\n#if defined(GAMMA_CORRECT_INPUTS)\r\n    return srgbColour * srgbColour;\r\n#else\r\n    return pow(srgbColour, vec3(2.2, 2.2, 2.2));\r\n#endif\r\n}\r\nvec3 LinearToSRGB(vec3 s) { return max(vec3(1.055) * pow(s, vec3(.416667)) - vec3(.055), vec3(0.)); }\r\nfloat LinearToSRGB(float s)\r\n{\r\n    const float p = 1. / 2.2;\r\n    return pow(s, p);\r\n}\r\nvec3 LinearToSRGBRunescape(vec3 s) { return sqrt(s); }\r\nfloat LinearToSRGBRunescape(float s) { return sqrt(s); }\r\nvec4 convertRGBtoHSL(vec4 s)\r\n{\r\n    const float p = 1. / 6.;\r\n    float v = s.s, m = s.t, t = s.p, f = min(min(s.s, s.t), s.p), q = max(max(s.s, s.t), s.p), r = q - f, G = (f + q) * .5, i = 0., e = 0.;\r\n    if (G > 0. && G < 1.)\r\n    {\r\n        float L = G < .5 ? G : 1. - G;\r\n        i = r / (L * 2.);\r\n    }\r\n    if (r > 0.)\r\n    {\r\n        vec3 L = vec3(q == v && q != m ? 1. : 0., q == m && q != t ? 1. : 0., q == t && q != v ? 1. : 0.), o = vec3((m - t) / r, 2. + (t - v) / r, 4. + (v - m) / r);\r\n        e += dot(o, L);\r\n        e *= p;\r\n        if (e < 0.)\r\n            e += 1.;\r\n    }\r\n    return vec4(e, i, G, s.q);\r\n}\r\nvec4 convertHSLtoRGB(vec4 s)\r\n{\r\n    const float v = 1. / 3., q = 2. / 3., m = 6.;\r\n    float p = s.s, t = s.t, r = s.p;\r\n    vec3 f = vec3(m * (p - q), 0., m * (1. - p));\r\n    if (p < q)\r\n        f.s = 0., f.t = m * (q - p), f.p = m * (p - v);\r\n    if (p < v)\r\n        f.s = m * (v - p), f.t = m * p, f.p = 0.;\r\n    f = min(f, 1.);\r\n    float L = 2. * t, i = 1. - t, G = 1. - r, e = 2. * r - 1.;\r\n    vec3 c = L * f + i, o;\r\n    if (r >= .5)\r\n        o = G * c + e;\r\n    else\r\n        o = r * c;\r\n    return vec4(o, s.q);\r\n}\r\n#endif\r\n#ifndef PACK_UTILS_INC\r\n#define PACK_UTILS_INC\r\n#ifndef SHADER_LIB_COMMON_INC\r\n#define SHADER_LIB_COMMON_INC\r\n#define USE_MOD_PACK\r\n#endif\r\n\r\nvec4 PackFloatToRGBA(highp float valueToPack)\r\n{\r\n#if defined(USE_MOD_PACK) || defined(USE_FRACT_PACK)\r\n    const highp vec4 bitShift = vec4(256 * 256 * 256, 256 * 256, 256, 1.0);\r\n    const highp vec4 bitMask = vec4(0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\r\n    highp vec4 fragColour = mod(valueToPack * bitShift * vec4(255), vec4(256)) / vec4(255);\r\n    return fragColour - fragColour.xxyz * bitMask;\r\n#endif\r\n#ifdef USE_ARAS_PACK\r\n    const highp vec4 bitShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\r\n    const highp vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\r\n    highp vec4 fragColour = fract(valueToPack * bitShift);\r\n    return fragColour - (fragColour.xxyz * bitMask);\r\n#endif\r\n}\r\nvec2 NormalPackSphereMap(vec3 v)\r\n{\r\n    vec2 f = normalize(v.st) * sqrt(-v.p * .5 + .5);\r\n    f = f * .5 + .5;\r\n    return f * 65535.;\r\n}\r\nvec2 PackFloatToVec2(float v)\r\n{\r\n    vec2 f;\r\n    const float b = 1. / 255.;\r\n    vec2 h = vec2(1., 255.), r = fract(h * v);\r\n    r.s -= r.t * b;\r\n    return r.st;\r\n}\r\n#endif\r\n#ifndef UNPACK_UTILS_INC\r\n#define UNPACK_UTILS_INC\r\n#ifndef SHADER_LIB_COMMON_INC\r\n#define SHADER_LIB_COMMON_INC\r\n#define USE_MOD_PACK\r\n#endif\r\n\r\nhighp float UnpackRGBAToFloat(highp vec4 valueToUnpack)\r\n{\r\n#if defined(USE_MOD_PACK) || defined(USE_FRACT_PACK)\r\n    const highp vec4 bitShifts = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\r\n    return dot(valueToUnpack, bitShifts);\r\n#endif\r\n#ifdef USE_ARAS_PACK\r\n    const highp vec4 bitShifts = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);\r\n    return dot(valueToUnpack, bitShifts);\r\n#endif\r\n}\r\nvec3 ColourUnpack(highp float v)\r\n{\r\n    vec3 f;\r\n    f.s = floor(v / 256. / 256.);\r\n    f.t = floor((v - f.s * 256. * 256.) / 256.);\r\n    f.p = floor(v - f.s * 256. * 256. - f.t * 256.);\r\n    return f / 256.;\r\n}\r\nvec3 NormalUnpackSphereMap(vec2 v)\r\n{\r\n    vec4 f = vec4(v.s / 32767. - 1., v.t / 32767. - 1., 1., -1.);\r\n    float U = dot(f.stp, -f.stq);\r\n    f.st *= sqrt(U);\r\n    f.p = U;\r\n    return f.stp * 2. + vec3(0., 0., -1.);\r\n}\r\nhighp float UnpackRGBAToIntegerFloat(highp vec4 f) { return floor(f.s * 255. + .5) * 256. * 256. * 256. + floor(f.t * 255. + .5) * 256. * 256. + floor(f.p * 255. + .5) * 256. + floor(f.q * 255. + .5); }\r\nhighp float UnpackRGBAToIntegerFloat16(highp vec2 f) { return floor(f.s * 255. + .5) * 256. + floor(f.t * 255. + .5); }\r\nhighp int UnpackRGBAToInt(vec4 f) { return int(UnpackRGBAToIntegerFloat(f)); }\r\nhighp vec4 UnpackFloatToRGBA(highp float f)\r\n{\r\n    const highp vec4 v = vec4(1., 255., 65025., 1.65814e+07), s = vec4(vec3(1. / 255.), 0.);\r\n    highp vec4 U = fract(f * v);\r\n    U -= U.sstp * s;\r\n    return U;\r\n}\r\nhighp float UnpackVec2ToFloat(highp vec2 f) { return floor(f.s * 255. + .5) * 256. + floor(f.t * 255. + .5); }\r\n#endif\r\n#if defined(MSAA) && defined(MSAA_AVAILABLE)\r\n#define SAMPLER_2D_AUTO_MULTISAMPLE sampler2DMS\r\n#define MSAA_SAMPLERS_ENABLED 1\r\n#define texture2DMultisample(sampler, texCoord, texSize) texelFetch(sampler, ivec2((texCoord)*texSize), 0)\r\n#else\r\n#define SAMPLER_2D_AUTO_MULTISAMPLE sampler2D\r\n#define MSAA_SAMPLERS_ENABLED 0\r\n#define texture2DMultisample(sampler, texCoord, texSize) texture2DLodCompat(sampler, texCoord, 0.0)\r\n#endif\r\nUNIFORM_BUFFER_BEGIN(ViewportLookupScale)\r\nuniform highp vec4 uViewportLookupScale;\r\nuniform highp vec4 uViewportOffsetScale;\r\nuniform highp vec4 uFullScreenLookupScale;\r\nUNIFORM_BUFFER_END\r\n\r\n/***************************************************/\r\n\r\nUNIFORM_BUFFER_BEGIN(ViewTransforms)\r\nuniform highp vec3 uCameraPosition;\r\nuniform highp mat4 uViewMatrix;\r\nuniform highp mat4 uProjectionMatrix;\r\nuniform highp mat4 uViewProjMatrix;\r\nuniform highp vec4 uZBufferParams;\r\nUNIFORM_BUFFER_END\r\n\r\nUNIFORM_BUFFER_BEGIN(Sunlight)\r\nuniform highp vec3 uInvSunDirection;\r\nuniform mediump vec3 uAmbientColour;\r\nuniform mediump vec3 uSunColour;\r\nuniform mediump float uDummy;\r\nUNIFORM_BUFFER_END\r\nuniform lowp vec4 uWaterFeatureFlags;\r\nuniform highp vec4 uWaterNormalMapTextureScales_FlowNoiseScale;\r\nuniform highp vec2 uWaterTickFade;\r\nuniform vec4 uWaterNormalBRDFParams;\r\nuniform vec3 uWaterSpecularColour;\r\nin highp vec4 vPosition_WaterDepth;\r\nin vec4 vColour;\r\nin highp vec4 vFlowControlMask_ViewSpaceDepth;\r\nin highp vec4 vNoisyPatchFlow0_NoisyPatchFlow1;\r\nin highp vec4 vNoisyPatchFlow2_UVPack_NormalsFlow0Map0;\r\nin highp vec4 vUVPack_NormalsFlow0Map1_NormalsFlow0Map2;\r\nin highp vec4 vUVPack_NormalsFlow1Map0_NormalsFlow1Map1;\r\nin highp vec4 vUVPack_NormalsFlow1Map2_NormalsFlow2Map0;\r\nin highp vec4 vUVPack_NormalsFlow2Map1_NormalsFlow2Map2;\r\nin highp vec4 vUVPack_NormalMapMacroUV_EmissiveUV[3];\r\nin highp vec2 vUVPack_FoamUV;\r\n#ifndef CONVERSION_UTILS_INC\r\n#define CONVERSION_UTILS_INC\r\nvec3 SRGBToLinear(vec3 srgbColour)\r\n{\r\n#if defined(GAMMA_CORRECT_INPUTS)\r\n    return srgbColour * srgbColour;\r\n#else\r\n    return pow(srgbColour, vec3(2.2, 2.2, 2.2));\r\n#endif\r\n}\r\nvec3 LinearToSRGB(vec3 s) { return max(vec3(1.055) * pow(s, vec3(.416667)) - vec3(.055), vec3(0.)); }\r\nfloat LinearToSRGB(float s)\r\n{\r\n    const float p = 1. / 2.2;\r\n    return pow(s, p);\r\n}\r\nvec3 LinearToSRGBRunescape(vec3 s) { return sqrt(s); }\r\nfloat LinearToSRGBRunescape(float s) { return sqrt(s); }\r\nvec4 convertRGBtoHSL(vec4 s)\r\n{\r\n    const float p = 1. / 6.;\r\n    float v = s.s, m = s.t, t = s.p, f = min(min(s.s, s.t), s.p), q = max(max(s.s, s.t), s.p), r = q - f, G = (f + q) * .5, i = 0., e = 0.;\r\n    if (G > 0. && G < 1.)\r\n    {\r\n        float L = G < .5 ? G : 1. - G;\r\n        i = r / (L * 2.);\r\n    }\r\n    if (r > 0.)\r\n    {\r\n        vec3 L = vec3(q == v && q != m ? 1. : 0., q == m && q != t ? 1. : 0., q == t && q != v ? 1. : 0.), o = vec3((m - t) / r, 2. + (t - v) / r, 4. + (v - m) / r);\r\n        e += dot(o, L);\r\n        e *= p;\r\n        if (e < 0.)\r\n            e += 1.;\r\n    }\r\n    return vec4(e, i, G, s.q);\r\n}\r\nvec4 convertHSLtoRGB(vec4 s)\r\n{\r\n    const float v = 1. / 3., q = 2. / 3., m = 6.;\r\n    float p = s.s, t = s.t, r = s.p;\r\n    vec3 f = vec3(m * (p - q), 0., m * (1. - p));\r\n    if (p < q)\r\n        f.s = 0., f.t = m * (q - p), f.p = m * (p - v);\r\n    if (p < v)\r\n        f.s = m * (v - p), f.t = m * p, f.p = 0.;\r\n    f = min(f, 1.);\r\n    float L = 2. * t, i = 1. - t, G = 1. - r, e = 2. * r - 1.;\r\n    vec3 c = L * f + i, o;\r\n    if (r >= .5)\r\n        o = G * c + e;\r\n    else\r\n        o = r * c;\r\n    return vec4(o, s.q);\r\n}\r\n#endif\r\n\r\nvec4 textureCubeSRGB(samplerCube sampler, vec3 reflDir)\r\n{\r\n    vec4 texel = textureCube(sampler, reflDir);\r\n    return texel;\r\n}\r\n\r\nvec4 textureCubeSRGB(samplerCube sampler, vec3 reflDir, float lod)\r\n{\r\n    vec4 texel = textureCube(sampler, reflDir, lod);\r\n    return texel;\r\n}\r\n\r\nvec4 textureCubeLodSRGB(samplerCube sampler, vec3 reflDir, float lod)\r\n{\r\n    vec4 texel = textureCubeLodCompat(sampler, reflDir, lod);\r\n    return texel;\r\n}\r\n#ifndef FRESNEL_INC\r\n#define FRESNEL_INC\r\nvec3 FresnelSchlick(vec3 F, float f, highp float h)\r\n{\r\n    vec3 c = F + (1. - F) * pow(1. - f, h);\r\n    return c;\r\n}\r\nvec3 FresnelSchlickRoughness(vec3 f, float F, highp float h, float v)\r\n{\r\n    vec3 c = f + (max(vec3(v), f) - f) * pow(1. - F, h);\r\n    return c;\r\n}\r\nfloat FresnelSchlick(float F, float f, highp float h)\r\n{\r\n    float c = F + (1. - F) * pow(1. - f, h);\r\n    return c;\r\n}\r\nfloat FresnelSchlickRoughness(float f, float F, highp float h, float v)\r\n{\r\n    float c = f + (max(v, f) - f) * pow(1. - F, h);\r\n    return c;\r\n}\r\nfloat FresnelSchlick(vec3 F, vec3 f, float c)\r\n{\r\n    float h = max(0., dot(F, f));\r\n    return c + (1. - c) * pow(1. - h, 5.);\r\n}\r\nfloat Fresnel(vec3 F, vec3 f, float c, float h)\r\n{\r\n    float p = 1. - max(0., dot(F, f)), v = p * p;\r\n    v = v * v;\r\n    v = v * p;\r\n    return clamp(v * (1. - clamp(h, 0., 1.)) + h - c, 0., 1.);\r\n}\r\n#endif\r\n\r\nvec3 UnpackCompressedNormal(vec3 U)\r\n{\r\n    vec3 v = vec3(U.ps * 255. / 127. - 1.00787, 0.);\r\n    v.p = sqrt(1. - min(1., dot(v.st, v.st)));\r\n    v.t = -v.t;\r\n    return v;\r\n}\r\nvec3 UnpackNormal(vec3 v, float U)\r\n{\r\n    vec3 t;\r\n#if defined(COMPRESSED_NORMALS)\r\n    t = UnpackCompressedNormal(v);\r\n#else\r\n    t = v.pst * 255. / 127. - 1.00787;\r\n    t.t = -t.t;\r\n#endif\r\n    t.st *= U;\r\n    return t;\r\n}\r\nvec3 UnpackNormal(vec3 U) { return UnpackNormal(U, 1.); }\r\nvec3 UnpackNormal(vec4 v) { return UnpackNormal(v.tpq, 1.); }\r\nvec3 UnpackNormal(vec4 v, float U) { return UnpackNormal(v.tpq, U); }\r\n\r\nconst highp float CAUSTICS_FIXED_POINT_SCALE = 10000.;\r\n#if defined(CAUSTICS) && !defined(CAUSTICS_COMPUTE) && !defined(CAUSTICS_STENCIL)\r\nfloat CalculateCausticsTerm(highp vec3 u, float t, vec3 e)\r\n{\r\n    float i = 0., s = 0.;\r\n    if (u.t <= uCausticsPlaneHeight)\r\n        s = step(1., t);\r\n    else\r\n    {\r\n#if defined(CAUSTICS_OVERWATER)\r\n        s = clamp(e.t * -1., 0., 1.);\r\n        float d = smoothstep(uCausticsOverWaterFade.s, uCausticsOverWaterFade.t, u.t - uCausticsPlaneHeight);\r\n        s *= 1. - d;\r\n#else\r\n        return 0.0;\r\n#endif\r\n    }\r\n    if (s > 0.)\r\n    {\r\n        highp vec4 C = uCausticsViewProjMatrix * vec4(u, 1.);\r\n        C.st /= 2. * C.q;\r\n        vec2 f = abs(C.st);\r\n        C.st += .5;\r\n        f = smoothstep(.4, .5, f);\r\n        s *= max(0., 1. - (f.s + f.t));\r\n        if (s > 0.)\r\n            i += textureOffset(uCausticsMap, C.st, ivec2(-1, -1)).s, i += textureOffset(uCausticsMap, C.st, ivec2(-1, 0)).s, i += textureOffset(uCausticsMap, C.st, ivec2(-1, 1)).s, i += textureOffset(uCausticsMap, C.st, ivec2(0, -1)).s, i += texture2D(uCausticsMap, C.st).s * 5., i += textureOffset(uCausticsMap, C.st, ivec2(0, 1)).s, i += textureOffset(uCausticsMap, C.st, ivec2(1, -1)).s, i += textureOffset(uCausticsMap, C.st, ivec2(1, 0)).s, i += textureOffset(uCausticsMap, C.st, ivec2(1, 1)).s, i *= s / 12.;\r\n    }\r\n    return i;\r\n}\r\n#endif\r\n#if defined(CAUSTICS_COMPUTE)\r\nvoid WriteCausticsRay(vec3 t, float i)\r\n{\r\n    vec2 s = t.sp * i * uCausticsRefractionScale, C = (gl_FragCoord.st + s * 2.) / uCausticsComputeResolution * uCausticsMapSize;\r\n    highp float u = min(uCausticsFade.s / i * uCausticsFade.t, 7. * uCausticsFade.t), f = smoothstep(uCausticsFade.p, uCausticsFade.q, i), E = f * u * CAUSTICS_FIXED_POINT_SCALE;\r\n    if (E >= 1.f)\r\n        imageAtomicAdd(uCausticsIntegerMap, ivec2(C.st), uint(E));\r\n}\r\n#endif\r\n\r\n#ifndef DEPTH_UTILS_INC\r\n#define DEPTH_UTILS_INC\r\nhighp float GetViewSpaceDepth(highp float v, highp vec3 G)\r\n{\r\n    return G.s / (G.t * v + G.p);\r\n}\r\nhighp vec4 GetViewSpaceDepth(highp vec4 v, highp vec3 G) { return G.s / (G.t * v + G.p); }\r\nhighp vec3 GetViewSpacePos(vec2 v, highp float G, highp mat4 f)\r\n{\r\n    highp vec4 m = vec4(2. * v - 1., 2. * G - 1., 1.), h = f * m;\r\n    h.stp /= h.q;\r\n    return h.stp;\r\n}\r\nhighp vec4 GetWorldSpacePos(vec2 v, highp float G, highp mat4 f)\r\n{\r\n    highp vec4 m = vec4(2. * v - 1., 2. * G - 1., 1.), h = f * m;\r\n    h = h / h.q;\r\n    return h;\r\n}\r\nhighp float GetViewSpaceDepthFromPos(vec3 v, mat4 G)\r\n{\r\n    vec3 h = vec3(G[0][2], G[1][2], G[2][2]);\r\n    return dot(v, h);\r\n}\r\n#if defined(SAMPLER_2D_AUTO_MULTISAMPLE)\r\nhighp vec3 GetViewSpacePos(vec2 v, SAMPLER_2D_AUTO_MULTISAMPLE G, highp mat4 h)\r\n{\r\n    highp float m;\r\n#if defined(VIEWPORTLOOKUPSCALE)\r\n    m = texture2DMultisample(G, v, uViewportLookupScale.pq).s;\r\n#else\r\n    m = texture2DMultisample(G, v, textureSize(G)).s;\r\n#endif\r\n    return GetViewSpacePos(v, m, h);\r\n}\r\nhighp vec3 GetViewSpacePos(vec2 v, vec4 G, vec2 h, SAMPLER_2D_AUTO_MULTISAMPLE f, highp mat4 m)\r\n{\r\n    highp float d = texture2DMultisample(f, v * G.pq + G.st, h).s;\r\n    return GetViewSpacePos(v, d, m);\r\n}\r\n#endif\r\n#endif\r\n\r\n#ifndef NOISE_UTILS_INC\r\n#define NOISE_UTILS_INC\r\nvec4 permute(vec4 t)\r\n{\r\n    return mod((t * 34. + 1.) * t, 289.);\r\n}\r\nvec2 fade(vec2 t) { return t * t * t * (t * (t * 6. - 15.) + 10.); }\r\nfloat cnoise(highp vec2 t)\r\n{\r\n    highp vec4 v = floor(t.stst) + vec4(0., 0., 1., 1.), d = fract(t.stst) - vec4(0., 0., 1., 1.);\r\n    v = mod(v, 289.);\r\n    vec4 p = v.spsp, s = v.ttqq, h = d.spsp, e = d.ttqq, f = permute(permute(p) + s), m = 2. * fract(f * .0243902) - 1., c = abs(m) - .5, q = floor(m + .5);\r\n    m = m - q;\r\n    vec2 N = vec2(m.s, c.s), r = vec2(m.t, c.t), o = vec2(m.p, c.p), a = vec2(m.q, c.q);\r\n    vec4 G = 1.79284 - .853735 * vec4(dot(N, N), dot(o, o), dot(r, r), dot(a, a));\r\n    N *= G.s;\r\n    o *= G.t;\r\n    r *= G.p;\r\n    a *= G.q;\r\n    float i = dot(N, vec2(h.s, e.s)), n = dot(r, vec2(h.t, e.t)), l = dot(o, vec2(h.p, e.p)), I = dot(a, vec2(h.q, e.q));\r\n    vec2 u = fade(d.st), S = mix(vec2(i, l), vec2(n, I), u.s);\r\n    float g = mix(S.s, S.t, u.t);\r\n    return 2.3 * g;\r\n}\r\nhighp float GetInterleavedGradientNoise(highp vec2 t) { return clamp(fract(52.9829 * fract(.0671106 * t.s + .00583715 * t.t)), 0., .999); }\r\n#endif\r\n\r\n#ifndef LIGHTING_UTILS_H\r\n#define LIGHTING_UTILS_H\r\n#ifndef LIGHTING_INC\r\n#define LIGHTING_INC\r\n#if __VERSION__ <= 120\r\n#ifdef in\r\n#undef in\r\n#endif\r\n#ifdef out\r\n#undef out\r\n#endif\r\n#endif\r\n\r\n#ifndef FRESNEL_INC\r\n#define FRESNEL_INC\r\nvec3 FresnelSchlick(vec3 F, float f, highp float h)\r\n{\r\n    vec3 c = F + (1. - F) * pow(1. - f, h);\r\n    return c;\r\n}\r\nvec3 FresnelSchlickRoughness(vec3 f, float F, highp float h, float v)\r\n{\r\n    vec3 c = f + (max(vec3(v), f) - f) * pow(1. - F, h);\r\n    return c;\r\n}\r\nfloat FresnelSchlick(float F, float f, highp float h)\r\n{\r\n    float c = F + (1. - F) * pow(1. - f, h);\r\n    return c;\r\n}\r\nfloat FresnelSchlickRoughness(float f, float F, highp float h, float v)\r\n{\r\n    float c = f + (max(v, f) - f) * pow(1. - F, h);\r\n    return c;\r\n}\r\nfloat FresnelSchlick(vec3 F, vec3 f, float c)\r\n{\r\n    float h = max(0., dot(F, f));\r\n    return c + (1. - c) * pow(1. - h, 5.);\r\n}\r\nfloat Fresnel(vec3 F, vec3 f, float c, float h)\r\n{\r\n    float p = 1. - max(0., dot(F, f)), v = p * p;\r\n    v = v * v;\r\n    v = v * p;\r\n    return clamp(v * (1. - clamp(h, 0., 1.)) + h - c, 0., 1.);\r\n}\r\n#endif\r\n\r\n#ifndef BRDF_INC\r\n#define BRDF_INC\r\n#ifndef NDF_INC\r\n#define NDF_INC\r\n#ifndef MATH_UTILS_INC\r\n#define MATH_UTILS_INC\r\nconst float PI = 3.14159, INV_PI = .31831, TWOPI = PI * 2., INV_TWOPI = 1. / TWOPI, PI_OVER_4 = PI / 4., PI_OVER_2 = PI / 2., SQRT_2_PI = .797885, INV_EIGHT = .125;\r\nfloat SpecPowToBeckmannRoughness(float f) { return sqrt(2. / (f + 2.)); }\r\nfloat PerceptualRoughnessToRoughness(float f) { return f * f; }\r\nfloat RoughnessToPerceptualRoughness(float f) { return sqrt(f); }\r\n#endif\r\n\r\nfloat BlinnPhongNDF(float f, float N)\r\n{\r\n    return (f + 2.) * INV_EIGHT * pow(N, f);\r\n}\r\nfloat GGXTrowbridgeReitzNDF(float N, float f)\r\n{\r\n    float P = N * N, I = f * f, T = I * (P - 1.) + 1.;\r\n    return P / (PI * (T * T + .0001));\r\n}\r\nfloat BeckmannNDF(float N, float f)\r\n{\r\n    float P = N * N, I = f * f;\r\n    return exp((I - 1.) / (P * I)) / (PI * P * (I * I));\r\n}\r\n#endif\r\n\r\n#ifndef VISIBILITY_FUNC_INC\r\n#define VISIBILITY_FUNC_INC\r\n#ifndef MATH_UTILS_INC\r\n#define MATH_UTILS_INC\r\nconst float PI = 3.14159, INV_PI = .31831, TWOPI = PI * 2., INV_TWOPI = 1. / TWOPI, PI_OVER_4 = PI / 4., PI_OVER_2 = PI / 2., SQRT_2_PI = .797885, INV_EIGHT = .125;\r\nfloat SpecPowToBeckmannRoughness(float f) { return sqrt(2. / (f + 2.)); }\r\nfloat PerceptualRoughnessToRoughness(float f) { return f * f; }\r\nfloat RoughnessToPerceptualRoughness(float f) { return sqrt(f); }\r\n#endif\r\n\r\nfloat SchlickSmithVis(float V, float f, float S)\r\n{\r\n    float P = 1. / sqrt(PI_OVER_4 * V + PI_OVER_2), d = 1. - P, v = (f * d + P) * (S * d + P);\r\n    return 1. / (v + .0001);\r\n}\r\nfloat KelemenSzirmayKalosVis(vec3 V, vec3 P)\r\n{\r\n    vec3 f = V + P;\r\n    return 4. / max(0., dot(f, f));\r\n}\r\n#endif\r\n\r\n#define GGX_NDF\r\n#define SCHLICK_SMITH_VIS\r\nvec3 CookTorranceBRDF(float d, float S, vec3 n, vec3 v, vec3 f, vec3 B, vec3 R, float F)\r\n{\r\n    float m = max(0., dot(v, f)), r = 1.;\r\n#if defined(BLINN_PHONG_NDF)\r\n    r = BlinnPhongNDF(d, m);\r\n#elif defined(GGX_NDF)\r\n    r = GGXTrowbridgeReitzNDF(PerceptualRoughnessToRoughness(S), m);\r\n#elif defined(BECKMANN_NDF)\r\n    r = max(0.f, BeckmannNDF(SpecPowToBeckmannRoughness(d), m));\r\n#else\r\n\r\n#error CookTorranceBRDF normal distribution function not specified\r\n\r\n#endif\r\n    float C = 1.;\r\n#if defined(SCHLICK_SMITH_VIS)\r\n    C = SchlickSmithVis(d, F, max(0., dot(v, B)));\r\n#elif defined(KELEMEN_SZIRMAY_KALOS_VIS)\r\n    C = KelemenSzirmayKalosVis(R, B);\r\n#endif\r\n    return n * (r * C);\r\n}\r\nfloat RunescapeLegacyBRDF(vec3 d, vec3 v, vec3 f, float B, float S)\r\n{\r\n    vec3 n = reflect(-d, f);\r\n    float C = pow(max(0., dot(n, v)), B);\r\n    return C * S;\r\n}\r\nfloat RunescapeRT5BRDF(vec3 d, vec3 v, float S) { return BlinnPhongNDF(S, max(0., dot(d, v))); }\r\nvec3 ShiftTangent(vec3 d, vec3 S, float B) { return normalize(d + B * S); }\r\nvec3 AnisotropicBRDF(vec3 v, vec3 d, vec3 S, vec3 f, vec3 B, float n, float m, float R, float C)\r\n{\r\n    const float F = 7.5, r = 1., e = .5, o = 1.;\r\n    float s = R - .5;\r\n    S = ShiftTangent(S, d, e + (C * 2. - 1.) * o + s);\r\n    float p = abs(dot(S, f)), a = 1. - p, t = 1. - abs(dot(S, B)), K = p * dot(d, B);\r\n    K += a * t;\r\n    K = pow(K, F) * n;\r\n    K = mix(K, K * C, o);\r\n    float G = pow(dot(d, v), m), P = mix(G, K, r);\r\n    return vec3(P, P, P);\r\n}\r\n#endif\r\n\r\nstruct LightingTerms\r\n{\r\n    vec3 Diffuse;\r\n    vec3 Specular;\r\n};\r\nvoid ClearLightingTerms(inout LightingTerms v) { v.Diffuse = vec3(0., 0., 0.), v.Specular = vec3(0., 0., 0.); }\r\nvoid AddLightingTerms(inout LightingTerms v, LightingTerms L) { v.Diffuse += L.Diffuse, v.Specular += L.Specular; }\r\nvoid EvaluateDirLightRT5(inout LightingTerms v, vec3 f, vec3 L, vec3 d, vec3 i, float S, float c, float F, float e, float E, vec3 A)\r\n{\r\n    v.Diffuse += A * e;\r\n#if defined(SPECULAR_LIGHTING)\r\n    vec3 G = normalize(d + i);\r\n    float r = FresnelSchlick(S, clamp(dot(i, G), 0., 1.), F);\r\n#if defined(ANISOTROPY_BRDF)\r\n    vec3 D = AnisotropicBRDF(G, f, L, i, d, E, c, .5, .5);\r\n#else\r\n    vec3 n = vec3(r) * vec3(RunescapeRT5BRDF(G, f, c));\r\n#endif\r\n    n *= A * e;\r\n    v.Specular += n;\r\n#endif\r\n}\r\nvoid EvaluateDirLightRT7(inout LightingTerms v, vec3 f, vec3 L, vec3 d, vec3 i, vec3 S, float c, float E, float G, float e, float F, vec3 A)\r\n{\r\n    v.Diffuse += A * e;\r\n#if defined(SPECULAR_LIGHTING)\r\n    vec3 r = normalize(d + i), n = FresnelSchlick(S, clamp(dot(i, r), 0., 1.), G);\r\n#if defined(ANISOTROPY_BRDF)\r\n    vec3 D = AnisotropicBRDF(r, f, L, i, d, F, c, .5, .5);\r\n#else\r\n    vec3 C = CookTorranceBRDF(c, E, n, f, r, d, i, F);\r\n#endif\r\n    C *= A * e;\r\n    v.Specular += C;\r\n#endif\r\n}\r\nfloat SpecularHorizonOcclusion(float L, vec3 i, vec3 v)\r\n{\r\n    vec3 d = reflect(i, v);\r\n    float A = clamp(1. + L * dot(d, v), 0., 1.);\r\n    A *= A;\r\n    return A;\r\n}\r\n#if __VERSION__ <= 120\r\n#define in varying\r\n#define out varying\r\n#endif\r\n\r\n#endif\r\n\r\n#if !defined(DEFERRED_SHADOWS)\r\nLightingTerms EvaluateSunlightRT5(inout int i, inout float E, highp vec4 v, vec3 u, vec3 f, float d, vec3 n, float p, float S, float r)\r\n{\r\n    float t = max(0., dot(u, uInvSunDirection)), L = t;\r\n    E = 1.;\r\n#if defined(SUNLIGHT_SHADOWS)\r\n    if (S == 0. && uMappingParams.p != 0.)\r\n    {\r\n        if (L > 0.)\r\n        {\r\n            highp vec4 h = uSunlightViewMatrix * v, e = vec4(u.st, 0., 0.) * 32.;\r\n            E = DirLightShadowAtten(i, v + e, h + e, d, uSunlightShadowMap, uSunlightShadowTranslucencyMap, r);\r\n        }\r\n    }\r\n#endif\r\n    L *= E;\r\n    float h = .65;\r\n    LightingTerms D;\r\n    ClearLightingTerms(D);\r\n    EvaluateDirLightRT5(D, u, f, n, uInvSunDirection, h, p, 5., L, t, uSunColour);\r\n    return D;\r\n}\r\n#else\r\nLightingTerms EvaluateSunlightRT5(inout float E, vec3 u, vec3 v, vec3 f, vec2 d, float n, float S)\r\n{\r\n    float t = max(0., dot(u, uInvSunDirection)), L = t;\r\n    E = 1.;\r\n#if defined(SUNLIGHT_SHADOWS) && defined(DEFERRED_SHADOWS)\r\n    if (S == 0. && uMappingParams.p != 0.)\r\n        E = texture2DLod(uShadowBuffer, d, 0.).s;\r\n#endif\r\n    L *= E;\r\n    float h = .65;\r\n    LightingTerms D;\r\n    ClearLightingTerms(D);\r\n    EvaluateDirLightRT5(D, u, v, f, uInvSunDirection, h, n, 5., L, uSunColour);\r\n    return D;\r\n}\r\n#endif\r\n#if !defined(DEFERRED_SHADOWS)\r\nLightingTerms EvaluateSunlightRT7(inout int u, inout float E, highp vec4 v, vec3 f, vec3 d, float n, vec3 h, vec3 L, float p, float i, float t, float S)\r\n{\r\n    float D = max(0., dot(f, uInvSunDirection)), e = D;\r\n    E = 1.;\r\n#if defined(SUNLIGHT_SHADOWS)\r\n    if (uMappingParams.p != 0.)\r\n    {\r\n        if (D > 0.)\r\n        {\r\n            highp vec4 r = uSunlightViewMatrix * v, a = vec4(f.st, 0., 0.) * 32.;\r\n            E = DirLightShadowAtten(u, v + a, r + a, n, uSunlightShadowMap, uSunlightShadowTranslucencyMap, S);\r\n        }\r\n    }\r\n#endif\r\n    e *= E;\r\n    LightingTerms r;\r\n    ClearLightingTerms(r);\r\n    EvaluateDirLightRT7(r, f, d, h, uInvSunDirection, L, p, i, t, e, D, uSunColour);\r\n    return r;\r\n}\r\n#else\r\nLightingTerms EvaluateSunlightRT7(inout float E, vec3 u, vec3 v, vec3 f, vec2 d, vec3 n, float h, float L, float r)\r\n{\r\n    float t = max(0., dot(u, uInvSunDirection)), p = t;\r\n    E = 1.;\r\n#if defined(SUNLIGHT_SHADOWS) && defined(DEFERRED_SHADOWS)\r\n    if (uMappingParams.p != 0.)\r\n        E = texture2DLod(uShadowBuffer, d, 0.).s;\r\n#endif\r\n    LightingTerms D;\r\n    ClearLightingTerms(D);\r\n    EvaluateDirLightRT7(D, u, v, f, uInvSunDirection, n, h, L, r, t, p, uSunColour);\r\n    return D;\r\n}\r\n#endif\r\n#endif\r\n\r\n#ifndef DISTANCE_FOG_UNIFORMS\r\n#define DISTANCE_FOG_UNIFORMS\r\n#if defined(FOG_DISTANCE)\r\nUNIFORM_BUFFER_BEGIN(DistanceFog)\r\nuniform mediump vec4 uFogColour;\r\nuniform highp vec4 uFogParams;\r\nUNIFORM_BUFFER_END\r\n#endif\r\n#endif\r\n\r\n#ifndef DISTANCE_FOG_FUNCTIONS\r\n#define DISTANCE_FOG_FUNCTIONS\r\n#if defined(FOG_DISTANCE)\r\nfloat FogBasedOnDistance(highp float f)\r\n{\r\n    highp float F = (uFogParams.t - f) * uFogParams.s;\r\n    return 1. - clamp(F, 0., 1.);\r\n}\r\nfloat FogBasedOnAngle(highp vec3 f)\r\n{\r\n    highp float F = 1. - clamp(f.t + uFogParams.q, 0., 1.);\r\n    F = pow(F, uFogParams.p);\r\n    return clamp(F, 0., 1.);\r\n}\r\n#endif\r\n#endif\r\n\r\n#if __VERSION__ <= 120\r\n#ifdef in\r\n#undef in\r\n#endif\r\n#ifdef out\r\n#undef out\r\n#endif\r\n#endif\r\n\r\nfloat GenerateNoise()\r\n{\r\n    const float d = 512., v = .125;\r\n    return clamp(cnoise(vPosition_WaterDepth.sp / d) * v, 0., 1.);\r\n}\r\nvec2 GetCombinedFlow() { return vNoisyPatchFlow0_NoisyPatchFlow1.st * vFlowControlMask_ViewSpaceDepth.s + vNoisyPatchFlow0_NoisyPatchFlow1.pq * vFlowControlMask_ViewSpaceDepth.t + vNoisyPatchFlow2_UVPack_NormalsFlow0Map0.st * vFlowControlMask_ViewSpaceDepth.p; }\r\n#if defined(WATER_NORMAL_MAPS)\r\nvec4 WeightedNormalMap_XY_DXDY(highp float v, sampler2D d, vec2 f, vec2 p, float E)\r\n{\r\n    if (v <= 0.)\r\n        return vec4(0.);\r\n    vec3 u = UnpackNormal(texture2D(d, f));\r\n    vec2 t = u.st / u.p;\r\n    const float W = 6.;\r\n    float q = clamp(length(p) * W + uWaterStillWaterNormalStrength_spareyzw.s, 0., 1.);\r\n    return vec4(u.st, t * q) * v * E;\r\n}\r\nvec2 GetNormalDXDYWeightedSum(highp vec4 d, highp vec4 v, highp vec4 u, vec2 f, vec2 p, vec2 t, vec2 W, float E)\r\n{\r\n    vec4 h = vec4(0.);\r\n    h += WeightedNormalMap_XY_DXDY(d.s, uWaterNormalMapTexture0, f, W, 1.);\r\n    p += h.st * v.t * E;\r\n    h += WeightedNormalMap_XY_DXDY(v.s, uWaterNormalMapTexture1, p, W, 1.);\r\n    t += h.st * u.t * E;\r\n    h += WeightedNormalMap_XY_DXDY(u.s, uWaterNormalMapTexture2, t, W, 1.);\r\n    return h.pq;\r\n}\r\nvec3 WaterDetailNormalWeightedSum(vec2 v, vec2 p, vec2 d, vec2 f, vec3 h)\r\n{\r\n    const float u = .5;\r\n    vec2 t = v + h.st * u * uSampleWeight_uvDistortion_sparezw[0].t, q = p + h.st * u * uSampleWeight_uvDistortion_sparezw[1].t, s = d + h.st * u * uSampleWeight_uvDistortion_sparezw[2].t;\r\n    const float E = .8;\r\n    vec2 W = GetNormalDXDYWeightedSum(uSampleWeight_uvDistortion_sparezw[0], uSampleWeight_uvDistortion_sparezw[1], uSampleWeight_uvDistortion_sparezw[2], t, q, s, f, E);\r\n    return normalize(vec3(W, 1.));\r\n}\r\n#if !defined(GLES2_COMPAT_MODE)\r\nvec3 WaterMacroNormalWeightedSum()\r\n{\r\n    const float d = .25;\r\n    const vec2 v = vec2(.1, -.13) * d;\r\n    const float f = .1;\r\n    vec2 p = GetNormalDXDYWeightedSum(uMacroSampleWeight_uvDistortion_sparezw[0], uMacroSampleWeight_uvDistortion_sparezw[1], uMacroSampleWeight_uvDistortion_sparezw[2], vUVPack_NormalMapMacroUV_EmissiveUV[0].st, vUVPack_NormalMapMacroUV_EmissiveUV[1].st, vUVPack_NormalMapMacroUV_EmissiveUV[2].st, v, f);\r\n    return normalize(vec3(p, 1.));\r\n}\r\n#else\r\nvec3 WaterMacroNormalWeightedSum()\r\n{\r\n    const float d = .25;\r\n    const vec2 v = vec2(.1, -.13) * d;\r\n    const float f = .1, p = .1;\r\n    vec2 W = vPosition_WaterDepth.sp * uWaterNormalMapTextureScales_FlowNoiseScale.s * p, u = vPosition_WaterDepth.sp * uWaterNormalMapTextureScales_FlowNoiseScale.t * p, t = vPosition_WaterDepth.sp * uWaterNormalMapTextureScales_FlowNoiseScale.p * p;\r\n    const float E = .01;\r\n    vec2 q = vec2(.1, -.13), s = vec2(-.08, .1), r = vec2(.11, -.9);\r\n    const float n = .5;\r\n    highp float m = uWaterTickFade.s * n;\r\n    vec2 h = W + q * d * m, e = u + s * d * m, c = t + r * d * m, G = GetNormalDXDYWeightedSum(uMacroSampleWeight_uvDistortion_sparezw[0], uMacroSampleWeight_uvDistortion_sparezw[1], uMacroSampleWeight_uvDistortion_sparezw[2], h, e, c, v, f);\r\n    return normalize(vec3(G, 1.));\r\n}\r\n#endif\r\nvec3 WaterNormal()\r\n{\r\n    vec3 v = WaterMacroNormalWeightedSum(), u = vec3(0.);\r\n    vec2 f = vNoisyPatchFlow0_NoisyPatchFlow1.pq - vNoisyPatchFlow0_NoisyPatchFlow1.st, p = vNoisyPatchFlow2_UVPack_NormalsFlow0Map0.st - vNoisyPatchFlow0_NoisyPatchFlow1.st, t = vec2(0., 0.), q = vec2(0., 0.), s = vec2(0., 0.), W = vec2(0., 0.), r = vec2(0., 0.), c = vec2(0., 0.), i = vec2(0., 0.), h = vec2(0., 0.), e = vec2(0., 0.);\r\n#if !defined(GLES2_COMPAT_MODE)\r\n    t = vNoisyPatchFlow2_UVPack_NormalsFlow0Map0.pq;\r\n    q = vUVPack_NormalsFlow0Map1_NormalsFlow0Map2.st;\r\n    s = vUVPack_NormalsFlow0Map1_NormalsFlow0Map2.pq;\r\n    W = vUVPack_NormalsFlow1Map0_NormalsFlow1Map1.st;\r\n    r = vUVPack_NormalsFlow1Map0_NormalsFlow1Map1.pq;\r\n    c = vUVPack_NormalsFlow1Map2_NormalsFlow2Map0.st;\r\n    i = vUVPack_NormalsFlow1Map2_NormalsFlow2Map0.pq;\r\n    h = vUVPack_NormalsFlow2Map1_NormalsFlow2Map2.st;\r\n    e = vUVPack_NormalsFlow2Map1_NormalsFlow2Map2.pq;\r\n#else\r\n    vec2 d = vNoisyPatchFlow2_UVPack_NormalsFlow0Map0.pq, m = vUVPack_NormalsFlow1Map0_NormalsFlow2Map0.st, E = vUVPack_NormalsFlow1Map0_NormalsFlow2Map0.pq;\r\n    t = d;\r\n    q = d * vec2(-.96, .95);\r\n    s = d * vec2(.97, -.94);\r\n    W = m;\r\n    r = m * vec2(-.96, .95);\r\n    c = m * vec2(.97, -.94);\r\n    i = E;\r\n    h = E * vec2(-.96, .95);\r\n    e = E * vec2(.97, -.94);\r\n#endif\r\n    const float G = 1e-07;\r\n    if (dot(f, f) <= G && dot(p, p) <= G)\r\n        u = WaterDetailNormalWeightedSum(t, q, s, vNoisyPatchFlow0_NoisyPatchFlow1.st, v) + v;\r\n    else\r\n        u += (WaterDetailNormalWeightedSum(t, q, s, vNoisyPatchFlow0_NoisyPatchFlow1.st, v) + v) * vFlowControlMask_ViewSpaceDepth.s, u += (WaterDetailNormalWeightedSum(W, r, c, vNoisyPatchFlow0_NoisyPatchFlow1.pq, v) + v) * vFlowControlMask_ViewSpaceDepth.t, u += (WaterDetailNormalWeightedSum(i, h, e, vNoisyPatchFlow2_UVPack_NormalsFlow0Map0.st, v) + v) * vFlowControlMask_ViewSpaceDepth.p;\r\n    return normalize(u).spt;\r\n}\r\n#else\r\nvec3 WaterNormal()\r\n{\r\n    return vec3(0., 1., 0.);\r\n}\r\n#endif\r\nvec3 WaterAlbedo(float v, float d, float E)\r\n{\r\n    vec3 f = vColour.stp;\r\n#if defined(WATER_FOAM_MAP)\r\n    float p = uWaterFoamScaleFoamDepth.t, u = clamp((1. - step(p, 0.)) * min(1., 1. - min(v / p, 1.)), 0., 1.), q = uWaterTickFade.s + vPosition_WaterDepth.s * .0001 + vPosition_WaterDepth.p * .0001, t = pow(max(0., cos(abs(v) * .005 + q + E * 4.)), 8.), s = pow(max(0., cos(abs(v) * .005 - q + E * 8.)), 4.), r = min(1., t + s * u) * max(.2 - d, 0.);\r\n#if !defined(GLES2_COMPAT_MODE)\r\n    vec4 h = texture2D(uWaterTextureFoam, vUVPack_FoamUV.st) * uWaterFoamScaleFoamDepth.s;\r\n    vec3 W = h.stp * h.q;\r\n    f = mix(vColour.stp, W, r * u);\r\n#else\r\n    f = vColour.stp;\r\n#endif\r\n\r\n#endif\r\n    return f;\r\n}\r\nfloat WaterSoftEdgeAlpha(float v)\r\n{\r\n    const float p = .004, u = 1.;\r\n    float f;\r\n#if defined(WATER_EXTINCTION)\r\n    const float d = .002;\r\n    float W = uWaterExtinctionVisibilityMetres / d, t = p + 1. / (W + .001), s = pow(v * t, u);\r\n    f = clamp(s, 0., 1.);\r\n#else\r\n    float q = pow(v * p, u);\r\n    f = clamp(q, 0., 1.);\r\n#endif\r\n    return f;\r\n}\r\nfloat SunLightShadowAttenuation(vec3 d, vec3 p, vec2 v, vec3 f, float E)\r\n{\r\n    float W = 1.;\r\n#if defined(SUNLIGHT_SHADOWS)\r\n    int u = -1;\r\n    vec4 t = uSunlightViewMatrix * vec4(vPosition_WaterDepth.stp, 1.);\r\n    W = DirLightShadowAtten(u, vec4(vPosition_WaterDepth.stp, 1.) + vec4(v, 0., 0.), t + vec4(v, 0., 0.), vFlowControlMask_ViewSpaceDepth.q, uSunlightShadowMap, uSunlightShadowTranslucencyMap, 1.);\r\n#endif\r\n    return W;\r\n}\r\nvec3 SunLightDiffuseContribution(vec3 v, vec3 d, vec2 p, vec3 f, float E, float u)\r\n{\r\n    vec3 r = vec3(0.);\r\n#if defined(SUNLIGHT_DIRECT_LIGHTING)\r\n    r = v * (dot(d, uInvSunDirection) * .5 + .5) * (1. - E) * uSunColour;\r\n#else\r\n    const float W = 2.;\r\n    r = v * W;\r\n#endif\r\n    return r * u;\r\n}\r\nvec3 SunLightSpecularContribution(vec3 d, vec3 v, vec2 p, vec3 f, float t, float E)\r\n{\r\n    vec3 W = vec3(0.);\r\n#if defined(SPECULAR_LIGHTING)\r\n    vec3 u = normalize(uInvSunDirection - f);\r\n    float q = clamp(dot(u, v), 0., 1.);\r\n    W = uSunColour * uSunColour * t * clamp(uInvSunDirection.t, 0., 1.) * pow(q, uWaterNormalBRDFParams.p * .25) * (uWaterNormalBRDFParams.q * 1.8 + .2) * clamp(uWaterNormalBRDFParams.q - .05, 0., 1.) * 25.;\r\n#endif\r\n    return W * E;\r\n}\r\n#if defined(GLOBAL_ENVIRONMENTMAPPING)\r\nvec3 GetEnvironmentMapReflection(vec3 v, vec3 f)\r\n{\r\n    vec3 u = reflect(v, f);\r\n    u.p = -u.p;\r\n    u.t = abs(u.t);\r\n    vec3 d = textureCubeSRGB(uGlobalEnvironmentMap, u).stp;\r\n#if defined(FOG_DISTANCE)\r\n    float E = FogBasedOnAngle(normalize(reflect(v, f)));\r\n    d = mix(d.stp, uFogColour.stp, E);\r\n#endif\r\n    return d;\r\n}\r\n#endif\r\nvec3 EnvMapContribution(vec3 v, vec3 f, vec3 d, float E)\r\n{\r\n    vec3 W = vec3(0.);\r\n    float u = 1.;\r\n#if defined(GLOBAL_ENVIRONMENTMAPPING)\r\n\r\n#if defined(REFLECTION)\r\n    u = uWaterReflectionStrength;\r\n    if (uWaterReflectionMapContribution < 1.)\r\n#endif\r\n    {\r\n        vec3 t = GetEnvironmentMapReflection(d, f);\r\n#if defined(REFLECTION)\r\n        t *= 1. - uWaterReflectionMapContribution;\r\n#endif\r\n        W = t * mix(v, vec3(1., 1., 1.), E);\r\n    }\r\n#endif\r\n    return W * u;\r\n}\r\nvec3 WaterReflection(vec3 v, vec3 f, vec2 d, vec3 p, float E)\r\n{\r\n    vec3 W = vec3(0.);\r\n#if defined(REFLECTION)\r\n    vec2 u = uViewportOffsetScale.st * uFullScreenLookupScale.pq, h = gl_FragCoord.st + d;\r\n    h = (h - u) * uViewportLookupScale.st;\r\n    vec4 r = texture2DLodCompat(uReflectionMap, vec2(1. - h.s, h.t), 0.);\r\n    if (r.q < 1.)\r\n    {\r\n        h = gl_FragCoord.st;\r\n        h = (h - u) * uViewportLookupScale.st;\r\n        r = texture2DLodCompat(uReflectionMap, vec2(1. - h.s, h.t), 0.);\r\n#if defined(GLOBAL_ENVIRONMENTMAPPING)\r\n        if (r.q == 0.)\r\n            r.stp = GetEnvironmentMapReflection(p, f), r.q = 1.;\r\n#endif\r\n    }\r\n    W = r.stp * mix(v, vec3(1.), E) * uWaterReflectionMapContribution * uWaterReflectionStrength;\r\n#endif\r\n    return W;\r\n}\r\nvec3 WaterExtinction(vec3 v, vec3 d, float f, vec2 p, vec3 W, float E)\r\n{\r\n    vec3 t = d;\r\n#if defined(WATER_EXTINCTION) && defined(REFRACTION)\r\n    const float u = .002;\r\n    if (uWaterFeatureFlags.t >= 1.)\r\n    {\r\n        vec3 h = GetWorldSpacePos(p, f, uSceneInvViewProjMatrix).stp;\r\n        float r = length(h - vPosition_WaterDepth.stp) * u;\r\n        highp float q = abs(h.t - vPosition_WaterDepth.t) * u, s = mix(.04, 1., clamp(uWaterExtinctionVisibilityMetres, 0., 1.));\r\n        vec3 m = W / v, c = v / max(max(v.s, v.t), v.p), n = m * c, e = uWaterExtinctionOpaqueWaterColour * n;\r\n        float G = clamp(r / uWaterExtinctionVisibilityMetres, 0., 1.), S = pow(G, s);\r\n        vec3 i = mix(d, e, S);\r\n        const float N = .25;\r\n        vec3 C = clamp(q / (uWaterExtinctionRGBDepthMetres * c), 0., 1.), P = pow(C, vec3(N));\r\n        t = i * (1. - P);\r\n        t = mix(d, t, E);\r\n    }\r\n#endif\r\n    return t;\r\n}\r\nvec3 WaterRefractionWithExtinction(vec3 v, vec3 d, float p, float t, vec3 f, float u)\r\n{\r\n    vec3 W = vec3(0.);\r\n#if defined(REFRACTION)\r\n    vec2 E = uViewportOffsetScale.st * uFullScreenLookupScale.pq;\r\n    vec3 q = vec3(0.);\r\n    float r = 0.;\r\n    highp vec2 h = d.sp * min(sqrt(p) * u * 2., 128.);\r\n    vec2 s = gl_FragCoord.st + h * t * 2.;\r\n    s = (s - E) * uViewportLookupScale.st;\r\n    if (uWaterFeatureFlags.s >= 1.)\r\n    {\r\n#if !defined(NXT_MOBILE)\r\n        r = texture2DLodCompat(uRefractionDepth, s, 0.).s;\r\n        if (r < gl_FragCoord.p || r >= 1.)\r\n            s = gl_FragCoord.st, s = (s - E) * uViewportLookupScale.st;\r\n#endif\r\n        q = texture2DLodCompat(uRefractionMap, vec3(s, 0.), 0.).stp;\r\n    }\r\n    W = WaterExtinction(v, q, r, s, f, u);\r\n#endif\r\n    return W;\r\n}\r\n#if defined(WATER_EMISSIVE) && !defined(GLES2_COMPAT_MODE)\r\n#define EMISSIVE_MAP_MASK (0)\r\n#define EMISSIVE_MAP_RGBMAP_MASK (1)\r\nvec4 SampleEmissiveMap(sampler2D v, vec2 E)\r\n{\r\n    vec2 u = vUVPack_NormalMapMacroUV_EmissiveUV[1].pq - vUVPack_NormalMapMacroUV_EmissiveUV[0].pq, p = vUVPack_NormalMapMacroUV_EmissiveUV[2].pq - vUVPack_NormalMapMacroUV_EmissiveUV[0].pq;\r\n    const float W = 1e-07;\r\n    if (dot(u, u) <= W && dot(p, p) <= W)\r\n        return texture2D(v, vUVPack_NormalMapMacroUV_EmissiveUV[0].pq + E);\r\n    else\r\n    {\r\n        vec4 f = texture2D(v, vUVPack_NormalMapMacroUV_EmissiveUV[0].pq + E) * vFlowControlMask_ViewSpaceDepth.s;\r\n        f += texture2D(v, vUVPack_NormalMapMacroUV_EmissiveUV[1].pq + E) * vFlowControlMask_ViewSpaceDepth.t;\r\n        f += texture2D(v, vUVPack_NormalMapMacroUV_EmissiveUV[2].pq + E) * vFlowControlMask_ViewSpaceDepth.p;\r\n        return f;\r\n    }\r\n}\r\nvec4 EmissiveContribution_Mask(vec3 v, vec2 f)\r\n{\r\n    float E = SampleEmissiveMap(uWaterEmissiveMapTexture, f).s;\r\n    vec3 d = mix(v, uWaterEmissiveColourEmissiveSource.stp, uWaterEmissiveColourEmissiveSource.q);\r\n    float W = uEmissiveScale_MapRefractionDepth_EmissiveMapMode_EmissiveMapExists.s;\r\n    return vec4(d * (1. + W), E);\r\n}\r\nvec4 EmissiveContribution_RGBMapMask(vec3 v, vec2 f)\r\n{\r\n    vec4 h = SampleEmissiveMap(uWaterEmissiveMapTexture, f);\r\n    vec3 d = mix(v, h.stp * uWaterEmissiveColourEmissiveSource.stp, uWaterEmissiveColourEmissiveSource.q);\r\n    float E = uEmissiveScale_MapRefractionDepth_EmissiveMapMode_EmissiveMapExists.s;\r\n    return vec4(d * (1. + E), h.q);\r\n}\r\nvec4 EmissiveContribution_NoMap(vec3 v)\r\n{\r\n    vec3 d = mix(v, uWaterEmissiveColourEmissiveSource.stp, uWaterEmissiveColourEmissiveSource.q);\r\n    float E = uEmissiveScale_MapRefractionDepth_EmissiveMapMode_EmissiveMapExists.s;\r\n    return vec4(d * (1. + E), 1.);\r\n}\r\nvec4 EmissiveContribution(vec3 v, vec3 d, float E)\r\n{\r\n    int W = int(uEmissiveScale_MapRefractionDepth_EmissiveMapMode_EmissiveMapExists.q);\r\n    if (W == 0)\r\n        return EmissiveContribution_NoMap(v);\r\n    vec2 f = d.sp * uEmissiveScale_MapRefractionDepth_EmissiveMapMode_EmissiveMapExists.t * E * 2.;\r\n    int u = int(uEmissiveScale_MapRefractionDepth_EmissiveMapMode_EmissiveMapExists.p);\r\n    if (u == EMISSIVE_MAP_MASK)\r\n        return EmissiveContribution_Mask(v, f);\r\n    else\r\n        return EmissiveContribution_RGBMapMask(v, f);\r\n}\r\n#endif\r\n#if (defined(SUNLIGHT_SHADOWS) && defined(DEBUG_SUNLIGHT_SHADOW_CASCADE) && !defined(DEFERRED_SHADOWS)) || defined(DEBUG_ALBEDO) || defined(DEBUG_NORMALS)\r\n#define WATER_DEBUG_OUTPUT\r\n#endif\r\n#if defined(WATER_DEBUG_OUTPUT)\r\nvoid WaterWriteDebugColour(vec3 v, vec3 d)\r\n{\r\n#if defined(DEBUG_ALBEDO)\r\n    gl_FragColor = vec4(v, 1.);\r\n    if (uDebugReturn != 0.)\r\n    {\r\n        return;\r\n    }\r\n#endif\r\n\r\n#if defined(DEBUG_NORMALS)\r\n    gl_FragColor = vec4(d * .5 + .5, 1.);\r\n    if (uDebugReturn != 0.)\r\n    {\r\n        return;\r\n    }\r\n#endif\r\n\r\n#if defined(SUNLIGHT_SHADOWS) && defined(DEBUG_SUNLIGHT_SHADOW_CASCADE) && !defined(DEFERRED_SHADOWS)\r\n    gl_FragColor = vec4(ShadowMapCascadeColour(iCascade, int(uMappingParams.q)).stp, 1.);\r\n    if (uDebugReturn != 0.)\r\n    {\r\n        return;\r\n    }\r\n#endif\r\n}\r\n#endif\r\nvoid WaterFragment()\r\n{\r\n    vec3 v = vPosition_WaterDepth.stp - uCameraPosition;\r\n    float d = length(v);\r\n    vec3 f = v / d;\r\n    vec2 u = GetCombinedFlow();\r\n    float p = length(u), E = GenerateNoise();\r\n    vec3 W = WaterAlbedo(vPosition_WaterDepth.q, p, E), h = WaterNormal();\r\n    vec2 t = h.sp * min(vPosition_WaterDepth.q, 32.);\r\n    float q = WaterSoftEdgeAlpha(vPosition_WaterDepth.q);\r\n    vec4 r = vec4(0.);\r\n    r.q = q;\r\n    const float s = .28, e = 0., c = .6;\r\n    float G = clamp(FresnelSchlick(h, -f, s), e, c), S = clamp(G + uWaterNormalBRDFParams.s, e, c);\r\n    r.q *= G;\r\n    r.stp += WaterReflection(W, h, t, f, S);\r\n    r.stp += EnvMapContribution(W, h, f, S);\r\n    float N = SunLightShadowAttenuation(W, h, t, f, G);\r\n    vec3 m = SunLightDiffuseContribution(W, h, t, f, G, N), n = SunLightSpecularContribution(W, h, t, f, S, N);\r\n    r.stp += n;\r\n#if defined(SUNLIGHT_DIRECT_LIGHTING) && (defined(LIGHT_SCATTERING) || defined(FOG_DISTANCE))\r\n    vec3 i = vOutScattering, P = vInScattering;\r\n    r.stp = ApplyInOutScattering(r.stp, i, P);\r\n    r.q = mix(r.q, 1., vColour.q);\r\n#endif\r\n\r\n#if !defined(REFRACTION)\r\n    r.stp += m;\r\n#if defined(WATER_EMISSIVE) && !defined(GLES2_COMPAT_MODE)\r\n    vec4 C = EmissiveContribution(W, h, G);\r\n    r.stp = mix(r.stp, C.stp, C.q * q * uEmissiveBlend);\r\n#endif\r\n\r\n#else\r\n    vec3 D = WaterRefractionWithExtinction(W, h, vPosition_WaterDepth.q, G, m, q);\r\n#if defined(WATER_EMISSIVE) && !defined(GLES2_COMPAT_MODE)\r\n    r.stp = mix(D, r.stp, G);\r\n    vec4 g = EmissiveContribution(W, h, G);\r\n    r.stp = mix(r.stp, g.stp, g.q * uEmissiveBlend);\r\n    r.stp = mix(D, r.stp, q);\r\n#else\r\n    r.stp = mix(D, r.stp, r.q);\r\n#endif\r\n\r\n#endif\r\n\r\n#if !defined(SUNLIGHT_DIRECT_LIGHTING)\r\n    r.q = 1.;\r\n#endif\r\n    gl_FragColor = r;\r\n#if defined(WATER_DEBUG_OUTPUT)\r\n    WaterWriteDebugColour(W, h);\r\n#endif\r\n}\r\n#if defined(CAUSTICS_STENCIL)\r\nvoid CausticsStencil()\r\n{\r\n    gl_FragColor.s = float(texture2D(uCausticsMap, gl_FragCoord.st / uCausticsMapSize).s) * uCausticsScale / CAUSTICS_FIXED_POINT_SCALE;\r\n}\r\n#endif\r\n#if defined(CAUSTICS_COMPUTE)\r\nvoid CausticsCompute()\r\n{\r\n    vec3 v = WaterNormal();\r\n    WriteCausticsRay(v, vPosition_WaterDepth.q);\r\n    discard;\r\n    return;\r\n}\r\n#endif\r\n#if defined(CLIP_PLANE_CLAMP)\r\nvoid ClipPlaneClamp()\r\n{\r\n    const float E = 200.;\r\n    if (abs(vPosition_WaterDepth.t + uClipPlane.q) < E)\r\n        gl_FragDepth = 1., gl_FragColor = vec4(uFogColour.stp, 1.);\r\n    else\r\n    {\r\n        discard;\r\n    }\r\n}\r\n#endif\r\nvoid main()\r\n{\r\n#if defined(CLIP_PLANE_CLAMP)\r\n    ClipPlaneClamp();\r\n#elif defined(CAUSTICS_STENCIL)\r\n    CausticsStencil();\r\n#elif defined(CAUSTICS_COMPUTE)\r\n    CausticsCompute();\r\n#else\r\n    WaterFragment();\r\n#endif\r\n}\r\n";
  }
});

// rsmv/src/viewer/threejsrender.ts
import * as THREE6 from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

// rsmv/src/utils.ts
function cacheFilenameHash(name, oldhash) {
  let hash = 0;
  if (oldhash) {
    name = name.toUpperCase();
    for (let ch of name) {
      hash = Math.imul(hash, 61) + ch.charCodeAt(0) - 32 | 0;
    }
  } else {
    for (let ch of name) {
      hash = ((hash << 5) - hash | 0) + ch.charCodeAt(0) | 0;
    }
  }
  return hash >>> 0;
}
globalThis.cacheFilenameHash = cacheFilenameHash;
function stringToMapArea(str) {
  let [x, z, xsize, zsize] = str.split(/[,\.\/:;]/).map((n) => +n);
  xsize = xsize ?? 1;
  zsize = zsize ?? xsize;
  if (isNaN(x) || isNaN(z) || isNaN(xsize) || isNaN(zsize)) {
    return null;
  }
  return { x, z, xsize, zsize };
}
function stringToFileRange(str) {
  let parts = str.split(",");
  let ranges = parts.map((q) => {
    let ends = q.split("-");
    let start = ends[0] ? ends[0].split(".") : [];
    let end = ends[0] || ends[1] ? (ends[1] ?? ends[0]).split(".") : [];
    return {
      start: [+(start[0] ?? 0), +(start[1] ?? 0), +(start[2] ?? 0)],
      end: [+(end[0] ?? Infinity), +(end[1] ?? Infinity), +(end[2] ?? Infinity)]
    };
  });
  return ranges;
}
function getOrInsert(map, key, fallback) {
  let val = map.get(key);
  if (val === void 0) {
    val = fallback();
    map.set(key, val);
  }
  return val;
}
function delay(ms) {
  return new Promise((d) => setTimeout(d, ms));
}
function posmod(x, n) {
  return (x % n + n) % n;
}
function escapeHTML(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
function rsmarkupToSafeHtml(str) {
  let res = "";
  let tokenstack = [];
  try {
    while (str) {
      let token = str.match(/<(\/?)(\w+)(=(\w+))?>/);
      if (!token) {
        res += escapeHTML(str);
        str = "";
      } else {
        res += escapeHTML(str.slice(0, token.index));
        str = str.slice(token.index + token[0].length);
        let isclose = !!token[1];
        let tagname = token[2];
        if (isclose) {
          let last = tokenstack.pop();
          if (last != tagname) {
            throw new Error("markup token mismatch");
          }
          if (last == "col") {
            res += "</span>";
          } else {
            throw new Error("unknown markup closing token " + last);
          }
        } else if (tagname == "br") {
          res += "<br/>";
        } else if (tagname == "col") {
          res += `<span style="color:#${token[4].replace(/\W/g, "")};">`;
          tokenstack.push("col");
        } else {
          throw new Error("unknown token " + tagname);
        }
      }
    }
    while (tokenstack.length != 0) {
      let token = tokenstack.pop();
      if (token == "col") {
        res += "</span>";
      } else {
        throw new Error("non-autocloseable token left unclosed " + token);
      }
    }
  } catch (e) {
    console.log(e.message);
    res = escapeHTML(str);
  }
  return res;
}
function arrayEnum(v) {
  return v;
}
function constrainedMap() {
  return function(v) {
    return v;
  };
}
var Stream = function Stream2(data, scan = 0) {
  this.getData = function() {
    return data;
  };
  this.bytesLeft = function() {
    return data.length - scan;
  };
  this.readBuffer = function(len = data.length - scan) {
    let res = data.slice(scan, scan + len);
    scan += len;
    return res;
  };
  this.tee = function() {
    return new Stream2(data, scan);
  };
  this.eof = function() {
    if (scan > data.length) {
      throw new Error("reading past end of buffer");
    }
    return scan >= data.length;
  };
  this.skip = function(n) {
    scan += n;
    return this;
  };
  this.scanloc = function() {
    return scan;
  };
  this.readByte = function() {
    var val = this.readUByte();
    if (val > 127)
      return val - 256;
    return val;
  };
  this.readUShortSmart = function() {
    let byte0 = this.readUByte();
    if ((byte0 & 128) == 0) {
      return byte0;
    }
    let byte1 = this.readUByte();
    return (byte0 & 127) << 8 | byte1;
  };
  this.readShortSmart = function() {
    let byte0 = this.readUByte();
    let byte0val = byte0 & 127;
    byte0val = byte0 < 64 ? byte0 : byte0 - 128;
    if ((byte0 & 128) == 0) {
      return byte0val;
    }
    let byte1 = this.readUByte();
    return byte0val << 8 | byte1;
  };
  this.readShortSmartBias = function() {
    let byte0 = this.readUByte();
    if ((byte0 & 128) == 0) {
      return byte0 - 64;
    }
    let byte1 = this.readUByte();
    return ((byte0 & 127) << 8 | byte1) - 16384;
  };
  this.readUIntSmart = function() {
    let byte0 = this.readUByte();
    let byte1 = this.readUByte();
    if ((byte0 & 128) == 0) {
      return byte0 << 8 | byte1;
    }
    let byte2 = this.readUByte();
    let byte3 = this.readUByte();
    return (byte0 & 127) << 24 | byte1 << 16 | byte2 << 8 | byte3;
  };
  this.readUByte = function() {
    return data[scan++];
  };
  this.readShort = function(bigendian = false) {
    var val = this.readUShort(bigendian);
    if (val > 32767)
      return val - 65536;
    return val;
  };
  this.readTribyte = function() {
    let val = data.readIntBE(scan, 3);
    scan += 3;
    return val;
  };
  this.readUShort = function(bigendian = false) {
    if (bigendian)
      return data[scan++] << 8 & 65280 | data[scan++];
    else
      return data[scan++] | data[scan++] << 8 & 65280;
  };
  this.readUInt = function(bigendian = false) {
    if (bigendian)
      return (data[scan++] << 24 & 4278190080 | data[scan++] << 16 & 16711680 | data[scan++] << 8 & 65280 | data[scan++]) >>> 0;
    else
      return (data[scan++] | data[scan++] << 8 & 65280 | data[scan++] << 16 & 16711680 | data[scan++] << 24 & 4278190080) >>> 0;
  };
  this.readFloat = function(bigendian = false, signage = false) {
    var upper, mid, lower, exponent;
    if (bigendian) {
      exponent = data[scan++];
      lower = data[scan++] << 16 & 16711680;
      mid = data[scan++] << 8 & 65280;
      upper = data[scan++];
    } else {
      upper = data[scan++];
      mid = data[scan++] << 8 & 65280;
      lower = data[scan++] << 16 & 16711680;
      exponent = data[scan++];
    }
    var mantissa = upper | mid | lower;
    if (signage) {
      exponent = exponent << 1 & 254;
      if ((mantissa & 8388608) == 8388608)
        exponent |= 1;
      mantissa &= 8388607;
    }
    return (1 + mantissa * Math.pow(2, signage ? -23 : -24)) * Math.pow(2, exponent - 127);
  };
  this.readHalf = function(flip = false) {
    var upper = data[scan++];
    var lower = data[scan++];
    var mantissa = lower | upper << 8 & 768;
    var exponent = upper >> 2 & 31;
    mantissa = mantissa * Math.pow(2, -10) + (exponent == 0 ? 0 : 1);
    mantissa *= Math.pow(2, exponent - 15);
    if ((upper & 128) == 128)
      mantissa *= -1;
    return mantissa;
  };
};
function flipEndian16(u16) {
  return (u16 & 255) << 8 | (u16 & 65280) >>> 8;
}
function ushortToHalf(bytes) {
  bytes = flipEndian16(bytes);
  let positive = (bytes & 32768) == 0;
  let exponent = (bytes & 31744) >> 10;
  let mantissa = bytes & 1023;
  let res = mantissa * Math.pow(2, -10) + (exponent == 0 ? 0 : 1);
  res *= Math.pow(2, exponent - 15);
  if (positive) {
    return res;
  }
  return -res;
}
function HSL2RGBfloat(hsl) {
  var h = hsl[0];
  var s = hsl[1];
  var l = hsl[2];
  var r, g, b;
  if (s == 0) {
    r = g = b = l;
  } else {
    var hue2rgb = function hue2rgb2(p2, q2, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p2 + (q2 - p2) * 6 * t;
      if (t < 1 / 2) return q2;
      if (t < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      return p2;
    };
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return [r, g, b];
}
function HSL2RGB(hsl) {
  let rgb = HSL2RGBfloat(hsl);
  return [Math.round(rgb[0] * 255), Math.round(rgb[1] * 255), Math.round(rgb[2] * 255)];
}
function RGB2HSL(r, g, b) {
  r /= 255, g /= 255, b /= 255;
  var max = Math.max(r, g, b), min = Math.min(r, g, b);
  var h = 0;
  var s = 0;
  let l = (max + min) / 2;
  if (max != min) {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return [h, s, l];
}
globalThis.hsl = (v) => HSL2RGB(packedHSL2HSL(v));
function HSL2packHSL(h, s, l) {
  if (h < 0) {
    h += 1;
  }
  return Math.round(h * 63) << 10 | Math.round(s * 7) << 7 | Math.round(l * 127);
}
function packedHSL2HSL(hsl) {
  var h = (hsl >> 10 & 63) / 63;
  var s = (hsl >> 7 & 7) / 7;
  var l = (hsl & 127) / 127;
  if (h > 0.5)
    h = h - 1;
  return [h, s, l];
}
var TypedEmitter = class {
  constructor() {
    this.listeners = {};
  }
  on(event, listener) {
    let listeners = this.listeners[event] ?? (this.listeners[event] = /* @__PURE__ */ new Set());
    listeners.add(listener);
  }
  once(event, listener) {
    let listeners = this.listeners[event] ?? (this.listeners[event] = /* @__PURE__ */ new Set());
    let oncer = (v) => {
      listeners.delete(oncer);
      listener(v);
    };
    listeners.add(oncer);
  }
  off(event, listener) {
    let listeners = this.listeners[event] ?? (this.listeners[event] = /* @__PURE__ */ new Set());
    listeners.delete(listener);
  }
  emit(event, value) {
    let listeners = this.listeners[event] ?? (this.listeners[event] = /* @__PURE__ */ new Set());
    listeners.forEach((cb) => cb(value));
  }
};
var CallbackPromise = class extends Promise {
  constructor(exe = (done, err) => {
  }) {
    let tmpdone;
    let tmperr;
    super((done, err) => {
      tmpdone = done;
      tmperr = err;
      return exe(done, err);
    });
    this.done = tmpdone;
    this.err = tmperr;
  }
};
async function trickleTasksTwoStep(parallel, tasks, steptwo) {
  let writecounter = 0;
  let completecounter = 0;
  let queue = new Array(parallel).fill(null);
  for (let prom of tasks()) {
    let index = writecounter++;
    queue[index % parallel] = prom;
    if (writecounter >= completecounter + parallel) {
      if (writecounter >= parallel) {
        let res = await queue[completecounter % parallel];
        completecounter++;
        steptwo(res);
      }
    }
  }
  while (completecounter < writecounter) {
    let res = await queue[completecounter % parallel];
    completecounter++;
    steptwo(res);
  }
}

// rsmv/src/imgutils.ts
function makeImageData(data, width, height) {
  if (!data) {
    data = new Uint8ClampedArray(width * height * 4);
  }
  if (data instanceof Uint8Array) {
    data = new Uint8ClampedArray(data.buffer, data.byteOffset, data.length);
  }
  if (typeof ImageData != "undefined") {
    return new ImageData(data, width, height);
  } else {
    return { data, width, height, colorSpace: "srgb" };
  }
}
async function pixelsToImageFile(imgdata, format, quality) {
  if (typeof HTMLCanvasElement != "undefined") {
    let cnv = document.createElement("canvas");
    cnv.width = imgdata.width;
    cnv.height = imgdata.height;
    let ctx = cnv.getContext("2d", { willReadFrequently: true });
    ctx.putImageData(imgdata, 0, 0);
    return canvasToImageFile(cnv, format, quality);
  } else {
    const sharp = require_lib();
    let img = sharp(imgdata.data, { raw: { width: imgdata.width, height: imgdata.height, channels: 4 } });
    if (format == "png") {
      return img.png().toBuffer();
    } else if (format == "webp") {
      return img.webp({ quality: quality * 100 }).toBuffer();
    } else {
      throw new Error("unknown format");
    }
  }
}
var warnedstripalpha = false;
async function fileToImageData(file, mimetype, stripAlpha) {
  if (typeof ImageDecoder != "undefined") {
    let decoder = new ImageDecoder({ data: file, type: mimetype, premultiplyAlpha: stripAlpha ? "none" : "default", colorSpaceConversion: "none" });
    let frame = await decoder.decode();
    let pixels = new Uint8Array(frame.image.allocationSize());
    frame.image.copyTo(pixels);
    let pixelcount = frame.image.visibleRect.width * frame.image.visibleRect.height;
    if (frame.image.format == "BGRX" || frame.image.format == "RGBX") {
      stripAlpha = true;
    }
    if (frame.image.format == "BGRA" || frame.image.format == "BGRX") {
      for (let i = 0; i < pixelcount; i++) {
        let tmp = pixels[i * 4 + 0];
        pixels[i * 4 + 0] = pixels[i * 4 + 2];
        pixels[i * 4 + 1] = pixels[i * 4 + 1];
        pixels[i * 4 + 2] = tmp;
        pixels[i * 4 + 3] = stripAlpha ? 255 : pixels[i * 4 + 3];
      }
    } else if (frame.image.format == "RGBA" || frame.image.format == "RGBX") {
      if (stripAlpha) {
        for (let i = 0; i < pixelcount; i++) {
          pixels[i * 4 + 3] = 255;
        }
      }
    } else {
      throw new Error("unexpected image format");
    }
    return makeImageData(pixels, frame.image.visibleRect.width, frame.image.visibleRect.height);
  } else if (typeof HTMLCanvasElement != "undefined") {
    if (stripAlpha && !warnedstripalpha) {
      console.warn("can not strip alpha in browser context that does not support ImageDecoder");
    }
    let img = new Image();
    let blob = new Blob([file], { type: mimetype });
    let url = URL.createObjectURL(blob);
    img.src = url;
    await img.decode();
    let cnv = document.createElement("canvas");
    cnv.width = img.naturalWidth;
    cnv.height = img.naturalHeight;
    let ctx = cnv.getContext("2d", { willReadFrequently: true });
    ctx.drawImage(img, 0, 0);
    URL.revokeObjectURL(url);
    return ctx.getImageData(0, 0, cnv.width, cnv.height);
  } else {
    const sharp = require_lib();
    let img = sharp(file);
    if (stripAlpha) {
      img.removeAlpha();
    }
    let decoded = await img.raw().toBuffer({ resolveWithObject: true });
    let pixbuf = new Uint8ClampedArray(decoded.data.buffer, decoded.data.byteOffset, decoded.data.byteLength);
    return makeImageData(pixbuf, decoded.info.width, decoded.info.height);
  }
}
async function pixelsToDataUrl(imgdata) {
  if (typeof HTMLCanvasElement != "undefined") {
    let cnv = document.createElement("canvas");
    cnv.width = imgdata.width;
    cnv.height = imgdata.height;
    let ctx = cnv.getContext("2d", { willReadFrequently: true });
    ctx.putImageData(imgdata, 0, 0);
    return cnv.toDataURL("image/png");
  } else {
    const sharp = require_lib();
    let pngfile = await sharp(imgdata.data, { raw: { width: imgdata.width, height: imgdata.height, channels: 4 } }).png().toBuffer();
    return "data:image/png;base64," + pngfile.toString("base64");
  }
}
async function canvasToImageFile(cnv, format, quality) {
  let blob = await new Promise((r) => cnv.toBlob(r, `image/${format}`, quality));
  if (!blob) {
    throw new Error("image compression failed");
  }
  let buf = await blob.arrayBuffer();
  return Buffer.from(buf);
}
function flipImage(img) {
  let stride = img.width * 4;
  let tmp = new Uint8Array(stride);
  for (let y = 0; y < img.height / 2; y++) {
    let itop = y * stride;
    let ibot = (img.height - 1 - y) * stride;
    tmp.set(img.data.slice(itop, itop + stride), 0);
    img.data.copyWithin(itop, ibot, ibot + stride);
    img.data.set(tmp, ibot);
  }
}
function dumpTexture(img, flip = false) {
  let cnv = document.createElement("canvas");
  let ctx = cnv.getContext("2d", { willReadFrequently: true });
  if (flip) {
    if (!(img instanceof ImageData)) {
      throw new Error("can only flip imagedata textures");
    }
    flipImage(img);
  }
  drawTexture(ctx, img);
  cnv.style.cssText = "position:absolute;top:0px;left:0px;border:1px solid red;background:purple;";
  document.body.appendChild(cnv);
  cnv.onclick = (e) => {
    navigator.clipboard.write([
      new ClipboardItem({ "image/png": new Promise((d) => cnv.toBlob(d)) })
    ]);
    cnv.remove();
  };
  return cnv;
}
globalThis.dumptex = dumpTexture;
function drawTexture(ctx, img) {
  const cnv = ctx.canvas;
  if ("data" in img) {
    if (typeof ImageData != "undefined" && !(img instanceof ImageData)) {
      img = new ImageData(img.data, img.width, img.height);
    }
    cnv.width = img.width;
    cnv.height = img.height;
    ctx.putImageData(img, 0, 0);
  } else if ("source" in img) {
    cnv.width = img.source.data.width;
    cnv.height = img.source.data.height;
    ctx.drawImage(img.source.data, 0, 0);
  } else {
    cnv.width = img.width;
    cnv.height = img.height;
    ctx.drawImage(img, 0, 0);
  }
}

// rsmv/src/viewer/threejsrender.ts
import { boundMethod as boundMethod6 } from "autobind-decorator";
import { GLTFExporter } from "three/examples/jsm/exporters/GLTFExporter.js";
import { STLExporter } from "three/examples/jsm/exporters/STLExporter.js";
import { BufferGeometry as BufferGeometry8, Clock as Clock2, Group as Group5, Mesh as Mesh9, PerspectiveCamera as PerspectiveCamera3, Texture as Texture5, Vector3 as Vector313 } from "three";

// rsmv/src/viewer/vr360camera.ts
import { Camera, CubeCamera, DoubleSide, LinearFilter, Mesh, PlaneGeometry, RawShaderMaterial, RGBAFormat, WebGLCubeRenderTarget } from "three";
var EquirectangularMaterial = class extends RawShaderMaterial {
  constructor() {
    super({
      //TODO check if typings are wrong here
      //@ts-ignore
      uniforms: { map: { type: "t", value: null } },
      vertexShader: `
				attribute vec3 position;
				varying vec2 vUv;
				void main()  {
					vUv = vec2(position.x,position.y);
					gl_Position = vec4(position, 1.0);
				}`,
      fragmentShader: `
				precision mediump float;
				uniform samplerCube map;
				varying vec2 vUv;
				#define M_PI 3.1415926535897932384626433832795
				void main() {
					float longitude = vUv.x * M_PI;
					float latitude = vUv.y * 0.5 * M_PI;
					vec3 dir = vec3(sin(longitude) * cos(latitude), sin(latitude), -cos(longitude) * cos(latitude));
					normalize(dir);
					gl_FragColor = textureCube(map, dir);
				}`,
      side: DoubleSide,
      transparent: true
    });
    this.transparent = true;
  }
};
var VR360Render = class {
  constructor(parent, size, near, far) {
    this.size = size;
    let gl = parent.getContext();
    this.cubeRenderTarget = new WebGLCubeRenderTarget(size, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      format: RGBAFormat,
      colorSpace: parent.outputColorSpace,
      samples: 0
      //gl.getParameter(gl.SAMPLES)//three.js crashes if using multisampled here
    });
    this.cubeRenderTarget.isXRRenderTarget = true;
    this.cubeCamera = new CubeCamera(near, far, this.cubeRenderTarget);
    this.skyCubeCamera = new CubeCamera(near, far, this.cubeRenderTarget);
    this.quad = new Mesh(new PlaneGeometry(2, 2), new EquirectangularMaterial());
    this.quad.frustumCulled = false;
    this.projectCamera = new Camera();
  }
  render(renderer) {
    this.quad.material.uniforms.map.value = this.cubeCamera.renderTarget.texture;
    renderer.render(this.quad, this.projectCamera);
  }
};

// rsmv/src/constants.ts
var cacheMajors = {
  framemaps: 1,
  config: 2,
  interfaces: 3,
  mapsquares: 5,
  oldmodels: 7,
  sprites: 8,
  clientscript: 12,
  sounds: 14,
  objects: 16,
  enums: 17,
  npcs: 18,
  items: 19,
  sequences: 20,
  spotanims: 21,
  structs: 22,
  quickchat: 24,
  materials: 26,
  particles: 27,
  worldmap: 23,
  music: 40,
  models: 47,
  frames: 48,
  texturesOldPng: 9,
  texturesOldCompoundPng: 37,
  textures2015Png: 43,
  textures2015CompoundPng: 44,
  textures2015Dds: 45,
  textures2015CompoundPngMips: 46,
  textures2015CompoundDds: 50,
  textures2015PngMips: 51,
  texturesDds: 52,
  texturesPng: 53,
  texturesBmp: 54,
  texturesKtx: 55,
  skeletalAnims: 56,
  achievements: 57,
  cutscenes: 66,
  index: 255
};
var latestBuildNumber = 940;
var cacheMapFiles = {
  locations: 0,
  squares: 3,
  squaresWater: 4,
  square_nxt: 5,
  env: 6
};
var cacheConfigPages = {
  mapunderlays: 1,
  identityKit: 3,
  mapoverlays: 4,
  params: 11,
  environments: 29,
  animgroups: 32,
  mapscenes: 34,
  maplabels: 36,
  dbtables: 40,
  dbrows: 41,
  varplayer: 60,
  varnpc: 61,
  varclient: 62,
  varworld: 63,
  varregion: 64,
  varobject: 65,
  varclan: 66,
  varclansettings: 67,
  varcampaign: 68,
  varplayergroup: 75,
  varbits: 69,
  //used before 488 (feb 2008)
  locs_old: 6,
  npcs_old: 9,
  items_old: 10,
  spotanim_old: 13
};
var lastLegacyBuildnr = 377;
var lastClassicBuildnr = 235;

// rsmv/src/opcode_reader.ts
var BufferTypes = {
  buffer: { constr: Buffer },
  //Buffer typings doesn't have BYTES_PER_ELEMENT
  hex: { constr: Uint8Array },
  //used to debug into json file
  byte: { constr: Int8Array },
  ubyte: { constr: Uint8Array },
  short: { constr: Int16Array },
  ushort: { constr: Uint16Array },
  int: { constr: Int32Array },
  uint: { constr: Uint32Array },
  float: { constr: Float32Array }
};
var debugdata = null;
function resolveAlias(typename, parent, typedef2) {
  if (!Object.hasOwn(typedef2, typename)) {
    throw new Error(`Type '${typename}' not found in typedef.json`);
  }
  let newtype = typedef2[typename];
  if (typeof newtype != "string") {
    return buildParser(parent, newtype, typedef2);
  } else if (Object.hasOwn(parserPrimitives, newtype)) {
    return parserPrimitives[newtype];
  } else {
    return resolveAlias(newtype, parent, typedef2);
  }
}
function buildParser(parent, chunkdef, typedef2) {
  parent ??= () => {
    throw new Error("reference failed to resolve");
  };
  switch (typeof chunkdef) {
    case "boolean":
    case "number":
      return literalValueParser(chunkdef);
    case "string": {
      if (Object.hasOwn(parserPrimitives, chunkdef)) {
        return parserPrimitives[chunkdef];
      } else {
        return resolveAlias(chunkdef, parent, typedef2);
      }
    }
    case "object":
      if (chunkdef == null) {
        return literalValueParser(null);
      } else if (!Array.isArray(chunkdef)) {
        return opcodesParser(chunkdef, parent, typedef2);
      } else {
        if (chunkdef.length < 1) throw new Error(`'read' variables must either be a valid type-defining string, an array of type-defining strings / objects, or a valid type-defining object: ${JSON.stringify(chunkdef)}`);
        let args = chunkdef.slice(1);
        if (parserFunctions[chunkdef[0]]) {
          return parserFunctions[chunkdef[0]](args, parent, typedef2);
        }
      }
    default:
      throw new Error(`'read' variables must either be a valid type-defining string, an array of type-defining strings / objects, or a valid type-defining object: ${JSON.stringify(chunkdef)}`);
  }
}
function opcodesParser(chunkdef, parent, typedef2) {
  let r = {
    read(state) {
      let r2 = {};
      let hidden = { $opcode: 0 };
      state.stack.push(r2);
      state.hiddenstack.push(hidden);
      if (debugdata && !debugdata.rootstate) {
        debugdata.rootstate = r2;
      }
      while (true) {
        if (state.scan == state.endoffset) {
          if (!hasexplicitnull) {
            console.log("ended reading opcode struct at end of file without 0x00 opcode");
          }
          break;
        }
        let opt = opcodetype.read(state);
        hidden.$opcode = opt;
        if (!hasexplicitnull && opt == 0) {
          break;
        }
        let parser = map.get(opt);
        if (debugdata) {
          debugdata.opcodes.push({ op: parser ? parser.key : `_0x${opt.toString(16)}_`, index: state.scan - 1, stacksize: state.stack.length });
        }
        if (!parser) {
          throw new Error("unknown chunk 0x" + opt.toString(16).toUpperCase());
        }
        r2[parser.key] = parser.parser.read(state);
      }
      state.stack.pop();
      state.hiddenstack.pop();
      return r2;
    },
    write(state, value) {
      if (typeof value != "object" || !value) {
        throw new Error("oject expected");
      }
      state.stack.push(value);
      state.hiddenstack.push({});
      for (let key in value) {
        if (key.startsWith("$")) {
          continue;
        }
        let opt = opts[key];
        if (!opt) {
          throw new Error("unknown property " + key);
        }
        opcodetype.write(state, opt.op);
        opt.parser.write(state, value[key]);
      }
      if (!hasexplicitnull) {
        opcodetype.write(state, 0);
      }
      state.stack.pop();
      state.hiddenstack.pop();
    },
    getTypescriptType(indent) {
      let r2 = "{\n";
      let newindent = indent + "	";
      for (let val of map.values()) {
        r2 += newindent + val.key + "?: " + val.parser.getTypescriptType(newindent) + " | null\n";
      }
      r2 += indent + "}";
      return r2;
    },
    getJsonSchema() {
      return {
        type: "object",
        properties: Object.fromEntries(
          [...map.values()].filter((prop) => !prop.key.startsWith("$")).map((prop) => {
            return [prop.key, { oneOf: [prop.parser.getJsonSchema(), { type: "null" }] }];
          })
        )
      };
    }
  };
  let resolveReference = function(targetprop, name, childresolve) {
    let result = {
      stackdepth: childresolve.stackdepth + 1,
      resolve(v, oldvalue) {
        if (typeof v != "object" || !v) {
          throw new Error("object expected");
        }
        let res = v[targetprop];
        return childresolve.resolve(res, oldvalue);
      }
    };
    if (name == "$opcode" || Object.prototype.hasOwnProperty.call(opts, name)) {
      refs[name] ??= [];
      refs[name].push(result);
      return result;
    } else {
      return buildReference(name, parent, result);
    }
  };
  let refs = {};
  let opcodetype = buildParser(null, chunkdef["$opcode"] ?? "unsigned byte", typedef2);
  let opts = {};
  for (let key in chunkdef) {
    if (key.startsWith("$")) {
      continue;
    }
    let op = chunkdef[key];
    if (typeof op != "object" || !op) {
      throw new Error("op name expected");
    }
    let opname = op["name"];
    if (typeof opname != "string") {
      throw new Error("op name expected");
    }
    if (opts[opname]) {
      throw new Error("duplicate opcode key " + opname);
    }
    opts[opname] = {
      op: parseInt(key),
      parser: buildParser(resolveReference.bind(null, key), op["read"], typedef2)
    };
  }
  let map = /* @__PURE__ */ new Map();
  for (let key in opts) {
    let opt = opts[key];
    map.set(opt.op, { key, parser: opt.parser });
  }
  let hasexplicitnull = !!map.get(0);
  return r;
}
function tuppleParser(args, parent, typedef2) {
  let r = {
    read(state) {
      let r2 = [];
      for (let prop of props) {
        let v = prop.read(state);
        r2.push(v);
      }
      return r2;
    },
    write(state, value) {
      if (!Array.isArray(value)) {
        throw new Error("array expected");
      }
      for (let [i, prop] of props.entries()) {
        prop.write(state, value[i]);
      }
    },
    getTypescriptType(indent) {
      let r2 = "[\n";
      let newindent = indent + "	";
      for (let prop of props) {
        r2 += newindent + prop.getTypescriptType(newindent) + ",\n";
      }
      r2 += indent + "]";
      return r2;
    },
    getJsonSchema() {
      return {
        type: "array",
        items: Object.entries(props).map(([k, v]) => v.getJsonSchema()),
        minItems: Object.keys(props).length,
        maxItems: Object.keys(props).length
      };
    }
  };
  const resolveReference = function(index, name, child) {
    return buildReference(name, parent, {
      stackdepth: child.stackdepth,
      resolve(v, old) {
        if (!Array.isArray(v)) {
          throw new Error("Array expected");
        }
        return child.resolve(v[index], old);
      }
    });
  };
  let props = args.map((d, i) => buildParser(resolveReference.bind(null, i), d, typedef2));
  return r;
}
function buildReference(name, container, startingpoint) {
  if (!container) {
    throw new Error("reference " + name + " could not be resolved");
  }
  return container(name, startingpoint);
}
function refgetter(refparent, propname, resolve3) {
  let final = buildReference(propname, refparent, { stackdepth: 0, resolve: resolve3 });
  let depth = final.stackdepth;
  let hidden = propname.startsWith("$");
  return {
    read(state) {
      let stack = hidden ? state.hiddenstack : state.stack;
      return stack[stack.length - depth][propname];
    },
    write(state, newvalue) {
      if (state.isWrite && !hidden) {
        throw new Error(`can update ref values in write mode when they are hidden (prefixed with $) in ${propname}`);
      }
      let stack = hidden ? state.hiddenstack : state.stack;
      stack[stack.length - depth][propname] = newvalue;
    }
  };
}
function structParser(args, parent, typedef2) {
  let refs = {};
  let r = {
    read(state) {
      let r2 = {};
      let hidden = {};
      state.stack.push(r2);
      state.hiddenstack.push(hidden);
      if (debugdata && !debugdata.rootstate) {
        debugdata.rootstate = r2;
      }
      for (let key of keys) {
        if (debugdata) {
          debugdata.opcodes.push({ op: key, index: state.scan, stacksize: state.stack.length });
        }
        let v = props[key].read(state);
        if (v !== void 0) {
          if (key[0] == "$") {
            hidden[key] = v;
          } else {
            r2[key] = v;
          }
        }
      }
      state.stack.pop();
      state.hiddenstack.pop();
      return r2;
    },
    write(state, value) {
      if (typeof value != "object" || !value) {
        throw new Error("object expected");
      }
      let hiddenvalue = {};
      state.stack.push(value);
      state.hiddenstack.push(hiddenvalue);
      for (let key of keys) {
        let propvalue = value[key];
        let prop = props[key];
        if (key.startsWith("$")) {
          if (prop.readConst != void 0) {
            propvalue = prop.readConst(state);
          } else {
            let refarray = refs[key];
            if (!refarray) {
              throw new Error("cannot write hidden values if they are not constant or not referenced");
            }
            propvalue ??= 0;
            for (let ref of refarray) {
              propvalue = ref.resolve(value, propvalue);
            }
          }
          hiddenvalue[key] = propvalue;
        }
        prop.write(state, propvalue);
      }
      state.stack.pop();
      state.hiddenstack.pop();
    },
    getTypescriptType(indent) {
      let r2 = "{\n";
      let newindent = indent + "	";
      for (let key of keys) {
        if (key[0] == "$") {
          continue;
        }
        r2 += newindent + key + ": " + props[key].getTypescriptType(newindent) + ",\n";
      }
      r2 += indent + "}";
      return r2;
    },
    getJsonSchema() {
      return {
        type: "object",
        properties: Object.fromEntries(
          [...Object.entries(props)].filter(([key]) => !key.startsWith("$")).map(([key, prop]) => [key, prop.getJsonSchema()])
        ),
        required: keys.filter((k) => !k.startsWith("$"))
      };
    }
  };
  let resolveReference = function(targetprop, name, childresolve) {
    let result = {
      stackdepth: childresolve.stackdepth + 1,
      resolve(v, oldvalue) {
        if (typeof v != "object" || !v) {
          throw new Error("object expected");
        }
        let res = v[targetprop];
        return childresolve.resolve(res, oldvalue);
      }
    };
    if (Object.prototype.hasOwnProperty.call(props, name)) {
      refs[name] ??= [];
      refs[name].push(result);
      return result;
    } else {
      return buildReference(name, parent, result);
    }
  };
  let props = {};
  for (let propdef of args) {
    if (!Array.isArray(propdef) || propdef.length != 2) {
      throw new Error("each struct args should be a [name,type] pair");
    }
    if (typeof propdef[0] != "string") {
      throw new Error("prop name should be string");
    }
    if (props[propdef[0]]) {
      throw new Error("duplicate struct prop " + propdef[0]);
    }
    props[propdef[0]] = buildParser(resolveReference.bind(null, propdef[0]), propdef[1], typedef2);
  }
  let keys = Object.keys(props);
  return r;
}
function optParser(args, parent, typedef2) {
  let r = {
    read(state) {
      let matchindex = condchecker.match(state);
      if (matchindex == -1) {
        return null;
      }
      return type.read(state);
    },
    write(state, value) {
      if (value != null) {
        return type.write(state, value);
      }
    },
    getTypescriptType(indent) {
      return type.getTypescriptType(indent) + " | null";
    },
    getJsonSchema() {
      return {
        oneOf: [
          type.getJsonSchema(),
          { type: "null" }
        ]
      };
    }
  };
  let resolveReference = function(name, child) {
    return buildReference(name, parent, {
      stackdepth: child.stackdepth,
      resolve(v, old) {
        return v != null ? child.resolve(v, old) : old;
      }
    });
  };
  if (args.length < 2) throw new Error(`2 arguments exptected for proprety with type opt`);
  let arg1 = args[0];
  let condstr = "";
  if (typeof arg1 == "string") {
    condstr = arg1;
  } else {
    let condvar;
    let condvalue;
    let cmpmode = "eq";
    if (Array.isArray(arg1)) {
      if (typeof arg1[1] != "number") {
        throw new Error("only literal ints as condition value are supported");
      }
      condvar = arg1[0];
      cmpmode = arg1[2] ?? "eq";
      condvalue = arg1[1];
    } else {
      if (typeof arg1 != "number") {
        throw new Error("");
      }
      condvar = "$opcode";
      condvalue = arg1;
    }
    let condmap = {
      bitand: "&=",
      bitflag: "&",
      bitflagnot: "!&",
      bitor: "&",
      eq: "==",
      eqnot: "!=",
      gteq: ">=",
      lteq: "<="
    };
    let mapped = condmap[cmpmode];
    if (cmpmode == "bitflag" || cmpmode == "bitflagnot") {
      condvalue = 1 << condvalue;
    }
    condstr = `${condvar}${mapped}${condvalue}`;
  }
  let condchecker = conditionParser(resolveReference, [condstr], (v) => v == null ? -1 : 0);
  let type = buildParser(resolveReference, args[1], typedef2);
  return r;
}
function chunkedArrayParser(args, parent, typedef2) {
  let r = {
    read(state) {
      let len = lengthtype.read(state);
      let r2 = [];
      let hiddenprops = [];
      for (let chunkindex = 0; chunkindex < chunktypes.length; chunkindex++) {
        let proptype = chunktypes[chunkindex];
        if (debugdata) {
          debugdata.opcodes.push({ op: Object.keys(proptype).join(), index: state.scan, stacksize: state.stack.length });
        }
        for (let i = 0; i < len; i++) {
          let hidden;
          let obj;
          if (chunkindex == 0) {
            obj = {};
            r2.push(obj);
            hidden = {};
            hiddenprops.push(hidden);
          } else {
            obj = r2[i];
            hidden = hiddenprops[i];
          }
          state.stack.push(obj);
          state.hiddenstack.push(hidden);
          for (let key in proptype) {
            let value = proptype[key].read(state);
            if (key.startsWith("$")) {
              hidden[key] = value;
            } else {
              obj[key] = value;
            }
          }
          state.stack.pop();
          state.hiddenstack.pop();
        }
      }
      return r2;
    },
    write(state, v) {
      if (!Array.isArray(v)) {
        throw new Error("array expected");
      }
      lengthtype.write(state, v.length);
      let hiddenprops = [];
      for (let chunkindex = 0; chunkindex < chunktypes.length; chunkindex++) {
        let proptype = chunktypes[chunkindex];
        for (let i = 0; i < v.length; i++) {
          let entry = v[i];
          let hiddenvalue = chunkindex == 0 ? hiddenprops[i] = {} : hiddenprops[i];
          state.stack.push(entry);
          state.hiddenstack.push(hiddenvalue);
          if (typeof entry != "object" || !entry) {
            throw new Error("object expected");
          }
          for (let key in proptype) {
            let prop = proptype[key];
            let propvalue = entry[key];
            if (key.startsWith("$")) {
              if (prop.readConst != void 0) {
                propvalue = prop.readConst(state);
              } else {
                let refarray = refs[key];
                if (!refarray) {
                  throw new Error("cannot write hidden values if they are not constant or not referenced");
                }
                propvalue ??= 0;
                for (let ref of refarray) {
                  propvalue = ref.resolve(entry, propvalue);
                }
              }
              hiddenvalue[key] = propvalue;
            }
            prop.write(state, propvalue);
          }
          state.stack.pop();
          state.hiddenstack.pop();
        }
      }
    },
    getTypescriptType(indent) {
      let r2 = "{\n";
      let newindent = indent + "	";
      for (let [key, prop] of Object.entries(fullobj)) {
        if (key[0] == "$") {
          continue;
        }
        r2 += newindent + key + ": " + prop.getTypescriptType(newindent) + ",\n";
      }
      r2 += indent + "}[]";
      return r2;
    },
    getJsonSchema() {
      return {
        type: "array",
        items: {
          type: "object",
          properties: Object.fromEntries(
            [...Object.entries(fullobj)].filter(([key]) => !key.startsWith("$")).map(([key, prop]) => [key, prop.getJsonSchema()])
          ),
          required: keys.filter((k) => !k.startsWith("$"))
        }
      };
    }
  };
  const resolveLength = function(prop, childresolve) {
    return buildReference(prop, parent, {
      stackdepth: childresolve.stackdepth,
      resolve(v, old) {
        if (!Array.isArray(v)) {
          throw new Error("array expected");
        }
        return childresolve.resolve(v.length, old);
      }
    });
  };
  const resolveReference = function(targetprop, name, childresolve) {
    let result = {
      stackdepth: childresolve.stackdepth + 1,
      resolve(v, oldvalue) {
        if (typeof v != "object" || !v) {
          throw new Error("object expected");
        }
        let res = v[targetprop];
        return childresolve.resolve(res, oldvalue);
      }
    };
    if (Object.prototype.hasOwnProperty.call(fullobj, name)) {
      refs[name] ??= [];
      refs[name].push(result);
      return result;
    } else {
      return buildReference(name, parent, result);
    }
  };
  let rawchunks = args.slice(1);
  let lengthtype = buildParser(resolveLength, args[0], typedef2);
  let refs = {};
  let fullobj = {};
  let chunktypes = [];
  for (let chunk of rawchunks) {
    if (!Array.isArray(chunk)) {
      throw new Error("each argument for composed chunk should be an array");
    }
    let group = {};
    chunktypes.push(group);
    for (let propdef of chunk) {
      if (!Array.isArray(propdef) || propdef.length != 2 || typeof propdef[0] != "string") {
        throw new Error("each composedchunk should be a [name,type] pair");
      }
      let p = buildParser(resolveReference.bind(null, propdef[0]), propdef[1], typedef2);
      group[propdef[0]] = p;
      fullobj[propdef[0]] = p;
    }
  }
  let keys = chunktypes.flatMap(Object.keys);
  return r;
}
function bufferParserValue(value, type, scalartype) {
  if (typeof value == "string") {
    if (scalartype == "hex") {
      return Buffer.from(value, "hex");
    } else {
      let m = value.match(/^buffer ([\w\[\]]+){([\d,\-\.]*)}/);
      if (!m) {
        throw new Error("invalid arraybuffer string");
      }
      return new type.constr(m[2].split(",").map((q) => +q));
    }
  }
  if (!(value instanceof type.constr)) {
    throw new Error("arraybuffer expected");
  }
  return value;
}
function bufferParser(args, parent, typedef2) {
  let r = {
    read(state) {
      let len = lengthtype.read(state);
      let bytelen = len * vectorLength * type.constr.BYTES_PER_ELEMENT;
      let backing = new ArrayBuffer(bytelen);
      if (state.scan + bytelen > state.endoffset) {
        throw new Error("trying to read outside buffer bounds");
      }
      let bytes = Buffer.from(backing);
      bytes.set(state.buffer.subarray(state.scan, state.scan + bytelen));
      state.scan += bytelen;
      let array2 = scalartype == "buffer" ? bytes : new type.constr(backing);
      if (scalartype == "hex") {
        array2.toJSON = () => bytes.toString("hex");
      } else if (state.args.keepBufferJson === true) {
        array2.toJSON = () => `buffer ${scalartype}${vectorLength != 1 ? `[${vectorLength}]` : ""}[${len}]`;
      } else {
        array2.toJSON = () => `buffer ${scalartype}${vectorLength != 1 ? `[${vectorLength}]` : ""}[]{${[...array2].join(",")}}`;
      }
      return array2;
    },
    write(state, rawvalue) {
      let value = bufferParserValue(rawvalue, type, scalartype);
      if (value.length % vectorLength != 0) {
        throw new Error("araybuffer is not integer multiple of vectorlength");
      }
      lengthtype.write(state, value.length / vectorLength);
      let bytes = new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
      state.buffer.set(bytes, state.scan);
      state.scan += bytes.byteLength;
    },
    getTypescriptType(indent) {
      return type.constr.name;
    },
    getJsonSchema() {
      return { type: "string" };
    }
  };
  const resolveLengthReference = function(name, child) {
    return buildReference(name, parent, {
      stackdepth: child.stackdepth,
      resolve(rawvalue, old) {
        let value = bufferParserValue(rawvalue, type, scalartype);
        return child.resolve(value.length / vectorLength, old);
      }
    });
  };
  if (args.length < 1) throw new Error(`'read' variables interpretted as an array must contain items: ${JSON.stringify(args)}`);
  let typestring = args[1] ?? "buffer";
  let lenarg = args[2] ?? 1;
  if (typeof typestring != "string" || !Object.hasOwn(BufferTypes, typestring)) {
    throw new Error("unknown buffer type " + args[1]);
  }
  if (typeof lenarg != "number") {
    throw new Error("vectorlength should be a number");
  }
  let vectorLength = lenarg;
  let scalartype = typestring;
  let lengthtype = buildParser(resolveLengthReference, args[0], typedef2);
  const type = BufferTypes[typestring];
  return r;
}
function arrayParser(args, parent, typedef2) {
  let r = {
    read(state) {
      let len = lengthtype.read(state);
      let r2 = [];
      for (let i = 0; i < len; i++) {
        r2.push(subtype.read(state));
      }
      return r2;
    },
    write(state, value) {
      if (!Array.isArray(value)) {
        throw new Error("array expected");
      }
      lengthtype.write(state, value.length);
      for (let i = 0; i < value.length; i++) {
        subtype.write(state, value[i]);
      }
    },
    getTypescriptType(indent) {
      return `${subtype.getTypescriptType(indent)}[]`;
    },
    getJsonSchema() {
      return {
        type: "array",
        items: subtype.getJsonSchema()
      };
    }
  };
  const resolveLengthReference = function(name, child) {
    return buildReference(name, parent, {
      stackdepth: child.stackdepth,
      resolve(v, old) {
        if (!Array.isArray(v)) {
          throw new Error("array expected");
        }
        return child.resolve(v.length, old);
      }
    });
  };
  const resolvePropReference = function(name, child) {
    return buildReference(name, parent, {
      stackdepth: child.stackdepth,
      resolve(v, old) {
        if (!Array.isArray(v)) {
          throw new Error("array expected");
        }
        return child.resolve(v[0], old);
      }
    });
  };
  if (args.length < 1) throw new Error(`'read' variables interpretted as an array must contain items: ${JSON.stringify(args)}`);
  let sizearg = args.length >= 2 ? args[0] : "variable unsigned short";
  let lengthtype = buildParser(resolveLengthReference, sizearg, typedef2);
  let subtype = buildParser(resolvePropReference, args[args.length >= 2 ? 1 : 0], typedef2);
  return r;
}
function arrayNullTerminatedParser(args, parent, typedef2) {
  let r = {
    read(state) {
      let r2 = [];
      let ctx = { $opcode: 0 };
      state.hiddenstack.push(ctx);
      state.stack.push({});
      while (true) {
        let oldscan = state.scan;
        let header = lengthtype.read(state);
        if (debugdata) {
          debugdata.opcodes.push({ op: "$opcode", index: oldscan, stacksize: state.stack.length });
        }
        ctx.$opcode = header;
        let endint = endvalue.read(state);
        if (header == endint) {
          break;
        }
        r2.push(subtype.read(state));
      }
      state.hiddenstack.pop();
      state.stack.pop();
      return r2;
    },
    write(state, value) {
      if (!Array.isArray(value)) {
        throw new Error("array expected");
      }
      state.stack.push(value);
      state.hiddenstack.push({});
      for (let prop of value) {
        lengthtype.write(state, 1);
        subtype.write(state, prop);
      }
      lengthtype.write(state, 0);
      state.stack.pop();
      state.hiddenstack.pop();
    },
    getTypescriptType(indent) {
      return `${subtype.getTypescriptType(indent)}[]`;
    },
    getJsonSchema() {
      return {
        type: "array",
        items: subtype.getJsonSchema()
      };
    }
  };
  const resolveReference = function(name, child) {
    if (name == "$opcode") {
      return {
        stackdepth: child.stackdepth + 1,
        resolve(v, old) {
          throw new Error("not implemented");
        }
      };
    }
    return buildReference(name, parent, {
      stackdepth: child.stackdepth + 1,
      resolve(v, old) {
        if (!Array.isArray(v)) {
          throw new Error("array expected");
        }
        return child.resolve(v[0], old);
      }
    });
  };
  if (args.length < 1) throw new Error(`'read' variables interpretted as an array must contain items: ${JSON.stringify(args)}`);
  let sizearg = args.length >= 2 ? args[0] : "variable unsigned short";
  let endintarg = args.length >= 3 ? args[1] : 0;
  let lengthtype = buildParser(null, sizearg, typedef2);
  let endvalue = buildParser(null, endintarg, typedef2);
  let subtype = buildParser(resolveReference, args[args.length - 1], typedef2);
  return r;
}
function literalValueParser(constvalue) {
  if (typeof constvalue != "number" && typeof constvalue != "string" && typeof constvalue != "boolean" && constvalue != null) {
    throw new Error("only bool, number, string or null literals allowed");
  }
  let r = {
    read(state) {
      return constvalue;
    },
    readConst() {
      return constvalue;
    },
    write(state, value) {
      if (value != constvalue) throw new Error(`expected constant ${constvalue} was not present during write`);
    },
    getTypescriptType() {
      return JSON.stringify(constvalue);
    },
    getJsonSchema() {
      return { const: constvalue };
    }
  };
  return r;
}
function referenceValueParser(args, parent, typedef2) {
  let read = (state) => {
    let value = ref.read(state);
    if (minbit != -1) {
      value = value >> minbit & ~(~0 << bitlength);
    }
    return value + offset;
  };
  let r = {
    read,
    readConst: read,
    write(state, value) {
    },
    getTypescriptType() {
      return "number";
    },
    getJsonSchema() {
      return {
        type: "integer",
        minimum: bitlength == -1 ? void 0 : 0,
        maximum: bitlength == -1 ? void 0 : 2 ** bitlength - 1
      };
    }
  };
  if (args.length < 1) throw new Error(`1 argument exptected for proprety with type ref`);
  if (typeof args[0] != "string") {
    throw new Error("ref propname expected");
  }
  let propname = args[0];
  let [minbit, bitlength] = [-1, -1];
  if (args[1]) {
    if (Array.isArray(args[1]) && args[1].length == 2 && typeof args[1][0] == "number" && typeof args[1][1] == "number") {
      minbit = args[1][0];
      bitlength = args[1][1];
    } else {
      throw new Error("second argument for ref should be [minbit,bitlen] pair");
    }
  }
  let offset = args[2] ?? 0;
  if (typeof offset != "number") {
    throw new Error("ref offset should be a number");
  }
  let ref = refgetter(parent, propname, (v, old) => {
    if (typeof v != "number") {
      throw new Error("number expected");
    }
    if (minbit != -1) {
      let mask = ~(-1 << bitlength) << minbit;
      return old & ~mask | v << minbit;
    } else {
      return v;
    }
  });
  return r;
}
function bytesRemainingParser() {
  return {
    read(state) {
      return state.endoffset - state.scan;
    },
    write(state, value) {
    },
    getTypescriptType() {
      return "number";
    },
    getJsonSchema() {
      return { type: "integer" };
    }
  };
}
function intAccumolatorParser(args, parent, typedef2) {
  let r = {
    read(state) {
      let increment = value.read(state);
      let newvalue;
      let refvalue = ref.read(state) ?? 0;
      if (mode == "add" || mode == "add-1" || mode == "postadd") {
        newvalue = refvalue + (increment ?? 0) + (mode == "add-1" ? -1 : 0);
      } else if (mode == "hold") {
        newvalue = increment ?? refvalue;
      } else {
        throw new Error("unknown accumolator mode");
      }
      ref.write(state, newvalue);
      return mode == "postadd" ? refvalue : newvalue;
    },
    write(state, v) {
      if (typeof v != "number") {
        throw new Error("number expected");
      }
      let refvalue = ref.read(state) ?? 0;
      let increment;
      if (mode == "add" || mode == "add-1") {
        increment = v - refvalue + (mode == "add-1" ? 1 : 0);
      } else if (mode == "hold") {
        throw new Error("writing accum intaccum hold not implemented");
      } else if (mode == "postadd") {
        throw new Error("writing accum intaccum postadd not implemented");
      } else {
        throw new Error("unknown accumolator mode");
      }
      value.write(state, increment);
      ref.write(state, v);
    },
    getTypescriptType() {
      return "number";
    },
    getJsonSchema() {
      return { type: "integer" };
    }
  };
  if (args.length < 2) throw new Error(`2 arguments exptected for proprety with type accum`);
  let refname = args[0];
  let value = buildParser(parent, args[1], typedef2);
  let mode = args[2] ?? "add";
  if (typeof refname != "string") {
    throw new Error("ref name should be a string");
  }
  let ref = refgetter(parent, refname, (v, old) => {
    return old;
  });
  return r;
}
function stringParser(prebytes) {
  const encoding = "latin1";
  return {
    read(state) {
      let terminator = getClientVersion(state.args) <= lastLegacyBuildnr ? 10 : 0;
      for (let i = 0; i < prebytes.length; i++, state.scan++) {
        if (state.buffer.readUInt8(state.scan) != prebytes[i]) {
          throw new Error("failed to match string header bytes");
        }
      }
      let end = state.scan;
      while (true) {
        if (end == state.endoffset) {
          throw new Error("reading string without null termination");
        }
        if (state.buffer.readUInt8(end) == terminator) {
          break;
        }
        end++;
      }
      let outputstr = state.buffer.toString(encoding, state.scan, end);
      state.scan = end + 1;
      return outputstr;
    },
    write(state, value) {
      if (typeof value != "string") throw new Error(`string expected`);
      let terminator = getClientVersion(state.args) <= lastLegacyBuildnr ? 10 : 0;
      let writebytes = [
        ...prebytes,
        ...Buffer.from(value, encoding),
        terminator
      ];
      state.buffer.set(writebytes, state.scan);
      state.scan += writebytes.length;
      ;
    },
    getTypescriptType() {
      return "string";
    },
    getJsonSchema() {
      return { type: "string" };
    }
  };
}
function conditionParser(parent, optionstrings, writegetindex) {
  let varmap = [];
  let options = [];
  for (let str of optionstrings) {
    str = str.replace(/\s/g, "");
    let parts = str.split(/&&/g);
    let conds = [];
    for (let opt of parts) {
      let op;
      let varname;
      let value = 0;
      if (opt == "default" || opt == "other") {
        continue;
      } else {
        let m = opt.match(/^((?<var>[\$a-zA-Z]\w*)?(?<op><|<=|>|>=|&|==|=|!&|&=|!=)?)?(?<version>0x[\da-fA=F]+|-?\d+)$/);
        if (!m) {
          throw new Error("invalid match value, expected <op><version>. For example '>10'");
        }
        value = parseInt(m.groups.version);
        op = m.groups.op ?? "=";
        if (op == "==") {
          op = "=";
        }
        varname = m.groups.var ?? "$opcode";
      }
      let varindex = varmap.findIndex((q) => q.name == varname);
      if (varindex == -1) {
        varindex = varmap.length;
        varmap.push({
          name: varname,
          parser: refgetter(parent, varname, (v, oldvalue) => {
            if (!writegetindex) {
              throw new Error("write not implemented");
            }
            let index = writegetindex(v);
            for (let optionindex = 0; optionindex < options.length; optionindex++) {
              let option4 = options[optionindex];
              for (let con of option4) {
                if (con.varindex != varindex) {
                  continue;
                }
                let state = optionindex == index;
                let compValue = con.value;
                switch (con.op) {
                  case "=":
                    oldvalue = state ? compValue : oldvalue;
                    break;
                  case "!=":
                    oldvalue = state ? oldvalue : compValue;
                    break;
                  case "&":
                    oldvalue = state ? oldvalue | compValue : oldvalue & ~compValue;
                    break;
                  case "&=":
                    oldvalue = state ? oldvalue | compValue : oldvalue & ~compValue;
                    break;
                  case "!&":
                    oldvalue = state ? oldvalue & ~compValue : oldvalue | compValue;
                    break;
                  case ">=":
                    oldvalue = state ? Math.max(compValue, oldvalue) : oldvalue;
                    break;
                  case ">":
                    oldvalue = state ? Math.max(compValue + 1, oldvalue) : oldvalue;
                    break;
                  case "<=":
                    oldvalue = state ? Math.min(compValue, oldvalue) : oldvalue;
                    break;
                  case "<":
                    oldvalue = state ? Math.min(compValue - 1, oldvalue) : oldvalue;
                    break;
                  default:
                    throw new Error("unknown condition " + con.op);
                }
              }
            }
            return oldvalue;
          })
        });
      }
      conds.push({ op, value, varname, varindex });
    }
    options.push(conds);
  }
  let match = (state) => {
    let vars = varmap.map((q) => q.parser.read(state));
    for (let optindex = 0; optindex < options.length; optindex++) {
      let opt = options[optindex];
      let matched = true;
      for (let cond of opt) {
        let value = vars[cond.varindex];
        switch (cond.op) {
          case "=":
            matched = value == cond.value;
            break;
          case "!=":
            matched = value != cond.value;
            break;
          case "<":
            matched = value < cond.value;
            break;
          case "<=":
            matched = value <= cond.value;
            break;
          case ">":
            matched = value > cond.value;
            break;
          case ">=":
            matched = value >= cond.value;
            break;
          case "&":
            matched = (value & cond.value) != 0;
            break;
          case "!&":
            matched = (value & cond.value) == 0;
            break;
          case "&=":
            matched = (value & cond.value) == cond.value;
            break;
          default:
            throw new Error("unknown op" + cond.op);
        }
        if (!matched) {
          break;
        }
      }
      if (matched) {
        return optindex;
      }
    }
    return -1;
  };
  return { match };
}
var hardcodes = {
  playeritem: function() {
    return {
      read(state) {
        let byte0 = state.buffer.readUInt8(state.scan++);
        if (byte0 == 0) {
          return 0;
        }
        let byte1 = state.buffer.readUInt8(state.scan++);
        if (byte1 == 255 && byte0 == 255) {
          return -1;
        }
        return byte0 << 8 | byte1;
      },
      write(state, value) {
        if (typeof value != "number") {
          throw new Error("number expected");
        }
        if (value == 0) {
          state.buffer.writeUInt8(0, state.scan++);
        } else {
          state.buffer.writeUint16BE(value == -1 ? 65535 : value & 65535, state.scan);
          state.scan += 2;
        }
      },
      getTypescriptType() {
        return "number";
      },
      getJsonSchema() {
        return { type: "integer", minimum: -1, maximum: 65535 - 16384 - 1 };
      }
    };
  },
  itemvar: function(args) {
    let type = args[0];
    if (typeof type != "string" || !["ref", "matcount", "colorcount", "modelcount"].includes(type)) {
      throw new Error();
    }
    return {
      read(state) {
        let activeitem = typeof state.args.activeitem == "number" ? state.args.activeitem : -1;
        if (type == "ref") {
          activeitem++;
          state.args.activeitem = activeitem;
        }
        if (!Array.isArray(state.args.slots)) {
          throw new Error("");
        }
        let ref = state.args.slots[activeitem];
        if (type == "ref") {
          return ref;
        } else if (type == "matcount") {
          return ref?.replaceMaterials?.length ?? 0;
        } else if (type == "colorcount") {
          return ref?.replaceColors?.length ?? 0;
        } else if (type == "modelcount") {
          return ref?.models.length;
        } else {
          throw new Error();
        }
      },
      write() {
      },
      getTypescriptType() {
        return type == "ref" ? "any" : "number";
      },
      getJsonSchema() {
        return { type: type == "ref" ? "any" : "integer" };
      }
    };
  },
  buildnr: function(args, typedef2) {
    return {
      readConst(state) {
        return getClientVersion(state.args);
      },
      read(state) {
        return getClientVersion(state.args);
      },
      write(state, v) {
      },
      getTypescriptType(indent) {
        return "number";
      },
      getJsonSchema() {
        return { type: "number" };
      }
    };
  },
  match: function(args, parent, typedef2) {
    let r = {
      read(state) {
        let opcodeprop = { $opcode: 0 };
        state.stack.push({});
        state.hiddenstack.push(opcodeprop);
        let value = opvalueparser ? opvalueparser.read(state) : 0;
        opcodeprop.$opcode = value;
        let opindex = conditionparser.match(state);
        if (opindex == -1) {
          throw new Error("no opcode matched");
        }
        let res = optionvalues[opindex].read(state);
        state.stack.pop();
        state.hiddenstack.pop();
        return res;
      },
      write(state, v) {
        let opcodeprop = { $opcode: 0 };
        state.stack.push({});
        state.hiddenstack.push(opcodeprop);
        if (opvalueparser) {
          if (!opvalueparser.readConst) {
            throw new Error("non-const or non-reference match value not implemented in write mode");
          }
          opcodeprop.$opcode = opvalueparser.readConst(state);
        }
        let opindex = conditionparser.match(state);
        if (opindex == -1) {
          throw new Error("no opcode matched");
        }
        optionvalues[opindex].write(state, v);
        state.stack.pop();
        state.hiddenstack.pop();
      },
      getTypescriptType(indent) {
        return "(" + optionvalues.map((opt) => opt.getTypescriptType(indent + "	")).join("|") + ")";
      },
      getJsonSchema() {
        return { anyOf: optionvalues.map((opt) => opt.getJsonSchema()) };
      }
    };
    const resolveReference = function(name, child) {
      let res = {
        stackdepth: child.stackdepth + 1,
        resolve(v, old) {
          throw new Error("write not supported");
        }
      };
      if (name == "$opcode") {
        return res;
      }
      return buildReference(name, parent, res);
    };
    if (args.length == 1) {
      args = [null, args[0]];
    }
    if (args.length != 2) {
      throw new Error("match chunks needs 2 arguments");
    }
    if (typeof args[1] != "object") {
      throw new Error("match chunk requires 2n+2 arguments");
    }
    let opvalueparser = args[0] ? buildParser(resolveReference, args[0], typedef2) : null;
    let conditionstrings = Object.keys(args[1]);
    let optionvalues = Object.values(args[1]).map((q) => buildParser(resolveReference, q, typedef2));
    let conditionparser = conditionParser(resolveReference, conditionstrings);
    return r;
  },
  footer: function(args, parent, typedef2) {
    if (args.length != 2) {
      throw new Error("footer requires length and subtype arguments");
    }
    let lentype = buildParser(parent, args[0], typedef2);
    let subtype = buildParser(parent, args[1], typedef2);
    return {
      read(state) {
        let len = lentype.read(state);
        let oldscan = state.scan;
        let footstart = state.endoffset - len;
        state.scan = footstart;
        if (debugdata) {
          debugdata.opcodes.push({ op: `footer`, index: oldscan, stacksize: state.stack.length + 1, jump: { to: footstart } });
        }
        let res = subtype.read(state);
        if (debugdata) {
          debugdata.opcodes.push({ op: `footer`, index: state.scan, stacksize: state.stack.length + 1, jump: { to: oldscan } });
        }
        if (state.scan != state.endoffset) {
          console.log(`didn't read full footer, ${state.endoffset - state.scan} bytes left`);
        }
        state.scan = oldscan;
        state.endoffset = state.endoffset - len;
        return res;
      },
      write(state, v) {
        let oldscan = state.scan;
        subtype.write(state, v);
        let len = state.scan - oldscan;
        state.buffer.copyWithin(state.endoffset - len, oldscan, state.scan);
        state.scan = oldscan;
        state.endoffset -= len;
      },
      getTypescriptType(indent) {
        return subtype.getTypescriptType(indent);
      },
      getJsonSchema() {
        return subtype.getJsonSchema();
      }
    };
  },
  "tailed varushort": function(args, parent, typedef2) {
    const overflowchunk = 32767;
    return {
      read(state) {
        let sum = 0;
        while (true) {
          let byte0 = state.buffer.readUint8(state.scan++);
          let v;
          if ((byte0 & 128) == 0) {
            v = byte0;
          } else {
            let byte1 = state.buffer.readUint8(state.scan++);
            v = (byte0 & 127) << 8 | byte1;
          }
          sum += v;
          if (v != overflowchunk) {
            return sum;
          }
        }
      },
      write(state, v) {
        if (typeof v != "number") {
          throw new Error("number expected");
        }
        while (v >= 0) {
          let chunk = Math.min(overflowchunk, v);
          if (chunk < 128) {
            state.buffer.writeUint8(chunk, state.scan++);
          } else {
            state.buffer.writeUint16BE(chunk | 32768, state.scan);
            state.scan += 2;
          }
          v -= chunk;
        }
      },
      getTypescriptType(indent) {
        return "number";
      },
      getJsonSchema() {
        return { type: "number" };
      }
    };
  },
  "legacy_maptile": function(args, parent, typedef2) {
    return {
      read(state) {
        let res = {
          flags: 0,
          shape: null,
          overlay: null,
          settings: null,
          underlay: null,
          height: null
        };
        while (true) {
          let op = state.buffer.readUint8(state.scan++);
          if (op == 0) {
            break;
          }
          if (op == 1) {
            res.height = state.buffer.readUint8(state.scan++);
            break;
          }
          if (op >= 2 && op <= 49) {
            res.shape = op - 2;
            res.overlay = state.buffer.readUint8(state.scan);
            state.scan += 1;
          }
          if (op >= 50 && op <= 81) {
            res.settings = op - 49;
          }
          if (op >= 82) {
            res.underlay = op - 81;
          }
        }
        return res;
      },
      write(state) {
        throw new Error("not implemented");
      },
      getTypescriptType(indent) {
        let newindent = indent + "	";
        return `{
${newindent}flags: number,
${newindent}shape: number | null,
${newindent}overlay: number | null,
${newindent}settings: number | null,
${newindent}underlay: number | null,
${newindent}height: number | null,
${indent}}`;
      },
      getJsonSchema() {
        return { type: "any" };
      }
    };
  },
  scriptopt: function(args, parent, typedef2) {
    return {
      read(state) {
        let cali = state.args.clientScriptDeob;
        if (!cali) {
          throw new Error("opcode callibration not set for clientscript with obfuscated opcodes");
        }
        if (debugdata) {
          debugdata.opcodes.push({ op: "opcode", index: state.scan, stacksize: state.stack.length + 1 });
        }
        let res = cali.readOpcode(state);
        return res;
      },
      write(state, v) {
        let cali = state.args.clientScriptDeob;
        ;
        if (!cali) {
          throw new Error("opcode callibration not set for clientscript with obfuscated opcodes");
        }
        cali.writeOpCode(state, v);
      },
      getJsonSchema() {
        return {
          type: "object",
          properties: {
            opcode: { type: "number" },
            imm: { type: "number" },
            imm_obj: { oneOf: [{ type: "number" }, { type: "string" }, { type: "null" }] }
          }
        };
      },
      getTypescriptType(indent) {
        let newindent = indent + "	";
        return `{
${newindent}opcode:number,
${newindent}imm:number,
${newindent}imm_obj:number|string|[number,number]|null,
${indent}}`;
      }
    };
  }
};
function getClientVersion(args) {
  if (typeof args.clientVersion != "number") {
    throw new Error("client version not set");
  }
  return args.clientVersion;
}
var numberTypes = {
  ubyte: {
    read(s) {
      let r = s.buffer.readUInt8(s.scan);
      s.scan += 1;
      return r;
    },
    write(s, v) {
      s.buffer.writeUInt8(v, s.scan);
      s.scan += 1;
    },
    min: 0,
    max: 255
  },
  byte: {
    read(s) {
      let r = s.buffer.readInt8(s.scan);
      s.scan += 1;
      return r;
    },
    write(s, v) {
      s.buffer.writeInt8(v, s.scan);
      s.scan += 1;
    },
    min: -128,
    max: 127
  },
  ushort: {
    read(s) {
      let r = s.buffer.readUInt16BE(s.scan);
      s.scan += 2;
      return r;
    },
    write(s, v) {
      s.buffer.writeUInt16BE(v, s.scan);
      s.scan += 2;
    },
    min: 0,
    max: 2 ** 16 - 1
  },
  short: {
    read(s) {
      let r = s.buffer.readInt16BE(s.scan);
      s.scan += 2;
      return r;
    },
    write(s, v) {
      s.buffer.writeInt16BE(v, s.scan);
      s.scan += 2;
    },
    min: -(2 ** 15),
    max: 2 ** 15 - 1
  },
  uint: {
    read(s) {
      let r = s.buffer.readUInt32BE(s.scan);
      s.scan += 4;
      return r;
    },
    write(s, v) {
      s.buffer.writeUInt32BE(v, s.scan);
      s.scan += 4;
    },
    min: 0,
    max: 2 ** 32 - 1
  },
  int: {
    read(s) {
      let r = s.buffer.readInt32BE(s.scan);
      s.scan += 4;
      return r;
    },
    write(s, v) {
      s.buffer.writeInt32BE(v, s.scan);
      s.scan += 4;
    },
    min: -(2 ** 31),
    max: 2 ** 31 - 1
  },
  uint_le: {
    read(s) {
      let r = s.buffer.readUInt32LE(s.scan);
      s.scan += 4;
      return r;
    },
    write(s, v) {
      s.buffer.writeUint32LE(v, s.scan);
      s.scan += 4;
    },
    min: 0,
    max: 2 ** 32 - 1
  },
  ushort_le: {
    read(s) {
      let r = s.buffer.readUInt16LE(s.scan);
      s.scan += 2;
      return r;
    },
    write(s, v) {
      s.buffer.writeUint16LE(v, s.scan);
      s.scan += 2;
    },
    min: 0,
    max: 2 ** 16 - 1
  },
  utribyte: {
    read(s) {
      let r = s.buffer.readUIntBE(s.scan, 3);
      s.scan += 3;
      return r;
    },
    write(s, v) {
      s.buffer.writeUintBE(v, s.scan, 3);
      s.scan += 3;
    },
    min: 0,
    max: 2 ** 24 - 1
  },
  float: {
    read(s) {
      let r = s.buffer.readFloatBE(s.scan);
      s.scan += 4;
      return r;
    },
    write(s, v) {
      s.buffer.writeFloatBE(v, s.scan);
      s.scan += 4;
    },
    min: Number.MIN_VALUE,
    max: Number.MAX_VALUE
  },
  varushort: {
    read(s) {
      let firstByte = s.buffer.readUInt8(s.scan++);
      if ((firstByte & 128) == 0) {
        return firstByte;
      }
      let secondByte = s.buffer.readUInt8(s.scan++);
      return (firstByte & 127) << 8 | secondByte;
    },
    write(s, v) {
      if (v < 128) {
        s.buffer.writeUInt8(v, s.scan);
        s.scan += 1;
      } else {
        s.buffer.writeUint16BE(v | 32768, s.scan);
        s.scan += 2;
      }
    },
    min: 0,
    max: 2 ** 15 - 1
  },
  varshort: {
    read(s) {
      let firstByte = s.buffer.readUInt8(s.scan++);
      if ((firstByte & 128) == 0) {
        return firstByte << 32 - 7 >> 32 - 7;
      }
      let secondByte = s.buffer.readUInt8(s.scan++);
      return ((firstByte & 127) << 8 | secondByte) << 32 - 15 >> 32 - 15;
    },
    write(s, v) {
      if (v < 64 && v >= -64) {
        s.buffer.writeUInt8(v & 127, s.scan);
        s.scan += 1;
      } else {
        s.buffer.writeInt16BE(v | 32768, s.scan);
        s.scan += 2;
      }
    },
    min: -(2 ** 14),
    max: 2 ** 14 - 1
  },
  varuint: {
    read(s) {
      let firstWord = s.buffer.readUInt16BE(s.scan);
      s.scan += 2;
      if ((firstWord & 32768) == 0) {
        return firstWord;
      } else {
        let secondWord = s.buffer.readUInt16BE(s.scan);
        s.scan += 2;
        return (firstWord & 32767) << 16 | secondWord;
      }
    },
    write(s, v) {
      if (v < 32768) {
        s.buffer.writeUInt16BE(v, s.scan);
        s.scan += 2;
      } else {
        s.buffer.writeUint32BE((v | 2147483648) >>> 0, s.scan);
        s.scan += 4;
      }
    },
    min: 0,
    max: 2 ** 31 - 1
  },
  varnullint: {
    read(s) {
      let firstWord = s.buffer.readUInt16BE(s.scan);
      s.scan += 2;
      if (firstWord == 32767) {
        return -1;
      } else if ((firstWord & 32768) == 0) {
        return firstWord;
      } else {
        let secondWord = s.buffer.readUInt16BE(s.scan);
        s.scan += 2;
        return (firstWord & 32767) << 16 | secondWord;
      }
    },
    write(s, v) {
      if (v == -1) {
        s.buffer.writeUint16BE(32767, s.scan);
        s.scan += 2;
      } else if (v < 32768) {
        s.buffer.writeUInt16BE(v, s.scan);
        s.scan += 2;
      } else {
        s.buffer.writeUint32BE((v | 2147483648) >>> 0, s.scan);
        s.scan += 4;
      }
    },
    min: -1,
    max: 2 ** 31 - 1
  },
  varint: {
    read(s) {
      let firstWord = s.buffer.readUInt16BE(s.scan);
      s.scan += 2;
      if ((firstWord & 32768) == 0) {
        return firstWord << 32 - 15 >> 32 - 15;
      }
      let secondWord = s.buffer.readUInt16BE(s.scan);
      s.scan += 2;
      return ((firstWord & 32767) << 16 | secondWord) << 32 - 31 >> 32 - 31;
    },
    write(s, v) {
      if (v < 16384 && v >= -16384) {
        s.buffer.writeUInt16BE(v & 32767, s.scan);
        s.scan += 2;
      } else {
        s.buffer.writeInt32BE(v | 8388608, s.scan);
        s.scan += 4;
      }
    },
    min: -(2 ** 30),
    max: 2 ** 30 - 1
  }
};
var parserPrimitives = {
  ...Object.fromEntries(Object.entries(numberTypes).map(([k, e]) => [k, {
    read: e.read,
    write: (s, v) => {
      if (typeof v != "number" || v > e.max || v < e.min) {
        throw new Error();
      }
      e.write(s, v);
    },
    getJsonSchema() {
      return { type: "number", maximum: e.max, minimum: e.min };
    },
    getTypescriptType(indent) {
      return "number";
    }
  }])),
  bool: {
    read(s) {
      let r = s.buffer.readUInt8(s.scan++);
      if (r != 0 && r != 1) {
        throw new Error("1 or 0 expected boolean value");
      }
      return r != 0;
    },
    write(s, v) {
      if (typeof v != "boolean") {
        throw new Error("boolean expected");
      }
      s.buffer.writeUInt8(+v, s.scan++);
    },
    getJsonSchema() {
      return { type: "boolean" };
    },
    getTypescriptType(indent) {
      return "boolean";
    }
  },
  string: stringParser([]),
  paddedstring: stringParser([0])
};
var parserFunctions = {
  ref: referenceValueParser,
  accum: intAccumolatorParser,
  opt: optParser,
  chunkedarray: chunkedArrayParser,
  bytesleft: bytesRemainingParser,
  buffer: bufferParser,
  nullarray: arrayNullTerminatedParser,
  array: arrayParser,
  struct: structParser,
  tuple: tuppleParser,
  ...hardcodes,
  ...parserPrimitives
};

// rsmv/src/opdecoder.ts
import commentJson from "comment-json";
var typedef = commentJson.parse(require_typedef());
var scratchbuf = Buffer.alloc(2 * 1024 * 1024);
var bytesleftoverwarncount = 0;
var FileParser = class _FileParser {
  constructor(opcodeobj, originalSource) {
    this.totaltime = 0;
    this.parser = buildParser(null, opcodeobj, typedef);
    this.originalSource = originalSource ?? JSON.stringify(opcodeobj, void 0, "	");
  }
  static fromJson(jsonObject) {
    let opcodeobj = commentJson.parse(jsonObject, void 0, true);
    return new _FileParser(opcodeobj, jsonObject);
  }
  readInternal(state) {
    let t = performance.now();
    let res = this.parser.read(state);
    this.totaltime += performance.now() - t;
    if (state.scan != state.endoffset) {
      bytesleftoverwarncount++;
      if (bytesleftoverwarncount < 100) {
        console.log(`bytes left over after decoding file: ${state.endoffset - state.scan}`);
      }
      if (bytesleftoverwarncount == 100) {
        console.log("too many bytes left over warning, no more warnings will be logged");
      }
      if (state.buffer.byteLength < 1e5) {
        throw new Error(`bytes left over after decoding file: ${state.endoffset - state.scan}`);
      }
    }
    return res;
  }
  read(buffer, source, args) {
    let state = {
      isWrite: false,
      buffer,
      stack: [],
      hiddenstack: [],
      scan: 0,
      endoffset: buffer.byteLength,
      args: {
        ...source.getDecodeArgs(),
        ...args
      }
    };
    return this.readInternal(state);
  }
  write(obj, args) {
    let state = {
      isWrite: true,
      stack: [],
      hiddenstack: [],
      buffer: scratchbuf,
      scan: 0,
      endoffset: scratchbuf.byteLength,
      args: {
        clientVersion: 1e3,
        //TODO
        ...args
      }
    };
    this.parser.write(state, obj);
    if (state.scan > state.endoffset) {
      throw new Error("tried to write file larger than scratchbuffer size");
    }
    state.buffer.copyWithin(state.scan, state.endoffset, scratchbuf.byteLength);
    state.scan += scratchbuf.byteLength - state.endoffset;
    let r = Uint8Array.prototype.slice.call(scratchbuf, 0, state.scan);
    scratchbuf.fill(0, 0, state.scan);
    return r;
  }
};
globalThis.parserTimings = () => {
  let all = Object.entries(parse).map((q) => ({ name: q[0], t: q[1].totaltime }));
  all.sort((a, b) => b.t - a.t);
  all.slice(0, 10).filter((q) => q.t > 0.01).forEach((q) => console.log(`${q.name} ${q.t.toFixed(3)}s`));
};
var parse = allParsers();
function allParsers() {
  return {
    cacheIndex: FileParser.fromJson(require_cacheindex()),
    npc: FileParser.fromJson(require_npcs()),
    item: FileParser.fromJson(require_items()),
    object: FileParser.fromJson(require_objects()),
    achievement: FileParser.fromJson(require_achievements()),
    mapsquareTiles: FileParser.fromJson(require_mapsquare_tiles()),
    mapsquareTilesNxt: FileParser.fromJson(require_mapsquare_tiles_nxt()),
    mapsquareWaterTiles: FileParser.fromJson(require_mapsquare_watertiles()),
    mapsquareUnderlays: FileParser.fromJson(require_mapsquare_underlays()),
    mapsquareOverlays: FileParser.fromJson(require_mapsquare_overlays()),
    mapsquareLocations: FileParser.fromJson(require_mapsquare_locations()),
    mapsquareEnvironment: FileParser.fromJson(require_mapsquare_envs()),
    mapZones: FileParser.fromJson(require_mapzones()),
    enums: FileParser.fromJson(require_enums()),
    mapscenes: FileParser.fromJson(require_mapscenes()),
    sequences: FileParser.fromJson(require_sequences()),
    framemaps: FileParser.fromJson(require_framemaps()),
    frames: FileParser.fromJson(require_frames()),
    animgroupConfigs: FileParser.fromJson(require_animgroupconfigs()),
    models: FileParser.fromJson(require_models()),
    oldmodels: FileParser.fromJson(require_oldmodels()),
    classicmodels: FileParser.fromJson(require_classicmodels()),
    spotAnims: FileParser.fromJson(require_spotanims()),
    rootCacheIndex: FileParser.fromJson(require_rootcacheindex()),
    skeletalAnim: FileParser.fromJson(require_skeletalanim()),
    materials: FileParser.fromJson(require_materials()),
    oldmaterials: FileParser.fromJson(require_oldmaterials()),
    quickchatCategories: FileParser.fromJson(require_quickchatcategories()),
    quickchatLines: FileParser.fromJson(require_quickchatlines()),
    environments: FileParser.fromJson(require_environments()),
    avatars: FileParser.fromJson(require_avatars()),
    avatarOverrides: FileParser.fromJson(require_avataroverrides()),
    identitykit: FileParser.fromJson(require_identitykit()),
    structs: FileParser.fromJson(require_structs()),
    params: FileParser.fromJson(require_params()),
    particles_0: FileParser.fromJson(require_particles_0()),
    particles_1: FileParser.fromJson(require_particles_1()),
    audio: FileParser.fromJson(require_audio()),
    proctexture: FileParser.fromJson(require_proctexture()),
    oldproctexture: FileParser.fromJson(require_oldproctexture()),
    maplabels: FileParser.fromJson(require_maplabels()),
    cutscenes: FileParser.fromJson(require_cutscenes()),
    clientscript: FileParser.fromJson(require_clientscript()),
    clientscriptdata: FileParser.fromJson(require_clientscriptdata()),
    interfaces: FileParser.fromJson(require_interfaces()),
    dbtables: FileParser.fromJson(require_dbtables()),
    dbrows: FileParser.fromJson(require_dbrows())
  };
}

// rsmv/src/3d/ddsimage.ts
function flipEndian32(int2) {
  return (int2 & 255) << 24 | (int2 & 65280) << 8 | (int2 & 16711680) >>> 8 | (int2 & 4278190080) >>> 24;
}
function readKtx(filedata) {
  let offset = 0;
  let magic0 = filedata.readUInt32BE(offset);
  offset += 4;
  let magic1 = filedata.readUInt32BE(offset);
  offset += 4;
  let magic2 = filedata.readUInt32BE(offset);
  offset += 4;
  let endianbytes = filedata.readUint32BE(offset);
  offset += 4;
  let littleendian = endianbytes != 67305985;
  let getuint = () => {
    let v = filedata.readUint32BE(offset);
    offset += 4;
    return littleendian ? flipEndian32(v) : v;
  };
  let glType = getuint();
  let glTypeSize = getuint();
  let glFormat = getuint();
  let glInternalFormat = getuint();
  let glBaseInternalFormat = getuint();
  let pixelWidth = getuint();
  let pixelHeight = getuint();
  let pixelDepth = getuint();
  let numberOfArrayElements = getuint();
  let numberOfFaces = getuint();
  let numberOfMipmapLevels = getuint();
  let bytesOfKeyValueData = getuint();
  offset += bytesOfKeyValueData;
  let isEtcAlpha = glInternalFormat == 37496;
  let isEtc = glInternalFormat == 37492;
  if (!isEtc && !isEtcAlpha) {
    throw new Error("dds file is not dxt1 or dxt5 encoded as expected, continuing as dxt5");
  }
  let mips = [];
  for (let i = 0; i < numberOfMipmapLevels; i++) {
    let mipwidth = pixelWidth >> i;
    let mipheight = pixelHeight >> i;
    let datasize = getuint();
    mips.push({
      width: mipwidth,
      height: mipheight,
      data: filedata.slice(offset, offset + datasize)
    });
    offset += datasize;
  }
  return { isDxt1: isEtc, isDxt5: isEtcAlpha, mips, width: pixelWidth, height: pixelHeight };
}
function readDds(filedata) {
  let offset = 0;
  let magic = filedata.readUInt32LE(offset);
  offset += 4;
  let headersize = filedata.readUInt32LE(offset);
  offset += 4;
  let flags = filedata.readUInt32LE(offset);
  offset += 4;
  let height = filedata.readUInt32LE(offset);
  offset += 4;
  let width = filedata.readUInt32LE(offset);
  offset += 4;
  let pitchorlinearsize = filedata.readUInt32LE(offset);
  offset += 4;
  let depth = filedata.readUInt32LE(offset);
  offset += 4;
  let mipmapcount = filedata.readUInt32LE(offset);
  offset += 4;
  offset += 11 * 4;
  let encoding = filedata.readUInt32LE(offset + 8);
  offset += 8 * 4;
  offset += 5 * 4;
  let isDxt5 = encoding == 894720068;
  let isDxt1 = encoding == 827611204;
  if (!isDxt1 && !isDxt5) {
    throw new Error("dds file is not dxt1 or dxt5 encoded as expected, continuing as dxt5");
  }
  let mips = [];
  for (let i = 0; i < mipmapcount; i++) {
    let mipwidth = width >> i;
    let mipheight = height >> i;
    let datasize = mipwidth * mipheight * (isDxt5 ? 16 : 8);
    mips.push({
      width: mipwidth,
      height: mipheight,
      data: filedata.slice(offset, offset + datasize)
    });
    offset += datasize;
  }
  return { magic, flags, height, width, pitchorlinearsize, depth, isDxt1, isDxt5, mips };
}
function loadDds(filedata, paddingsize = -1, forceOpaque = true) {
  let parsedfile = readDds(filedata);
  if (paddingsize == -1) {
    if (parsedfile.isDxt5) {
      paddingsize = 32;
    } else {
      paddingsize = 0;
    }
  }
  let innerwidth = parsedfile.width - paddingsize * 2;
  let innerheight = parsedfile.height - paddingsize * 2;
  let data = Buffer.alloc(innerwidth * innerheight * 4);
  dxtdata(data, innerwidth * 4, parsedfile.mips[0].data, parsedfile.mips[0].width, paddingsize, paddingsize, innerwidth, innerheight, parsedfile.isDxt5);
  if (forceOpaque) {
    for (let i = 0; i < data.length; i += 4) {
      data[i + 3] = 255;
    }
  }
  return { data, width: innerwidth, height: innerheight };
}
function loadKtx(filedata, paddingsize = -1, forceOpaque = true) {
  let parsedfile = readKtx(filedata);
  if (paddingsize == -1) {
    if (parsedfile.isDxt5) {
      paddingsize = 32;
    } else {
      paddingsize = 0;
    }
  }
  let innerwidth = parsedfile.width - paddingsize * 2;
  let innerheight = parsedfile.height - paddingsize * 2;
  let data = Buffer.alloc(innerwidth * innerheight * 4);
  etc2data(data, innerwidth * 4, parsedfile.mips[0].data, parsedfile.mips[0].width, paddingsize, paddingsize, innerwidth, innerheight, parsedfile.isDxt5);
  if (forceOpaque) {
    for (let i = 0; i < data.length; i += 4) {
      data[i + 3] = 255;
    }
  }
  return { data, width: innerwidth, height: innerheight };
}
function unpackpixel(value, shift, bits) {
  return ((value >> shift & (1 << bits) - 1) * 2 * 255 + (1 << bits) - 1) / ((1 << bits) - 1) / 2;
}
function selectbits(value, shift, bits) {
  let preshift = 32 - bits - shift;
  return value << preshift >>> preshift + shift;
}
function selectsignedbits(value, shift, bits) {
  let preshift = 32 - bits - shift;
  return value << preshift >> preshift + shift;
}
function uint16le(src, offset) {
  return src[offset] | src[offset + 1] << 8;
}
function uint32be(src, offset) {
  return (src[offset] << 24 | src[offset + 1] << 16 | src[offset + 2] << 8 | src[offset + 3]) >>> 0;
}
function dxtdata(targetdata, targetstride, source, sourcewidth, subx, suby, width, height, isDxt5) {
  const bytesperblock = isDxt5 ? 16 : 8;
  const coloroffset = isDxt5 ? 8 : 0;
  const r = new Uint8Array(4);
  const g = new Uint8Array(4);
  const b = new Uint8Array(4);
  const a = new Uint8Array(8);
  const datawords = new Uint16Array(8);
  for (let blocky = suby / 4; blocky < (suby + height) / 4; blocky++) {
    for (let blockx = subx / 4; blockx < (subx + width) / 4; blockx++) {
      let blockindex = sourcewidth / 4 * blocky + blockx;
      let dataptr = blockindex * bytesperblock;
      datawords[4] = uint16le(source, dataptr + coloroffset + 0);
      datawords[5] = uint16le(source, dataptr + coloroffset + 2);
      datawords[6] = uint16le(source, dataptr + coloroffset + 4);
      datawords[7] = uint16le(source, dataptr + coloroffset + 6);
      r[0] = unpackpixel(datawords[4], 11, 5);
      g[0] = unpackpixel(datawords[4], 5, 6);
      b[0] = unpackpixel(datawords[4], 0, 5);
      r[1] = unpackpixel(datawords[5], 11, 5);
      g[1] = unpackpixel(datawords[5], 5, 6);
      b[1] = unpackpixel(datawords[5], 0, 5);
      a[0] = 255;
      a[1] = 255;
      a[2] = 255;
      a[3] = 255;
      if (datawords[4] > datawords[5]) {
        r[2] = (2 * r[0] + r[1] + 1) / 3;
        g[2] = (2 * g[0] + g[1] + 1) / 3;
        b[2] = (2 * b[0] + b[1] + 1) / 3;
        r[3] = (r[0] + 2 * r[1] + 1) / 3;
        g[3] = (g[0] + 2 * g[1] + 1) / 3;
        b[3] = (b[0] + 2 * b[1] + 1) / 3;
      } else {
        r[2] = (r[0] + r[1]) / 2;
        g[2] = (g[0] + g[1]) / 2;
        b[2] = (b[0] + b[1]) / 2;
        r[3] = 0;
        g[3] = 0;
        b[3] = 0;
        a[3] = 0;
      }
      for (let p = 0; p < 16; p++) {
        let pxoffset = (blockx * 4 + p % 4 - subx) * 4 + (blocky * 4 + (p / 4 | 0) - suby) * targetstride;
        let id = datawords[p < 8 ? 6 : 7] >> p % 8 * 2 & 3;
        targetdata[pxoffset + 0] = r[id];
        targetdata[pxoffset + 1] = g[id];
        targetdata[pxoffset + 2] = b[id];
        targetdata[pxoffset + 3] = a[id];
      }
      if (isDxt5) {
        datawords[0] = uint16le(source, dataptr + 0);
        datawords[1] = uint16le(source, dataptr + 2);
        datawords[2] = uint16le(source, dataptr + 4);
        datawords[3] = uint16le(source, dataptr + 6);
        a[0] = unpackpixel(datawords[0], 0, 8);
        a[1] = unpackpixel(datawords[0], 8, 8);
        if (a[0] > a[1]) {
          for (let i = 0; i < 6; i++) {
            a[2 + i] = ((6 - i) * a[0] + (1 + i) * a[1] + 3) / 7;
          }
        } else {
          for (let i = 0; i < 4; i++) {
            a[2 + i] = ((4 - i) * a[0] + (1 + i) * a[1] + 2) / 5;
          }
          a[6] = 0;
          a[7] = 255;
        }
        let alphabitoffset = 0;
        let alphawordoffset = 1;
        for (let p = 0; p < 16; p++) {
          let pxoffset = (blockx * 4 + p % 4 - subx) * 4 + (blocky * 4 + (p / 4 | 0) - suby) * targetstride;
          let alphaid = datawords[alphawordoffset] >> alphabitoffset & 7;
          alphabitoffset += 3;
          if (alphabitoffset >= 16) {
            alphabitoffset -= 16;
            alphawordoffset++;
            alphaid |= datawords[alphawordoffset] & 1 << alphabitoffset - 1;
          }
          targetdata[pxoffset + 3] = a[alphaid];
        }
      }
    }
  }
}
var etc2offsets = new Int16Array([
  2,
  8,
  -2,
  -8,
  5,
  17,
  -5,
  -17,
  9,
  29,
  -9,
  -29,
  13,
  42,
  -13,
  -42,
  18,
  60,
  -18,
  -60,
  24,
  80,
  -24,
  -80,
  33,
  106,
  -33,
  -106,
  47,
  183,
  -47,
  -183
]);
var etc2alphas = new Int8Array([
  -3,
  -6,
  -9,
  -15,
  2,
  5,
  8,
  14,
  -3,
  -7,
  -10,
  -13,
  2,
  6,
  9,
  12,
  -2,
  -5,
  -8,
  -13,
  1,
  4,
  7,
  12,
  -2,
  -4,
  -6,
  -13,
  1,
  3,
  5,
  12,
  -3,
  -6,
  -8,
  -12,
  2,
  5,
  7,
  11,
  -3,
  -7,
  -9,
  -11,
  2,
  6,
  8,
  10,
  -4,
  -7,
  -8,
  -11,
  3,
  6,
  7,
  10,
  -3,
  -5,
  -8,
  -11,
  2,
  4,
  7,
  10,
  -2,
  -6,
  -8,
  -10,
  1,
  5,
  7,
  9,
  -2,
  -5,
  -8,
  -10,
  1,
  4,
  7,
  9,
  -2,
  -4,
  -8,
  -10,
  1,
  3,
  7,
  9,
  -2,
  -5,
  -7,
  -10,
  1,
  4,
  6,
  9,
  -3,
  -4,
  -7,
  -10,
  2,
  3,
  6,
  9,
  -1,
  -2,
  -3,
  -10,
  0,
  1,
  2,
  9,
  -4,
  -6,
  -8,
  -9,
  3,
  5,
  7,
  8,
  -3,
  -5,
  -7,
  -9,
  2,
  4,
  6,
  8
]);
var etc2dists = new Uint8Array([3, 6, 11, 16, 23, 32, 41, 64]);
function clamp(num) {
  return num > 255 ? 255 : num < 0 ? 0 : num;
}
function ect2alphalookup(base, table, mult, pix) {
  return clamp(base + etc2alphas[table << 3 | pix] * mult);
}
function extend4to8(num) {
  return num << 4 | num;
}
function extend5to8(num) {
  return num << 3 | num >> 2;
}
function extend6to8(num) {
  return num << 2 | num >> 4;
}
function extend7to8(num) {
  return num << 1 | num >> 7;
}
function etc2data(targetdata, targetstride, source, sourcewidth, subx, suby, width, height, hasalpha) {
  const bytesperblock = hasalpha ? 16 : 8;
  const coloroffset = hasalpha ? 8 : 0;
  const colorlut = new Uint8Array(4 * 4);
  for (let blocky = suby / 4; blocky < (suby + height) / 4; blocky++) {
    for (let blockx = subx / 4; blockx < (subx + width) / 4; blockx++) {
      let blockindex = sourcewidth / 4 * blocky + blockx;
      let dataptr = blockindex * bytesperblock;
      let dataupper = uint32be(source, dataptr + coloroffset);
      let datalower = uint32be(source, dataptr + coloroffset + 4);
      let horizontalsplit = selectbits(dataupper, 0, 1);
      let moded = selectbits(dataupper, 1, 1);
      let moder = selectbits(dataupper, 27, 5);
      let modeg = selectbits(dataupper, 19, 5);
      let modeb = selectbits(dataupper, 11, 5);
      let modedr = selectsignedbits(dataupper, 24, 3);
      let modedg = selectsignedbits(dataupper, 16, 3);
      let modedb = selectsignedbits(dataupper, 8, 3);
      let modersum = moder + modedr;
      let modegsum = modeg + modedg;
      let modebsum = modeb + modedb;
      let validr = modersum >= 0 && modersum < 32;
      let validg = modegsum >= 0 && modegsum < 32;
      let validb = modebsum >= 0 && modebsum < 32;
      let allvalid = validr && validg && validb;
      let base_r1, base_g1, base_b1;
      let base_r2, base_g2, base_b2;
      let base_r3, base_g3, base_b3;
      if (moded == 0 || allvalid) {
        if (moded == 0) {
          base_r1 = extend4to8(selectbits(dataupper, 28, 4));
          base_r2 = extend4to8(selectbits(dataupper, 24, 4));
          base_g1 = extend4to8(selectbits(dataupper, 20, 4));
          base_g2 = extend4to8(selectbits(dataupper, 16, 4));
          base_b1 = extend4to8(selectbits(dataupper, 12, 4));
          base_b2 = extend4to8(selectbits(dataupper, 8, 4));
        } else {
          base_r1 = extend5to8(moder);
          base_g1 = extend5to8(modeg);
          base_b1 = extend5to8(modeb);
          base_r2 = extend5to8(modersum);
          base_g2 = extend5to8(modegsum);
          base_b2 = extend5to8(modebsum);
        }
        let table1 = selectbits(dataupper, 5, 3);
        let table2 = selectbits(dataupper, 2, 3);
        for (let p = 0; p < 16; p++) {
          let index = datalower >>> p + 15 & 2 | datalower >>> p & 1;
          let pxoffset = (blockx * 4 + (p / 4 | 0) - subx) * 4 + (blocky * 4 + p % 4 - suby) * targetstride;
          let isfirst = horizontalsplit == 1 ? p % 4 < 2 : p < 8;
          let table = isfirst ? table1 : table2;
          targetdata[pxoffset + 0] = clamp((isfirst ? base_r1 : base_r2) + etc2offsets[table << 2 | index]);
          targetdata[pxoffset + 1] = clamp((isfirst ? base_g1 : base_g2) + etc2offsets[table << 2 | index]);
          targetdata[pxoffset + 2] = clamp((isfirst ? base_b1 : base_b2) + etc2offsets[table << 2 | index]);
          targetdata[pxoffset + 3] = 255;
        }
      } else {
        if (!validr || !validg) {
          if (!validr) {
            colorlut[0] = extend4to8(selectbits(dataupper, 27, 2) << 2 | selectbits(dataupper, 24, 2));
            colorlut[1] = extend4to8(selectbits(dataupper, 20, 4));
            colorlut[2] = extend4to8(selectbits(dataupper, 16, 4));
            colorlut[8] = extend4to8(selectbits(dataupper, 12, 4));
            colorlut[9] = extend4to8(selectbits(dataupper, 8, 4));
            colorlut[10] = extend4to8(selectbits(dataupper, 4, 4));
            let distindex = selectbits(dataupper, 2, 2) << 1 | selectbits(dataupper, 0, 1);
            let dist = etc2dists[distindex];
            colorlut[4] = clamp(colorlut[8] + dist);
            colorlut[5] = clamp(colorlut[9] + dist);
            colorlut[6] = clamp(colorlut[10] + dist);
            colorlut[12] = clamp(colorlut[4] - dist);
            colorlut[13] = clamp(colorlut[5] - dist);
            colorlut[14] = clamp(colorlut[6] - dist);
          } else {
            base_r1 = extend4to8(selectbits(dataupper, 27, 4));
            base_g1 = extend4to8(selectbits(dataupper, 24, 3) << 1 | selectbits(dataupper, 20, 1));
            base_b1 = extend4to8(selectbits(dataupper, 19, 1) << 3 | selectbits(dataupper, 15, 3));
            base_r2 = extend4to8(selectbits(dataupper, 11, 4));
            base_g2 = extend4to8(selectbits(dataupper, 7, 4));
            base_b2 = extend4to8(selectbits(dataupper, 3, 4));
            let baseint1 = base_r1 << 16 | base_g1 << 8 | base_b1;
            let baseint2 = base_r2 << 16 | base_g2 << 8 | base_b2;
            let distlastbit = baseint1 >= baseint2 ? 1 : 0;
            let distindex = selectbits(dataupper, 2, 1) << 2 | selectbits(dataupper, 0, 1) << 1 | distlastbit;
            let dist = etc2dists[distindex];
            colorlut[0] = clamp(base_r1 + dist);
            colorlut[1] = clamp(base_g1 + dist);
            colorlut[2] = clamp(base_b1 + dist);
            colorlut[4] = clamp(base_r1 - dist);
            colorlut[5] = clamp(base_g1 - dist);
            colorlut[6] = clamp(base_b1 - dist);
            colorlut[8] = clamp(base_r2 + dist);
            colorlut[9] = clamp(base_g2 + dist);
            colorlut[10] = clamp(base_b2 + dist);
            colorlut[12] = clamp(base_r2 - dist);
            colorlut[13] = clamp(base_g2 - dist);
            colorlut[14] = clamp(base_b2 - dist);
          }
          for (let p = 0; p < 16; p++) {
            let index = datalower >>> p + 15 & 2 | datalower >>> p & 1;
            let pxoffset = (blockx * 4 + (p / 4 | 0) - subx) * 4 + (blocky * 4 + p % 4 - suby) * targetstride;
            targetdata[pxoffset + 0] = clamp(colorlut[index << 2 | 0]);
            targetdata[pxoffset + 1] = clamp(colorlut[index << 2 | 1]);
            targetdata[pxoffset + 2] = clamp(colorlut[index << 2 | 2]);
            targetdata[pxoffset + 3] = 255;
          }
        } else if (!validb) {
          base_r1 = extend6to8(selectbits(dataupper, 25, 6));
          base_g1 = extend7to8(selectbits(dataupper, 24, 1) << 6 | selectbits(dataupper, 17, 6));
          base_b1 = extend6to8(selectbits(dataupper, 16, 1) << 5 | selectbits(dataupper, 11, 2) << 3 | selectbits(dataupper, 7, 3));
          base_r2 = extend6to8(selectbits(dataupper, 2, 5) << 1 | selectbits(dataupper, 0, 1));
          base_g2 = extend7to8(selectbits(datalower, 25, 7));
          base_b2 = extend6to8(selectbits(datalower, 19, 6));
          base_r3 = extend6to8(selectbits(datalower, 13, 6));
          base_g3 = extend7to8(selectbits(datalower, 6, 7));
          base_b3 = extend6to8(selectbits(datalower, 0, 6));
          for (let p = 0; p < 16; p++) {
            let px = p % 4;
            let py = p / 4 | 0;
            let pxoffset = (blockx * 4 + px - subx) * 4 + (blocky * 4 + py - suby) * targetstride;
            targetdata[pxoffset + 0] = clamp(px * (base_r2 - base_r1) + py * (base_r3 - base_r1) + 4 * base_r1 + 2 >> 2);
            targetdata[pxoffset + 1] = clamp(px * (base_g2 - base_g1) + py * (base_g3 - base_g1) + 4 * base_g1 + 2 >> 2);
            targetdata[pxoffset + 2] = clamp(px * (base_b2 - base_b1) + py * (base_b3 - base_b1) + 4 * base_b1 + 2 >> 2);
            targetdata[pxoffset + 3] = 255;
          }
        } else {
        }
      }
      if (hasalpha) {
        let alphaupper = uint32be(source, dataptr);
        let alphalower = uint32be(source, dataptr + 4);
        let base = selectbits(alphaupper, 24, 8);
        let mult = selectbits(alphaupper, 20, 4);
        let table = selectbits(alphaupper, 16, 4);
        let basepxoffset = (blockx * 4 - subx) * 4 + (blocky * 4 - suby) * targetstride + 3;
        targetdata[basepxoffset + 0 + 0 * targetstride] = ect2alphalookup(base, table, mult, selectbits(alphaupper, 13, 3));
        targetdata[basepxoffset + 0 + 1 * targetstride] = ect2alphalookup(base, table, mult, selectbits(alphaupper, 10, 3));
        targetdata[basepxoffset + 0 + 2 * targetstride] = ect2alphalookup(base, table, mult, selectbits(alphaupper, 7, 3));
        targetdata[basepxoffset + 0 + 3 * targetstride] = ect2alphalookup(base, table, mult, selectbits(alphaupper, 4, 3));
        targetdata[basepxoffset + 4 + 0 * targetstride] = ect2alphalookup(base, table, mult, selectbits(alphaupper, 1, 3));
        targetdata[basepxoffset + 4 + 1 * targetstride] = ect2alphalookup(base, table, mult, selectbits(alphaupper, 0, 1) << 2 | selectbits(alphalower, 30, 2));
        targetdata[basepxoffset + 4 + 2 * targetstride] = ect2alphalookup(base, table, mult, selectbits(alphalower, 27, 3));
        targetdata[basepxoffset + 4 + 3 * targetstride] = ect2alphalookup(base, table, mult, selectbits(alphalower, 24, 3));
        targetdata[basepxoffset + 8 + 0 * targetstride] = ect2alphalookup(base, table, mult, selectbits(alphalower, 21, 3));
        targetdata[basepxoffset + 8 + 1 * targetstride] = ect2alphalookup(base, table, mult, selectbits(alphalower, 18, 3));
        targetdata[basepxoffset + 8 + 2 * targetstride] = ect2alphalookup(base, table, mult, selectbits(alphalower, 15, 3));
        targetdata[basepxoffset + 8 + 3 * targetstride] = ect2alphalookup(base, table, mult, selectbits(alphalower, 12, 3));
        targetdata[basepxoffset + 12 + 0 * targetstride] = ect2alphalookup(base, table, mult, selectbits(alphalower, 9, 3));
        targetdata[basepxoffset + 12 + 1 * targetstride] = ect2alphalookup(base, table, mult, selectbits(alphalower, 6, 3));
        targetdata[basepxoffset + 12 + 2 * targetstride] = ect2alphalookup(base, table, mult, selectbits(alphalower, 3, 3));
        targetdata[basepxoffset + 12 + 3 * targetstride] = ect2alphalookup(base, table, mult, selectbits(alphalower, 0, 3));
      }
    }
  }
}

// rsmv/src/3d/textures.ts
var ParsedTexture = class {
  constructor(texture, stripAlpha, isMaterialTexture) {
    this.bmpWidth = -1;
    this.bmpHeight = -1;
    this.isMaterialTexture = !!isMaterialTexture;
    this.stripAlpha = stripAlpha;
    this.imagefiles = [];
    this.cachedDrawables = [];
    this.cachedImageDatas = [];
    if (texture instanceof ImageData) {
      this.filesize = texture.data.byteLength;
      this.type = "imagedata";
      this.mipmaps = 1;
      this.cachedImageDatas = [Promise.resolve(texture)];
    } else {
      this.filesize = texture.byteLength;
      let header = texture.readUint32BE(0);
      if (header == 2303741511) {
        this.type = "png";
        this.imagefiles.push(texture);
        this.mipmaps = 1;
      } else {
        let offset = 0;
        let extraoffset = 0;
        while (true) {
          let byte0 = texture.readUInt8(extraoffset + offset + 1 + 4 + 0);
          let byte1 = texture.readUInt8(extraoffset + offset + 1 + 4 + 1);
          if (byte0 == 0 && byte1 == 0) {
            this.type = "bmpmips";
            break;
          } else if (byte0 == 68 && byte1 == 68) {
            this.type = "dds";
            break;
          } else if (byte0 == 137 && byte1 == 80) {
            this.type = "png";
            break;
          } else if (byte0 == 171 && byte1 == 75) {
            this.type = "ktx";
            break;
          } else if (extraoffset++ <= 1) {
            continue;
          }
          throw new Error(`failed to detect texture`);
        }
        if (extraoffset == 1) {
          let numtexs = texture.readUint8(offset++);
        }
        this.mipmaps = texture.readUInt8(offset++);
        if (this.type == "bmpmips") {
          this.bmpWidth = texture.readUInt32BE(offset);
          offset += 4;
          this.bmpHeight = texture.readUInt32BE(offset);
          offset += 4;
        }
        for (let i = 0; i < this.mipmaps; i++) {
          let compressedsize;
          if (this.type == "bmpmips") {
            compressedsize = (this.bmpWidth >> i) * (this.bmpHeight >> i) * 4;
          } else {
            compressedsize = texture.readUInt32BE(offset);
            offset += 4;
          }
          this.imagefiles.push(texture.slice(offset, offset + compressedsize));
          offset += compressedsize;
          this.cachedDrawables.push(null);
          this.cachedImageDatas.push(null);
        }
      }
    }
  }
  toImageData(subimg = 0) {
    let res = this.cachedImageDatas[subimg];
    if (!res) {
      res = (async () => {
        const padsize = this.isMaterialTexture ? 32 : void 0;
        if (this.type == "bmpmips") {
          let width = this.bmpWidth >> subimg;
          let height = this.bmpHeight >> subimg;
          let imgdata = loadBmp(this.imagefiles[subimg], width, height, padsize, this.stripAlpha);
          return makeImageData(imgdata.data, imgdata.width, imgdata.height);
        } else if (this.type == "png") {
          return fileToImageData(this.imagefiles[subimg], "image/png", this.stripAlpha);
        } else if (this.type == "dds") {
          let imgdata = loadDds(this.imagefiles[subimg], padsize, this.stripAlpha);
          return makeImageData(imgdata.data, imgdata.width, imgdata.height);
        } else if (this.type == "ktx") {
          let imgdata = loadKtx(this.imagefiles[subimg], padsize, this.stripAlpha);
          return makeImageData(imgdata.data, imgdata.width, imgdata.height);
        } else if (this.type == "imagedata") {
          throw new Error("image not found");
        } else {
          throw new Error("unknown format");
        }
      })();
      this.cachedImageDatas[subimg] = res;
    }
    return res;
  }
  //create a texture for use in webgl (only use this in a browser context like electron)
  async toWebgl(subimg = 0) {
    let res = this.cachedDrawables[subimg];
    if (!res) {
      if (this.type == "png") {
        res = new Promise((resolve3, reject) => {
          let img = new Image();
          img.onload = () => {
            URL.revokeObjectURL(img.src);
            resolve3(img);
          };
          img.onerror = reject;
          let blob = new Blob([this.imagefiles[subimg]], { type: "image/png" });
          img.src = URL.createObjectURL(blob);
        });
      } else {
        res = this.toImageData(subimg).then((q) => createImageBitmap(q));
      }
      this.cachedDrawables[subimg] = res;
    }
    return res;
  }
};
function loadBmp(bmpdata, inwidth, inheight, padsize = -1, forceOpaque = true) {
  if (padsize == -1) {
    padsize = 0;
    console.warn("cannot infer padding size on bmp textures");
  }
  const instride = inwidth * 4;
  const inoffset = padsize * instride + padsize * 4;
  const outheight = inheight - 2 * padsize;
  const outwidth = inwidth - 2 * padsize;
  const outstride = outwidth * 4;
  const out = new Uint8Array(outstride * outheight);
  for (let y = 0; y < outheight; y++) {
    const target = y * outstride;
    out.set(bmpdata.subarray(inoffset + instride * y, inoffset + instride * y + outstride), target);
    if (forceOpaque) {
      for (let d = target; d < target + outstride; d += 4) {
        out[d + 3] = 255;
      }
    }
  }
  return { data: out, width: outwidth, height: outheight };
}

// rsmv/src/3d/rt7model.ts
import * as THREE from "three";

// rsmv/src/3d/gltfutil.ts
var TextEncoderPolyfill = typeof TextEncoder != "undefined" ? TextEncoder : __require("util").TextEncoder;

// rsmv/src/3d/rt7model.ts
function getBoneCenters(model) {
  let bonecenters = [];
  for (let i = 0; i < model.bonecount; i++) {
    bonecenters.push({ xsum: 0, ysum: 0, zsum: 0, weightsum: 0 });
  }
  for (let mesh of model.meshes) {
    let ids = mesh.attributes.boneids;
    let weights = mesh.attributes.boneweights;
    let pos = mesh.attributes.pos;
    let indices = mesh.indices;
    if (!ids || !weights) {
      continue;
    }
    for (let i = 0; i < indices.count; i++) {
      let vert = indices.array[i];
      for (let skin = 0; skin < ids.itemSize; skin++) {
        let skinid = ids.array[vert * ids.itemSize + skin];
        let skinweight = weights.array[vert * weights.itemSize + skin];
        let center = bonecenters[skinid];
        center.xsum += pos.array[pos.itemSize * vert + 0] * skinweight;
        center.ysum += pos.array[pos.itemSize * vert + 1] * skinweight;
        center.zsum += pos.array[pos.itemSize * vert + 2] * skinweight;
        center.weightsum += skinweight;
      }
    }
  }
  return bonecenters;
}
function parsePosData(arr) {
  return new THREE.BufferAttribute(new Float32Array(arr), 3);
}
function addBoneIdBuffer(attributes, boneidBuffer) {
  let quadboneids = new Uint8Array(boneidBuffer.length * 4);
  let quadboneweights = new Uint8Array(boneidBuffer.length * 4);
  const maxshort = (1 << 16) - 1;
  for (let i = 0; i < boneidBuffer.length; i++) {
    let id = boneidBuffer[i];
    id = id == maxshort ? 0 : id + 1;
    quadboneids[i * 4] = id;
    quadboneweights[i * 4] = 255;
  }
  attributes.boneids = new THREE.BufferAttribute(quadboneids, 4);
  attributes.boneweights = new THREE.BufferAttribute(quadboneweights, 4, true);
}
function addUvBuffer(attributes, vertexCount, uvBuffer) {
  if (uvBuffer instanceof Uint16Array) {
    let uvBufferCopy = new Float32Array(vertexCount * 2);
    for (let i = 0; i < vertexCount * 2; i++) {
      uvBufferCopy[i] = ushortToHalf(uvBuffer[i]);
    }
    attributes.texuvs = new THREE.BufferAttribute(uvBufferCopy, 2);
  } else {
    attributes.texuvs = new THREE.BufferAttribute(uvBuffer, 2);
  }
}
function addNormalsBuffer(attributes, normalBuffer) {
  let normalsrepacked = new Int8Array(normalBuffer.length);
  for (let i = 0; i < normalBuffer.length; i += 3) {
    let x = normalBuffer[i + 0];
    let y = normalBuffer[i + 1];
    let z = normalBuffer[i + 2];
    let len = Math.hypot(x, y, z);
    if (len == 0) {
      len = 1;
    }
    let scale = 127 / len;
    normalsrepacked[i + 0] = Math.round(x * scale);
    normalsrepacked[i + 1] = Math.round(y * scale);
    normalsrepacked[i + 2] = Math.round(z * scale);
  }
  attributes.normals = new THREE.BufferAttribute(normalsrepacked, 3, true);
}
function parseOb3Model(modelfile, source) {
  let parsed = parse.models.read(modelfile, source);
  let meshes = [];
  if (parsed.meshes) {
    for (let mesh of parsed.meshes) {
      if (mesh.isHidden) {
        continue;
      }
      let indexBuffers = mesh.indexBuffers;
      let indexlods = indexBuffers.map((q) => new THREE.BufferAttribute(q, 1));
      let indexbuf = indexBuffers[0];
      let attributes = {
        pos: parsePosData(mesh.positionBuffer)
      };
      if (mesh.skin) {
        let skinIdBuffer = new Uint16Array(mesh.vertexCount * 4);
        let skinWeightBuffer = new Uint8Array(mesh.vertexCount * 4);
        let weightin = mesh.skin.skinWeightBuffer;
        let idin = mesh.skin.skinBoneBuffer;
        let idindex = 0;
        let weightindex = 0;
        for (let i = 0; i < mesh.vertexCount; i++) {
          let remainder = 255;
          for (let j = 0; j < 4; j++) {
            let weight = weightin[weightindex++];
            let boneid = idin[idindex++];
            let actualweight = weight != 0 ? weight : remainder;
            remainder -= weight;
            skinIdBuffer[i * 4 + j] = boneid == 65535 ? 0 : boneid;
            skinWeightBuffer[i * 4 + j] = actualweight;
            if (weight == 0) {
              break;
            }
          }
        }
        if (idindex != mesh.skin.skinWeightCount || weightindex != mesh.skin.skinWeightCount) {
          console.log("model skin decode failed");
          debugger;
        }
        attributes.skinids = new THREE.BufferAttribute(skinIdBuffer, 4);
        attributes.skinweights = new THREE.BufferAttribute(skinWeightBuffer, 4, true);
      }
      if (mesh.colourBuffer) {
        if (!indexbuf) {
          throw new Error("need index buf in order to read per-face colors");
        }
        let vertexcolor = new Uint8Array(mesh.vertexCount * 4);
        let alphaBuffer = mesh.alphaBuffer;
        for (let i = 0; i < mesh.faceCount; i++) {
          let [r, g, b] = HSL2RGB(packedHSL2HSL(mesh.colourBuffer[i]));
          for (let j = 0; j < 3; j++) {
            let index = indexbuf[i * 3 + j] * 4;
            vertexcolor[index + 0] = r;
            vertexcolor[index + 1] = g;
            vertexcolor[index + 2] = b;
            if (alphaBuffer) {
              vertexcolor[index + 3] = alphaBuffer[i];
            } else {
              vertexcolor[index + 3] = 255;
            }
          }
        }
        attributes.color = new THREE.BufferAttribute(vertexcolor, 4, true);
      }
      if (mesh.boneidBuffer) {
        addBoneIdBuffer(attributes, mesh.boneidBuffer);
      }
      if (mesh.uvBuffer) {
        addUvBuffer(attributes, mesh.vertexCount, mesh.uvBuffer);
      }
      if (mesh.normalBuffer) {
        addNormalsBuffer(attributes, mesh.normalBuffer);
      }
      meshes.push({
        indices: indexlods[0],
        vertexstart: 0,
        vertexend: attributes.pos.count,
        indexLODs: indexlods,
        materialId: mesh.materialArgument - 1,
        hasVertexAlpha: !!mesh.alphaBuffer,
        needsNormalBlending: false,
        attributes
      });
    }
  } else if (parsed.meshdata) {
    let mesh = parsed.meshdata;
    let attributes = {
      pos: parsePosData(mesh.positionBuffer)
    };
    if (mesh.vertexColours) {
      let vertexcolor = new Uint8Array(mesh.vertexCount * 4);
      let alphaBuffer = mesh.vertexAlpha;
      for (let i = 0; i < mesh.vertexColours.length; i++) {
        let [r, g, b] = HSL2RGB(packedHSL2HSL(mesh.vertexColours[i]));
        let alpha = alphaBuffer ? alphaBuffer[i] : 255;
        let index = i * 4;
        vertexcolor[index + 0] = r;
        vertexcolor[index + 1] = g;
        vertexcolor[index + 2] = b;
        vertexcolor[index + 3] = alpha;
      }
      attributes.color = new THREE.BufferAttribute(vertexcolor, 4, true);
    }
    if (mesh.skin) {
      let skinIdBuffer = new Uint16Array(mesh.vertexCount * 4);
      let skinWeightBuffer = new Uint8Array(mesh.vertexCount * 4);
      for (let i = 0; i < mesh.skin.length; i++) {
        let entry = mesh.skin[i];
        let remainder = 255;
        if (entry.ids.length != entry.weights.length) {
          throw new Error("unexpected length difference in skin weights/ids");
        }
        for (let j = 0; j < entry.ids.length; j++) {
          let weight = entry.weights[j];
          let boneid = entry.ids[j];
          let actualweight = weight != 0 ? weight : remainder;
          remainder -= weight;
          skinIdBuffer[i * 4 + j] = boneid == 65535 ? 0 : boneid;
          skinWeightBuffer[i * 4 + j] = actualweight;
          if (weight == 0) {
            break;
          }
        }
      }
      attributes.skinids = new THREE.BufferAttribute(skinIdBuffer, 4);
      attributes.skinweights = new THREE.BufferAttribute(skinWeightBuffer, 4, true);
    }
    if (mesh.boneidBuffer) {
      addBoneIdBuffer(attributes, mesh.boneidBuffer);
    }
    if (mesh.uvBuffer) {
      addUvBuffer(attributes, mesh.vertexCount, mesh.uvBuffer);
    }
    if (mesh.normalBuffer) {
      addNormalsBuffer(attributes, mesh.normalBuffer);
    }
    for (let render of mesh.renders) {
      if (render.isHidden) {
        continue;
      }
      if (render.buf.length == 0) {
        continue;
      }
      let buf = render.buf;
      if (buf.BYTES_PER_ELEMENT == 4) {
        let newbuf = new Uint32Array(buf.length);
        for (let i = 0; i < buf.length; i++) {
          let v = buf[i];
          newbuf[i] = v >> 24 & 255 | v >> 8 & 65280 | v << 8 & 16711680 | v << 24 & 4278190080;
        }
        buf = newbuf;
      }
      let minindex = buf[0];
      let maxindex = buf[0];
      for (let i = 0; i < buf.length; i++) {
        let v = buf[i];
        if (v < minindex) {
          minindex = v;
        }
        if (v > maxindex) {
          maxindex = v;
        }
      }
      let index = new THREE.BufferAttribute(buf, 1);
      meshes.push({
        indices: index,
        vertexstart: minindex,
        vertexend: maxindex + 1,
        indexLODs: [index],
        materialId: render.materialArgument - 1,
        hasVertexAlpha: !!render.hasVertexAlpha,
        needsNormalBlending: false,
        attributes
      });
    }
  }
  return makeModelData(meshes);
}
function makeModelData(meshes) {
  let maxy = 0;
  let miny = 0;
  let bonecount = 0;
  let skincount = 0;
  for (let mesh of meshes) {
    let pos = mesh.attributes.pos;
    for (let i = 0; i < pos.count; i++) {
      let y = pos.getY(i);
      if (y > maxy) {
        maxy = y;
      }
      if (y < miny) {
        miny = y;
      }
    }
    let boneids = mesh.attributes.boneids;
    if (boneids) {
      for (let i = 0; i < boneids.count; i++) {
        bonecount = Math.max(bonecount, boneids.getX(i), boneids.getY(i), boneids.getZ(i), boneids.getW(i));
      }
      bonecount += 2;
    }
    let skinids = mesh.attributes.skinids;
    if (skinids) {
      for (let i = 0; i < skinids.count; i++) {
        skincount = Math.max(skincount, skinids.getX(i), skinids.getY(i), skinids.getZ(i), skinids.getW(i));
      }
      skincount += 2;
    }
  }
  let r = { maxy, miny, meshes, bonecount, skincount };
  return r;
}

// rsmv/src/3d/rt5model.ts
import * as THREE2 from "three";
import { BoxGeometry, BufferAttribute as BufferAttribute2, CylinderGeometry, LatheGeometry, Matrix3, Matrix4, Mesh as Mesh2, PlaneGeometry as PlaneGeometry2, SphereGeometry, Vector2, Vector3 } from "three";
var nonfiniteWarnCount = 0;
var tmp_rot = [0, 0, 0, 0, 0, 0, 0, 0, 0];
var tmp_normspace = [0, 0, 0, 0, 0, 0, 0, 0, 0];
function jagexOldNormalSpace(normal_x, normal_y, normal_z, rot_int, scale_x, scale_y, scale_z) {
  let tex_space = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  let rot_cos = Math.cos(rot_int * 0.024543693);
  let rot_sin = Math.sin(rot_int * 0.024543693);
  tmp_rot[0] = rot_cos;
  tmp_rot[1] = 0;
  tmp_rot[2] = rot_sin;
  tmp_rot[3] = 0;
  tmp_rot[4] = 1;
  tmp_rot[5] = 0;
  tmp_rot[6] = -rot_sin;
  tmp_rot[7] = 0;
  tmp_rot[8] = rot_cos;
  let map_n_norm_neg = 1;
  let map_p_norm = 0;
  let map_m_norm = normal_y / 32767;
  let map_pn_norm_neg = -Math.sqrt(1 - Math.min(1, map_m_norm * map_m_norm));
  let map_1_m = 1 - map_m_norm;
  let map_pn = Math.sqrt(normal_x * normal_x + normal_z * normal_z);
  if (map_pn == 0 && map_m_norm == 0) {
    tex_space = tmp_rot;
  } else {
    if (map_pn != 0) {
      map_n_norm_neg = -normal_z / map_pn;
      map_p_norm = normal_x / map_pn;
    }
    tmp_normspace[0] = map_m_norm + map_n_norm_neg * map_n_norm_neg * map_1_m;
    tmp_normspace[1] = map_p_norm * map_pn_norm_neg;
    tmp_normspace[2] = map_p_norm * map_n_norm_neg * map_1_m;
    tmp_normspace[3] = -map_p_norm * map_pn_norm_neg;
    tmp_normspace[4] = map_m_norm;
    tmp_normspace[5] = map_n_norm_neg * map_pn_norm_neg;
    tmp_normspace[6] = map_n_norm_neg * map_p_norm * map_1_m;
    tmp_normspace[7] = -map_n_norm_neg * map_pn_norm_neg;
    tmp_normspace[8] = map_m_norm + map_p_norm * map_p_norm * map_1_m;
    tex_space[0] = tmp_rot[0] * tmp_normspace[0] + tmp_rot[1] * tmp_normspace[3] + tmp_rot[2] * tmp_normspace[6];
    tex_space[1] = tmp_rot[0] * tmp_normspace[1] + tmp_rot[1] * tmp_normspace[4] + tmp_rot[2] * tmp_normspace[7];
    tex_space[2] = tmp_rot[0] * tmp_normspace[2] + tmp_rot[1] * tmp_normspace[5] + tmp_rot[2] * tmp_normspace[8];
    tex_space[3] = tmp_rot[3] * tmp_normspace[0] + tmp_rot[4] * tmp_normspace[3] + tmp_rot[5] * tmp_normspace[6];
    tex_space[4] = tmp_rot[3] * tmp_normspace[1] + tmp_rot[4] * tmp_normspace[4] + tmp_rot[5] * tmp_normspace[7];
    tex_space[5] = tmp_rot[3] * tmp_normspace[2] + tmp_rot[4] * tmp_normspace[5] + tmp_rot[5] * tmp_normspace[8];
    tex_space[6] = tmp_rot[6] * tmp_normspace[0] + tmp_rot[7] * tmp_normspace[3] + tmp_rot[8] * tmp_normspace[6];
    tex_space[7] = tmp_rot[6] * tmp_normspace[1] + tmp_rot[7] * tmp_normspace[4] + tmp_rot[8] * tmp_normspace[7];
    tex_space[8] = tmp_rot[6] * tmp_normspace[2] + tmp_rot[7] * tmp_normspace[5] + tmp_rot[8] * tmp_normspace[8];
  }
  tex_space[0] *= scale_x;
  tex_space[1] *= scale_x;
  tex_space[2] *= scale_x;
  tex_space[3] *= scale_y;
  tex_space[4] *= scale_y;
  tex_space[5] *= scale_y;
  tex_space[6] *= scale_z;
  tex_space[7] *= scale_z;
  tex_space[8] *= scale_z;
  return tex_space;
}
function parseRT5Model(modelfile, source) {
  const enabletextures = false;
  let modeldata = parse.oldmodels.read(modelfile, source);
  let maxy = 0;
  let miny = 0;
  let bonecount = 0;
  let skincount = 0;
  let debugmeshes = [];
  let debugmat = new THREE2.MeshBasicMaterial({ wireframe: true });
  let debugmat2 = new THREE2.MeshBasicMaterial({ color: 16711680 });
  let decodedx = new Int16Array(modeldata.vertcount);
  let decodedy = new Int16Array(modeldata.vertcount);
  let decodedz = new Int16Array(modeldata.vertcount);
  let xvalue = 0;
  let yvalue = 0;
  let zvalue = 0;
  let xstream = new Stream(modeldata.posx);
  let ystream = new Stream(modeldata.posy);
  let zstream = new Stream(modeldata.posz);
  for (let i = 0; i < modeldata.vertcount; i++) {
    let flag2 = modeldata.vertflags[i];
    if (flag2 & 1) {
      xvalue += xstream.readShortSmartBias();
    }
    if (flag2 & 2) {
      yvalue += -ystream.readShortSmartBias();
    }
    if (flag2 & 4) {
      zvalue += zstream.readShortSmartBias();
    }
    decodedx[i] = xvalue;
    decodedy[i] = yvalue;
    decodedz[i] = zvalue;
    if (yvalue > maxy) {
      maxy = yvalue;
    }
    if (yvalue < miny) {
      miny = yvalue;
    }
  }
  if (!xstream.eof()) {
    throw new Error("stream not used to completion");
  }
  if (!ystream.eof()) {
    throw new Error("stream not used to completion");
  }
  if (!zstream.eof()) {
    throw new Error("stream not used to completion");
  }
  let textureMappings = [];
  for (let i = 0; i < modeldata.texmapcount; i++) {
    let flag2 = modeldata.texflags[i];
    textureMappings.push({
      texspace: new Matrix4(),
      vertexsum: new Vector3(),
      vertexcount: 0,
      vertexmin: new Vector3(1e7, 1e7, 1e7),
      vertexmax: new Vector3(-1e7, -1e7, -1e7),
      args: flag2
    });
  }
  let matusecount = /* @__PURE__ */ new Map();
  let matmesh = /* @__PURE__ */ new Map();
  let materialbuffer = modeldata.material;
  let colorbuffer = modeldata.colors;
  let uvids = [];
  let usenewuvkey;
  if (modeldata.modelversion >= 16) {
    usenewuvkey = 32767;
    let uvstream = new Stream(modeldata.uvs);
    while (!uvstream.eof()) {
      uvids.push(uvstream.readUShortSmart());
    }
    if (!uvstream.eof()) {
      throw new Error("stream not used to completion");
    }
  } else {
    usenewuvkey = 255;
    uvids = Array.from(modeldata.uvs);
  }
  if (modeldata.mode_2) {
    materialbuffer = new Uint16Array(modeldata.facecount);
    colorbuffer = colorbuffer.slice();
    for (let i = 0; i < modeldata.facecount; i++) {
      let op = modeldata.mode_2[i];
      if (op & 2) {
        materialbuffer[i] = flipEndian16(flipEndian16(colorbuffer[i]) + 1);
        colorbuffer[i] = flipEndian16(127);
        uvids.push((op >> 2) + 1);
      }
    }
  }
  if (materialbuffer) {
    for (let matid of materialbuffer) {
      matusecount.set(matid, (matusecount.get(matid) ?? 0) + 1);
    }
  } else {
    matusecount.set(0, modeldata.facecount);
  }
  for (let [matid, facecount] of matusecount) {
    let finalvertcount = facecount * 3;
    let colstride = colorbuffer ? modeldata.alpha ? 4 : 3 : 0;
    let mesh = {
      pos: new BufferAttribute2(new Float32Array(finalvertcount * 3), 3),
      normals: new BufferAttribute2(new Float32Array(finalvertcount * 3), 3),
      color: new BufferAttribute2(new Uint8Array(finalvertcount * colstride), colstride, true),
      texuvs: new BufferAttribute2(new Float32Array(finalvertcount * 2), 2),
      index: new Uint16Array(facecount * 3),
      currentface: 0,
      matid: flipEndian16(matid) - 1
      //TODO fix endianness elsewhere
    };
    matmesh.set(matid, mesh);
  }
  let vertexindex = new Uint16Array(modeldata.facecount * 3);
  let srcindex0 = 0, srcindex1 = 0, srcindex2 = 0, srcindexlast = 0;
  let stream = new Stream(modeldata.indexbuffer);
  for (let i = 0; i < modeldata.facecount; i++) {
    let typedata = modeldata.tritype[i];
    let type = typedata & 7;
    if (type == 1) {
      srcindex0 = srcindexlast + stream.readShortSmartBias();
      srcindex1 = srcindex0 + stream.readShortSmartBias();
      srcindex2 = srcindex1 + stream.readShortSmartBias();
      srcindexlast = srcindex2;
    } else if (type == 2) {
      srcindex1 = srcindex2;
      srcindex2 = srcindexlast + stream.readShortSmartBias();
      srcindexlast = srcindex2;
    } else if (type == 3) {
      srcindex0 = srcindex2;
      srcindex2 = srcindexlast + stream.readShortSmartBias();
      srcindexlast = srcindex2;
    } else if (type == 4) {
      let srctmp = srcindex0;
      srcindex0 = srcindex1;
      srcindex1 = srctmp;
      srcindex2 = srcindexlast + stream.readShortSmartBias();
      srcindexlast = srcindex2;
    } else {
      throw new Error("unkown face type");
    }
    vertexindex[i * 3 + 0] = srcindex0;
    vertexindex[i * 3 + 1] = srcindex1;
    vertexindex[i * 3 + 2] = srcindex2;
  }
  if (!stream.eof()) {
    throw new Error("stream not used to completion");
  }
  if (materialbuffer) {
    let posa = new Vector3();
    let posb = new Vector3();
    let posc = new Vector3();
    let texindex = 0;
    for (let i = 0; i < modeldata.facecount; i++) {
      let matarg = materialbuffer[i];
      if (matarg == 0) {
        continue;
      }
      let mapid = texindex < uvids.length ? uvids[texindex++] : 0;
      if (mapid != 0 && mapid != usenewuvkey) {
        let mapping = textureMappings[mapid - 1];
        srcindex0 = vertexindex[i * 3 + 0];
        srcindex1 = vertexindex[i * 3 + 1];
        srcindex2 = vertexindex[i * 3 + 2];
        posa.set(decodedx[srcindex0], decodedy[srcindex0], decodedz[srcindex0]);
        posb.set(decodedx[srcindex1], decodedy[srcindex1], decodedz[srcindex1]);
        posc.set(decodedx[srcindex2], decodedy[srcindex2], decodedz[srcindex2]);
        mapping.vertexsum.add(posa).add(posb).add(posc);
        mapping.vertexmin.min(posa).min(posb).min(posc);
        mapping.vertexmax.max(posa).max(posb).max(posc);
        mapping.vertexcount += 3;
      }
    }
  }
  let hadbaduvscale = false;
  if (modeldata.texflags) {
    let mtmp = new Matrix4();
    let v02 = new Vector3();
    let v12 = new Vector3();
    let v22 = new Vector3();
    let vtmp = new Vector3();
    let texmap_verts = modeldata.texmap_verts_1 ?? modeldata.texmap_verts_2;
    for (let i = 0; i < modeldata.texflags.length; i++) {
      let mapping = textureMappings[i];
      if (mapping.args.type == 0) {
        let [i0, i1, i2] = texmap_verts[mapping.args.vertindex];
        v02.set(decodedx[i0], decodedy[i0], decodedz[i0]);
        v12.set(decodedx[i1], decodedy[i1], decodedz[i1]);
        v22.set(decodedx[i2], decodedy[i2], decodedz[i2]);
        v12.sub(v02);
        v22.sub(v02);
        vtmp.copy(v12).cross(v22);
        mapping.texspace.set(
          v12.x,
          v22.x,
          vtmp.x,
          v02.x,
          v12.y,
          v22.y,
          vtmp.y,
          v02.y,
          v12.z,
          v22.z,
          vtmp.z,
          v02.z,
          0,
          0,
          0,
          1
        );
        mapping.texspace.invert();
      } else if (mapping.args.type >= 1) {
        let proj = modeldata.texmap_projections[mapping.args.projection];
        let scalex = 1, scaley = 1, scalez = 1;
        if (mapping.args.type == 1) {
          let scale = proj.scale[0];
          if (scale > 0) {
            scalex = 1;
            scalez = scale / 1024;
          } else if (scale < 0) {
            scalex = -scale / 1024;
            scalez = 1;
          }
          scalex *= 512;
          scalez *= 512;
          scaley = 64 / (proj.scale[1] & 65535);
        } else if (mapping.args.type == 2) {
          scalex = 64 / (proj.scale[0] & 65535);
          scaley = 64 / (proj.scale[1] & 65535);
          scalez = 64 / (proj.scale[2] & 65535);
        } else {
          scalex = proj.scale[0] / 1024;
          scaley = proj.scale[1] / 1024;
          scalez = proj.scale[2] / 1024;
        }
        if (!isFinite(scalex)) {
          scalex = 1;
          hadbaduvscale = true;
        }
        if (!isFinite(scaley)) {
          scaley = 1;
          hadbaduvscale = true;
        }
        if (!isFinite(scalez)) {
          scalez = 1;
          hadbaduvscale = true;
        }
        let space = jagexOldNormalSpace(proj.normal[0], proj.normal[1], proj.normal[2], proj.rotation, scalex, scaley, scalez);
        mapping.texspace.set(
          space[0],
          -space[1],
          space[2],
          0,
          space[3],
          -space[4],
          space[5],
          0,
          space[6],
          -space[7],
          space[8],
          0,
          0,
          0,
          0,
          1
        );
        v02.copy(mapping.vertexmax).add(mapping.vertexmin).divideScalar(-2);
        mtmp.makeTranslation(v02.x, v02.y, v02.z);
        mapping.texspace.multiply(mtmp);
      }
      if (globalThis.testmat >= 0 && globalThis.testmat == i) {
        let geo2 = new LatheGeometry([new Vector2(0.05, 0), new Vector2(0.05, 1), new Vector2(0.15, 1), new Vector2(0, 1.15)]);
        let geo;
        if (mapping.args.type == 0) {
          geo = new PlaneGeometry2(1, 1);
        } else if (mapping.args.type == 1) {
          geo = new CylinderGeometry(0.5, 0.5, 1, 10);
        } else if (mapping.args.type == 2) {
          geo = new BoxGeometry(1, 1, 1);
        } else if (mapping.args.type == 3) {
          geo = new SphereGeometry(1);
        }
        let mesh = new Mesh2(geo, debugmat);
        let arrowmesh = new Mesh2(geo2, debugmat2);
        mesh.matrixAutoUpdate = false;
        mesh.matrix.copy(mapping.texspace).invert();
        arrowmesh.matrixAutoUpdate = false;
        arrowmesh.matrix.copy(mapping.texspace).invert();
        debugmeshes.push(mesh, arrowmesh);
      }
    }
  }
  if (hadbaduvscale && nonfiniteWarnCount++ < 20) {
    console.warn("nonfinite texture scale");
  }
  let vertexuvids = null;
  if (modeldata.texuvs) {
    vertexuvids = new Uint16Array(modeldata.vertcount);
    let vertexuvcount = 0;
    for (let i = 0; i < modeldata.texuvs.vertex.length; i++) {
      vertexuvids[i] = vertexuvcount;
      vertexuvcount += modeldata.texuvs.vertex[i];
    }
  }
  let texmapindex = 0;
  let v0 = new Vector3();
  let v1 = new Vector3();
  let v2 = new Vector3();
  let vnormal = new Vector3();
  let vtmp0 = new Vector3();
  let vtmp1 = new Vector3();
  let vtmp2 = new Vector3();
  let m3tmp = new Matrix3();
  for (let i = 0; i < modeldata.facecount; i++) {
    srcindex0 = vertexindex[i * 3 + 0];
    srcindex1 = vertexindex[i * 3 + 1];
    srcindex2 = vertexindex[i * 3 + 2];
    v0.set(decodedx[srcindex0], decodedy[srcindex0], decodedz[srcindex0]);
    v1.set(decodedx[srcindex1], decodedy[srcindex1], decodedz[srcindex1]);
    v2.set(decodedx[srcindex2], decodedy[srcindex2], decodedz[srcindex2]);
    vtmp0.copy(v1).sub(v0);
    vnormal.copy(v2).sub(v0).cross(vtmp0).normalize();
    if (materialbuffer && materialbuffer[i] == 0 && !colorbuffer || colorbuffer[i] == 0) {
      continue;
    }
    let matargument = materialbuffer ? materialbuffer[i] : 0;
    let submesh = matmesh.get(matargument);
    let dstfaceindex = submesh.currentface++;
    let vertbase = dstfaceindex * 3;
    let posattr = submesh.pos;
    let uvattr = submesh.texuvs;
    let normalattr = submesh.normals;
    let indexbuf = submesh.index;
    if (!(Math.abs(1 - vnormal.length()) < 0.01)) {
    }
    posattr.setXYZ(vertbase + 0, v0.x, v0.y, v0.z);
    posattr.setXYZ(vertbase + 1, v1.x, v1.y, v1.z);
    posattr.setXYZ(vertbase + 2, v2.x, v2.y, v2.z);
    normalattr.setXYZ(vertbase + 0, vnormal.x, vnormal.y, vnormal.z);
    normalattr.setXYZ(vertbase + 1, vnormal.x, vnormal.y, vnormal.z);
    normalattr.setXYZ(vertbase + 2, vnormal.x, vnormal.y, vnormal.z);
    if (colorbuffer) {
      let colorattr = submesh.color;
      let colint = colorbuffer[i];
      let [r2, g, b] = HSL2RGBfloat(packedHSL2HSL(flipEndian16(colint)));
      if (!modeldata.alpha) {
        colorattr.setXYZ(vertbase + 0, r2, g, b);
        colorattr.setXYZ(vertbase + 1, r2, g, b);
        colorattr.setXYZ(vertbase + 2, r2, g, b);
      } else {
        let alpha = (255 - modeldata.alpha[i]) / 255;
        colorattr.setXYZW(vertbase + 0, r2, g, b, alpha);
        colorattr.setXYZW(vertbase + 1, r2, g, b, alpha);
        colorattr.setXYZW(vertbase + 2, r2, g, b, alpha);
      }
    }
    if (matargument) {
      let mapid = texmapindex < uvids.length ? uvids[texmapindex++] : 0;
      if (mapid == 0) {
      } else if (mapid == usenewuvkey) {
        uvattr.setXY(vertbase + 0, modeldata.texuvs.udata[vertexuvids[srcindex0]] / 4096, modeldata.texuvs.vdata[vertexuvids[srcindex0]] / 4096);
        uvattr.setXY(vertbase + 1, modeldata.texuvs.udata[vertexuvids[srcindex1]] / 4096, modeldata.texuvs.vdata[vertexuvids[srcindex1]] / 4096);
        uvattr.setXY(vertbase + 2, modeldata.texuvs.udata[vertexuvids[srcindex2]] / 4096, modeldata.texuvs.vdata[vertexuvids[srcindex2]] / 4096);
      } else {
        let mapping = textureMappings[mapid - 1];
        v0.applyMatrix4(mapping.texspace);
        v1.applyMatrix4(mapping.texspace);
        v2.applyMatrix4(mapping.texspace);
        if (mapping.args.type == 0) {
          uvattr.setXY(vertbase + 0, v0.x, v0.y);
          uvattr.setXY(vertbase + 1, v1.x, v1.y);
          uvattr.setXY(vertbase + 2, v2.x, v2.y);
        } else if (mapping.args.type == 1) {
          let u0 = Math.atan2(v0.z, v0.x) / Math.PI / 2 * 3;
          let u1 = Math.atan2(v1.z, v1.x) / Math.PI / 2 * 3;
          let u2 = Math.atan2(v2.z, v2.x) / Math.PI / 2 * 3;
          uvattr.setXY(vertbase + 0, u0 - 0.5, v0.y - 0.5);
          uvattr.setXY(vertbase + 1, u1 - 0.5, v1.y - 0.5);
          uvattr.setXY(vertbase + 2, u2 - 0.5, v2.y - 0.5);
        } else if (mapping.args.type == 2) {
          vtmp0.copy(v1).sub(v0);
          vtmp1.copy(v2).sub(v0).cross(vtmp0);
          m3tmp.setFromMatrix4(mapping.texspace);
          vtmp1.applyMatrix3(m3tmp);
          let max = Math.max(vtmp1.x, -vtmp1.x, vtmp1.y, -vtmp1.y, vtmp1.z, -vtmp1.z);
          if (vtmp1.x == max) {
            m3tmp.set(0, 0, 1, 0, -1, 0, 0, 0, 0);
          } else if (vtmp1.x == -max) {
            m3tmp.set(0, 0, -1, 0, -1, 0, 0, 0, 0);
          } else if (vtmp1.z == max) {
            m3tmp.set(1, 0, 0, 0, -1, 0, 0, 0, 0);
          } else if (vtmp1.z == -max) {
            m3tmp.set(-1, 0, 0, 0, -1, 0, 0, 0, 0);
          } else if (vtmp1.y == max) {
            m3tmp.set(1, 0, 0, 0, 0, 1, 0, 0, 0);
          } else if (vtmp1.y == -max) {
            m3tmp.set(1, 0, 0, 0, 0, 1, 0, 0, 0);
          } else {
            throw new Error("unexpected");
          }
          vtmp0.copy(v0).applyMatrix3(m3tmp).subScalar(0.5);
          vtmp1.copy(v1).applyMatrix3(m3tmp).subScalar(0.5);
          vtmp2.copy(v2).applyMatrix3(m3tmp).subScalar(0.5);
          uvattr.setXY(vertbase + 0, vtmp0.x, vtmp0.y);
          uvattr.setXY(vertbase + 1, vtmp1.x, vtmp1.y);
          uvattr.setXY(vertbase + 2, vtmp2.x, vtmp2.y);
        } else if (mapping.args.type == 3) {
          let u0 = Math.atan2(v0.z, v0.x) / Math.PI / 2;
          let u1 = Math.atan2(v1.z, v1.x) / Math.PI / 2;
          let u2 = Math.atan2(v2.z, v2.x) / Math.PI / 2;
          let vv0 = Math.atan2(v0.y, Math.sqrt(v0.x * v0.x + v0.z * v0.z)) / Math.PI / 2;
          let vv1 = Math.atan2(v1.y, Math.sqrt(v1.x * v1.x + v1.z * v1.z)) / Math.PI / 2;
          let vv2 = Math.atan2(v2.y, Math.sqrt(v2.x * v2.x + v2.z * v2.z)) / Math.PI / 2;
          uvattr.setXY(vertbase + 0, u0, vv0);
          uvattr.setXY(vertbase + 1, u1, vv1);
          uvattr.setXY(vertbase + 2, u2, vv2);
        }
      }
      if (globalThis.testmat >= 0 && globalThis.testmat != mapid - 1) {
        uvattr.setXY(vertbase + 0, 0, 0);
        uvattr.setXY(vertbase + 1, 0, 0);
        uvattr.setXY(vertbase + 2, 0, 0);
        let colorattr = submesh.color;
        colorattr.setXYZ(vertbase + 0, 0, 0, 0);
        colorattr.setXYZ(vertbase + 1, 0, 0, 0);
        colorattr.setXYZ(vertbase + 2, 0, 0, 0);
      }
    }
    indexbuf[dstfaceindex * 3 + 0] = vertbase + 0;
    indexbuf[dstfaceindex * 3 + 1] = vertbase + 2;
    indexbuf[dstfaceindex * 3 + 2] = vertbase + 1;
  }
  let meshes = [...matmesh.values()].map((m) => {
    let indices = new BufferAttribute2(m.index, 1);
    return {
      indices,
      vertexstart: 0,
      vertexend: m.pos.count,
      indexLODs: [indices],
      materialId: m.matid,
      hasVertexAlpha: !!modeldata.alpha,
      needsNormalBlending: true,
      attributes: {
        pos: m.pos,
        color: m.color,
        texuvs: m.texuvs,
        normals: m.normals
      }
    };
  });
  if (modeldata.modelversion <= 7) {
    const scale = 4;
    maxy *= scale;
    miny *= scale;
    for (let mesh of meshes) {
      let arr = mesh.attributes.pos.array;
      for (let i = 0; i < arr.length; i++) {
        arr[i] *= scale;
      }
    }
  }
  let r = { maxy, miny, meshes, bonecount, skincount, debugmeshes };
  return r;
}

// rsmv/src/3d/jmat.ts
function defaultMaterial() {
  return {
    textures: {},
    texmodes: "repeat",
    texmodet: "repeat",
    uvAnim: void 0,
    baseColorFraction: 0,
    baseColor: [1, 1, 1],
    alphamode: "opaque",
    alphacutoff: 0.1,
    stripDiffuseAlpha: false,
    raw: null
  };
}
function materialCacheKey(matid, hasVertexAlpha, minimapVariant) {
  return (matid == -1 ? 4194303 : matid) | (hasVertexAlpha ? 8388608 : 0) | (minimapVariant ? 4194304 : 0);
}
function convertMaterial(data, materialid, source) {
  let rawparsed = parse.materials.read(data, source);
  let mat = defaultMaterial();
  mat.raw = rawparsed;
  if (rawparsed.v0) {
    let raw = rawparsed.v0;
    let olddiffuse = raw.arr.find((q) => q.op == 1);
    if (olddiffuse) {
      if (source.getBuildNr() <= 838) {
        mat.textures.diffuse = olddiffuse.value;
      } else {
        mat.textures.diffuse = materialid;
      }
    } else if (raw.diffuse) {
      mat.textures.diffuse = raw.diffuse;
    } else if (raw.textureflags & 17) {
      mat.textures.diffuse = materialid;
    }
    if (raw.normal) {
      mat.textures.normal = raw.normal;
    } else if (raw.textureflags & 10) {
      mat.textures.normal = materialid;
    }
    let repeatu = raw.texrepeatflags & 7;
    let repeatv = raw.textureflags >> 2 & 7;
    mat.texmodes = repeatu == 0 ? "mirror" : repeatu == 1 ? "repeat" : "clamp";
    mat.texmodet = repeatv == 0 ? "mirror" : repeatv == 1 ? "repeat" : "clamp";
    mat.alphamode = raw.alphamode == 0 ? "opaque" : raw.alphamode == 1 ? "cutoff" : "blend";
    if (raw.alphacutoff) {
      mat.alphacutoff = raw.alphacutoff / 255;
    }
    if (raw.animtexU || raw.animtexV) {
      let scale = 1 / (1 << 15);
      mat.uvAnim = { u: (raw.animtexU ?? 0) * scale, v: (raw.animtexV ?? 0) * scale };
    }
    if (raw.extra) {
      mat.baseColorFraction = raw.extra.baseColorFraction / 255;
      mat.baseColor = raw.extra.baseColor == 0 ? [1, 1, 1] : HSL2RGBfloat(packedHSL2HSL(raw.extra.baseColor));
    }
    mat.stripDiffuseAlpha = mat.alphamode == "opaque";
  } else if (rawparsed.v1) {
    let raw = rawparsed.v1;
    mat.alphamode = raw.opaque_2 && !raw.hasUVanimU ? "cutoff" : "blend";
    mat.baseColorFraction = 1;
    if (raw.diffuse) {
      mat.textures.diffuse = raw.diffuse.texture;
    }
    if (raw.normal) {
      mat.textures.normal = raw.normal.texture;
    }
    if (raw.compound) {
      mat.textures.compound = raw.compound.texture;
    }
    if (raw.uvanim_u || raw.uvanim_v) {
      let scale = 1 / (1 << 15);
      mat.uvAnim = { u: (raw.uvanim_u ?? 0) * scale, v: (raw.uvanim_v ?? 0) * scale };
    }
  } else {
    throw new Error("unkown material version " + rawparsed.version);
  }
  return mat;
}

// rsmv/src/3d/modeltothree.ts
import * as THREE4 from "three";

// rsmv/src/libs/crc32util.ts
var POLY = 3988292384;
var crc32_table = new Uint32Array(256);
var crc32_reverse = new Uint32Array(256);
function build_crc_tables() {
  for (let i = 0; i < 256; i++) {
    let fwd = i;
    let rev = i << 24;
    for (let j = 8; j > 0; j--) {
      if ((fwd & 1) == 1) {
        fwd = fwd >>> 1 ^ POLY;
      } else {
        fwd >>>= 1;
      }
      if ((rev & 2147483648) != 0) {
        rev = (rev ^ POLY) << 1 | 1;
      } else {
        rev <<= 1;
      }
      rev &= 4294967295;
    }
    crc32_table[i] = fwd & 4294967295;
    crc32_reverse[i] = rev;
  }
}
build_crc_tables();
function crc32(buf, crc = 0, rangeStart = 0, rangeEnd = buf.length) {
  crc = crc ^ 4294967295;
  for (let i = rangeStart; i < rangeEnd; i++) {
    crc = crc >>> 8 ^ crc32_table[(crc ^ buf[i]) & 255];
  }
  return (crc ^ 4294967295) >>> 0;
}
var staticintbuf = Buffer.alloc(4);
function crc32addInt(int2, crc) {
  staticintbuf.writeUInt32BE(int2 >>> 0);
  return crc32(staticintbuf, crc);
}
var CrcBuilder = class _CrcBuilder {
  constructor(initcrc = 0) {
    this.crc = initcrc ^ 4294967295;
  }
  addbyte(byte) {
    this.crc = this.crc >>> 8 ^ crc32_table[(this.crc ^ byte & 255) & 255];
  }
  addUint16Flipped(u16) {
    this.crc = this.crc >>> 8 ^ crc32_table[(this.crc ^ u16 >> 16 & 255) & 255];
    this.crc = this.crc >>> 8 ^ crc32_table[(this.crc ^ u16 & 255) & 255];
  }
  addUint16(u16) {
    this.crc = this.crc >>> 8 ^ crc32_table[(this.crc ^ u16 & 255) & 255];
    this.crc = this.crc >>> 8 ^ crc32_table[(this.crc ^ u16 >> 16 & 255) & 255];
  }
  addUint32(u16) {
    this.crc = this.crc >>> 8 ^ crc32_table[(this.crc ^ u16 >> 0 & 255) & 255];
    this.crc = this.crc >>> 8 ^ crc32_table[(this.crc ^ u16 >> 16 & 255) & 255];
    this.crc = this.crc >>> 8 ^ crc32_table[(this.crc ^ u16 >> 24 & 255) & 255];
    this.crc = this.crc >>> 8 ^ crc32_table[(this.crc ^ u16 >> 32 & 255) & 255];
  }
  get() {
    return (this.crc ^ 4294967295) >>> 0;
  }
  fork() {
    return new _CrcBuilder(this.get());
  }
};
function crc32_backward(buf, crc, rangeStart = 0, rangeEnd = buf.length) {
  crc = crc ^ 4294967295;
  for (let i = rangeEnd - 1; i >= rangeStart; i--) {
    crc = crc << 8 & 4294967295 ^ crc32_reverse[crc >>> 24] ^ buf[i];
  }
  return (crc ^ 4294967295) >>> 0;
}
function intbuffer(value, bigendian = false, bytes = 4) {
  let buf = Buffer.alloc(bytes);
  if (bigendian) {
    buf.writeUIntBE(value >>> 0, 0, bytes);
  } else {
    buf.writeUIntLE(value >>> 0, 0, bytes);
  }
  return buf;
}
function forge_crcbytes(frontcrc, backcrc) {
  let fwd_bytes = intbuffer(frontcrc);
  let bkd_crc = crc32_backward(fwd_bytes, backcrc);
  return intbuffer(bkd_crc);
}

// rsmv/src/libs/xtea.ts
var ROUNDS = 32;
var DELTA = 2654435769;
function simplexteadecrypt(data, key) {
  let res = Buffer.allocUnsafe(data.length);
  let index = 0;
  for (; index <= data.length - 8; index += 8) {
    let v0 = data.readUInt32BE(index + 0);
    let v1 = data.readUInt32BE(index + 4);
    var sum = DELTA * ROUNDS >>> 0;
    while (sum) {
      v1 -= (v0 << 4 >>> 0 ^ v0 >>> 5) + v0 ^ sum + key[sum >> 11 & 3];
      v1 = v1 >>> 0;
      sum = sum - DELTA >>> 0;
      v0 -= (v1 << 4 >>> 0 ^ v1 >>> 5) + v1 ^ sum + key[sum & 3];
      v0 = v0 >>> 0;
    }
    res.writeUInt32BE(v0, index + 0);
    res.writeUInt32BE(v1, index + 4);
  }
  data.copy(res, index, index, res.length);
  return res;
}

// rsmv/src/cache/compression.ts
function decompress(input, key) {
  switch (input.readUInt8(0)) {
    case 0:
      return _uncompressed(input);
    case 1:
      return _bz2(input);
    case 2:
      return _zlib(input, key);
    case 3:
      return _lzma(input);
    case 90:
      return _zlibSqlite(input);
    default:
      throw new Error("Unknown compression type (" + input.readUInt8(0).toString() + ")");
  }
}
function compressSqlite(input, compression) {
  switch (compression) {
    case "zlib":
      return _zlibSqliteCompress(input);
    default:
      throw new Error(`unknown compression type ${compression}`);
  }
}
var _uncompressed = function(input) {
  var size = input.readUInt32BE(1);
  var output = Buffer.alloc(size);
  input.copy(output, 0, 5);
  return output;
};
var _bz2 = function(input) {
  var bzip2 = require_bzip2fork();
  var compressed = input.readUInt32BE(1);
  var uncompressed = input.readUInt32BE(5);
  var processed = Buffer.alloc(compressed + 2 + 1 + 1);
  input.copy(processed, 4, 9);
  processed.writeUInt16BE(16986, 0);
  processed.writeUInt8(104, 2);
  processed.writeUInt8(8 + 48, 3);
  return Buffer.from(bzip2.simple(bzip2.array(processed)));
};
function legacybz2(input) {
  var bzip2 = require_bzip2fork();
  var processed = Buffer.alloc(input.byteLength + 4);
  input.copy(processed, 4);
  processed.writeUInt16BE(16986, 0);
  processed.writeUInt8(104, 2);
  processed.writeUInt8(8 + 48, 3);
  return Buffer.from(bzip2.simple(bzip2.array(processed)));
}
var _zlib = function(input, key) {
  var zlib2 = __require("zlib");
  try {
    let compressedsize = input.readUint32BE(1);
    if (key) {
      let compressedData = simplexteadecrypt(input.slice(5, 5 + 4 + compressedsize), key);
      return zlib2.gunzipSync(compressedData.slice(4, 4 + compressedsize));
    } else {
      let compressedData = input.slice(9, 9 + compressedsize);
      return zlib2.gunzipSync(compressedData);
    }
  } catch (e) {
    throw new Error(`gzip decompress failed, possibly due to missing or wrong xtea key, key: ${key ?? "none"}`, { cause: e });
  }
};
function legacyGzip(input) {
  var zlib2 = __require("zlib");
  return zlib2.gunzipSync(input);
}
var nativelzma = null;
var nativelzmaAttempted = false;
var _lzma = function(input) {
  var compressed = input.readUInt32BE(1);
  var uncompressed = input.readUInt32BE(5);
  var processed = Buffer.alloc(compressed + 8);
  input.copy(processed, 0, 9, 14);
  processed.writeUInt32LE(uncompressed, 5);
  processed.writeUInt32LE(0, 5 + 4);
  input.copy(processed, 13, 14);
  if (!nativelzmaAttempted && !nativelzma) {
    nativelzmaAttempted = true;
    try {
      nativelzma = __non_webpack_require__("lzma-native").LZMA();
    } catch (e) {
      console.log("can't load native lzma, falling back to naive js implementation");
    }
  }
  if (nativelzma) {
    return nativelzma.decompress(processed);
  } else {
    var lzma = __require("lzma/src/lzma_worker.js").LZMA;
    return Buffer.from(lzma.decompress(processed));
  }
};
function _zlibSqlite(input) {
  var uncompressed_size = input.readUInt32BE(4);
  var zlib2 = __require("zlib");
  return zlib2.inflateSync(input.slice(8));
}
function _zlibSqliteCompress(input) {
  const zlib2 = __require("zlib");
  let compressbytes = zlib2.deflateSync(input);
  let result = Buffer.alloc(4 + 4 + compressbytes.byteLength);
  result.write("5a4c4201", 0, "hex");
  result.writeUInt32BE(input.byteLength, 4);
  compressbytes.copy(result, 8);
  return result;
}

// rsmv/src/3d/sprite.ts
function parseSubsprite(buf, palette, width, height, alpha, transposed) {
  let imgsize = width * height;
  let offset = 0;
  let imgdata = new Uint8ClampedArray(imgsize * 4);
  let indexoffset = offset;
  let alphaoffset = offset + imgsize;
  offset += imgsize + (alpha ? imgsize : 0);
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      let outoffset = x * 4 + y * width * 4;
      let inoffset = transposed ? y + x * height : x + y * width;
      let pxindex = buf.readUInt8(indexoffset + inoffset);
      if (pxindex == 0) {
        imgdata[outoffset + 0] = 0;
        imgdata[outoffset + 1] = 0;
        imgdata[outoffset + 2] = 0;
        imgdata[outoffset + 3] = 0;
      } else {
        let paletteoffset = (pxindex - 1) * 3;
        imgdata[outoffset + 0] = palette[paletteoffset + 0];
        imgdata[outoffset + 1] = palette[paletteoffset + 1];
        imgdata[outoffset + 2] = palette[paletteoffset + 2];
        imgdata[outoffset + 3] = alpha ? buf.readUInt8(alphaoffset + inoffset) : 255;
      }
    }
  }
  return {
    img: makeImageData(imgdata, width, height),
    bytesused: offset
  };
}
function parseLegacySprite(metafile, buf) {
  let file = new Stream(buf);
  let metaoffset = file.readUShort(true);
  if (!metafile) {
    throw new Error("sprite meta file not found");
  }
  let meta = new Stream(metafile);
  meta.skip(metaoffset);
  let totalwidth = meta.readUShort(true);
  let totalheight = meta.readUShort(true);
  let palettecount = meta.readUByte() - 1;
  let palette = meta.readBuffer(palettecount * 3);
  let imgs = [];
  while (!file.eof()) {
    let offsetx = meta.readUByte();
    let offsety = meta.readUByte();
    let width = meta.readUShort(true);
    let height = meta.readUShort(true);
    let transpose = meta.readUByte() != 0;
    let imgbytes = file.readBuffer(width * height);
    imgs.push({
      x: offsetx,
      y: offsety,
      fullwidth: totalwidth,
      fullheight: totalheight,
      img: parseSubsprite(imgbytes, palette, width, height, false, transpose).img
    });
  }
  if (imgs.length != 1) {
    console.log(imgs);
  }
  return imgs[0];
}
function expandSprite(subimg) {
  if (subimg.x == 0 && subimg.y == 0 && subimg.fullwidth == subimg.img.width && subimg.fullheight == subimg.img.height) {
    return subimg.img;
  }
  let img = new ImageData(subimg.fullwidth, subimg.fullheight);
  for (let dy = 0; dy < subimg.img.height; dy++) {
    let instride = subimg.img.width * 4;
    let inoffset = dy * instride;
    let outstride = img.width * 4;
    let outoffset = (dy + subimg.y) * outstride + subimg.x * 4;
    img.data.set(subimg.img.data.subarray(inoffset, inoffset + instride), outoffset);
  }
  return img;
}
function parseSprite(buf) {
  let data = buf.readUInt16BE(buf.length - 2);
  let format = data >> 15;
  let count = data & 32767;
  let spriteimgs = [];
  if (format == 0) {
    let footsize = 7 + 8 * count;
    let offset = buf.length - footsize;
    let maxwidth = buf.readUInt16BE(offset);
    offset += 2;
    let maxheight = buf.readUInt16BE(offset);
    offset += 2;
    let palette_count = buf.readUInt8(offset);
    offset++;
    let subimgs = [];
    for (let subimg = 0; subimg < count; subimg++) {
      subimgs.push({
        x: buf.readUInt16BE(offset + count * 0 + subimg * 2),
        y: buf.readUInt16BE(offset + count * 2 + subimg * 2),
        width: buf.readUInt16BE(offset + count * 4 + subimg * 2),
        height: buf.readUInt16BE(offset + count * 6 + subimg * 2)
      });
    }
    let palette = buf.slice(buf.length - footsize - 3 * palette_count, buf.length - footsize);
    offset = 0;
    for (let imgdef of subimgs) {
      if (imgdef.width != 0 && imgdef.height != 0) {
        let flags = buf.readUInt8(offset);
        offset++;
        let transposed = (flags & 1) != 0;
        let alpha = (flags & 2) != 0;
        let subimg = parseSubsprite(buf.slice(offset), palette, imgdef.width, imgdef.height, alpha, transposed);
        offset += subimg.bytesused;
        spriteimgs.push({
          x: imgdef.x,
          y: imgdef.y,
          fullwidth: maxwidth,
          fullheight: maxheight,
          img: subimg.img
        });
      }
    }
  } else {
    let offset = 0;
    let type = buf.readUInt8(offset);
    offset++;
    if (type != 0) {
      throw new Error("unknown type");
    }
    let flags = buf.readUInt8(offset);
    offset++;
    let alpha = (flags & 1) != 0;
    let width = buf.readUInt16BE(offset);
    offset += 2;
    let height = buf.readUInt16BE(offset);
    offset += 2;
    let coloroffset = offset;
    offset += width * height * 3;
    let alphaoffset = offset;
    offset += alpha ? width * height : 0;
    let imgdata = new Uint8ClampedArray(width * height * 4);
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let outoffset = x * 4 + y * width * 4;
        let inoffset = x + y * width;
        imgdata[outoffset + 0] = buf.readUInt8(coloroffset + inoffset * 3 + 0);
        imgdata[outoffset + 1] = buf.readUInt8(coloroffset + inoffset * 3 + 1);
        imgdata[outoffset + 2] = buf.readUInt8(coloroffset + inoffset * 3 + 2);
        imgdata[outoffset + 3] = alpha ? buf.readUInt8(alphaoffset + inoffset + 2) : 255;
      }
    }
    spriteimgs.push({
      x: 0,
      y: 0,
      fullwidth: width,
      fullheight: height,
      img: makeImageData(imgdata, width, height)
    });
  }
  return spriteimgs;
}
function parseTgaSprite(file) {
  let str = new Stream(file);
  let idlength = str.readUByte();
  let colormaptype = str.readUByte();
  let datatypecode = str.readUByte();
  let colormapoffset = str.readUShort(false);
  let colormaplen = str.readUShort(false);
  let colormapdepth = str.readUByte();
  let originx = str.readUShort(false);
  let originy = str.readUShort(false);
  let width = str.readUShort(false);
  let height = str.readUShort(false);
  let bpp = str.readUByte();
  let imgdescr = str.readUByte();
  str.skip(idlength);
  if (colormaptype != 1 || bpp != 8) {
    throw new Error("only palette based uncompressed TGA supported");
  }
  if (colormapdepth != 24) {
    throw new Error("only 24bpp rgb TGA supported");
  }
  if (imgdescr != 0) {
    throw new Error("no fancy TGA's allowed");
  }
  let palette = str.readBuffer(colormaplen * 3);
  let imgdata = new Uint8ClampedArray(width * height * 4);
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      let outoffset = x * 4 + y * width * 4;
      let pxindex = str.readUByte();
      let paletteoffset = pxindex * 3;
      imgdata[outoffset + 0] = palette[paletteoffset + 2];
      imgdata[outoffset + 1] = palette[paletteoffset + 1];
      imgdata[outoffset + 2] = palette[paletteoffset + 0];
      imgdata[outoffset + 3] = 255;
      if (imgdata[outoffset + 0] == 255 && imgdata[outoffset + 1] == 0 && imgdata[outoffset + 2] == 255) {
        imgdata[outoffset + 0] = 0;
        imgdata[outoffset + 1] = 0;
        imgdata[outoffset + 2] = 0;
        imgdata[outoffset + 3] = 0;
      }
    }
  }
  if (!str.eof) {
    console.warn("didn't parse TGA sprite to completion");
  }
  let r = {
    x: originx,
    y: originy,
    fullwidth: width,
    fullheight: height,
    img: makeImageData(imgdata, width, height)
  };
  return r;
}

// rsmv/src/cache/legacycache.ts
var legacyMajors = {
  data: 0,
  //mostly index 2 in dat2
  oldmodels: 1,
  //index 7 in dat2
  oldframebases: 2,
  //index 0 in dat2
  //3? has 636 files sprites?
  map: 4
  // index 5 in dat2
};
var legacyGroups = {
  //1 login 
  config: 2,
  //3 interface?
  sprites: 4,
  index: 5,
  textures: 6
};
function parseLegacyArchive(file, major, isclassic) {
  if (!isclassic && major != 0) {
    return [{
      buffer: file,
      fileid: 0,
      namehash: null,
      offset: 0,
      size: file.byteLength
    }];
  }
  let stream = new Stream(file);
  let len = stream.readTribyte();
  let compressedlen = stream.readTribyte();
  if (compressedlen != len) {
    stream = new Stream(legacybz2(stream.readBuffer()));
    if (stream.bytesLeft() != len) {
      throw new Error("decompress failed");
    }
  }
  let files = [];
  let count = stream.readUShort(true);
  let filestream = stream.tee().skip(count * 10);
  for (let i = 0; i < count; i++) {
    let namehash = stream.readUInt(true);
    let subdecomplen = stream.readTribyte();
    let subcomplen = stream.readTribyte();
    let subfileoffset = filestream.scanloc();
    let subfile = filestream.readBuffer(subcomplen);
    if (subdecomplen != subcomplen) {
      subfile = legacybz2(subfile);
      if (subfile.length != subdecomplen) {
        throw new Error("decompress failed");
      }
    }
    files.push({
      fileid: i,
      buffer: subfile,
      offset: subfileoffset,
      size: subdecomplen,
      namehash
    });
  }
  return files;
}
async function legacyPreload(engine) {
  let indexgroup = await engine.getArchiveById(legacyMajors.data, legacyGroups.index);
  let configgroup = await engine.getArchiveById(legacyMajors.data, legacyGroups.config);
  let r = {
    items: readLegacySubGroup(configgroup, "OBJ"),
    objects: readLegacySubGroup(configgroup, "LOC"),
    overlays: readLegacySubGroup(configgroup, "FLO"),
    npcs: readLegacySubGroup(configgroup, "NPC"),
    // spotanims: readLegacySubGroup(configgroup, "SPOT")
    underlays: [],
    spotanims: [],
    mapmeta: readLegacyMapIndex(indexgroup)
  };
  return r;
}
function readLegacyMapIndex(group) {
  let indexname = cacheFilenameHash(`MAP_INDEX`, true);
  let versionname = cacheFilenameHash(`MAP_VERSION`, true);
  let crcname = cacheFilenameHash(`MAP_CRC`, true);
  let indexfile = group.find((q) => q.namehash == indexname);
  let versionfile = group.find((q) => q.namehash == versionname);
  let crcfile = group.find((q) => q.namehash == crcname);
  if (!indexfile || !versionfile || !crcfile) {
    throw new Error();
  }
  let index = new Stream(indexfile.buffer);
  let version = new Stream(versionfile.buffer);
  let crc = new Stream(crcfile.buffer);
  let mapinfo = /* @__PURE__ */ new Map();
  while (!index.eof()) {
    mapinfo.set(index.readUShort(true), {
      map: index.readUShort(true),
      loc: index.readUShort(true),
      crc: crc.readUInt(true),
      version: version.readUShort(true)
    });
    index.readUByte();
  }
  return mapinfo;
}
function readLegacySubGroup(group, groupname) {
  let idxname = cacheFilenameHash(`${groupname}.IDX`, true);
  let datname = cacheFilenameHash(`${groupname}.DAT`, true);
  let idxfile = group.find((q) => q.namehash == idxname);
  let datfile = group.find((q) => q.namehash == datname);
  if (!idxfile || !datfile) {
    throw new Error();
  }
  let idx = new Stream(idxfile.buffer);
  let count = idx.readUShort(true);
  let offset = 2;
  let files = [];
  for (let i = 0; i < count; i++) {
    let size = idx.readUShort(true);
    files.push(datfile.buffer.slice(offset, offset + size));
    offset += size;
  }
  return files;
}
async function getLegacyImage(source, name, usetga) {
  let filename = `${name}.${usetga ? "tga" : "dat"}`;
  let spritefile = await source.findSubfileByName(legacyMajors.data, legacyGroups.textures, filename);
  if (usetga) {
    return parseTgaSprite(spritefile.buffer);
  } else {
    return parseLegacyImageFile(source, spritefile.buffer);
  }
}
async function parseLegacyImageFile(source, buf) {
  let metafile = await source.findSubfileByName(legacyMajors.data, legacyGroups.textures, "INDEX.DAT");
  return parseLegacySprite(metafile.buffer, buf);
}
async function combineLegacyTexture(engine, name, subname, useTga) {
  let img = await getLegacyImage(engine, name, useTga);
  if (!subname) {
    return img;
  }
  let subimg = await getLegacyImage(engine, subname, useTga);
  if (subimg.img.width + subimg.x > img.img.width || subimg.img.height + subimg.y > img.img.height) {
    console.warn("tried to overlay image outside of dest bounds");
    return img;
    throw new Error("tried to overlay image outside of dest bounds");
  }
  let combined = makeImageData(img.img.data.slice(), img.img.width, img.img.height);
  for (let srcy = 0; srcy < subimg.img.height; srcy++) {
    for (let srcx = 0; srcx < subimg.img.width; srcx++) {
      let srci = (srcy * subimg.img.width + srcx) * 4;
      let dsti = ((srcy + subimg.y) * img.img.width + (srcx + subimg.x)) * 4;
      let subr = subimg.img.data[srci + 0];
      let subg = subimg.img.data[srci + 1];
      let subb = subimg.img.data[srci + 2];
      let suba = subimg.img.data[srci + 3];
      let forcetrans = subr == 0 && subg == 255 && subb == 0 && suba == 255;
      let usesub = suba == 255;
      combined.data[dsti + 0] = forcetrans ? 0 : usesub ? subr : img.img.data[dsti + 0];
      combined.data[dsti + 1] = forcetrans ? 0 : usesub ? subg : img.img.data[dsti + 1];
      combined.data[dsti + 2] = forcetrans ? 0 : usesub ? subb : img.img.data[dsti + 2];
      combined.data[dsti + 3] = forcetrans ? 0 : usesub ? suba : img.img.data[dsti + 3];
    }
  }
  return {
    x: img.x,
    y: img.y,
    fullwidth: img.fullwidth,
    fullheight: img.fullheight,
    img: combined
  };
}

// rsmv/src/cache/index.ts
globalThis.ignoreCache = false;
function packSqliteBufferArchive(buffers) {
  return new Archive(buffers).packSqlite();
}
function unpackSqliteBufferArchive(buffer, subids, namehashes) {
  if (subids.length == 1) {
    return [{ buffer, offset: 0, size: buffer.byteLength, fileid: subids[0], namehash: namehashes?.[0] ?? null }];
  }
  let index = 0;
  let unknownbyte = buffer.readUInt8(index);
  index++;
  let fileoffset = buffer.readUInt32BE(index);
  index += 4;
  let files = [];
  for (let filenr = 0; filenr < subids.length; filenr++) {
    let endoffset = buffer.readUInt32BE(index);
    index += 4;
    files.push({
      buffer: buffer.slice(fileoffset, endoffset),
      offset: fileoffset,
      size: endoffset - fileoffset,
      fileid: subids[filenr],
      namehash: namehashes?.[filenr] ?? null
    });
    fileoffset = endoffset;
  }
  return files;
}
var Archive = class {
  constructor(files) {
    this.files = files;
  }
  forgecrc(wantedcrc, gapfileindex, gapoffset) {
    let frontcrc = 0;
    for (let i = 0; i < this.files.length; i++) {
      if (i == gapfileindex) {
        frontcrc = crc32(this.files[i], frontcrc, 0, gapoffset);
        break;
      }
      frontcrc = crc32(this.files[i], frontcrc);
    }
    let backcrc = wantedcrc;
    backcrc = crc32_backward(this.networkFooter(), backcrc);
    for (let i = this.files.length - 1; i >= 0; i--) {
      if (i == gapfileindex) {
        backcrc = crc32(this.files[i], backcrc, 0, gapoffset + 4);
        break;
      }
      backcrc = crc32(this.files[i], backcrc);
    }
    console.log("forging file", gapfileindex, gapoffset, forge_crcbytes(frontcrc, backcrc));
    this.files[gapfileindex] = Buffer.from(this.files[gapfileindex]);
    forge_crcbytes(frontcrc, backcrc).copy(this.files[gapfileindex], gapoffset);
  }
  networkFooter() {
    if (this.files.length == 1) {
      return Buffer.from([]);
    }
    let len = 1 + this.files.length * 4;
    let result = Buffer.alloc(len);
    let lastsize = 0;
    let footerindex = 0;
    for (let buf of this.files) {
      result.writeInt32BE(buf.byteLength - lastsize, footerindex);
      lastsize = buf.byteLength;
      footerindex += 4;
    }
    result.writeUInt8(1, len - 1);
    return result;
  }
  packNetwork() {
    return Buffer.concat([...this.files, this.networkFooter()]);
  }
  sqliteHeader() {
    if (this.files.length == 1) {
      return Buffer.from([]);
    }
    let headersize = 1 + 4 + this.files.length * 4;
    let result = Buffer.alloc(headersize);
    let offset = 0;
    let dataoffset = headersize;
    result.writeUInt8(1, offset);
    offset++;
    result.writeUInt32BE(dataoffset, offset);
    offset += 4;
    for (let buffer of this.files) {
      dataoffset += buffer.byteLength;
      result.writeUInt32BE(dataoffset, offset);
      offset += 4;
    }
    return result;
  }
  packSqlite() {
    return Buffer.concat([this.sqliteHeader(), ...this.files]);
  }
};
function unpackBufferArchive(buffer, subids, namehashes) {
  if (subids.length == 1) {
    let r = [{
      buffer,
      offset: 0,
      size: buffer.byteLength,
      fileid: subids[0],
      namehash: namehashes?.[0] ?? null
    }];
    return r;
  }
  let nchunks = buffer.readUInt8(buffer.length - 1);
  var suboffsetScan = buffer.length - 1 - 4 * subids.length * nchunks;
  var subbufs = [];
  var scan = 0;
  for (let chunkindex = 0; chunkindex < nchunks; chunkindex++) {
    var lastRecordSize = 0;
    for (var fileindex = 0; fileindex < subids.length; ++fileindex) {
      lastRecordSize += buffer.readInt32BE(suboffsetScan);
      suboffsetScan += 4;
      let size = lastRecordSize;
      let recordBuffer = buffer.slice(scan, scan + size);
      scan += size;
      let oldchunk = subbufs[fileindex];
      if (oldchunk) {
        oldchunk.buffer = Buffer.concat([oldchunk.buffer, recordBuffer]);
        oldchunk.size += size;
      } else {
        subbufs[fileindex] = {
          buffer: recordBuffer,
          offset: scan,
          size,
          fileid: subids[fileindex],
          namehash: namehashes?.[fileindex] ?? null
        };
      }
    }
  }
  return subbufs;
}
function rootIndexBufferToObject(metaindex, source) {
  let index = parse.rootCacheIndex.read(metaindex, source);
  return index.cachemajors.map((q) => {
    if (q.crc == 0) {
      return void 0;
    }
    let r = {
      major: 255,
      minor: q.minor,
      crc: q.crc,
      version: q.version,
      size: 0,
      name: null,
      subindexcount: q.subindexcount,
      subindices: [0],
      subnames: null,
      uncompressed_crc: 0,
      uncompressed_size: 0
    };
    return r;
  });
}
function indexBufferToObject(major, buffer, source) {
  if (major == cacheMajors.index) {
    return rootIndexBufferToObject(buffer, source);
  }
  let readres = parse.cacheIndex.read(buffer, source);
  let indices = readres.indices;
  let linear = [];
  for (let entry of indices) {
    linear[entry.minor] = Object.assign(entry, { major });
  }
  return linear;
}
var mappedFileIds = {
  [cacheMajors.items]: 256,
  [cacheMajors.npcs]: 128,
  [cacheMajors.structs]: 32,
  [cacheMajors.enums]: 256,
  [cacheMajors.objects]: 256,
  [cacheMajors.sequences]: 128,
  [cacheMajors.spotanims]: 256,
  [cacheMajors.achievements]: 128,
  [cacheMajors.materials]: Number.MAX_SAFE_INTEGER
  //is single index
};
var oldConfigMaps = {
  [cacheMajors.items]: cacheConfigPages.items_old,
  [cacheMajors.npcs]: cacheConfigPages.npcs_old,
  [cacheMajors.objects]: cacheConfigPages.locs_old,
  [cacheMajors.spotanims]: cacheConfigPages.spotanim_old
};
function fileIdToArchiveminor(major, fileid, buildnr) {
  if (buildnr < 488) {
    let page = oldConfigMaps[major];
    if (page !== void 0) {
      return { major: cacheMajors.config, minor: page, subid: fileid };
    }
  }
  let archsize = mappedFileIds[major] ?? 1;
  let holderindex = Math.floor(fileid / archsize);
  return { minor: holderindex, major, subid: fileid % archsize };
}
function archiveToFileId(major, minor, subfile) {
  let archsize = mappedFileIds[major] ?? 1;
  return minor * archsize + subfile;
}
var CacheFileSource = class {
  constructor() {
    this.decodeArgs = {};
  }
  getCacheMeta() {
    return { name: "unkown", descr: "", timestamp: /* @__PURE__ */ new Date(0) };
  }
  //could use abstract here but typings get weird
  getFile(major, minor, crc) {
    throw new Error("not implemented");
  }
  getFileArchive(index) {
    throw new Error("not implemented");
  }
  getCacheIndex(major) {
    throw new Error("not implemented");
  }
  getBuildNr() {
    return latestBuildNumber;
  }
  getDecodeArgs() {
    this.decodeArgs.clientVersion = this.getBuildNr();
    return this.decodeArgs;
  }
  writeFile(major, minor, file) {
    throw new Error("not implemented");
  }
  writeFileArchive(major, minor, files) {
    throw new Error("not implemented");
  }
  async getIndexEntryById(major, minor) {
    let index;
    if (this.getBuildNr() <= lastLegacyBuildnr) {
      index = { major, minor, crc: 0, name: null, subindexcount: 1, subindices: [0], subnames: null, version: 0 };
    } else {
      let indexfile = await this.getCacheIndex(major);
      index = indexfile[minor];
    }
    if (!index) {
      throw new Error(`minor id ${minor} does not exist in major ${major}.`);
    }
    return index;
  }
  async getArchiveById(major, minor) {
    let index = await this.getIndexEntryById(major, minor);
    return this.getFileArchive(index);
  }
  async getFileById(major, fileid) {
    let holderindex = fileIdToArchiveminor(major, fileid, this.getBuildNr());
    let files = await this.getArchiveById(holderindex.major, holderindex.minor);
    let match = files.find((q) => q.fileid == holderindex.subid);
    if (!match) {
      throw new Error(`File ${fileid} in major ${major} not found, (redirected to ${holderindex.major}.${holderindex.minor}.${holderindex.subid})`);
    }
    return match.buffer;
  }
  async findFileByName(major, name) {
    let hash = cacheFilenameHash(name, this.getBuildNr() <= lastLegacyBuildnr);
    let indexfile = await this.getCacheIndex(major);
    return indexfile.find((q) => q && q.name == hash);
  }
  async findSubfileByName(major, minor, name) {
    let hash = cacheFilenameHash(name, this.getBuildNr() <= lastLegacyBuildnr);
    let arch = await this.getArchiveById(major, minor);
    return arch.find((q) => q && q.namehash == hash);
  }
  //for testing only
  async bruteForceFindAnyNamedFile(name) {
    let rootindex = await this.getCacheIndex(cacheMajors.index);
    for (let index of rootindex) {
      if (!index) {
        continue;
      }
      let res = await this.findFileByName(index.minor, name);
      if (res) {
        return this.getFileArchive(res);
      }
    }
    return null;
  }
  close() {
  }
};
var DirectCacheFileSource = class extends CacheFileSource {
  constructor(needscrc) {
    super();
    this.indexMap = /* @__PURE__ */ new Map();
    this.xteakeys = null;
    this.requiresCrc = needscrc;
  }
  getFile(major, minor, crc) {
    throw new Error("not implemented");
  }
  async getFileArchive(meta) {
    let file = await this.getFile(meta.major, meta.minor, meta.crc);
    if (this.getBuildNr() <= lastLegacyBuildnr) {
      return parseLegacyArchive(file, meta.major, this.getBuildNr() <= lastClassicBuildnr);
    } else {
      return unpackBufferArchive(file, meta.subindices, meta.subnames);
    }
  }
  getXteaKey(major, minor) {
    let key = major << 23 | minor;
    return this.xteakeys?.get(key);
  }
  getCacheIndex(major) {
    let index = this.indexMap.get(major);
    if (!index) {
      index = (async () => {
        let crc = void 0;
        if (this.requiresCrc && major != cacheMajors.index) {
          let index2 = await this.getCacheIndex(cacheMajors.index);
          crc = index2[major].crc;
        }
        let indexfile = await this.getFile(cacheMajors.index, major, crc);
        let decoded = indexBufferToObject(major, indexfile, this);
        return decoded;
      })();
      this.indexMap.set(major, index);
    }
    return index;
  }
};
var CallbackCacheLoader = class extends DirectCacheFileSource {
  constructor(fn, needsCrc) {
    super(needsCrc);
    this.getFile = fn;
  }
  getCacheMeta() {
    return { name: "callback", descr: "Cache source based on external getter", timestamp: /* @__PURE__ */ new Date(0) };
  }
};

// rsmv/src/cache/memorycache.ts
var CachingFileSource = class extends CacheFileSource {
  constructor(base) {
    super();
    this.archieveCache = /* @__PURE__ */ new Map();
    this.cachedObjects = [];
    this.cacheFetchCounter = 0;
    this.cacheAddCounter = 0;
    this.maxcachesize = 2e8;
    this.rawsource = base;
  }
  fetchCachedObject(map, id, create, getSize) {
    let bucket = map.get(id);
    if (!bucket || globalThis.ignoreCache) {
      let data = create();
      bucket = {
        promise: data,
        data: null,
        owner: map,
        id,
        lastuse: 0,
        size: 0,
        usecount: 0
      };
      data.then((obj) => {
        bucket.size = getSize(obj);
        bucket.promise = null;
        bucket.data = obj;
      });
      this.cachedObjects.push(bucket);
      map.set(id, bucket);
      if (++this.cacheAddCounter % 100 == 0) {
        this.sweepCachedObjects();
      }
    }
    bucket.usecount++;
    bucket.lastuse = this.cacheFetchCounter++;
    if (bucket.data) {
      return Promise.resolve(bucket.data);
    } else {
      return bucket.promise;
    }
  }
  sweepCachedObjects() {
    let score = (bucket) => {
      return (
        //up to 100 penalty for not being used recently
        Math.min(100, this.cacheFetchCounter - bucket.lastuse) + Math.max(-100, -bucket.usecount * 10)
      );
    };
    this.cachedObjects.sort((a, b) => score(a) - score(b));
    let newlength = this.cachedObjects.length;
    let totalsize = 0;
    for (let i = 0; i < this.cachedObjects.length; i++) {
      let bucket = this.cachedObjects[i];
      totalsize += bucket.size;
      if (totalsize > this.maxcachesize) {
        newlength = Math.min(newlength, i);
        bucket.owner.delete(bucket.id);
      } else {
        bucket.usecount = 0;
      }
    }
    this.cachedObjects.length = newlength;
  }
  getCacheIndex(major) {
    return this.rawsource.getCacheIndex(major);
  }
  getFile(major, minor, crc) {
    return this.rawsource.getFile(major, minor, crc);
  }
  getFileArchive(index) {
    let get3 = () => this.rawsource.getFileArchive(index);
    if (index.major == cacheMajors.models || index.major == cacheMajors.texturesBmp || index.major == cacheMajors.texturesDds || index.major == cacheMajors.texturesPng) {
      return get3();
    } else {
      let cachekey = index.major << 23 | index.minor;
      return this.fetchCachedObject(this.archieveCache, cachekey, get3, (obj) => obj.reduce((a, v) => a + v.size, 0));
    }
  }
  getBuildNr() {
    return this.rawsource.getBuildNr();
  }
  getCacheMeta() {
    return this.rawsource.getCacheMeta();
  }
};

// rsmv/src/3d/modeltothree.ts
import { Bone as Bone3, BufferAttribute as BufferAttribute5, Object3D as Object3D4, Skeleton as Skeleton4 } from "three";

// rsmv/src/scripts/filetypes.ts
import prettyJson2 from "json-stringify-pretty-compact";

// rsmv/src/scripts/musictrack.ts
async function parseMusic(source, major, id, firstchunk, allowdownload = false) {
  let indexfile = firstchunk ?? await source.getFileById(major, id);
  let header = indexfile.readUint32BE();
  if (header != 1245792065) {
    return indexfile;
  }
  let index = parse.audio.read(indexfile, source);
  let chunkdatas = allowdownload ? await asyncMap(index.chunks, (q) => q.data ?? source.getFileById(major, q.fileid), 8) : index.chunks.filter((q) => q.data).map((q) => q.data);
  let output = [];
  let granuleoffset = 0n;
  let pagecounter = 0;
  for (let [chunkindex, chunk] of chunkdatas.entries()) {
    let lastgranule = 0n;
    for (let scan = 0; scan < chunk.length; ) {
      let headerindex = scan;
      let header2 = chunk.readUint32BE(scan);
      scan += 4;
      let version = chunk.readUint8(scan);
      scan += 1;
      let type = chunk.readUint8(scan);
      scan += 1;
      let granule = chunk.readBigInt64LE(scan);
      scan += 8;
      let series = chunk.readUint32LE(scan);
      scan += 4;
      let counter = chunk.readUint32LE(scan);
      scan += 4;
      let crc = chunk.readUint32LE(scan);
      scan += 4;
      let page_segments = chunk.readUint8(scan);
      scan += 1;
      let datalen = 0;
      for (let i = 0; i < page_segments; i++) {
        datalen += chunk.readUint8(scan);
        scan += 1;
      }
      let newheader = Uint8Array.prototype.slice.call(chunk, headerindex, scan);
      let datachunk = chunk.slice(scan, scan + datalen);
      scan += datalen;
      let isfirst = headerindex == 0 && chunkindex == 0;
      let islast = chunkindex == chunkdatas.length - 1 && scan == chunk.length;
      newheader.writeUint8(+isfirst << 1 | +islast << 2, 5);
      newheader.writeBigInt64LE(granule + granuleoffset, 6);
      newheader.writeUint32LE(pagecounter++, 18);
      newheader.writeUInt32LE(0, 22);
      let newcrc = crc32ogg(datachunk, crc32ogg(newheader));
      newheader.writeUint32LE(newcrc, 22);
      if (chunkindex == 0 || scan != 0) {
        output.push(newheader);
        output.push(datachunk);
      }
      lastgranule = granule;
    }
    granuleoffset += lastgranule;
  }
  return Buffer.concat(output);
}
async function asyncMap(iter, mapper, maxParallel = 4) {
  let pending = [];
  let writeindex = 0;
  let readindex = 0;
  let res = [];
  for (let item of iter) {
    if (writeindex >= readindex + maxParallel) {
      res.push(await pending[readindex % maxParallel]);
      readindex++;
    }
    pending[writeindex % maxParallel] = mapper(item, writeindex);
    writeindex++;
  }
  while (readindex < writeindex) {
    res.push(await pending[readindex % maxParallel]);
    readindex++;
  }
  return res;
}
var oggtable = new Uint32Array([
  0,
  79764919,
  159529838,
  222504665,
  319059676,
  398814059,
  445009330,
  507990021,
  638119352,
  583659535,
  797628118,
  726387553,
  890018660,
  835552979,
  1015980042,
  944750013,
  1276238704,
  1221641927,
  1167319070,
  1095957929,
  1595256236,
  1540665371,
  1452775106,
  1381403509,
  1780037320,
  1859660671,
  1671105958,
  1733955601,
  2031960084,
  2111593891,
  1889500026,
  1952343757,
  2552477408,
  2632100695,
  2443283854,
  2506133561,
  2334638140,
  2414271883,
  2191915858,
  2254759653,
  3190512472,
  3135915759,
  3081330742,
  3009969537,
  2905550212,
  2850959411,
  2762807018,
  2691435357,
  3560074640,
  3505614887,
  3719321342,
  3648080713,
  3342211916,
  3287746299,
  3467911202,
  3396681109,
  4063920168,
  4143685023,
  4223187782,
  4286162673,
  3779000052,
  3858754371,
  3904687514,
  3967668269,
  881225847,
  809987520,
  1023691545,
  969234094,
  662832811,
  591600412,
  771767749,
  717299826,
  311336399,
  374308984,
  453813921,
  533576470,
  25881363,
  88864420,
  134795389,
  214552010,
  2023205639,
  2086057648,
  1897238633,
  1976864222,
  1804852699,
  1867694188,
  1645340341,
  1724971778,
  1587496639,
  1516133128,
  1461550545,
  1406951526,
  1302016099,
  1230646740,
  1142491917,
  1087903418,
  2896545431,
  2825181984,
  2770861561,
  2716262478,
  3215044683,
  3143675388,
  3055782693,
  3001194130,
  2326604591,
  2389456536,
  2200899649,
  2280525302,
  2578013683,
  2640855108,
  2418763421,
  2498394922,
  3769900519,
  3832873040,
  3912640137,
  3992402750,
  4088425275,
  4151408268,
  4197601365,
  4277358050,
  3334271071,
  3263032808,
  3476998961,
  3422541446,
  3585640067,
  3514407732,
  3694837229,
  3640369242,
  1762451694,
  1842216281,
  1619975040,
  1682949687,
  2047383090,
  2127137669,
  1938468188,
  2001449195,
  1325665622,
  1271206113,
  1183200824,
  1111960463,
  1543535498,
  1489069629,
  1434599652,
  1363369299,
  622672798,
  568075817,
  748617968,
  677256519,
  907627842,
  853037301,
  1067152940,
  995781531,
  51762726,
  131386257,
  177728840,
  240578815,
  269590778,
  349224269,
  429104020,
  491947555,
  4046411278,
  4126034873,
  4172115296,
  4234965207,
  3794477266,
  3874110821,
  3953728444,
  4016571915,
  3609705398,
  3555108353,
  3735388376,
  3664026991,
  3290680682,
  3236090077,
  3449943556,
  3378572211,
  3174993278,
  3120533705,
  3032266256,
  2961025959,
  2923101090,
  2868635157,
  2813903052,
  2742672763,
  2604032198,
  2683796849,
  2461293480,
  2524268063,
  2284983834,
  2364738477,
  2175806836,
  2238787779,
  1569362073,
  1498123566,
  1409854455,
  1355396672,
  1317987909,
  1246755826,
  1192025387,
  1137557660,
  2072149281,
  2135122070,
  1912620623,
  1992383480,
  1753615357,
  1816598090,
  1627664531,
  1707420964,
  295390185,
  358241886,
  404320391,
  483945776,
  43990325,
  106832002,
  186451547,
  266083308,
  932423249,
  861060070,
  1041341759,
  986742920,
  613929101,
  542559546,
  756411363,
  701822548,
  3316196985,
  3244833742,
  3425377559,
  3370778784,
  3601682597,
  3530312978,
  3744426955,
  3689838204,
  3819031489,
  3881883254,
  3928223919,
  4007849240,
  4037393693,
  4100235434,
  4180117107,
  4259748804,
  2310601993,
  2373574846,
  2151335527,
  2231098320,
  2596047829,
  2659030626,
  2470359227,
  2550115596,
  2947551409,
  2876312838,
  2788305887,
  2733848168,
  3165939309,
  3094707162,
  3040238851,
  2985771188
]);
function crc32ogg(buf, crc = 0, rangeStart = 0, rangeEnd = buf.length) {
  crc = crc ^ 0;
  for (let i = rangeStart; i < rangeEnd; i++) {
    crc = crc << 8 ^ oggtable[crc >>> 24 & 255 ^ buf[i]];
  }
  return (crc ^ 0) >>> 0;
}

// rsmv/src/cache/classicloader.ts
var classicGroups = {
  //same as early rs2
  textures: 6,
  //classic only
  models: 101,
  entity: 102,
  maps: 103,
  land: 104,
  filter: 105,
  jagex: 106,
  media: 107,
  sounds: 108,
  config: 110
};
function cversion(buildnr, date, config, maps, land, media, models, textures, entity, sounds, filter, locsjson, name) {
  return {
    buildnr,
    locsjson,
    name,
    date,
    versions: { config, maps, land, media, models, textures, entity, sounds, filter }
  };
}
var classicBuilds = [
  cversion(115, /* @__PURE__ */ new Date("2001-12-24 20:28"), 48, 27, 0, 28, 12, 8, 10, 0, 0, null, "dec 2001 - last original world data"),
  cversion(230, /* @__PURE__ */ new Date("2004-02-18 11:43"), 100, 100, 100, 100, 100, 100, 100, 100, 100, "SceneryLocs.json", "Last version of entered files")
];
var classicGroupNames = Object.fromEntries(Object.entries(classicGroups).map(([name, id]) => [id, name]));
function detectClassicVersions(filenames) {
  let versions = [];
  for (let build of classicBuilds) {
    versions.push({
      buildnr: build.buildnr,
      iscomplete: false,
      locsjson: build.locsjson,
      target: build.versions,
      foundjag: Object.fromEntries(Object.entries(build.versions).map(([key]) => [key, 0])),
      foundmem: Object.fromEntries(Object.entries(build.versions).map(([key]) => [key, 0]))
    });
  }
  for (let filename of filenames) {
    let namematch = filename.match(/^(?<name>[a-zA-Z]+)(?<version>\d+)\.(?<type>jag|mem)$/);
    if (namematch) {
      let version = +namematch.groups.version;
      let ismem = namematch.groups.type == "mem";
      let cachename = namematch.groups.name;
      for (let cache of versions) {
        let found = ismem ? cache.foundmem : cache.foundjag;
        if (cache.target[cachename] && version <= cache.target[cachename] && version > found[cachename]) {
          found[cachename] = version;
        }
      }
    }
  }
  for (let cache of versions) {
    let complete = true;
    for (let key in cache.target) {
      if (cache.foundjag[key] != cache.target[key]) {
        complete = false;
      }
      if (cache.foundmem[key] != 0 && cache.foundmem[key] != cache.target[key]) {
        complete = false;
      }
    }
    cache.iscomplete = complete;
  }
  return versions;
}
var ClassicFileSource = class _ClassicFileSource extends CacheFileSource {
  constructor(fs7, version) {
    super();
    this.fs = fs7;
    this.usingversion = version;
  }
  static async create(files, version) {
    if (!version) {
      let filenames = await files.readDir(".");
      let versions = detectClassicVersions(filenames.map((q) => q.name));
      let index = localStorage.rsmv_classicversion ?? "-1";
      version = versions.at(+index);
    }
    return new _ClassicFileSource(files, version);
  }
  async getFileArchive(meta) {
    if (meta.major != 0) {
      throw new Error("all files are placed in index 0 for classic caches");
    }
    let name = classicGroupNames[meta.minor];
    let jagfile = await this.getNamedFile(name, false);
    let memfile = await this.getNamedFile(name, true);
    let jagarch = !jagfile ? [] : parseLegacyArchive(jagfile, meta.major, true);
    let memarch = !memfile ? [] : parseLegacyArchive(memfile, meta.major, true);
    if (jagarch.length == 0 && memarch.length == 0) {
      throw new Error("no files found in index " + meta.minor);
    }
    return [...jagarch, ...memarch];
  }
  async getNamedFile(name, mem) {
    if (!this.usingversion || !this.fs) {
      throw new Error("no classic files loaded in classic cache loader");
    }
    let version = (mem ? this.usingversion.foundmem : this.usingversion.foundjag)[name];
    if (!version) {
      return null;
    }
    let filename = `${name}${version}.${mem ? "mem" : "jag"}`;
    console.log("loading", filename);
    return this.fs.readFileBuffer(filename);
  }
  getBuildNr() {
    return this.usingversion?.buildnr ?? 200;
  }
  getCacheMeta() {
    if (!this.usingversion) {
      return { name: "Classic", descr: "no files loaded", timestamp: /* @__PURE__ */ new Date(0) };
    }
    return {
      name: `Classic ${this.getBuildNr()}`,
      descr: `${Object.entries(this.usingversion.foundjag).map(([key, v]) => `${key}: ${v}`).join("\n")}`,
      timestamp: /* @__PURE__ */ new Date(0)
    };
  }
  async getFile(major, minor) {
    throw new Error("can only load archives in a classic cache");
  }
};
function mapprops(count, template) {
  let res = new Array(count).fill(null).map(() => ({}));
  for (let [key, callback] of Object.entries(template)) {
    for (let i = 0; i < count; i++) {
      res[i][key] = callback();
    }
  }
  return res;
}
async function classicConfig(source, buildnr) {
  let modelarchive = await source.getArchiveById(0, classicGroups.models);
  let stringsbuf = (await source.findSubfileByName(0, classicGroups.config, "STRING.DAT")).buffer;
  let intbuf = (await source.findSubfileByName(0, classicGroups.config, "INTEGER.DAT")).buffer;
  let stringcursor = 0;
  let getstring = () => {
    let start = stringcursor;
    while (stringcursor < stringsbuf.length && stringsbuf[stringcursor++] != 0) ;
    return stringsbuf.toString("latin1", start, stringcursor - 1);
  };
  let intcursor = 0;
  let getuint = () => {
    let r = intbuf.readUint32BE(intcursor);
    intcursor += 4;
    return r;
  };
  let getint = () => {
    let r = intbuf.readInt32BE(intcursor);
    intcursor += 4;
    return r;
  };
  let getushort = () => {
    let r = intbuf.readUint16BE(intcursor);
    intcursor += 2;
    return r;
  };
  let getubyte = () => intbuf.readUint8(intcursor++);
  let getbool = () => !!getubyte();
  let items = mapprops(getushort(), {
    name: getstring,
    examine: getstring,
    command: getstring,
    sprite: getushort,
    price: buildnr < 180 ? getushort : getuint,
    //exact build nr unknown
    stackable: getbool,
    special: getbool,
    equip: getushort,
    color: getuint,
    untradeable: buildnr < 180 ? () => false : getbool,
    //exact build nr unknown
    member: buildnr < 180 ? () => false : getbool
    //exact build nr unknown
  });
  let npcs = mapprops(getushort(), {
    name: getstring,
    examine: getstring,
    command: buildnr < 180 ? () => "" : getstring,
    //exact build nr unknown
    attack: getubyte,
    strength: getubyte,
    hits: getubyte,
    defence: getubyte,
    hostility: getubyte,
    anims: () => new Array(12).fill(null).map(getubyte),
    haircolor: getuint,
    topcolor: getuint,
    bottomcolor: getuint,
    skincolor: getuint,
    width: getushort,
    height: getushort,
    walkmodel: getubyte,
    combatmodel: getubyte,
    combatanim: getubyte
  });
  let textures = mapprops(getushort(), {
    name: getstring,
    subname: getstring
  });
  let anims = mapprops(getushort(), {
    name: getstring,
    color: getuint,
    gendermodel: getubyte,
    has_a: getbool,
    has_f: getbool,
    unk: getubyte
  });
  let objects = mapprops(getushort(), {
    name: getstring,
    examine: getstring,
    command_0: getstring,
    command_1: getstring,
    model: () => {
      let name = getstring();
      let namehash = cacheFilenameHash(`${name}.ob3`, true);
      let id = modelarchive.find((q) => q.namehash == namehash)?.fileid;
      return { name, id };
    },
    xsize: getubyte,
    zsize: getubyte,
    type: getubyte,
    item_height: getubyte
  });
  let wallobjects = mapprops(getushort(), {
    name: getstring,
    examine: getstring,
    command_0: getstring,
    command_1: getstring,
    height: getushort,
    frontdecor: getint,
    backdecor: getint,
    blocked: getbool,
    invisible: getbool
  });
  let roofs = mapprops(getushort(), {
    height: getubyte,
    texture: getubyte
  });
  let tiles = mapprops(getushort(), {
    decor: getuint,
    type: () => {
      let type = getubyte();
      return {
        type,
        autoconnect: type == 1 || type == 3,
        indoors: type == 2,
        iswater: type == 3,
        bridge: type == 4
      };
    },
    blocked: getbool
  });
  let projectile = mapprops(getushort(), {
    //empty
  });
  let spells = mapprops(getushort(), {
    name: getstring,
    examine: getstring,
    level: getubyte,
    num_runes: getubyte,
    type: getubyte,
    runetypes: () => new Array(getubyte()).fill(null).map(getushort),
    runeamounts: () => new Array(getubyte()).fill(null).map(getubyte)
  });
  let prayers = mapprops(getushort(), {
    name: getstring,
    examine: getstring,
    level: getubyte,
    drain: getubyte
  });
  console.log(`decoded rsc config, ints ${intcursor}/${intbuf.length}, strings ${stringcursor}/${stringsbuf.length}`);
  let jsonlocs = [];
  if (source.usingversion.locsjson) {
    try {
      let raw = JSON.parse(await source.fs.readFileText(source.usingversion.locsjson));
      let levelstride = 20 * 48 - 16;
      jsonlocs = raw.sceneries.map((q) => ({
        id: q.id,
        dir: q.direction,
        level: Math.floor(q.pos.Y / levelstride),
        x: 48 * 48 + q.pos.X,
        z: 37 * 48 + q.pos.Y % levelstride
      }));
    } catch (e) {
      console.warn("failed to load external classic locs");
    }
  }
  return { items, npcs, textures, anims, objects, wallobjects, roofs, tiles, projectile, spells, prayers, jsonlocs };
}

// rsmv/src/scripts/rendercutscene.ts
async function renderCutscene(engine, file) {
  let obj = parse.cutscenes.read(file, engine);
  let root = document.createElement("div");
  root.style.width = `${obj.width}px`;
  root.style.height = `${obj.height}px`;
  console.log(obj);
  let uuid = `cutscene-${crc32(file) >>> 0}`;
  let css = "";
  let html = "";
  let endtime = obj.elements.reduce((a, v) => Math.max(a, v.end), 0);
  let timetopercent = (t) => `${Math.max(0, t / endtime * 100).toFixed(2)}%`;
  let imgcache = /* @__PURE__ */ new Map();
  let anim = function(el, animname, frames, stylefn) {
    css += `@keyframes ${animname}{
`;
    css += `  from{${stylefn(frames[0])}}
`;
    css += frames.map((q) => `  ${timetopercent(el.start + q[0])}{${stylefn(q)}}
`).join("");
    css += `  to{${stylefn(frames.at(-1))}}
`;
    css += `}
`;
    return `${endtime}s infinite ${animname} linear`;
  };
  css += `.subtitle{
`;
  css += `  position: absolute;
`;
  css += `  font-size: 50px;
`;
  css += `  bottom: 20px;
`;
  css += `  text-align: center;
`;
  css += `  color: white;
`;
  css += `  padding: 5px;
`;
  css += `  left: 20px;
`;
  css += `  right: 20px;
`;
  css += `  font-family: sans-serif;
`;
  css += `  display:flex;
`;
  css += `}
`;
  css += `.subtitle>div{
`;
  css += `  background:rgba(0,0,0,0.3);
`;
  css += `  margin:0px auto;
`;
  css += `  padding:12px;
`;
  css += `  border-radius:20px;
`;
  css += `}
`;
  for (let i = obj.elements.length - 1; i >= 0; i--) {
    let el = obj.elements[i];
    let visibilityanim = `${uuid}-${i}-visibility`;
    css += `@keyframes ${visibilityanim}{
`;
    css += `  0%{visibility:hidden}
`;
    css += `  ${timetopercent(el.start)}{visibility:visible}
`;
    css += `  ${timetopercent(el.end)}{visibility:hidden}
`;
    css += `}
`;
    html += `<div style="animation:${endtime}s step-end infinite ${visibilityanim}">
`;
    if (el.subtitle) {
      html += `<div class="subtitle"><div>${escapeHTML(el.subtitle)}</div></div>
`;
    }
    if (el.soundid) {
      try {
        let file2 = await parseMusic(engine, cacheMajors.sounds, el.soundid, null, true);
        html += `<audio src="data:audio/ogg;base64,${file2.toString("base64")}" data-timestart="${el.start}" data-timeend="${el.end}"></audio>
`;
      } catch (e) {
        console.warn(`missing sound ${el.soundid} ${el.sound}`);
      }
    }
    if (el.graphics) {
      if (el.graphics.length != 0) {
        for (let imgindex = el.graphics.length - 1; imgindex >= 0; imgindex--) {
          let img = el.graphics[imgindex];
          let pngfile = imgcache.get(img.spriteid);
          if (!pngfile) {
            let spritebuf = await engine.getFileById(cacheMajors.sprites, img.spriteid);
            pngfile = await pixelsToDataUrl(parseSprite(spritebuf)[0].img);
            imgcache.set(img.spriteid, pngfile);
          }
          let anims = [];
          if (img.opacityframes.length != 0) {
            let animname = `${uuid}-${i}-${imgindex}-opacity`;
            anims.push(anim(el, animname, img.opacityframes, (v) => `opacity:${v[1].toFixed(2)}`));
          }
          if (img.rotateframes.length != 0) {
            let animname = `${uuid}-${i}-${imgindex}-rotate`;
            anims.push(anim(el, animname, img.rotateframes, (v) => `rotate:${v[1].toFixed(2)}deg;`));
          }
          if (img.translateframes.length != 0) {
            let animname = `${uuid}-${i}-${imgindex}-translate`;
            anims.push(anim(el, animname, img.translateframes, (v) => `translate:${v[1].toFixed(2)}px ${v[2].toFixed(2)}px`));
          }
          if (img.scaleframes.length != 0) {
            let animname = `${uuid}-${i}-${imgindex}-scale`;
            anims.push(anim(el, animname, img.scaleframes, (v) => `scale:${v[1].toFixed(3)} ${v[2].toFixed(2)};`));
          }
          let positionstyle = `position:absolute; top:0px; left:0px; transform-origin:center;margin-left:${-img.width / 2}px; margin-top:${-img.height / 2}px;`;
          html += `<img src="${pngfile}" width="${img.width}" height="${img.height}" style="${positionstyle} animation:${anims.join()};">
`;
        }
      }
      html += "</div>";
    }
  }
  function embeddedModule(endtime2) {
    console.log("module init");
    let lastseektime = 0;
    let lastseektimestamp = Date.now();
    let lastplayrate = 1;
    let endtimeout = 0;
    function getTime() {
      return lastseektime + (Date.now() - lastseektimestamp) / 1e3 * lastplayrate;
    }
    function onRangeChange(e) {
      let time = e.currentTarget.valueAsNumber;
      seek(time, 0);
    }
    function play() {
      seek(getTime(), 1);
    }
    function pause() {
      seek(getTime(), 0);
    }
    function seek(time, playbackRate = 1) {
      lastseektime = time;
      lastplayrate = playbackRate;
      lastseektimestamp = Date.now();
      if (endtimeout) {
        clearTimeout(endtimeout);
        endtimeout = 0;
      }
      if (playbackRate != 0) {
        let timeleft = (endtime2 - time / playbackRate) * 1e3;
        endtimeout = +setTimeout(() => {
          seek(0, playbackRate);
        }, timeleft);
      }
      let anims = document.getAnimations();
      for (let anim2 of anims) {
        anim2.currentTime = 1e3 * time;
        anim2.playbackRate = playbackRate;
        if (playbackRate != 0) {
          anim2.play();
        } else {
          anim2.pause();
        }
      }
      let audios = Array.from(document.querySelectorAll("audio"));
      for (let audio of audios) {
        let reltime = time - +(audio.dataset.timestart ?? 0);
        if (audio.dataset.delaytimer) {
          clearTimeout(+audio.dataset.delaytimer);
          audio.dataset.delaytimer = void 0;
        }
        if (playbackRate != 0) {
          audio.playbackRate = playbackRate;
          if (reltime < 0) {
            audio.dataset.delaytimer = "" + +setTimeout(() => {
              audio.currentTime = 0;
              audio.play();
            }, -reltime / playbackRate * 1e3);
          } else {
            audio.currentTime = reltime;
            audio.play();
          }
        } else {
          audio.pause();
        }
      }
    }
    return { seek, play, pause, onRangeChange };
  }
  let doc = `<!DOCTYPE html>
`;
  doc += `<html>
`;
  doc += `<head>
`;
  doc += `<style>
`;
  doc += css;
  doc += `</style>
`;
  doc += `</head>
`;
  doc += `<body>
`;
  doc += `<input type="range" min="0" max="${endtime}" step="0.01" style="width:400px;" oninput="controls.onRangeChange(event)">
`;
  doc += `<input type="button" value="play" onclick="controls.play()">
`;
  doc += `<input type="button" value="pause" onclick="controls.pause()">
`;
  doc += `<div style="position:relative; width:${obj.width}px; height:${obj.height}px; overflow:hidden; zoom:0.5;">
`;
  doc += html;
  doc += `</div>
`;
  doc += `<script>
`;
  doc += `var controls=(${embeddedModule})(${endtime});
`;
  doc += `controls.play()
`;
  doc += `</script>
`;
  doc += `</body>
`;
  doc += `</html>
`;
  return { html, css, doc };
}

// rsmv/src/3d/avatar.ts
function avatarStringToBytes(text) {
  let base64 = text.replace(/\*/g, "+").replace(/-/g, "/");
  return Buffer.from(base64, "base64");
}
var slotNames = [
  "helm",
  "cape",
  "necklace",
  "weapon",
  "body",
  "offhand",
  //5
  "arms",
  "legs",
  "face",
  "gloves",
  "boots",
  //10
  "beard",
  "ring",
  "ammo",
  "aura",
  "slot15"
];
var slotToKitMale = { 4: 2, 6: 3, 7: 5, 8: 0, 9: 4, 10: 6, 11: 1 };
var slotToKitFemale = { 4: 9, 6: 10, 7: 12, 8: 7, 9: 11, 10: 13 };
var defaultcols = {
  hair0: 6798,
  hair1: 55232,
  skin0: 4533,
  skin1: 4540,
  skin2: 4550,
  skin3: 4554,
  body0: 8741,
  body1: 9104,
  legs0: 25485,
  legs1: 25238,
  boots0: 4620,
  boots1: 4626
};
var humanheadanims = {
  none: -1,
  default: 9804,
  worried: 9743,
  talkfast: 9745,
  scared: 9748,
  wtf: 9752,
  drunk: 9851,
  happy: 9843,
  evil: 9842,
  laughing: 9841,
  crying: 9765
};
var kitcolors = null;
async function loadKitData(source) {
  if (!kitcolors) {
    let mapcolorenum = async (enumid, mappingid) => {
      let colorfile = await source.getFileById(cacheMajors.enums, enumid);
      let colordata = parse.enums.read(colorfile, source);
      let orderfile = await source.getFileById(cacheMajors.enums, mappingid);
      let orderdata = parse.enums.read(orderfile, source);
      return Object.fromEntries(orderdata.intArrayValue2.values.map((q) => {
        let col = colordata.intArrayValue2.values.find((w) => w[0] == q[0])[1];
        return [
          q[1],
          HSL2packHSL(...RGB2HSL(col >> 16 & 255, col >> 8 & 255, col >> 0 & 255))
        ];
      }));
    };
    kitcolors = {
      feet: await mapcolorenum(753, 3297),
      skin: await mapcolorenum(746, 748),
      hair: await mapcolorenum(2343, 2345),
      clothes: await mapcolorenum(2347, 3282)
    };
  }
  return kitcolors;
}
async function avatarToModel(engine, buffer, head) {
  let addOpt = (parent, offset, penalty, usesBackup, slot) => {
    activelist.push({
      buffer: parent.buffer,
      offset,
      parent,
      penalty: parent.penalty + penalty,
      slot,
      slotindex: parent.slotindex + 1,
      usesBackup: parent.usesBackup || usesBackup
    });
  };
  let addNumberOpt = async (parent, offset, isBackup, slot) => {
    let slotindex = parent.slotindex + 1;
    if (slot < 16384) {
      let kitid = slot - 256;
      let kit = playerkit[kitid];
      if (kit?.models) {
        let models2 = [];
        let headmodels = [];
        for (let m of kit.models) {
          models2.push(m, m);
        }
        if (kit.headmodel) {
          headmodels.push(kit.headmodel, kit.headmodel);
        }
        let bodypart = kit.bodypart ?? -1;
        let targetpart = (isFemale ? slotToKitFemale : slotToKitMale)[slotindex] ?? -2;
        let penalty = bodypart == targetpart ? 0 : 1;
        addOpt(parent, offset, penalty, isBackup, {
          name: slotNames[slotindex] + "_" + kitid,
          type: "kit",
          id: kitid,
          models: models2,
          headmodels,
          replaceColors: kit.recolor ?? [],
          replaceMaterials: [],
          animStruct: -1
        });
      }
    }
    let itemid = slot - 16384 & 65535;
    let iswrapped = slot < 16384;
    let file = await engine.getGameFile("items", itemid).catch(() => null);
    if (file) {
      let item = parse.item.read(file, engine.rawsource);
      let animStruct = item.extra?.find((q) => q.prop == 686)?.intvalue ?? -1;
      let models2 = [];
      if (item.maleModels_0) {
        models2[0] = item.maleModels_0.id;
      }
      if (item.femaleModels_0) {
        models2[1] = item.femaleModels_0.id;
      }
      if (item.maleModels_1) {
        models2[2] = item.maleModels_1;
      }
      if (item.femaleModels_1) {
        models2[3] = item.femaleModels_1;
      }
      if (item.maleModels_2) {
        models2[4] = item.maleModels_2;
      }
      if (item.femaleModels_2) {
        models2[5] = item.femaleModels_2;
      }
      let headmodels = [];
      if (item.maleHeads_0) {
        headmodels[0] = item.maleHeads_0;
      }
      if (item.femaleHeads_0) {
        headmodels[1] = item.femaleHeads_0;
      }
      if (item.maleHeads_1) {
        headmodels[2] = item.maleHeads_1;
      }
      if (item.femaleHeads_1) {
        headmodels[3] = item.femaleHeads_1;
      }
      let penalty = item.equipSlotId != slotindex ? 1 : 0;
      addOpt(parent, offset, penalty, isBackup || iswrapped, {
        name: item.name ? item.name : "item_" + itemid,
        type: "item",
        id: itemid,
        models: models2,
        headmodels,
        replaceColors: item.color_replacements ?? [],
        replaceMaterials: item.material_replacements ?? [],
        animStruct
      });
    }
  };
  let finalizeNode = async (opt) => {
    let slots = [];
    let parent = opt;
    while (parent.parent) {
      slots.push(parent.slot);
      parent = parent.parent;
    }
    slots.reverse();
    let custbuf = opt.buffer.slice(opt.offset);
    try {
      var avatar2 = parse.avatarOverrides.read(custbuf, engine.rawsource, { slots });
    } catch (e) {
      return false;
    }
    let globalrecolors = [
      [defaultcols.hair0, kitdata.hair[avatar2.haircol0]],
      [defaultcols.hair1, kitdata.hair[avatar2.haircol0]],
      //TODO figure out when the second hair color is actually used
      // [defaultcols.hair1, kitdata.hair[avatar.haircol1]],
      [defaultcols.skin0, kitdata.skin[avatar2.skincol0]],
      [defaultcols.skin1, kitdata.skin[avatar2.skincol0]],
      [defaultcols.skin2, kitdata.skin[avatar2.skincol0]],
      [defaultcols.skin3, kitdata.skin[avatar2.skincol0]],
      [defaultcols.body0, kitdata.clothes[avatar2.bodycol]],
      [defaultcols.body1, kitdata.clothes[avatar2.bodycol]],
      [defaultcols.legs0, kitdata.clothes[avatar2.legscol]],
      [defaultcols.legs1, kitdata.clothes[avatar2.legscol]],
      [defaultcols.boots0, kitdata.feet[avatar2.bootscol]],
      [defaultcols.boots1, kitdata.feet[avatar2.bootscol]]
    ];
    let models2 = [];
    let anims2 = { none: -1 };
    avatar2.slots.forEach((slot) => {
      const equip = slot.slot;
      if (equip) {
        let mods = {
          replaceColors: [...equip.replaceColors],
          replaceMaterials: [...equip.replaceMaterials]
        };
        if (slot.cust?.color?.col2) {
          for (let i in mods.replaceColors) {
            mods.replaceColors[i][1] = slot.cust.color.col2[i];
          }
        }
        if (slot.cust?.color?.col4) {
          mods.replaceColors.push(...slot.cust.color.col4);
        }
        if (slot.cust?.material) {
          for (let i in mods.replaceMaterials) {
            mods.replaceMaterials[i][1] = slot.cust.material.materials[i];
          }
        }
        if (slot.cust?.model) {
          for (let i in slot.cust.model) {
            equip.models[i] = slot.cust.model[i];
          }
        }
        mods.replaceColors.push(...globalrecolors);
        let equipmodels = head ? equip.headmodels : equip.models;
        for (let i = isFemale ? 1 : 0; i < equipmodels.length; i += 2) {
          if (equipmodels[i] != -1) {
            models2.push({ modelid: equipmodels[i], mods });
          }
        }
      }
    });
    if (head) {
      anims2 = humanheadanims;
    } else {
      let animgroup = 2699;
      let animslot = slots.find((q) => q && q.animStruct != -1);
      if (animslot) {
        let file = await engine.getFileById(cacheMajors.structs, animslot.animStruct);
        let animfile = parse.structs.read(file, engine.rawsource);
        let noncombatset = animfile.extra?.find((q) => q.prop == 2954);
        if (noncombatset) {
          animgroup = noncombatset.intvalue;
        }
      }
      anims2 = await animGroupToAnims(engine, animgroup);
    }
    return { models: models2, avatar: avatar2, anims: anims2 };
  };
  let solveNode = async (parent) => {
    let offset = parent.offset;
    if (offset >= parent.buffer.length - 2) {
      return;
    }
    let byte0 = parent.buffer.readUint8(offset++);
    if (byte0 == 0) {
      addOpt(parent, offset, 0, false, null);
    }
    let byte1 = parent.buffer.readUint8(offset++);
    if (byte0 != 0 || byte1 != 0) {
      let value = byte0 << 8 | byte1;
      await addNumberOpt(parent, offset, byte0 == 0, value);
    }
  };
  let activelist = [];
  let kitdata = await loadKitData(engine);
  let playerkitarch = await engine.getArchiveById(cacheMajors.config, cacheConfigPages.identityKit);
  let playerkit = Object.fromEntries(playerkitarch.map((q) => [q.fileid, parse.identitykit.read(q.buffer, engine.rawsource)]));
  let models;
  let avatar = null;
  let npc = null;
  let anims = { none: -1 };
  let gender = buffer.readUint8(0);
  let isFemale = !!(gender & 1);
  let npcbuzz = buffer.readUint16BE(1);
  if (npcbuzz == 65535) {
    let npcid = buffer.readUint16BE(3);
    let file = await engine.getGameFile("npcs", npcid);
    let npc2 = parse.npc.read(file, engine.rawsource);
    let mods = {
      replaceColors: npc2.color_replacements ?? [],
      replaceMaterials: npc2.color_replacements ?? []
    };
    let models2 = [];
    if (!head) {
      if (npc2.models) {
        models2.push(...npc2.models.map((q) => ({ modelid: q, mods })));
      }
      if (npc2.animation_group) {
        anims = await animGroupToAnims(engine, npc2.animation_group);
      }
    } else {
      if (npc2.headModels) {
        models2.push(...npc2.headModels.map((q) => ({ modelid: q, mods })));
      }
    }
  } else {
    activelist.push({
      buffer,
      offset: 1,
      parent: null,
      penalty: 0,
      slot: null,
      slotindex: -1,
      usesBackup: false
    });
    for (let stepcount = 0; true; stepcount++) {
      activelist.sort((a, b) => b.penalty - a.penalty || a.slotindex - b.slotindex);
      let node = activelist.pop();
      if (!node) {
        throw new Error("no avatar read solution found");
      }
      stepcount++;
      if (node.slotindex == 15) {
        let res = await finalizeNode(node);
        if (res) {
          models = res.models;
          anims = res.anims;
          avatar = res.avatar;
          console.log(`solved player avatar in ${stepcount} steps, ${activelist.length} nodes left, ${node.penalty} penalty. ${node.usesBackup ? "used backup" : "did not use backup"}`);
          break;
        }
      } else {
        await solveNode(node);
      }
    }
  }
  return castModelInfo({
    models,
    anims,
    info: { avatar, gender, npc, kitcolors: kitdata, buffer },
    id: buffer,
    name: "player"
  });
}
async function animGroupToAnims(engine, groupid) {
  let animsetarch = await engine.getArchiveById(cacheMajors.config, cacheConfigPages.animgroups);
  let animsetfile = animsetarch[groupid];
  let animset = parse.animgroupConfigs.read(animsetfile.buffer, engine.rawsource);
  return serializeAnimset(animset);
}
function appearanceUrl(name) {
  if (typeof document != "undefined" && typeof document.location != "undefined" && (document.location.protocol.startsWith("http") || document.location.protocol == "about:")) {
    return `https://runeapps.org/data/getplayeravatar.php?player=${encodeURIComponent(name)}`;
  } else {
    return `https://secure.runescape.com/m=avatar-rs/${encodeURIComponent(name)}/appearance.dat`;
  }
}

// rsmv/src/3d/modelnodes.ts
import * as THREE3 from "three";
import { boundMethod } from "autobind-decorator";
import { AnimationClip as AnimationClip3, AnimationMixer as AnimationMixer2, Material, Mesh as Mesh4, Object3D as Object3D3, Skeleton as Skeleton3, SkinnedMesh as SkinnedMesh3, Vector2 as Vector22 } from "three";

// rsmv/src/3d/animationframes.ts
import { AnimationClip, AnimationMixer, Bone, Euler, Matrix4 as Matrix42, Quaternion, QuaternionKeyframeTrack, Skeleton, SkinnedMesh, Vector3 as Vector32, VectorKeyframeTrack } from "three";
function mountBakedSkeleton(rootnode, model) {
  let centers = getBoneCenters(model);
  let rootbone = new Bone();
  rootnode.add(rootbone);
  let leafbones = [rootbone];
  let rootbones = [];
  let inverses = [new Matrix42()];
  for (let i = 1; i < model.bonecount; i++) {
    let rootbone2 = new Bone();
    let leafbone = new Bone();
    rootbone2.name = `root_${i}`;
    leafbone.name = `bone_${i}`;
    rootbone2.add(leafbone);
    rootbones.push(rootbone2);
    leafbones.push(leafbone);
    let inverse = new Matrix42();
    let center = centers[i];
    if (center && center.weightsum != 0) {
      rootbone2.position.set(center.xsum / center.weightsum, center.ysum / center.weightsum, center.zsum / center.weightsum);
      inverse.setPosition(rootbone2.position);
    }
    inverse.invert();
    inverses.push(inverse);
  }
  let skeleton = new Skeleton(leafbones, inverses);
  if (rootbones.length != 0) {
    rootbone.add(...rootbones);
  }
  rootbone.updateMatrixWorld(true);
  let childbind = new Matrix42().copy(rootbone.matrixWorld);
  skeleton.calculateInverses();
  rootnode.traverse((node) => {
    if (node instanceof SkinnedMesh) {
      node.bind(skeleton, childbind);
      let geo = node.geometry;
      geo.attributes.skinIndex = geo.attributes.RA_skinIndex_bone;
      geo.attributes.skinWeight = geo.attributes.RA_skinWeight_bone;
    }
  });
  let mixer = new AnimationMixer(rootnode);
  return { mixer };
}
async function parseAnimationSequence4(loader, sequenceframes) {
  let secframe0 = sequenceframes[0];
  if (!secframe0) {
    throw new Error("animation has no frames");
  }
  let framearch = await loader.engine.getArchiveById(cacheMajors.frames, secframe0.frameidhi);
  let frames = Object.fromEntries(framearch.map((q, i) => [q.fileid, parse.frames.read(q.buffer, loader.engine.rawsource)]));
  const insertLoopFrame = true;
  let endtime = 0;
  let keyframetimeslist = [];
  let orderedframes = [];
  for (let i = 0; i < sequenceframes.length; i++) {
    let seqframe = sequenceframes[i];
    if (frames[seqframe.frameidlow]) {
      keyframetimeslist.push(endtime);
      endtime += seqframe.framelength * 0.02;
      orderedframes.push(frames[seqframe.frameidlow]);
    } else {
      console.log(`missing animation frame ${seqframe.frameidlow} in sequence ${seqframe.frameidhi}`);
    }
  }
  if (insertLoopFrame) {
    orderedframes.push(orderedframes[0]);
    keyframetimeslist.push(endtime);
  }
  let framebase = parse.framemaps.read(await loader.engine.getFileById(cacheMajors.framemaps, orderedframes[0].probably_framemap_id), loader.engine.rawsource);
  let keyframetimes = new Float32Array(keyframetimeslist);
  let clips = getFrameClips(framebase, orderedframes);
  return (model) => {
    let centers = getBoneCenters(model);
    let transforms = bakeAnimation(framebase, clips, keyframetimes, centers).map((arr, i) => ({ id: i, trans: arr }));
    let nframes = keyframetimes.length;
    let tracks = [];
    let matrix = new Matrix42();
    let scale = new Vector32();
    let translate = new Vector32();
    let prerotate = new Quaternion();
    let postrotate = new Quaternion();
    let skippedbones = 0;
    for (let trans of transforms) {
      if (trans.id == 0) {
        continue;
      }
      if (trans.id >= model.bonecount) {
        skippedbones++;
        continue;
      }
      let rootname = `root_${trans.id}`;
      let leafname = `bone_${trans.id}`;
      let scales = new Float32Array(nframes * 3);
      let positions = new Float32Array(nframes * 3);
      let prerotates = new Float32Array(nframes * 4);
      let postrotates = new Float32Array(nframes * 4);
      for (let i = 0; i < nframes; i++) {
        matrix.fromArray(trans.trans, i * 16);
        matrixToDoubleBone(matrix, translate, prerotate, scale, postrotate);
        translate.toArray(positions, i * 3);
        prerotate.toArray(prerotates, i * 4);
        scale.toArray(scales, i * 3);
        postrotate.toArray(postrotates, i * 4);
      }
      tracks.push(new VectorKeyframeTrack(`${rootname}.position`, keyframetimes, positions));
      tracks.push(new QuaternionKeyframeTrack(`${rootname}.quaternion`, keyframetimes, prerotates));
      tracks.push(new VectorKeyframeTrack(`${rootname}.scale`, keyframetimes, scales));
      tracks.push(new QuaternionKeyframeTrack(`${leafname}.quaternion`, keyframetimes, postrotates));
    }
    if (skippedbones != 0) {
      console.log("skipped " + skippedbones + " bone animations since the model didn't have them");
    }
    let clip = new AnimationClip("anim", void 0, tracks);
    return clip;
  };
}
function matrixToDoubleBone(matrix, translate, rotate1, scale, rotate2) {
  matrix.decompose(translate, rotate1, scale);
  rotate2.identity();
}
function bakeAnimation(base, clips, frametimes, bonecenters) {
  let nframes = frametimes.length;
  let matrix = new Matrix42();
  let transform = new Matrix42();
  let quat = new Quaternion();
  let pivotmatrixright = new Matrix42();
  let pivotmatrixleft = new Matrix42();
  let nbones = Math.max(...base.data.flatMap((q) => q.data)) + 1 + 1;
  let bonestates = [];
  for (let i = 0; i < nbones; i++) {
    let bonematrices = new Float32Array(16 * nframes);
    let center = bonecenters[i];
    let x = !center || center.weightsum == 0 ? 0 : center.xsum / center.weightsum;
    let y = !center || center.weightsum == 0 ? 0 : center.ysum / center.weightsum;
    let z = !center || center.weightsum == 0 ? 0 : center.zsum / center.weightsum;
    for (let j = 0; j < nframes; j++) {
      bonematrices[j * 16 + 0] = 1;
      bonematrices[j * 16 + 5] = 1;
      bonematrices[j * 16 + 10] = 1;
      bonematrices[j * 16 + 15] = 1;
      bonematrices[j * 16 + 12] = x;
      bonematrices[j * 16 + 13] = y;
      bonematrices[j * 16 + 14] = z;
    }
    bonestates.push(bonematrices);
  }
  let pivot = new Vector32();
  for (let framenr = 0; framenr < nframes; framenr++) {
    pivot.set(0, 0, 0);
    let matrixoffset = framenr * 16;
    for (let [stepnr, step] of base.data.entries()) {
      let clip = clips[stepnr];
      if (step.type == 0) {
        pivot.fromArray(clip, framenr * 3);
        let sumx = 0, sumy = 0, sumz = 0;
        let weight = 0;
        for (let boneid of step.data) {
          let center = bonecenters[boneid + 1];
          let matrices = bonestates[boneid + 1];
          if (center) {
            sumx += matrices[matrixoffset + 12] * center.weightsum;
            sumy += matrices[matrixoffset + 13] * center.weightsum;
            sumz += matrices[matrixoffset + 14] * center.weightsum;
            weight += center.weightsum;
          }
        }
        if (weight != 0) {
          pivot.set(
            pivot.x + sumx / weight,
            pivot.y + sumy / weight,
            pivot.z + sumz / weight
          );
        }
        pivotmatrixright.makeTranslation(-pivot.x, -pivot.y, -pivot.z);
        pivotmatrixleft.makeTranslation(pivot.x, pivot.y, pivot.z);
      }
      if (step.type == 1) {
        for (let boneid of step.data) {
          let bone = bonestates[boneid + 1];
          bone[matrixoffset + 12] += clip[framenr * 3 + 0];
          bone[matrixoffset + 13] += clip[framenr * 3 + 1];
          bone[matrixoffset + 14] += clip[framenr * 3 + 2];
        }
      }
      if (step.type == 2) {
        quat.fromArray(clip, framenr * 4);
        transform.makeRotationFromQuaternion(quat);
        transform.multiply(pivotmatrixright);
        transform.premultiply(pivotmatrixleft);
        for (let boneid of step.data) {
          let bone = bonestates[boneid + 1];
          matrix.fromArray(bone, matrixoffset);
          matrix.premultiply(transform);
          matrix.toArray(bone, matrixoffset);
        }
      }
      if (step.type == 3) {
        transform.makeScale(clip[framenr * 3 + 0], clip[framenr * 3 + 1], clip[framenr * 3 + 2]);
        transform.multiply(pivotmatrixright);
        transform.premultiply(pivotmatrixleft);
        for (let boneid of step.data) {
          let bone = bonestates[boneid + 1];
          matrix.fromArray(bone, matrixoffset);
          matrix.premultiply(transform);
          matrix.toArray(bone, matrixoffset);
        }
      }
    }
  }
  return bonestates;
}
function getFrameClips(framebase, framesparsed) {
  let frames = framesparsed.map((framedata) => {
    return {
      flags: framedata.flags,
      animdata: framedata.animdata,
      dataindex: 0,
      baseid: framedata.probably_framemap_id,
      stream: new Stream(Buffer.from(framedata.animdata))
    };
  });
  let clips = [];
  for (let [index, base] of framebase.data.entries()) {
    let nfields = [3, 3, 4, 3, 3, 4, 3, 3, 3, 3, 3][base.type];
    let rawclip = new Float32Array(nfields * frames.length);
    let clipindex = 0;
    let tempquat = new Quaternion();
    let tempEuler = new Euler();
    for (let frame of frames) {
      let flag2 = frame?.flags[index] ?? 0;
      if (flag2 & ~7) {
        console.log("unexpexted frame data flag " + (flag2 & ~7));
      }
      if (base.type == 0) {
        rawclip[clipindex++] = flag2 & 1 ? frame.stream.readShortSmartBias() : 0;
        rawclip[clipindex++] = flag2 & 2 ? frame.stream.readShortSmartBias() : 0;
        rawclip[clipindex++] = flag2 & 4 ? frame.stream.readShortSmartBias() : 0;
        if (flag2 & 7) {
          console.log("type 0 data", flag2, [...rawclip.slice(clipindex - 3, clipindex)]);
        }
      }
      if (base.type == 1) {
        rawclip[clipindex++] = flag2 & 1 ? frame.stream.readShortSmartBias() : 0;
        rawclip[clipindex++] = -(flag2 & 2 ? frame.stream.readShortSmartBias() : 0);
        rawclip[clipindex++] = flag2 & 4 ? frame.stream.readShortSmartBias() : 0;
      }
      if (base.type == 2) {
        let rotx = 0;
        if (flag2 & 1) {
          let comp1 = frame.stream.readShortSmartBias();
          let comp2 = frame.stream.readShortSmartBias();
          rotx = Math.atan2(comp1, comp2);
        }
        let roty = 0;
        if (flag2 & 2) {
          let comp1 = frame.stream.readShortSmartBias();
          let comp2 = frame.stream.readShortSmartBias();
          roty = Math.atan2(comp1, comp2);
        }
        let rotz = 0;
        if (flag2 & 4) {
          let comp1 = frame.stream.readShortSmartBias();
          let comp2 = frame.stream.readShortSmartBias();
          rotz = Math.atan2(comp1, comp2);
        }
        tempEuler.set(rotx, roty, rotz, "YXZ");
        tempquat.setFromEuler(tempEuler);
        tempquat.toArray(rawclip, clipindex);
        clipindex += 4;
      }
      if (base.type == 3) {
        rawclip[clipindex++] = (flag2 & 1 ? frame.stream.readShortSmartBias() : 128) / 128;
        rawclip[clipindex++] = (flag2 & 2 ? frame.stream.readShortSmartBias() : 128) / 128;
        rawclip[clipindex++] = (flag2 & 4 ? frame.stream.readShortSmartBias() : 128) / 128;
      }
      if (base.type == 5) {
        rawclip[clipindex++] = flag2 & 1 ? frame.stream.readUShortSmart() : 0;
        rawclip[clipindex++] = flag2 & 2 ? frame.stream.readUShortSmart() : 0;
        rawclip[clipindex++] = flag2 & 4 ? frame.stream.readUShortSmart() : 0;
      } else if (base.type >= 4) {
        rawclip[clipindex++] = flag2 & 1 ? frame.stream.readUShortSmart() : 0;
        rawclip[clipindex++] = flag2 & 2 ? frame.stream.readUShortSmart() : 0;
        rawclip[clipindex++] = flag2 & 4 ? frame.stream.readUShortSmart() : 0;
      }
    }
    clips.push(rawclip);
  }
  frames.forEach((q, i) => {
    let bytes = q.stream.bytesLeft();
    if (bytes != 0) {
      console.warn("ints left in anim decode: " + bytes, i);
      let counts = {};
      framebase.data.map((fr, i2) => {
        counts[fr.type] = (counts[fr.type] ?? 0) + (q.flags[i2] ?? 0).toString(2).replaceAll("0", "").length;
      });
      console.log(counts);
    }
  });
  return clips;
}

// rsmv/src/3d/animationskeletal.ts
import { AnimationClip as AnimationClip2, Bone as Bone2, Euler as Euler2, Matrix4 as Matrix43, Quaternion as Quaternion2, QuaternionKeyframeTrack as QuaternionKeyframeTrack2, Skeleton as Skeleton2, SkinnedMesh as SkinnedMesh2, VectorKeyframeTrack as VectorKeyframeTrack2 } from "three";
function sampleAnimBezier(track, t) {
  for (let i = 0; i < track.length - 1; i++) {
    let sample = track[i];
    let next = track[i + 1];
    if (sample.time <= t && next.time >= t) {
      let x0 = sample.value[0];
      let x3 = next.value[0];
      let t0 = sample.time;
      let t3 = next.time;
      let x1 = x0 + sample.value[2];
      let t1 = t0 + sample.value[1];
      let x2 = x3 - sample.value[4];
      let t2 = t3 - sample.value[3];
      let a = sampleInverseBezierSection(t0, t1, t2, t3, t);
      let r = sampleBezier(x0, x1, x2, x3, a);
      return r;
    }
  }
  throw new Error("out of track bounds");
}
function sampleBezier(x0, x1, x2, x3, t) {
  let a = 3 * x1 - x0 - 3 * x2 + x3;
  let b = 3 * x0 - 6 * x1 + 3 * x2;
  let c = 3 * x1 - 3 * x0;
  let d = x0;
  return t * t * t * a + t * t * b + t * c + d;
}
function sampleInverseBezierSection(x0, x1, x2, x3, x) {
  let eps = 1e-5;
  let a = 3 * x1 - x0 - 3 * x2 + x3;
  let b = 3 * x0 - 6 * x1 + 3 * x2;
  let c = 3 * x1 - 3 * x0;
  let d = x0 - x;
  if (Math.abs(a) < eps) {
    let det = c * c - 4 * b * d;
    if (det < 0) {
      throw new Error("no solution for quadratic interpolation");
    }
    let sol0 = 2 * d / (-c - Math.sqrt(det));
    let sol1 = 2 * d / (-c + Math.sqrt(det));
    let sol0valid = sol0 >= -eps && sol0 <= 1 + eps;
    let sol1valid = sol1 >= -eps && sol1 <= 1 + eps;
    if (sol0valid && sol1valid) {
    }
    if (!sol0valid && !sol1valid) {
      throw new Error("no valid solutions for quadratic interpolation");
    }
    return sol0valid ? sol0 : sol1;
  }
  let p = -b / (3 * a);
  let q = p * p * p + (b * c - 3 * a * d) / (6 * a * a);
  let r = c / (3 * a);
  let dd = q * q + Math.pow(r - p * p, 3);
  let ddrootreal = dd >= 0 ? Math.sqrt(dd) : 0;
  let ddrootimag = dd >= 0 ? 0 : Math.sqrt(-dd);
  let posreal = q + ddrootreal;
  let posimag = ddrootimag;
  let negreal = q - ddrootreal;
  let negimag = -ddrootimag;
  let magpos = Math.hypot(posreal, posimag);
  let anglepos = Math.atan2(posimag, posreal);
  let magneg = Math.hypot(negreal, negimag);
  let angleneg = Math.atan2(negimag, negreal);
  let magpos2 = Math.pow(magpos, 1 / 3);
  let anglepos2 = anglepos / 3;
  let magneg2 = Math.pow(magneg, 1 / 3);
  let angleneg2 = angleneg / 3;
  let solution = 0;
  let solutioncount = 0;
  for (let k of [0, 1, 2]) {
    for (let j of [0, 1, 2]) {
      let solimag = magpos2 * Math.sin(anglepos2 + k * Math.PI / 3 * 2) + magneg2 * Math.sin(angleneg2 + j * Math.PI / 3 * 2);
      let solreal = magpos2 * Math.cos(anglepos2 + k * Math.PI / 3 * 2) + magneg2 * Math.cos(angleneg2 + j * Math.PI / 3 * 2) + p;
      if (Math.abs(solimag) < eps && solreal >= -eps && solreal <= 1 + eps) {
        let newsolution = magpos2 * Math.cos(anglepos2 + k * Math.PI / 3 * 2) + magneg2 * Math.cos(angleneg2 + j * Math.PI / 3 * 2) + p;
        if (solutioncount != 0 && Math.abs(newsolution - solution) > eps) {
        }
        solution = newsolution;
        solutioncount++;
      }
    }
  }
  if (solutioncount == 0) {
    throw new Error("no solution found");
  }
  return solution;
}
async function mountSkeletalSkeleton(rootnode, cache, framebaseid) {
  let base = parse.framemaps.read(await cache.engine.getFileById(cacheMajors.framemaps, framebaseid), cache.engine.rawsource);
  if (!base.skeleton) {
    throw new Error("framebase does not have skeleton");
  }
  let bones = [];
  let rootbones = [];
  let tmp = new Matrix43();
  let prematrix = new Matrix43().makeScale(1, 1, -1);
  for (let [id, entry] of base.skeleton.entries()) {
    let bone = new Bone2();
    let matrix = new Matrix43().fromArray(entry.bonematrix);
    bone.name = "bone_" + id;
    if (entry.nonskinboneid == 65535) {
      rootbones.push(bone);
      matrix.multiply(prematrix);
    } else {
      bones[entry.nonskinboneid].add(bone);
    }
    tmp.copy(matrix).decompose(bone.position, bone.quaternion, bone.scale);
    bone.updateMatrixWorld();
    bones[id] = bone;
  }
  let skeleton = new Skeleton2(bones);
  if (rootbones.length != 0) {
    rootnode.add(...rootbones);
  }
  rootnode.updateMatrixWorld(true);
  let childbind = new Matrix43().copy(rootnode.matrixWorld);
  skeleton.calculateInverses();
  rootnode.traverse((node) => {
    if (node instanceof SkinnedMesh2) {
      node.bind(skeleton, childbind);
      let geo = node.geometry;
      geo.attributes.skinIndex = geo.attributes.RA_skinIndex_skin;
      geo.attributes.skinWeight = geo.attributes.RA_skinWeight_skin;
    }
  });
}
async function parseSkeletalAnimation(cache, animid) {
  let anim = parse.skeletalAnim.read(await cache.engine.getFileById(cacheMajors.skeletalAnims, animid), cache.engine.rawsource);
  let convertedtracks = [];
  let animtracks = anim.tracks.sort((a, b) => {
    if (a.boneid != b.boneid) {
      return a.boneid - b.boneid;
    }
    return a.type_0to9 - b.type_0to9;
  });
  let actiontypemap = [
    { t: "unknown", a: 0 },
    //1-9
    { t: "rotate", a: 0 },
    { t: "rotate", a: 1 },
    { t: "rotate", a: 2 },
    { t: "translate", a: 0 },
    { t: "translate", a: 1 },
    { t: "translate", a: 2 },
    { t: "scale", a: 0 },
    { t: "scale", a: 1 },
    { t: "scale", a: 2 },
    //10-16 unknown
    { t: "unknown", a: 0 },
    //109 hits, -1 3x, 0 103x, 1 3x
    { t: "unknown", a: 0 },
    //109 hits, -1 6x, 0 103x
    { t: "unknown", a: 0 },
    //109 hits, -1 4x, 0 94x, 1 15x
    { t: "unknown", a: 0 },
    //4k hits, 0x 3400, 42 600x
    { t: "unknown", a: 0 },
    //4k hits, sort of spread between 0-0.015, most at bounderies
    { t: "unknown", a: 0 },
    //4k hits, spread between -0.3-0.1, most at bounderies
    { t: "unknown", a: 0 }
    //2k hits, spread between -1-1, most at bounderies or 0
  ];
  for (let index = 0; index < animtracks.length; ) {
    let track = animtracks[index];
    let xvalues = null;
    let yvalues = null;
    let zvalues = null;
    let tracktype = actiontypemap[track.type_0to9];
    let boneid = track.boneid < 16e3 ? track.boneid - 64 : track.boneid - 16384;
    while (index < animtracks.length) {
      let track2 = animtracks[index];
      let t2 = actiontypemap[track2.type_0to9];
      if (track2.boneid != track.boneid || t2.t != tracktype.t) {
        break;
      }
      if (t2.a == 0) {
        xvalues = track2.chunks;
      }
      if (t2.a == 1) {
        yvalues = track2.chunks;
      }
      if (t2.a == 2) {
        zvalues = track2.chunks;
      }
      index++;
    }
    let bonename = "bone_" + boneid;
    let defaultvalue = tracktype.t == "scale" ? 1 : 0;
    let timearray = [];
    let data = [];
    let euler = new Euler2();
    let quat = new Quaternion2();
    let endtime = xvalues?.at(-1)?.time ?? yvalues?.at(-1)?.time ?? zvalues?.at(-1)?.time ?? 0;
    let idata = 0;
    for (let t = 0; t < endtime; t += 5) {
      data[idata++] = xvalues ? sampleAnimBezier(xvalues, t) : defaultvalue;
      data[idata++] = yvalues ? sampleAnimBezier(yvalues, t) : defaultvalue;
      data[idata++] = zvalues ? sampleAnimBezier(zvalues, t) : defaultvalue;
      timearray.push(t);
    }
    let times = new Float32Array(timearray.map((q) => q * 0.02));
    if (tracktype.t == "translate") {
      convertedtracks.push(new VectorKeyframeTrack2(`${bonename}.position`, times, data));
    }
    if (tracktype.t == "scale") {
      if (boneid == 0) {
        for (let i = 0; i < data.length; i += 3) {
          data[i + 2] *= -1;
        }
      }
      convertedtracks.push(new VectorKeyframeTrack2(`${bonename}.scale`, times, data));
    }
    if (tracktype.t == "rotate") {
      let quatdata = new Float32Array(timearray.length * 4);
      for (let i = 0; i * 3 < data.length; i++) {
        euler.set(data[i * 3 + 0], data[i * 3 + 1], data[i * 3 + 2], "YXZ");
        quat.setFromEuler(euler);
        quat.toArray(quatdata, i * 4);
      }
      convertedtracks.push(new QuaternionKeyframeTrack2(`${bonename}.quaternion`, times, quatdata));
    }
  }
  let clip = new AnimationClip2("anim_" + (Math.random() * 1e3 | 0), void 0, convertedtracks);
  return { clip, framebaseid: anim.framebase };
}

// rsmv/src/map/svgrender.ts
var similarangle = (a1, a2) => {
  const PI2 = Math.PI * 2;
  const EPS = 1e-4;
  let d = ((a1 - a2 + Math.PI) % PI2 + PI2) % PI2 - Math.PI;
  return Math.abs(d) < EPS;
};
function mergePoly(set3, corners, dirtystart, dirtycount) {
  for (let group of set3) {
    if (group == corners) {
      continue;
    }
    for (let a = 0; a < group.length; a++) {
      let a1 = group[a];
      let a2 = group[(a + 1) % group.length];
      for (let b = dirtystart; b < dirtystart + dirtycount; b++) {
        let b1 = corners[b % corners.length];
        let b2 = corners[(b + 1) % corners.length];
        if (a1.x == b2.x && a1.z == b2.z && a2.x == b1.x && a2.z == b1.z) {
          let srcoffset = b % corners.length;
          let dstoffset = a + 1;
          let insertgroup = [
            ...corners.slice(Math.min(srcoffset + 2, corners.length), corners.length),
            ...corners.slice(Math.max(0, srcoffset - corners.length + 2), srcoffset)
          ];
          group.splice(dstoffset, 0, ...insertgroup);
          set3.delete(corners);
          return mergePoly(set3, group, dstoffset, insertgroup.length + 2);
        }
      }
    }
  }
  return corners;
}
function unfoldPolygon(poly, mergelinear) {
  for (let i = 0; i < poly.length; i++) {
    let a = poly[i];
    let b = poly[(i + 1) % poly.length];
    let c = poly[(i + 2) % poly.length];
    if (a.x == b.x && a.z == b.z) {
      poly.splice((i + 1) % poly.length, 1);
      i = Math.max(-1, i - 2);
      continue;
    }
    let dx1 = b.x - a.x, dz1 = b.z - a.z;
    let dx2 = c.x - b.x, dz2 = c.z - b.z;
    let angle1 = Math.atan2(dz1, dx1);
    let angle2 = Math.atan2(dz2, dx2);
    if (similarangle(angle1 + Math.PI, angle2) || mergelinear && similarangle(angle1, angle2)) {
      poly.splice((i + 1) % poly.length, 1);
      i = Math.max(-1, i - 2);
    }
  }
}
async function svgfloor(engine, grid, locs, rect, maplevel, pxpertile, wallsonly, drawicons, thicklines = false) {
  let drawground = !wallsonly;
  let drawwalls = true;
  let drawmapscenes = !wallsonly;
  let underlay = "";
  let mapscenes = /* @__PURE__ */ new Map();
  let maplabels = /* @__PURE__ */ new Map();
  let overlays = [/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map()];
  let whitelines = [];
  let redlines = [];
  let transparent = 16711935;
  let coltoint2 = (col) => {
    if (!col) {
      return transparent;
    }
    return col[0] << 16 | col[1] << 8 | col[2];
  };
  let getOverlayColor = (tile2) => {
    let overlay = tile2.waterProps?.rawOverlay ?? tile2.rawOverlay;
    let colint = coltoint2(overlay?.secondary_colour);
    if (colint == transparent) {
      colint = coltoint2(tile2.waterProps?.props.color ?? tile2.overlayprops.color);
    }
    return colint;
  };
  if (drawground) {
    let underlaybitmap = new Uint8ClampedArray(rect.xsize * rect.zsize * 4);
    for (let i = 0; i < underlaybitmap.length; i += 4) {
      underlaybitmap[i + 0] = 0;
      underlaybitmap[i + 1] = 0;
      underlaybitmap[i + 2] = 0;
      underlaybitmap[i + 3] = 255;
    }
    for (let dz = 0; dz < rect.zsize; dz++) {
      for (let dx = 0; dx < rect.xsize; dx++) {
        let underlaycolor = [0, 0, 0];
        let occluded = false;
        for (let level = squareLevels - 1; !occluded && level >= 0; level--) {
          let tile2 = grid.getTile(rect.x + dx, rect.z + dz, level);
          if (!tile2 || !(tile2.settings & 8) && tile2.effectiveLevel > maplevel) {
            continue;
          }
          if (tile2.underlayVisible) {
            underlaycolor = tile2.underlayprops.color;
            occluded = true;
          }
          if (tile2.waterProps || tile2.rawOverlay) {
            let vertices = tile2.waterProps?.shape ?? tile2.shape.overlay;
            let colint = getOverlayColor(tile2);
            if (colint == transparent) {
              if (tile2.underlayVisible) {
                vertices = tile2.shape.underlay;
                colint = coltoint2(tile2.underlayprops.color);
                underlaycolor = [0, 0, 0];
                occluded = false;
              } else {
                vertices = [];
              }
            }
            if (vertices.length != 0) {
              let set3 = getOrInsert(overlays[level], colint, () => /* @__PURE__ */ new Set());
              let corners = vertices.map((q) => ({ x: dx + q.subx, z: dz + q.subz }));
              set3.add(corners);
              let group = mergePoly(set3, corners, 0, corners.length);
              unfoldPolygon(group, false);
            }
          }
        }
        let underlayindex = dx * 4 + dz * 4 * rect.xsize;
        underlaybitmap[underlayindex + 0] = underlaycolor[0];
        underlaybitmap[underlayindex + 1] = underlaycolor[1];
        underlaybitmap[underlayindex + 2] = underlaycolor[2];
        underlaybitmap[underlayindex + 3] = 255;
      }
    }
    underlay = await pixelsToDataUrl(makeImageData(underlaybitmap, rect.xsize, rect.zsize));
  }
  let addline = (group, tilex, tilez, corner1, corner2, rotation) => {
    let x1 = tilex + ((corner1 + rotation + 1) % 4 < 2 ? 0 : 1);
    let z1 = tilez + ((corner1 + rotation + 2) % 4 < 2 ? 0 : 1);
    let x2 = tilex + ((corner2 + rotation + 1) % 4 < 2 ? 0 : 1);
    let z2 = tilez + ((corner2 + rotation + 2) % 4 < 2 ? 0 : 1);
    for (let line of group) {
      let xv1 = line[0].x;
      let zv1 = line[0].z;
      let xv2 = line[line.length - 1].x;
      let zv2 = line[line.length - 1].z;
      if (xv1 == x1 && zv1 == z1) {
        line.unshift({ x: x2, z: z2 });
        return;
      }
      if (xv1 == x2 && zv1 == z2) {
        line.unshift({ x: x1, z: z1 });
        return;
      }
      if (xv2 == x1 && zv2 == z1) {
        line.push({ x: x2, z: z2 });
        return;
      }
      if (xv2 == x2 && zv2 == z2) {
        line.push({ x: x1, z: z1 });
        return;
      }
    }
    group.push([{ x: x1, z: z1 }, { x: x2, z: z2 }]);
  };
  const overdraw = 2;
  for (let loc of locs) {
    if (loc.x < rect.x - overdraw || loc.z < rect.z - overdraw) {
      continue;
    }
    if (loc.x >= rect.x + rect.xsize + overdraw || loc.z >= rect.z + rect.zsize + overdraw) {
      continue;
    }
    if (loc.effectiveLevel == -1 || !loc.forceVisible && loc.effectiveLevel > maplevel) {
      continue;
    }
    let linegroup = loc.location.deletable || loc.location.actions_0 ? redlines : whitelines;
    let occluded = false;
    for (let level = loc.plane + 1; level < squareLevels; level++) {
      let tile2 = grid.getTile(loc.x, loc.z, level);
      if (!tile2 || tile2?.effectiveLevel != loc.effectiveLevel) {
        break;
      }
      if (tile2.effectiveLevel == maplevel && (getOverlayColor(tile2) != transparent || tile2.underlayVisible)) {
        occluded = true;
      }
    }
    if (wallsonly && loc.effectiveLevel != maplevel) {
      occluded = true;
    }
    if (drawicons && loc.effectiveLevel == maplevel && loc.location.mapFunction) {
      let group = maplabels.get(loc.location.mapFunction);
      if (!group) {
        let maplabel = engine.mapMaplabels[loc.location.mapFunction];
        if (maplabel.legacy_switch) {
          maplabel = engine.mapMaplabels[maplabel.legacy_switch.default_ref];
        }
        let src = "";
        let width = 0;
        let height = 0;
        if (maplabel.sprite != void 0) {
          let spritefile = await engine.getFileById(cacheMajors.sprites, maplabel.sprite);
          let sprite = parseSprite(spritefile);
          src = await pixelsToDataUrl(sprite[0].img);
          width = sprite[0].img.width;
          height = sprite[0].img.height;
        }
        group = { src, width, height, uses: [] };
        maplabels.set(loc.location.mapFunction, group);
      }
      group.uses.push({ x: loc.x - rect.x, z: loc.z - rect.z });
    }
    if (!loc.location.mapscene) {
      if (drawwalls && !occluded) {
        if (loc.type == 0) {
          addline(linegroup, loc.x - rect.x, loc.z - rect.z, 3, 0, loc.rotation);
        } else if (loc.type == 2) {
          addline(linegroup, loc.x - rect.x, loc.z - rect.z, 3, 0, loc.rotation);
          addline(linegroup, loc.x - rect.x, loc.z - rect.z, 0, 1, loc.rotation);
        } else if (loc.type == 9) {
          addline(linegroup, loc.x - rect.x, loc.z - rect.z, 3, 1, loc.rotation);
        }
      }
    } else {
      if (drawmapscenes) {
        let group = mapscenes.get(loc.location.mapscene);
        if (!group) {
          let mapscene = engine.mapMapscenes[loc.location.mapscene];
          let src = "";
          let width = 0;
          let height = 0;
          if (mapscene.sprite_id != void 0) {
            let spritefile = await engine.getFileById(cacheMajors.sprites, mapscene.sprite_id);
            let sprite = parseSprite(spritefile);
            src = await pixelsToDataUrl(sprite[0].img);
            width = sprite[0].img.width;
            height = sprite[0].img.height;
          }
          group = { src, width, height, uses: [] };
          mapscenes.set(loc.location.mapscene, group);
        }
        group.uses.push({ x: loc.x - rect.x, z: loc.z - rect.z });
      }
    }
  }
  let r = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${rect.xsize} ${rect.zsize}" width="${rect.xsize * pxpertile}" height="${rect.zsize * pxpertile}">
`;
  r += `<g transform="scale(1,-1) translate(0,-${rect.zsize})">
`;
  r += `<defs>
`;
  for (let [id, scene] of mapscenes) {
    r += `<image id="mapscene-${id}" class="mapscene" width="${scene.width / 4}" height="${scene.height / 4}" href="${scene.src}" style="image-rendering: pixelated;" transform="scale(1,-1)"/>
`;
  }
  for (let [id, scene] of maplabels) {
    r += `<image id="maplabel-${id}" class="maplabel" width="${scene.width / 4}" height="${scene.height / 4}" x="${-scene.width / 4 / 2}" y="${0}" href="${scene.src}" style="image-rendering: pixelated;" transform="scale(1,-1)"/>
`;
  }
  r += `</defs>
`;
  if (underlay) {
    r += `<image href="${underlay}" style="image-rendering: pixelated;" width="${rect.xsize}" height="${rect.zsize}"/>
`;
  }
  if (overlays.reduce((a, q) => q.size + a, 0) != 0) {
    r += `<g shape-rendering="crispEdges">
`;
    for (let overlaylayer of overlays) {
      for (let [col, overlay] of overlaylayer.entries()) {
        for (let poly of overlay) {
          unfoldPolygon(poly, true);
          let colstr = col.toString(16).padStart(6, "0");
          r += `<polygon fill="#${colstr}" points="${poly.map((q) => `${q.x},${q.z}`).join(" ")}"/>
`;
        }
      }
    }
    r += `</g>`;
  }
  const linewidth = thicklines ? 3 / 8 : 0.2;
  if (whitelines.length != 0) {
    r += `<g stroke="white" stroke-width="${linewidth}" fill="none">`;
    for (let line of whitelines) {
      r += `<polyline points="${line.map((q) => `${q.x},${q.z}`).join(" ")}"/>
`;
    }
    r += `</g>`;
  }
  if (redlines.length != 0) {
    r += `<g stroke="red" stroke-width="${linewidth}" fill="none">`;
    for (let line of redlines) {
      r += `<polyline points="${line.map((q) => `${q.x},${q.z}`).join(" ")}"/>
`;
    }
    r += `</g>`;
  }
  for (let [id, scene] of mapscenes) {
    for (let use of scene.uses) {
      r += `<use href="#mapscene-${id}" x="${use.x}" y="${use.z + scene.height / 4}"/>
`;
    }
  }
  for (let [id, scene] of maplabels) {
    for (let use of scene.uses) {
      r += `<use href="#maplabel-${id}" x="${use.x}" y="${use.z + scene.height / 4}"/>
`;
    }
  }
  r += `</g>
`;
  r += `</svg>`;
  return r;
}

// rsmv/src/3d/modelnodes.ts
var import_node_fetch = __toESM(require_lib3());
function castModelInfo(info) {
  return info;
}
async function modelToModel(cache, id) {
  let modeldata = await cache.getModelData(id);
  let info;
  if (cache.modelType == "classic") {
    let arch = await cache.engine.getArchiveById(0, classicGroups.models);
    info = parse.classicmodels.read(arch[id].buffer, cache.engine.rawsource);
  } else if (cache.modelType == "old") {
    let major = cache.engine.legacyData ? legacyMajors.oldmodels : cacheMajors.oldmodels;
    info = parse.oldmodels.read(await cache.engine.getFileById(major, id), cache.engine.rawsource);
  } else if (cache.modelType == "nxt") {
    info = parse.models.read(await cache.engine.getFileById(cacheMajors.models, id), cache.engine.rawsource);
  }
  return castModelInfo({
    models: [{ modelid: id, mods: {} }],
    anims: {},
    info: { modeldata, info },
    id,
    name: `model:${id}`
  });
}
async function playerToModel(cache, name) {
  let avadata = "";
  if (name.length <= 20) {
    let url = appearanceUrl(name);
    let data = await (0, import_node_fetch.default)(url).then((q) => q.text());
    if (data.indexOf("404 - Page not found") != -1) {
      throw new Error("player avatar not found");
    }
    avadata = data;
  } else {
    avadata = name;
  }
  let avainfo = await avatarToModel(cache.engine, avatarStringToBytes(avadata), false);
  return castModelInfo({
    ...avainfo,
    id: name,
    name
  });
}
async function npcBodyToModel(cache, id) {
  return npcToModel(cache, { id, head: false });
}
async function npcToModel(cache, id) {
  let npc = parse.npc.read(await cache.engine.getGameFile("npcs", id.id), cache.engine.rawsource);
  let anims = {};
  let modelids = (id.head ? npc.headModels : npc.models) ?? [];
  if (!id.head && npc.animation_group) {
    let arch = await cache.engine.getArchiveById(cacheMajors.config, cacheConfigPages.animgroups);
    let animgroup = parse.animgroupConfigs.read(arch[npc.animation_group].buffer, cache.engine.rawsource);
    anims = serializeAnimset(animgroup);
  }
  let mods = {};
  if (npc.color_replacements) {
    mods.replaceColors = npc.color_replacements;
  }
  if (npc.material_replacements) {
    mods.replaceMaterials = npc.material_replacements;
  }
  let models = modelids.map((q) => ({ modelid: q, mods }));
  return castModelInfo({
    info: npc,
    models,
    anims,
    id,
    name: npc.name ?? `npc:${id.id}`
  });
}
async function spotAnimToModel(cache, id) {
  let animdata = parse.spotAnims.read(await cache.engine.getGameFile("spotanims", id), cache.engine.rawsource);
  let mods = {};
  if (animdata.replace_colors) {
    mods.replaceColors = animdata.replace_colors;
  }
  if (animdata.replace_materials) {
    mods.replaceMaterials = animdata.replace_materials;
  }
  let models = animdata.model ? [{ modelid: animdata.model, mods }] : [];
  let anims = {};
  if (animdata.sequence) {
    anims.default = animdata.sequence;
  }
  return castModelInfo({
    models,
    anims,
    info: animdata,
    id,
    name: `spotanim:${id}`
  });
}
async function locToModel(cache, id) {
  let { morphedloc } = await resolveMorphedObject(cache.engine, id);
  let mods = {};
  let anims = {};
  let models = [];
  if (morphedloc) {
    if (morphedloc.color_replacements) {
      mods.replaceColors = morphedloc.color_replacements;
    }
    if (morphedloc.material_replacements) {
      mods.replaceMaterials = morphedloc.material_replacements;
    }
    if (cache.engine.getBuildNr() > lastClassicBuildnr && cache.engine.getBuildNr() < 377) {
      mods.replaceMaterials = mods.replaceColors;
    }
    models = [
      ...morphedloc.models?.flatMap((m) => m.values).map((q) => ({ modelid: q, mods })) ?? [],
      ...morphedloc.models_05?.models.flatMap((m) => m.values).map((q) => ({ modelid: q, mods })) ?? []
    ];
  }
  if (morphedloc?.probably_animation) {
    anims.default = morphedloc.probably_animation;
  }
  return castModelInfo({
    models,
    anims,
    info: morphedloc,
    id,
    name: morphedloc.name ?? `loc:${id}`
  });
}
async function itemToModel(cache, id) {
  let item = parse.item.read(await cache.engine.getGameFile("items", id), cache.engine.rawsource);
  if (!item.baseModel && item.noteTemplate) {
    item = parse.item.read(await cache.engine.getGameFile("items", item.noteTemplate), cache.engine.rawsource);
  }
  let mods = {};
  if (item.color_replacements) {
    mods.replaceColors = item.color_replacements;
  }
  if (item.material_replacements) {
    mods.replaceMaterials = item.material_replacements;
  }
  let models = item.baseModel ? [{ modelid: item.baseModel, mods }] : [];
  return castModelInfo({
    models,
    anims: {},
    info: item,
    id,
    name: item.name ?? `item:${id}`
  });
}
var RSModel = class extends TypedEmitter {
  constructor(cache, models, name = "") {
    super();
    this.loaded = null;
    this.rootnode = new THREE3.Group();
    this.nullAnimPromise = { clip: null, prom: new CallbackPromise() };
    this.anims = {
      "-1": this.nullAnimPromise
    };
    this.mountedanim = null;
    this.mixer = new AnimationMixer2(this.rootnode);
    this.renderscene = null;
    this.targetAnimId = -1;
    this.skeletontype = "none";
    this.skeletonHelper = null;
    this.cache = cache;
    this.model = (async () => {
      let meshdatas = await Promise.all(models.map(async (modelinit) => {
        let meshdata = await cache.getModelData(modelinit.modelid);
        let modified = {
          ...meshdata,
          meshes: meshdata.meshes.map((q) => modifyMesh(q, modelinit.mods))
        };
        return modified;
      }));
      let modeldata = mergeModelDatas(meshdatas);
      mergeBoneids(modeldata);
      let mesh = await ob3ModelToThree(this.cache, modeldata);
      mesh.name = name;
      let nullbones = [];
      for (let i = 0; i < Math.max(modeldata.bonecount, modeldata.skincount); i++) {
        nullbones.push(mesh);
      }
      let nullskel = new Skeleton3(nullbones);
      let matUvAnims = [];
      mesh.traverse((node) => {
        if (node instanceof SkinnedMesh3) {
          node.bind(nullskel);
        }
        if (node instanceof Mesh4 && node.material instanceof Material) {
          let uvExt = node.material.userData.gltfExtensions?.RA_materials_uvanim;
          if (uvExt) {
            let mat = node.material;
            let animvec = new Vector22(uvExt.uvAnim[0], uvExt.uvAnim[1]);
            if (mat.map) {
              matUvAnims.push({ tex: mat.map, v: animvec });
            }
            if (mat.normalMap) {
              matUvAnims.push({ tex: mat.normalMap, v: animvec });
            }
            if (mat.emissiveMap) {
              matUvAnims.push({ tex: mat.emissiveMap, v: animvec });
            }
            if (mat.metalnessMap) {
              matUvAnims.push({ tex: mat.metalnessMap, v: animvec });
            }
            if (mat.roughnessMap) {
              matUvAnims.push({ tex: mat.roughnessMap, v: animvec });
            }
          }
        }
      });
      let nullAnim = new AnimationClip3(void 0, void 0, []);
      this.nullAnimPromise.clip = nullAnim;
      this.nullAnimPromise.prom.done(nullAnim);
      this.rootnode.add(mesh);
      this.loaded = { mesh, modeldata, nullAnim, matUvAnims };
      if (this.targetAnimId == -1) {
        this.setAnimation(-1);
      }
      this.onModelLoaded();
      return this.loaded;
    })();
  }
  cleanup() {
    this.listeners = {};
    this.renderscene?.removeSceneElement(this);
    this.skeletonHelper?.removeFromParent();
    this.renderscene = null;
  }
  getSceneElements() {
    return {
      modelnode: this.rootnode,
      updateAnimation: this.updateAnimation
    };
  }
  addToScene(scene) {
    this.renderscene = scene;
    scene.addSceneElement(this);
  }
  onModelLoaded() {
    this.emit("loaded", void 0);
    this.renderscene?.forceFrame();
    this.renderscene?.setCameraLimits();
  }
  updateAnimation(delta, epochtime) {
    this.mixer.update(delta);
    this.loaded?.matUvAnims.forEach((q) => q.tex.offset.copy(q.v).multiplyScalar(epochtime));
  }
  mountAnim(clip) {
    if (!this.loaded) {
      throw new Error("attempting to mount anim before model is loaded");
    }
    if (this.mountedanim == clip) {
      return;
    }
    if (this.loaded.modeldata.bonecount == 0 && this.loaded.modeldata.skincount == 0) {
      return;
    }
    let mesh = this.loaded.mesh;
    if (mesh.animations.indexOf(clip) == -1) {
      mesh.animations.push(clip);
    }
    this.mixer.stopAllAction();
    let action = this.mixer.clipAction(clip, mesh);
    action.play();
    this.mountedanim = clip;
  }
  loadAnimation(animid) {
    if (this.anims[animid]) {
      return this.anims[animid];
    }
    this.anims[animid] = {
      clip: null,
      prom: (async () => {
        let seqfile = await this.cache.engine.getFileById(cacheMajors.sequences, animid);
        let seq = parse.sequences.read(seqfile, this.cache.engine.rawsource);
        let clip;
        if (seq.skeletal_animation) {
          let anim = await parseSkeletalAnimation(this.cache, seq.skeletal_animation);
          clip = anim.clip;
          let loaded = this.loaded ?? await this.model;
          if (this.skeletontype != "full") {
            if (this.skeletontype != "none") {
              throw new Error("wrong skeleton type already mounted to model");
            }
            await mountSkeletalSkeleton(loaded.mesh, this.cache, anim.framebaseid);
            this.skeletontype = "full";
          }
        } else if (seq.frames) {
          let frameanim = await parseAnimationSequence4(this.cache, seq.frames);
          let loaded = this.loaded ?? await this.model;
          if (this.skeletontype != "baked") {
            if (this.skeletontype != "none") {
              throw new Error("wrong skeleton type already mounted to model");
            }
            mountBakedSkeleton(loaded.mesh, loaded.modeldata);
            this.skeletontype = "baked";
          }
          clip = frameanim(loaded.modeldata);
        } else {
          throw new Error("animation has no frames");
        }
        this.anims[animid] = { clip, prom: Promise.resolve(clip) };
        if (!this.loaded?.modeldata) {
          await this.model;
        }
        this.anims[animid].clip = clip;
        return clip;
      })()
    };
    return this.anims[animid];
  }
  async setAnimation(animid) {
    this.targetAnimId = animid;
    const mount = this.loadAnimation(animid);
    return this.mountAnim(mount.clip ?? await mount.prom);
  }
};
__decorateClass([
  boundMethod
], RSModel.prototype, "updateAnimation", 1);
var RSMapChunkGroup = class extends TypedEmitter {
  constructor(cache, rect, extraopts) {
    super();
    this.rootnode = new THREE3.Group();
    this.renderscene = null;
    this.mixer = new AnimationMixer2(this.rootnode);
    this.chunks = [];
    for (let z = rect.z; z < rect.z + rect.zsize; z++) {
      for (let x = rect.x; x < rect.x + rect.xsize; x++) {
        let sub = RSMapChunk.create(cache, x, z, extraopts);
        this.chunks.push(sub);
      }
    }
    Promise.all(this.chunks.map((q) => q.chunkdata)).then((q) => {
      this.emit("loaded", void 0);
    });
  }
  getSceneElements() {
    return this.chunks.map((q) => q.getSceneElements());
  }
  addToScene(scene) {
    this.renderscene = scene;
    scene.addSceneElement(this);
  }
  cleanup() {
    this.listeners = {};
    this.chunks.forEach((q) => q.cleanup());
    this.renderscene?.removeSceneElement(this);
    this.renderscene = null;
  }
};
var RSMapChunk = class _RSMapChunk extends TypedEmitter {
  constructor(cache, preparsed, chunkx, chunkz, opts) {
    super();
    this.loaded = null;
    this.rootnode = new THREE3.Group();
    this.mixer = new AnimationMixer2(this.rootnode);
    this.renderscene = null;
    this.toggles = {};
    this.globalname = "";
    this.cache = cache;
    this.chunkx = chunkx;
    this.chunkz = chunkz;
    this.chunkdata = (async () => {
      this.loaded = await renderMapSquare(cache, preparsed, chunkx, chunkz, opts);
      this.rootnode.add(this.loaded.chunkroot);
      this.onModelLoaded();
      return this.loaded;
    })();
  }
  static defaultopts(extraopts) {
    let opts = { invisibleLayers: true, collision: true, map2d: false, padfloor: true, skybox: false, minimap: false, ...extraopts };
    return opts;
  }
  static create(cache, chunkx, chunkz, extraopts) {
    let opts = this.defaultopts(extraopts);
    let preparsed = parseMapsquare(cache.engine, chunkx, chunkz, opts);
    return new _RSMapChunk(cache, preparsed, chunkx, chunkz, opts);
  }
  //TODO remove
  async testLocImg(loc) {
    if (!this.loaded) {
      throw new Error("not loaded");
    }
    let model = this.loaded?.locRenders.get(loc) ?? [];
    let sections = model.map((q) => q.mesh.cloneSection(q));
    model.map((q) => q.mesh.setSectionHide(q, true));
    let group = new Object3D3();
    group.add(...sections.map((q) => q.mesh));
    group.traverse((q) => q.layers.set(1));
    this.loaded.chunkroot.add(group);
    let cam = this.renderscene.getCurrent2dCamera();
    let img = await this.renderscene.takeMapPicture(cam, 256, 256, false, group);
    group.removeFromParent();
    model.map((q) => q.mesh.setSectionHide(q, false));
    return img;
  }
  cloneLocModel(entry) {
    return entry.map((q) => q.mesh.cloneSection(q));
  }
  replaceLocModel(loc, newmodels) {
    let entry = this.loaded?.locRenders.get(loc) ?? [];
    entry.forEach((q) => q.mesh.setSectionHide(q, true));
    if (!newmodels) {
      this.loaded?.locRenders.delete(loc);
    } else {
      this.loaded?.locRenders.set(loc, newmodels);
      newmodels.forEach((q) => q.mesh.setSectionHide(q, false));
    }
    return entry;
  }
  cleanup() {
    this.listeners = {};
    if (this.globalname) {
      delete globalThis[this.globalname];
      this.globalname = "";
    }
    this.chunkdata.then((q) => q.chunkroot.traverse((obj) => {
      if (obj instanceof Mesh4) {
        obj.geometry.dispose();
      }
    }));
    this.renderscene?.removeSceneElement(this);
    this.renderscene = null;
  }
  async renderSvg(level = 0, wallsonly = false, pxpersquare = 1) {
    let { chunk, grid, chunkSize: chunkSize2, chunkx, chunkz } = await this.chunkdata;
    let rect = { x: chunkx * chunkSize2, z: chunkz * chunkSize2, xsize: chunkSize2, zsize: chunkSize2 };
    return svgfloor(this.cache.engine, grid, chunk?.locs ?? [], rect, level, pxpersquare, wallsonly, false);
  }
  getSceneElements() {
    return {
      modelnode: this.rootnode,
      sky: this.loaded?.sky,
      options: { hideFloor: true }
    };
  }
  addToScene(scene) {
    if (this.renderscene == null && globalThis.debugchunks) {
      for (let i = 0; i < 10; i++) {
        let name = `chunk_${this.chunkx}_${this.chunkz}${i == 0 ? "" : `_${i}`}`;
        if (!globalThis[name]) {
          globalThis[name] = this;
          this.globalname = name;
          break;
        }
      }
    }
    this.renderscene = scene;
    scene.addSceneElement(this);
  }
  onModelLoaded() {
    this.setToggles(this.toggles);
    this.emit("loaded", this.loaded);
    this.emit("changed", void 0);
    this.renderscene?.sceneElementsChanged();
  }
  setToggles(toggles, hideall = false) {
    this.toggles = toggles;
    this.rootnode.traverse((node) => {
      if (node.userData.modelgroup) {
        let newvis = hideall ? false : toggles[node.userData.modelgroup] ?? true;
        node.traverse((child) => {
          if (child instanceof THREE3.Mesh) {
            child.visible = newvis;
          }
        });
      }
    });
  }
};
function serializeAnimset(group) {
  let anims = {};
  let addanim = (name, id) => {
    if (id != -1 && Object.values(anims).indexOf(id) == -1) {
      anims[name] = id;
    }
  };
  anims.none = -1;
  if (group.baseAnims) {
    addanim("default", group.baseAnims.idle);
    addanim("walk", group.baseAnims.walk);
  }
  if (group.run) {
    addanim("run", group.run);
  }
  if (group.idleVariations) {
    let totalchance = group.idleVariations.reduce((a, v) => a + v.probably_chance, 0);
    for (let [i, variation] of group.idleVariations.entries()) {
      addanim(i == 0 ? "default" : `idle${i}_${variation.probably_chance}/${totalchance}`, variation.animid);
    }
  }
  for (let [key, val] of Object.entries(group)) {
    if (typeof val == "number") {
      addanim(key, group[key]);
    }
  }
  return anims;
}

// rsmv/src/clientscript/codewriter.ts
import { boundMethod as boundMethod2 } from "autobind-decorator";

// rsmv/src/cache/openrs2loader.ts
var import_node_fetch2 = __toESM(require_lib3());

// rsmv/src/libs/sqlite3wrap.ts
function sqliteOpenDatabase(filepath, opts) {
  let sqlite = __non_webpack_require__("sqlite3");
  let flags = (opts.write ? sqlite.OPEN_READWRITE : sqlite.OPEN_READONLY) | (opts.create ? sqlite.OPEN_CREATE : 0);
  return new Promise((done, err) => {
    let db = new sqlite.Database(filepath, flags, (e) => e ? err(e) : done(db));
  });
}
function sqlitePrepare(db, query) {
  return new Promise((done, err) => {
    let stmt = db.prepare(query, (e) => e ? err(e) : done(stmt));
  });
}
function sqliteExec(db, query) {
  return new Promise((done, err) => {
    db.exec(query, (e) => e ? err(e) : done());
  });
}
function sqliteRunStatement(statement, args) {
  return new Promise((done, err) => {
    statement.all(args, (e, rows) => e ? err(e) : done(rows));
  });
}

// rsmv/src/cache/fscache.ts
import * as fs from "fs/promises";
import * as path from "path";
var dbpath = "./cache/fscache.sqlite3";
var FileSourceFsCache = class _FileSourceFsCache {
  static tryCreate() {
    if (typeof __non_webpack_require__ == "undefined") {
      return null;
    }
    try {
      __non_webpack_require__("sqlite3");
    } catch {
      return null;
    }
    return new _FileSourceFsCache(dbpath);
  }
  constructor(filename) {
    this.isready = false;
    this.ready = (async () => {
      await fs.mkdir(path.dirname(filename), { recursive: true });
      let database = await sqliteOpenDatabase(filename, { create: true, write: true });
      await sqliteExec(database, `CREATE TABLE IF NOT EXISTS groupcache (major INT, minor INT, crc UNSIGNED INT, file BLOB);`);
      await sqliteExec(database, `CREATE UNIQUE INDEX IF NOT EXISTS mainindex ON groupcache(major,minor,crc)`);
      this.getstatement = await sqlitePrepare(database, `SELECT major, minor, crc, file FROM groupcache WHERE major=? AND minor=? AND crc=?`);
      this.setstatement = await sqlitePrepare(database, `INSERT INTO groupcache(major,minor,crc,file) VALUES (?,?,?,?)`);
      this.isready = true;
    })();
  }
  async addFile(major, minor, crc, file) {
    if (!this.isready) {
      await this.ready;
    }
    console.log("saving", major, minor, crc, "len", file.length);
    sqliteRunStatement(this.setstatement, [major, minor, crc, file]);
  }
  async getFile(major, minor, crc) {
    if (!this.isready) {
      await this.ready;
    }
    let cached = await sqliteRunStatement(this.getstatement, [major, minor, crc]);
    if (cached.length > 1) {
      throw new Error("more than one match for fs cached file");
    }
    if (cached.length == 1) {
      if (!cached[0].file) {
        throw new Error(`file ${major}.${minor} not found (explicitly missing in cache)`);
      }
      return cached[0].file;
    }
    return null;
  }
};

// rsmv/src/cache/openrs2loader.ts
var endpoint = `https://archive.openrs2.org`;
var downloadedBytes = 0;
var validcachelist = null;
var cachelist = null;
function loadOpenrsCachelist() {
  cachelist ??= (0, import_node_fetch2.default)(`${endpoint}/caches.json`).then((q) => q.json());
  return cachelist;
}
function validOpenrs2Caches() {
  validcachelist ??= (async () => {
    const openrs2Blacklist = [
      //some of these might actually be fine
      423,
      //osrs cache wrongly labeled as rs3?
      623,
      //seems to have different builds in it
      693,
      //wrong timestamp?
      621,
      619,
      618,
      620,
      617,
      //wrong timestamp/osrs?
      840,
      //multiple builds
      734,
      736,
      733,
      732,
      731,
      //don't have items index
      20,
      19,
      17,
      13,
      10,
      9,
      8,
      7,
      6,
      5,
      //don't have items index
      2,
      //missing basically everything
      1255,
      //missing files and invalid compression?
      905,
      //missing textures
      1256,
      //missing materials
      1003,
      //missing materials
      638,
      //missing materials
      542,
      //missing models
      463,
      //wrong build number?
      //large gaps in files according to openrs2ids command
      621,
      623,
      620,
      617,
      618,
      619,
      734,
      733,
      20,
      10,
      9,
      8,
      7,
      2,
      666,
      729,
      730,
      728,
      1455,
      //weird clientscript
      312,
      286,
      1420,
      1421,
      1530,
      //missing clientscripts
      //TODO fix these or figure out whats wrong with them
      1480,
      644,
      257,
      //incomplete textures
      1456,
      1665,
      //missing materials
      1479
      //missing items could probably be worked around
    ];
    let allcaches = await loadOpenrsCachelist();
    let checkedcaches = allcaches.filter(
      (q) => q.language == "en" && q.environment == "live" && !openrs2Blacklist.includes(q.id) && q.game == "runescape" && q.timestamp && q.builds.length != 0
    ).sort((a, b) => b.builds[0].major - a.builds[0].major || (b.builds[0].minor ?? 0) - (a.builds[0].minor ?? 0) || +new Date(b.timestamp) - +new Date(a.timestamp));
    return checkedcaches;
  })();
  return validcachelist;
}
function openrs2GetEffectiveBuildnr(cachemeta) {
  let match = cachemeta.builds.find((q) => q.major != 0);
  return match ? match.major : -1;
}
var Openrs2CacheSource = class _Openrs2CacheSource extends DirectCacheFileSource {
  constructor(meta) {
    super(false);
    this.xteaKeysLoaded = false;
    this.xteakeysPromise = null;
    this.meta = meta;
    let buildnr = openrs2GetEffectiveBuildnr(meta);
    if (buildnr != -1) {
      this.buildnr = buildnr;
    } else {
      console.warn("using historic cache for which the build number is not available, treating it as current.");
      this.buildnr = latestBuildNumber;
    }
    this.fscache = FileSourceFsCache.tryCreate();
  }
  static async fromId(cacheid) {
    let caches = await loadOpenrsCachelist();
    let meta = caches.find((q) => q.id == cacheid);
    if (!meta) {
      throw new Error(`cache ${cacheid} not found on openrs`);
    }
    return new _Openrs2CacheSource(meta);
  }
  getCacheMeta() {
    return {
      name: `openrs2:${this.meta.id}`,
      descr: `build: ${this.buildnr}
date: ${new Date(this.meta.timestamp ?? "").toDateString()}
Historic cache loaded from openrs2 cache repository.`,
      timestamp: new Date(this.meta.timestamp ?? 0)
    };
  }
  getBuildNr() {
    return this.buildnr;
  }
  async getCacheIndex(major) {
    if (this.buildnr <= 700 && !this.xteaKeysLoaded && major == cacheMajors.mapsquares) {
      this.xteakeysPromise ??= (async () => {
        this.xteakeys ??= /* @__PURE__ */ new Map();
        let keys = await (0, import_node_fetch2.default)(`${endpoint}/caches/runescape/${this.meta.id}/keys.json`).then((q) => q.json());
        for (let key of keys) {
          let lookupid = key.archive << 23 | key.group;
          this.xteakeys.set(lookupid, new Uint32Array(key.key));
        }
        this.xteaKeysLoaded = true;
        console.log(`loaded ${keys.length} xtea keys`);
      })();
      await this.xteakeysPromise;
    }
    return super.getCacheIndex(major);
  }
  static async getRecentCache(count = 0) {
    let relevantcaches = await validOpenrs2Caches();
    return relevantcaches[count];
  }
  async downloadFile(major, minor) {
    let url;
    if (major == cacheMajors.index && minor == cacheMajors.index || this.getBuildNr() <= lastLegacyBuildnr) {
      url = `${endpoint}/caches/runescape/${this.meta.id}/archives/${major}/groups/${minor}.dat`;
    } else {
      let index = await this.getIndexEntryById(major, minor);
      url = `${endpoint}/caches/runescape/archives/${major}/groups/${minor}/versions/${index.version}/checksums/${index.crc | 0}.dat`;
    }
    const req = await (0, import_node_fetch2.default)(url);
    if (!req.ok) {
      throw new Error(`failed to download cache file ${major}.${minor} from openrs2 ${this.meta.id}, http code: ${req.status}`);
    }
    const buf = await req.arrayBuffer();
    let res = Buffer.from(buf);
    if (Math.floor(downloadedBytes / 1e7) != Math.floor((downloadedBytes + buf.byteLength) / 1e7)) {
      console.info(`loaded ${(downloadedBytes + res.byteLength) / 1e6 | 0} mb from openrs2`);
    }
    downloadedBytes += res.byteLength;
    return res;
  }
  async getFile(major, minor, crc) {
    let cachedfile = null;
    if (this.fscache && typeof crc != "undefined" && crc != 0) {
      cachedfile = await this.fscache.getFile(major, minor, crc);
    } else {
    }
    let rawfile = cachedfile ?? await this.downloadFile(major, minor);
    if (this.fscache && !cachedfile && typeof crc != "undefined" && crc != 0) {
      this.fscache.addFile(major, minor, crc, rawfile);
    }
    if (this.buildnr <= lastLegacyBuildnr) {
      if (major == 0) {
        return rawfile;
      } else {
        return legacyGzip(rawfile);
      }
    } else {
      return decompress(rawfile, this.getXteaKey(major, minor));
    }
  }
};

// rsmv/src/clientscript/callibrator.ts
import * as fs2 from "fs/promises";

// rsmv/src/clientscript/opnames.ts
var rs3opnames = {
  "6": "BRANCH",
  "7": "BRANCH_NOT",
  "8": "BRANCH_EQUALS",
  "9": "BRANCH_LESS_THAN",
  "10": "BRANCH_GREATER_THAN",
  "21": "RETURN",
  "31": "BRANCH_LESS_THAN_OR_EQUALS",
  "32": "BRANCH_GREATER_THAN_OR_EQUALS",
  "33": "PUSH_INT_LOCAL",
  "34": "POP_INT_LOCAL",
  "35": "PUSH_STRING_LOCAL",
  "36": "POP_STRING_LOCAL",
  "37": "JOIN_STRING",
  "40": "GOSUB_WITH_PARAMS",
  "42": "PUSH_VAR",
  "43": "POP_VAR",
  "45": "PUSH_ARRAY_INT",
  "46": "POP_ARRAY_INT",
  "51": "SWITCH",
  "150": "CC_CREATE",
  "152": "CC_DELETEALL",
  "404": "BASECOLOUR",
  "1000": "CC_SETPOSITION",
  "1001": "CC_SETSIZE",
  "1003": "CC_SETHIDE",
  "1101": "CC_SETCOLOUR",
  "1102": "CC_SETFILL",
  "1103": "CC_SETTRANS",
  "1105": "CC_SETGRAPHIC",
  "1106": "CC_SET2DANGLE",
  "1107": "CC_SETTILING",
  "1108": "CC_SETMODEL",
  "1109": "CC_SETMODELANGLE",
  "1110": "CC_SETMODELANIM",
  "1112": "CC_SETTEXT",
  "1113": "CC_SETTEXTFONT",
  "1114": "CC_SETTEXTALIGN",
  "1115": "CC_SETTEXTSHADOW",
  "1118": "CC_SETVFLIP",
  "1119": "CC_SETHFLIP",
  "1211": "CC_SETPLAYERMODEL_SELF",
  "1300": "CC_SETOP",
  "1301": "CC_SETDRAGGABLE",
  "1302": "CC_SETDRAGRENDERBEHAVIOUR",
  "1303": "CC_SETDRAGDEADZONE",
  "1304": "CC_SETDRAGDEADTIME",
  "1305": "CC_SETOPBASE",
  "1400": "CC_SETONCLICK",
  "1401": "CC_SETONHOLD",
  "1402": "CC_SETONRELEASE",
  "1403": "CC_SETONMOUSEOVER",
  "1404": "CC_SETONMOUSELEAVE",
  "1405": "CC_SETONDRAG",
  "1408": "CC_SETONTIMER",
  "1409": "CC_SETONOP",
  "1410": "CC_SETONDRAGCOMPLETE",
  "1428": "CC_SETONVARCTRANSMIT",
  "1500": "CC_GETX",
  "1501": "CC_GETY",
  "1505": "CC_GETLAYER",
  "1702": "CC_GETID",
  "2000": "IF_SETPOSITION",
  "2001": "IF_SETSIZE",
  "2003": "IF_SETHIDE",
  "2005": "IF_SETNOCLICKTHROUGH",
  "2100": "IF_SETSCROLLPOS",
  "2101": "IF_SETCOLOUR",
  "2102": "IF_SETFILL",
  "2103": "IF_SETTRANS",
  "2105": "IF_SETGRAPHIC",
  "2108": "IF_SETMODEL",
  "2109": "IF_SETMODELANGLE",
  "2110": "IF_SETMODELANIM",
  "2112": "IF_SETTEXT",
  "2113": "IF_SETTEXTFONT",
  "2116": "IF_SETOUTLINE",
  "2117": "IF_SETGRAPHICSHADOW",
  "2120": "IF_SETSCROLLSIZE",
  "2123": "IF_SETMODELZOOM",
  "2127": "IF_SETPARAM_INT",
  "2200": "IF_SETOBJECT",
  "2201": "IF_SETNPCHEAD",
  "2205": "IF_SETOBJECT_NONUM",
  "2300": "IF_SETOP",
  "2305": "IF_SETOPBASE",
  "2307": "IF_CLEAROPS",
  "2309": "IF_SETOPCURSOR",
  "2400": "IF_SETONCLICK",
  "2404": "IF_SETONMOUSELEAVE",
  "2406": "IF_SETONTARGETLEAVE",
  "2407": "IF_SETONVARTRANSMIT",
  "2408": "IF_SETONTIMER",
  "2409": "IF_SETONOP",
  "2410": "IF_SETONDRAGCOMPLETE",
  "2412": "IF_SETONMOUSEREPEAT",
  "2414": "IF_SETONINVTRANSMIT",
  "2415": "IF_SETONSTATTRANSMIT",
  "2416": "IF_SETONTARGETENTER",
  "2417": "IF_SETONSCROLLWHEEL",
  "2422": "IF_SETONMISCTRANSMIT",
  "2424": "IF_SETONSUBCHANGE",
  "2426": "IF_SETONCAMFINISHED",
  "2428": "IF_SETONVARCTRANSMIT",
  "2429": "IF_SETONVARCSTRTRANSMIT",
  "2431": "IF_SETONCLANSETTINGSTRANSMIT",
  "2433": "IF_SETONVARCLANTRANSMIT",
  "2500": "IF_GETX",
  "2501": "IF_GETY",
  "2502": "IF_GETWIDTH",
  "2503": "IF_GETHEIGHT",
  "2505": "IF_GETLAYER",
  "2600": "IF_GETSCROLLX",
  "2601": "IF_GETSCROLLY",
  "2602": "IF_GETTEXT",
  "2603": "IF_GETSCROLLWIDTH",
  "2604": "IF_GETSCROLLHEIGHT",
  "2605": "IF_GETMODELZOOM",
  "2606": "IF_GETMODELANGLE_X",
  "2607": "IF_GETMODELANGLE_Z",
  "2608": "IF_GETMODELANGLE_Y",
  "2609": "IF_GETTRANS",
  "2610": "IF_GETMODELXOF",
  "2611": "IF_GETMODELYOF",
  "2612": "IF_GETGRAPHIC",
  "2703": "IF_GETNEXTSUBID",
  "2800": "IF_GETTARGETMASK",
  "3100": "MES",
  "3110": "RESUME_OBJDIALOG",
  "3114": "MES_TYPED",
  "3116": "RESUME_HSLDIALOG",
  "3200": "SOUND_SYNTH",
  "3206": "SOUND_VORBIS_VOLUME",
  "3209": "SOUND_VORBIS_RATE",
  "3300": "CLIENTCLOCK",
  "3301": "INV_GETOBJ",
  "3302": "INV_GETNUM",
  "3303": "INV_TOTAL",
  "3304": "INV_SIZE",
  "3306": "STAT_BASE",
  "3307": "STAT_VISIBLE_XP",
  "3308": "COORD",
  "3309": "COORDX",
  "3310": "COORDY",
  "3311": "COORDZ",
  "3313": "INVOTHER_GETOBJ",
  "3321": "RUNENERGY_VISIBLE",
  "3335": "MAP_LANG",
  "3336": "MOVECOORD",
  "3342": "GET_MOUSEX",
  "3343": "GET_MOUSEY",
  "3408": "ENUM",
  "3411": "ENUM_GETOUTPUTCOUNT",
  "3612": "CLAN_GETCHATCOUNT",
  "3616": "CLAN_GETCHATMINKICK",
  "3618": "CLAN_GETCHATRANK",
  "3620": "CLAN_LEAVECHAT",
  "3753": "ACTIVECLANCHANNEL_GETRANKKICK",
  "3757": "ACTIVECLANCHANNEL_GETUSERRANK",
  "3760": "ACTIVECLANCHANNEL_GETUSERSLOT",
  "4000": "ADD",
  "4001": "SUB",
  "4002": "MULTIPLY",
  "4003": "DIVIDE",
  "4004": "RANDOM",
  "4005": "RANDOMINC",
  "4010": "TESTBIT",
  "4011": "MODULO",
  "4012": "POW",
  "4014": "AND",
  "4016": "MIN",
  "4017": "MAX",
  "4018": "SCALE",
  "4019": "RANDOM_SOUND_PITCH",
  "4020": "HSVTORGB",
  "4101": "APPEND",
  "4103": "LOWERCASE",
  "4107": "COMPARE",
  "4108": "PARAHEIGHT",
  "4117": "STRING_LENGTH",
  "4118": "SUBSTRING",
  "4119": "REMOVETAGS",
  "4121": "STRING_INDEXOF_STRING",
  "4124": "TOSTRING_LOCALISED",
  "4125": "STRINGWIDTH",
  "4200": "OC_NAME",
  "4208": "OC_PARAM",
  "4500": "STRUCT_PARAM",
  "4600": "BAS_GETANIM_READY",
  "5000": "CHAT_GETFILTER_PUBLIC",
  "5001": "CHAT_SETFILTER",
  "5005": "CHAT_GETFILTER_PRIVATE",
  "5016": "CHAT_GETFILTER_TRADE",
  "5020": "CHAT_PLAYERNAME_UNFILTERED",
  "5207": "WORLDMAP_GETMAPNAME",
  "5214": "WORLDMAP_JUMPTOSOURCECOORD",
  "5306": "GETWINDOWMODE",
  "5405": "SPLINE_NEW",
  "5406": "SPLINE_ADDPOINT",
  "5407": "SPLINE_LENGTH",
  "5500": "CAM_MOVETO",
  "5501": "CAM_LOOKAT",
  "5502": "CAM_MOVEALONG",
  "5503": "CAM_RESET",
  "5504": "CAM_FORCEANGLE",
  "5511": "CAM_FOLLOWCOORD",
  "5512": "CAM_SMOOTHRESET",
  "5616": "LOBBY_LEAVELOBBY",
  "5624": "USERFLOWFLAGS",
  "5630": "LOGIN_CANCEL",
  "6300": "DATE_MINUTES",
  "6306": "DATE_MINUTES_FROMRUNEDAY",
  "6509": "WORLDLIST_PINGWORLDS",
  "9001": "PUSH_CONSTANT_STRING",
  "10000": "CAM2_REMOVEALLEFFECTS",
  "10001": "NOTIFICATIONS_OPENSETTINGS",
  "10002": "AUTOSETUP_SETMIN",
  "10003": "CANCEL_INTERFACE_DRAG",
  "10004": "POP_INT_DISCARD",
  "10005": "STEAM_STORESTATS",
  "10006": "RESUME_COUNTDIALOG",
  "10007": "FRIEND_DEL",
  "10008": "INTERFACE_SETPICKINGRADIUS",
  "10009": "UNKNOWN_COMMAND_637",
  "10010": "IF_SENDTOFRONT",
  "10011": "IF_SENDTOBACK",
  "10012": "MAP_PRELOAD",
  "10013": "UNKNOWN_COMMAND_186",
  "10014": "MINIMENU_CLOSE",
  "10015": "UNKNOWN_COMMAND_501",
  "10016": "DEEPLINK_CLEAR_INDEX",
  "10017": "UNKNOWN_COMMAND_722",
  "10018": "CC_PAGEDCAROUSEL_SETDYNAMICPAGECOUNT",
  "10019": "CC_RADIALPROGRESSOVERLAY_SETVALUE",
  "10020": "IF_CLOSESUBCLIENT",
  "10021": "CUTSCENE2D_STOP",
  "10022": "PUSH_VARBIT",
  "10023": "POP_VARBIT",
  "10024": "PUSH_LONG_LOCAL",
  "10025": "CC_SETPAUSETEXT",
  "10026": "CC_CLEAROPS",
  "10027": "CAM2_ADDEFFECT_ZTILT",
  "10028": "MAP_MEMBERS",
  "10029": "CHAT_PLAYERNAME",
  "10030": "CAM2_SETCOLLISIONMODE",
  "10031": "ABORT_DIALOG",
  "10032": "CLIENTOPTION_SET",
  "10033": "INT_TO_LONG",
  "10034": "IF_SETMODELORTHOG",
  "10035": "CAM2_UPDATEEFFECT_ZTILT",
  "10036": "CAM2_SETFIELDOFVIEW",
  "10037": "IF_SETOBJECT_HIGHRES",
  "10038": "IF_RADIALPROGRESSOVERLAY_SETVALUE",
  "10039": "UNKNOWN_COMMAND_130",
  "10040": "OPENURLRAW",
  "10041": "IF_SETMOUSEOVERCURSOR",
  "10042": "VIEWPORT_SETFOV",
  "10043": "CC_SETOPCURSOR",
  "10044": "SHOP_OPENCATEGORIES",
  "10045": "CC_CHECK_SETBUTTONSIZE",
  "10046": "CC_CHECK_SETALIGNMENT",
  "10047": "ENUM_STRING",
  "10048": "IF_HASSUB",
  "10049": "CC_PARAM",
  "10050": "BITCOUNT",
  "10051": "IF_SETONCAMERAUPDATETRANSMIT",
  "10052": "IF_SETONDIALOGABORT",
  "10053": "UNKNOWN_COMMAND_128",
  "10054": "OPENURL",
  "10055": "CC_RADIALPROGRESSOVERLAY_SET",
  "10056": "CC_RADIOGROUP_CLEAROPTIONS",
  "10057": "IF_TRIGGEROP",
  "10058": "IF_CHECK_GET",
  "10059": "IF_CALLONRESIZE",
  "10060": "IF_SET2DANGLE",
  "10061": "GET_COL_TAG",
  "10062": "OC_MINIMENU_COLOUR",
  "10063": "CHAT_LASTUID",
  "10064": "TOSTRING",
  "10065": "DATE_RUNEDAY_FROMDATE",
  "10066": "CC_SETHELD",
  "10067": "LOBBY_ENTERLOBBYREPLY",
  "10068": "IF_HASSUBMODAL",
  "10069": "IF_HASSUBOVERLAY",
  "10070": "OC_COST",
  "10071": "CC_CAROUSEL_SETSELECTED",
  "10072": "CC_CAROUSEL_SETTEXTENTRIES",
  "10073": "CC_CAROUSEL_SETICONENTRIES",
  "10074": "CC_RADIALPROGRESSOVERLAY_START",
  "10075": "OR",
  "10076": "NC_PARAM",
  "10077": "IF_GETHIDE",
  "10078": "DB_GETFIELDCOUNT",
  "10079": "IF_RADIALPROGRESSOVERLAY_SET",
  "10080": "ACTIVECLANSETTINGS_FIND_LISTENED",
  "10081": "ACTIVECLANSETTINGS_FIND_AFFINED",
  "10082": "PLAYER_GROUP_FIND",
  "10083": "IF_SETNPCMODEL",
  "10084": "OPENURL_SHIM",
  "10085": "CC_CHECK_SET",
  "10086": "CC_SETFEEDBACKMODE",
  "10087": "CC_SETENABLED",
  "10088": "STAT_VISIBLE_XP_ACTUAL",
  "10089": "IGNORE_DEL",
  "10090": "CC_INPUT_SETUP",
  "10091": "SHOP_APPLYPENDINGTRANSACTIONS",
  "10092": "IF_GETTOP",
  "10093": "STAT",
  "10094": "DB_GETFIELD",
  "10095": "IF_LIST_ADDENTRY",
  "10096": "IF_RADIALPROGRESSOVERLAY_START",
  "10097": "IF_SETONRESIZE",
  "10098": "CC_SETPARAM",
  "10099": "IF_LIST_GETSELECTED",
  "10100": "DB_FIND_WITH_COUNT",
  "10101": "IF_SETONMOUSEOVER",
  "10102": "IF_FIND",
  "10103": "FEDERATED_LOGIN",
  "10104": "UNKNOWN_COMMAND_461",
  "10105": "CC_SETNOCLICKTHROUGH",
  "10106": "UNKNOWN_COMMAND_702",
  "10107": "CC_SETONMOUSEREPEAT",
  "10108": "DATE_RUNEDAY",
  "10109": "UNKNOWN_COMMAND_181",
  "10110": "MAP_LOADINGSCREEN_SETTRIGGERPERCENT",
  "10111": "IF_SETPAUSETEXT",
  "10112": "DB_FINDNEXT",
  "10113": "DB_FIND",
  "10114": "IF_SETPARAM_STRING",
  "10115": "CC_DELETE",
  "10116": "CC_FIND",
  "10117": "CC_RESUME_PAUSEBUTTON",
  "10118": "CC_SETOUTLINE",
  "10119": "RESUME_STRINGDIALOG",
  "10120": "CLIENTTYPE",
  "10121": "IF_GETPARENTLAYER",
  "10122": "SETDEFAULTCURSORS",
  "10123": "CAM2_GETCONTROLMODE",
  "10124": "URLENCODE",
  "10125": "CHAT_SENDPUBLIC",
  "10126": "CHAT_SETMODE",
  "10127": "CLANFORUMQFC_TOSTRING",
  "10128": "CC_BUTTON_SETTOGGLED",
  "10129": "CC_BUTTON_SETCANTOGGLE",
  "10130": "PLAYERCOUNTRY",
  "10131": "WORLDMAP_GETCONFIGORIGIN",
  "10132": "CC_PAGEDLAYER_SETPAGELABELS",
  "10133": "CC_PAGEDLAYER_SETDYNAMICPAGECOUNT",
  "10134": "CC_PAGEDLAYER_SETPAGEICONS",
  "10135": "UNKNOWN_COMMAND_502",
  "10136": "CLANPROFILE_FIND",
  "10137": "CC_SCROLLBAR_SETUP",
  "10138": "CC_SCROLLBAR_SETVISIBLE",
  "10139": "CLIENTOPTION_GET",
  "10140": "KEYHELD_ALT",
  "10141": "IF_OPENSUBCLIENT",
  "10142": "HIGHLIGHT_SET_CATEGORY_COLOUR",
  "10143": "HIGHLIGHT_SET_CATEGORY_MODE",
  "10144": "OS_PHYSICALMEMORYSIZE",
  "10145": "CC_SETONVARTRANSMIT",
  "10146": "PLAYERMEMBER",
  "10147": "INV_TOTALCAT",
  "10148": "ACTIVECLANCHANNEL_FIND_AFFINED",
  "10149": "WORLDMAP_ISLOADED",
  "10150": "CC_FINDBYCATEGORY",
  "10151": "IF_CLOSE",
  "10152": "IF_SETENABLED",
  "10153": "LONG_BRANCH_EQUALS",
  "10154": "ENUM_GETREVERSEINDEX",
  "10155": "INV_GETVAR",
  "10156": "DETAIL_LOGINVOL",
  "10157": "DETAIL_SPEECHVOL",
  "10158": "DETAIL_BGSOUNDVOL",
  "10159": "DETAIL_MUSICVOL",
  "10160": "DETAIL_SOUNDVOL",
  "10161": "CC_DRAGPICKUP",
  "10162": "CC_GETHEIGHT",
  "10163": "WORLDLIST_FETCH",
  "10164": "UNKNOWN_COMMAND_474",
  "10165": "CAM2_SETPOSITIONANGULARINTERPOLATION",
  "10166": "CAM2_SETLINEARMOVEMENTMODE",
  "10167": "IF_GET2DANGLE",
  "10168": "CREATE_SUGGEST_NAME_REQUEST",
  "10169": "GET_OBJ_BOUNDING_BOX",
  "10170": "GET_OBJ_SCREEN_POSITION",
  "10171": "GET_OBJ_OVERLAY_HEIGHT",
  "10172": "GET_ENTITY_BOUNDING_BOX",
  "10173": "GET_ENTITY_SCREEN_POSITION",
  "10174": "GET_ENTITY_OVERLAY_HEIGHT",
  "10175": "GET_LOC_BOUNDING_BOX",
  "10176": "GET_LOC_SCREEN_POSITION",
  "10177": "GET_LOC_OVERLAY_HEIGHT",
  "10178": "OC_ALLOWSPLACEHOLDER",
  "10179": "USERDETAIL_DOB",
  "10180": "STAFFMODLEVEL",
  "10181": "NOTIFICATIONS_INIT",
  "10182": "CC_PAGEDCAROUSEL_SETSELECTED",
  "10183": "CC_PAGEDLAYER_SETACTIVEPAGE",
  "10184": "SOUND_GROUP_STOP",
  "10185": "IF_BUTTON_SETTOGGLED",
  "10186": "LOBBY_ENTERGAMEREPLY",
  "10187": "IF_SETRETEX",
  "10188": "ACTIVECLANCHANNEL_FIND_LISTENED",
  "10189": "UNKNOWN_COMMAND_131",
  "10190": "LOGIN_REPLY",
  "10191": "CC_CREATECHILD",
  "10192": "MEC_PARAM",
  "10193": "IF_SETOPKEYIGNOREHELD",
  "10194": "IF_SETOPKEY",
  "10195": "ACHIEVEMENT_FINDGRACED",
  "10196": "IF_SETASPECT",
  "10197": "IF_SETONBUTTONCLICK",
  "10198": "CAM2_SETDEPTHPLANES",
  "10199": "INV_FREESPACE",
  "10200": "CC_SETPARAM_INT",
  "10201": "CC_GETTEXT",
  "10202": "CC_GETWIDTH",
  "10203": "CC_CRMVIEW_GETINT",
  "10204": "CC_CRMVIEW_CONTAINS",
  "10205": "CC_SETNPCHEAD",
  "10206": "TARGETMODE_CANCEL",
  "10207": "TARGETMODE_ACTIVE",
  "10208": "WORLDLIST_SPECIFIC_THISWORLD",
  "10209": "PLATFORMTYPE",
  "10210": "MAP_WORLD",
  "10211": "HAS_NXT",
  "10212": "FRIEND_GETWORLD",
  "10213": "CLAN_GETCHATUSERWORLD",
  "10214": "UNKNOWN_COMMAND_129",
  "10215": "OS_DRIVER_VENDOR",
  "10216": "SHOP_PURCHASEITEM",
  "10217": "CC_CLEARSCRIPTHOOKS",
  "10218": "INV_TOTALPARAM",
  "10219": "WORLDMAP_DISABLEELEMENTCATEGORY",
  "10220": "IF_CHECK_SET",
  "10221": "VIEWPORT_CLAMPFOV",
  "10222": "VIEWPORT_SETZOOM",
  "10223": "IF_SETONFRIENDTRANSMIT",
  "10224": "CC_RADIOGROUP_SETOPTIONS",
  "10225": "CC_RADIOGROUP_SETSELECTIONLIMITS",
  "10226": "RUNWEIGHT_VISIBLE",
  "10227": "STEAM_SETACHIVEMENT",
  "10228": "IF_SETONCLANCHANNELTRANSMIT",
  "10229": "IF_SETONCLANTRANSMIT",
  "10230": "UNKNOWN_COMMAND_499",
  "10231": "UNKNOWN_COMMAND_500",
  "10232": "SETBIT",
  "10233": "CLEARBIT",
  "10234": "IF_DELETEALLNESTED",
  "10235": "GENDER",
  "10236": "ACHIEVEMENT_FINDCATEGORY",
  "10237": "POP_LONG_LOCAL",
  "10238": "ADD_LONG",
  "10239": "BASEIDKIT",
  "10240": "ENUM_GETREVERSECOUNT",
  "10241": "QUEST_GETDIFFICULTY",
  "10242": "IF_SETMODELLIGHTING",
  "10243": "OC_IOP",
  "10244": "ENUM_HASOUTPUT",
  "10245": "QUEST_GETNAME",
  "10246": "ACHIEVEMENT_FINDSUBCAT",
  "10247": "IF_SET_GAMESCREEN_ENABLED",
  "10248": "CC_GETINVCOUNT",
  "10249": "OC_UNCERT",
  "10250": "SEQLENGTH",
  "10251": "PARAWIDTH",
  "10252": "CC_SETSCROLLPOS",
  "10253": "OC_WEARPOS",
  "10254": "NOTIFICATIONS_SENDLOCAL",
  "10255": "IF_SETONRELEASE",
  "10256": "RESUME_CLANFORUMQFCDIALOG",
  "10257": "UNKNOWN_COMMAND_733",
  "10258": "IF_SETMAXLINES",
  "10259": "SHOW_SOFTWARE_LICENSE",
  "10260": "IF_CREATENESTED",
  "10261": "IF_SETTEXTALIGN",
  "10262": "QUEST_PARAM",
  "10263": "TEXT_SWITCH",
  "10264": "CREATE_NAME_AVAILABLEREQUEST",
  "10265": "IF_SETONKEY",
  "10266": "LOGIN_RESETREPLY",
  "10267": "LOGIN_INPROGRESS",
  "10268": "CC_SLIDER_SETUPENUM",
  "10269": "CC_SLIDER_SETUP",
  "10270": "IGNORE_TEST",
  "10271": "ACHIEVEMENT_ACHIEVEMENT_REQ_COUNT",
  "10272": "ACHIEVEMENT_IS_CHECKLIST",
  "10273": "CAM2_GETPOSITIONENTITY_ANGLEOFFSETS",
  "10274": "CAM2_GETPOSITIONMODE",
  "10275": "DATE_RUNEDAY_TODATE",
  "10276": "REBOOTTIMER",
  "10277": "CC_SETMAXLINES",
  "10278": "UNKNOWN_COMMAND_183",
  "10279": "WORLDMAP_DISABLETEXTSIZE",
  "10280": "WORLDMAP_DISABLETYPE",
  "10281": "UNKNOWN_COMMAND_152",
  "10282": "SETWALKMARKER",
  "10283": "IF_RESUME_PAUSEBUTTON",
  "10284": "CAM2_SETPOSITIONENTITY_NPC",
  "10285": "CAM2_SETLOOKATENTITY_NPC",
  "10286": "CLAN_GETCHATDISPLAYNAME",
  "10287": "FRIEND_PLATFORM",
  "10288": "CC_SETONCLICKREPEAT",
  "10289": "CC_GETGRAPHIC",
  "10290": "IF_SETDRAGGABLE",
  "10291": "CC_SETPARAM_STRING",
  "10292": "IF_SETPLAYERMODEL_SELF",
  "10293": "FEDERATED_LOGIN_STATUS",
  "10294": "SSO_AVAILABLE",
  "10295": "CAM2_ADDEFFECT_SHAKE",
  "10296": "STAT_BASE_ACTUAL",
  "10297": "CC_GETCOLOUR",
  "10298": "IF_CREATECHILD",
  "10299": "UNKNOWN_COMMAND_187",
  "10300": "STOCKMARKET_ISOFFEREMPTY",
  "10301": "CC_SETMOUSEOVERCURSOR",
  "10302": "PLAYER_GROUP_MEMBER_GET_STATUS",
  "10303": "IF_SETRECOL",
  "10304": "IF_GRID_SETLAYOUTPARAMS",
  "10305": "USERDETAIL_QUICKCHAT",
  "10306": "DETAILGET_LOGINVOL",
  "10307": "DETAILGET_SPEECHVOL",
  "10308": "DETAILGET_BGSOUNDVOL",
  "10309": "DETAILGET_MUSICVOL",
  "10310": "DETAILGET_SOUNDVOL",
  "10311": "LOBBY_ENTERGAME",
  "10312": "ACTIVECLANSETTINGS_GETAFFINEDCOUNT",
  "10313": "CC_GETINVOBJECT",
  "10314": "OC_MEMBERS",
  "10315": "CC_SETOBJECT_HIGHRES",
  "10316": "SHOP_REQUESTDATA",
  "10317": "IF_GETFONTMETRICS",
  "10318": "CC_RADIOGROUP_SETOPTIONSELECTED",
  "10319": "AUTOSETUP_GETLEVEL",
  "10320": "CC_GETHIDE",
  "10321": "LONG_BRANCH_GREATER_THAN",
  "10322": "SUB_LONG",
  "10323": "IF_GETNEXTCATEGORYSUBID",
  "10324": "UNKNOWN_COMMAND_729",
  "10325": "RESEND_UID_PASSPORT_REQUEST",
  "10326": "CC_GETMODELZOOM",
  "10327": "CC_GETMODELANGLE_Z",
  "10328": "CC_GETMODELANGLE_Y",
  "10329": "CC_GETMODELANGLE_X",
  "10330": "CC_GETMODELYOF",
  "10331": "CC_GETMODELXOF",
  "10332": "MINIMENUOPEN",
  "10333": "IF_SETDRAGDEADTIME",
  "10334": "IF_SETDRAGDEADZONE",
  "10335": "ACTIVECLANCHANNEL_GETUSERWORLD",
  "10336": "CC_GETDYNAMICLAYER",
  "10337": "CC_DELETEALLNESTED",
  "10338": "CC_GETOPBASE",
  "10339": "MARKETING_INITATTRIBUTION",
  "10340": "MARKETING_INITANALYTICS",
  "10341": "OC_HASVAROBJ",
  "10342": "CLAN_JOINCHAT",
  "10343": "SHOP_PURCHASEITEMSTATUS",
  "10344": "IF_SETONHORIZONTALSWIPE",
  "10345": "IF_LIST_SETDROPDOWNNUMENTRIES",
  "10346": "STYLESHEET_GET_VALUE",
  "10347": "IF_GETSTYLESHEET",
  "10348": "IF_LIST_SETSELECTIONLIMIT",
  "10349": "LONG_BRANCH_GREATER_THAN_OR_EQUALS",
  "10350": "INV_STOCKBASE",
  "10351": "ACHIEVEMENT_SUBCAT",
  "10352": "ACHIEVEMENT_CATEGORY",
  "10353": "CC_SETCHILDSPACING",
  "10354": "CC_PANEL_SETISVERTICAL",
  "10355": "FULLSCREEN_GETMODE",
  "10356": "OC_CATEGORY",
  "10357": "CC_SETOPTKEYIGNOREHELD",
  "10358": "CC_SETOPTKEY",
  "10359": "IF_SETONVERTICALSWIPE",
  "10360": "POP_STRING_DISCARD",
  "10361": "IF_SETONPLAYERGROUPTRANSMIT",
  "10362": "QUIT",
  "10363": "DB_GETROWTABLE",
  "10364": "UNKNOWN_COMMAND_735",
  "10365": "VIDEO_ADVERT_FORCE_REMOVE",
  "10366": "CC_SETOBJECT_ALWAYSNUM",
  "10367": "CC_SETOBJECT_NONUM",
  "10368": "CC_SETOBJECT",
  "10369": "APPLET_HASFOCUS",
  "10370": "CAM2_SETPOSITIONPOINTCOLLISION",
  "10371": "MULTIPLY_LONG",
  "10372": "CC_LIST_CLEARSELECTION",
  "10373": "IF_SETVFLIP",
  "10374": "IF_GETMODEL",
  "10375": "LOBBY_ENTERLOBBY_SSO",
  "10376": "IF_SETONHOOK46",
  "10377": "CC_CRMVIEW_GETSTRING",
  "10378": "CC_GETTRANS",
  "10379": "CC_GRID_SETLAYOUTPARAMS",
  "10380": "UNKNOWN_COMMAND_473",
  "10381": "UNKNOWN_COMMAND_182",
  "10382": "UNKNOWN_COMMAND_173",
  "10383": "CC_SETOPTKEYRATE",
  "10384": "CC_COMBO_CLEARENTRIES",
  "10385": "UNKNOWN_COMMAND_737",
  "10386": "WORLDMAP_CLOSEMAP",
  "10387": "IF_CLEARSCRIPTHOOKS",
  "10388": "IF_SETONDRAG",
  "10389": "MAX_LONG",
  "10390": "FORMATMINIMENU",
  "10391": "IF_LIST_SETENTRIES",
  "10392": "CC_SETONDROPDOWNSELECT",
  "10393": "SCALE_LONG",
  "10394": "WORLDLIST_SWITCH",
  "10395": "COS_DEG",
  "10396": "SIN_DEG",
  "10397": "UI_GETDYNID",
  "10398": "UI_GETCATEGORY",
  "10399": "COORDZ_FINE",
  "10400": "COORDX_FINE",
  "10401": "MOVECOORD_FINE",
  "10402": "COORDY_FINE",
  "10403": "COORD_GRIDTOFINE",
  "10404": "UNKNOWN_COMMAND_734",
  "10405": "UNKNOWN_COMMAND_738",
  "10406": "IF_SETTEXTANTIMACRO",
  "10407": "CC_GETTARGETMASK",
  "10408": "PLAYER_GROUP_GET_OWNER_SLOT",
  "10409": "CC_NPC_SETCUSTOMRETEX",
  "10410": "SETBIT_RANGE_TOINT",
  "10411": "LONG_BRANCH_LESS_THAN",
  "10412": "DIVIDE_LONG",
  "10413": "IGNORE_ADD_TEMP",
  "10414": "FRIEND_TEST",
  "10415": "COMLEVEL_ACTIVE",
  "10416": "UNKNOWN_COMMAND_126",
  "10417": "TTV_LIVESTREAMS_UPDATE",
  "10418": "UNKNOWN_COMMAND_120",
  "10419": "FRIEND_ADD",
  "10420": "SSO_LOGOUT",
  "10421": "DATE_YEAR",
  "10422": "OC_CERT",
  "10423": "IF_SETSUBTRACTINSETS",
  "10424": "WORLDMAP_GETZOOM",
  "10425": "WORLDMAP_SETZOOM",
  "10426": "PLAYER_GROUP_MEMBER_GET_RANK",
  "10427": "PLAYER_GROUP_MEMBER_IS_OWNER",
  "10428": "DEEPLINK_GET",
  "10429": "DEEPLINK_COUNT",
  "10430": "QUEST_FINISHED",
  "10431": "IF_GETENABLED",
  "10432": "CC_TRIGGEROP",
  "10433": "UNPACK_LONG",
  "10434": "SSO_DISPLAYNAME",
  "10435": "CC_GETPARENTLAYER",
  "10436": "IGNORE_ADD",
  "10437": "CC_GETFONTMETRICS",
  "10438": "CC_SETSCROLLSIZE",
  "10439": "CAM2_SETPOSITIONPOINT_POINT",
  "10440": "CAM2_SETLOOKATPOINT_POINT",
  "10441": "ESCAPE",
  "10442": "CAM2_SETLOOKATENTITY_PLAYER",
  "10443": "CAM2_SETPOSITIONMODE",
  "10444": "CAM2_SETLOOKATMODE",
  "10445": "CC_SETONBUTTONCLICK",
  "10446": "WINDOW_GETINSETS",
  "10447": "NOTIFICATIONS_CANCELLOCAL",
  "10448": "ACTIVECLANSETTINGS_GETCLANNAME",
  "10449": "LONG_BRANCH_NOT",
  "10450": "CC_SETMODELLIGHTING",
  "10451": "CC_SETSTYLESHEET",
  "10452": "DB_LISTALL",
  "10453": "CAM_GETANGLE_YA",
  "10454": "CAM_GETANGLE_XA",
  "10455": "PLAYERMODLEVEL",
  "10456": "PLAYERMOD",
  "10457": "CC_SETASPECT",
  "10458": "CC_GETGRAPHICDIMENSIONS",
  "10459": "CC_GETSCROLLWIDTH",
  "10460": "CC_GETSCROLLX",
  "10461": "VIEWPORT_GETZOOM",
  "10462": "IF_SETONPLAYERGROUPVARPTRANSMIT",
  "10463": "IF_NPC_SETCUSTOMRETEX",
  "10464": "IF_NPC_SETCUSTOMHEADMODEL",
  "10465": "IF_SETONHORIZONTALPINCH",
  "10466": "IF_SETONVERTICALPINCH",
  "10467": "IF_SETPINCHFLAGS",
  "10468": "IF_SETPINCHDEADZONE",
  "10469": "CHATPHRASE_GETDYNAMICCOMMANDCOUNT",
  "10470": "IF_SETONSTOCKTRANSMIT",
  "10471": "IGNORE_SETNOTES",
  "10472": "IGNORE_GETNAME",
  "10473": "FRIEND_SETNOTES",
  "10474": "FRIEND_GETNAME",
  "10475": "CC_SETSWIPEDEADZONE",
  "10476": "CC_SETSWIPEDEADTIME",
  "10477": "CC_SETSWIPEUNKNOWN2",
  "10478": "CC_SETSWIPEUNKNOWN1",
  "10479": "CC_SETSWIPEFLAGS",
  "10480": "CC_GETOP",
  "10481": "FRIEND_SETRANK",
  "10482": "STRING_INDEXOF_CHAR",
  "10483": "STYLESHEET_GET_PARENT_ID",
  "10484": "STYLESHEET_HAS_VALUE",
  "10485": "WORLDLIST_SPECIFIC",
  "10486": "IF_SETONCHATTRANSMIT",
  "10487": "OC_WEARPOS2",
  "10488": "WORLDMAP_JUMPTODISPLAYCOORD",
  "10489": "HAS_HTML5",
  "10490": "STOCKMARKET_ISOFFERFINISHED",
  "10491": "LONG_BRANCH_LESS_THAN_OR_EQUALS",
  "10492": "CC_CALLONRESIZE",
  "10493": "FRIEND_GETSLOTFROMNAME",
  "10494": "GETBIT_RANGE",
  "10495": "CC_SETOPKEYIGNOREHELD",
  "10496": "CC_SETOPKEY",
  "10497": "UNKNOWN_COMMAND_455",
  "10498": "IF_SETOBJECT_ALWAYSNUM",
  "10499": "CC_GET2DANGLE",
  "10500": "OC_STACKABLE",
  "10501": "ACHIEVEMENT_REQSTATE",
  "10502": "CC_SENDTOFRONT",
  "10503": "TTV_LIBRARY_REQUEST",
  "10504": "CAM2_GETPOSITIONPOINT_POINT",
  "10505": "ACTIVECLANSETTINGS_GETBANNEDDISPLAYNAME",
  "10506": "INVPOW",
  "10507": "GETCLIPBOARD",
  "10508": "QUEST_STATREQ_LEVEL",
  "10509": "QUEST_STATREQ_STAT",
  "10510": "QUEST_STATREQ_COUNT",
  "10511": "CC_SETOPKEYRATE",
  "10512": "IF_SETTEXTSHADOW",
  "10513": "IF_LIST_SETISSELECTED",
  "10514": "MARKETING_SENDATTRIBUTIONEVENT",
  "10515": "MARKETING_SENDANALYTICSEVENT",
  "10516": "QUEST_POINTSREQ",
  "10517": "CC_SETONVARCSTRTRANSMIT",
  "10518": "CC_SETONINVTRANSMIT",
  "10519": "TOSTRING_LOCALISED_LONG",
  "10520": "ACHIEVEMENT_ALLPREREQMET",
  "10521": "QUEST_STARTED",
  "10522": "UNKNOWN_COMMAND_175",
  "10523": "IF_SETONGAMEPADBUTTONHELD",
  "10524": "IF_SETONGAMEPADTRIGGER",
  "10525": "IF_SETONGAMEPADAXIS",
  "10526": "IF_SETONGAMEPADBUTTON",
  "10527": "ABS",
  "10528": "KEYHELD_SHIFT",
  "10529": "KEYHELD_CTRL",
  "10530": "CC_LIST_SETENTRYICON",
  "10531": "CC_LIST_ADDENTRY",
  "10532": "ACHIEVEMENT_FINDNEXT",
  "10533": "CHATPHRASE_GETAUTORESPONSECOUNT",
  "10534": "TTV_WEBCAM_GETDEVICE_BYUNIQUENAME",
  "10535": "MAP_LOADEDPERCENT",
  "10536": "CAM2_ISENABLED",
  "10537": "CAM2_SETFIELDOFVIEWSCREEN",
  "10538": "VIEWPORT_GETEFFECTIVESIZE",
  "10539": "SETHARDCODEDOPCURSORS",
  "10540": "QUEST_GETSORTNAME",
  "10541": "CC_SENDTOBACK",
  "10542": "INVOTHER_TOTAL",
  "10543": "IF_GET_GAMESCREEN",
  "10544": "CC_SETNPCMODEL",
  "10545": "CREATE_SUGGEST_NAME_REPLY",
  "10546": "ACTIVECLANSETTINGS_GETAFFINEDRANK",
  "10547": "ACTIVECLANSETTINGS_GETAFFINEDSLOT",
  "10548": "WORLDMAP_3DVIEW_SETLODDISTANCE",
  "10549": "PLAYER_GROUP_MEMBER_GET_DISPLAYNAME",
  "10550": "PLAYER_GROUP_MEMBER_COUNT",
  "10551": "IF_SETTARGETVERB",
  "10552": "IF_SETOPKEYRATE",
  "10553": "DETAILGET_INTERFACESCALE",
  "10554": "UNKNOWN_COMMAND_458",
  "10555": "TTV_STREAM_GETVIEWERS",
  "10556": "TTV_STREAM_GETSTATE",
  "10557": "IF_SETMODELTINT",
  "10558": "MAP_LOADINGSCREEN_ISOPEN",
  "10559": "SOUND_SPEECH_VOLUME",
  "10560": "OC_ICURSOR",
  "10561": "ACHIEVEMENT_GETNAME",
  "10562": "OPENSTORE",
  "10563": "CREATE_REPLY",
  "10564": "TELEMETRY_GET_GRID_VALUE",
  "10565": "TELEMETRY_GET_COLUMN_INDEX",
  "10566": "TELEMETRY_GET_ROW_INDEX",
  "10567": "TELEMETRY_GET_GROUP_INDEX",
  "10568": "ACHIEVEMENT_GETREWARD",
  "10569": "DEFINE_ARRAY",
  "10570": "STOCKMARKET_GETOFFERITEM",
  "10571": "CHAT_CLEAR",
  "10572": "CREATE_NAME_VALIDATE_REPLY",
  "10573": "OC_DESC",
  "10574": "PUSH_CONSTANT_INT",
  "10575": "IF_GETCOLOUR",
  "10576": "FORMAT_DATETIME_FROM_MINUTES",
  "10577": "CAM2_SETPOSITIONENTITY_PLAYER",
  "10578": "TTV_LOGIN",
  "10579": "RESUME_COUNTDIALOG_LONG",
  "10580": "CC_RADIALPROGRESSOVERLAY_GETPROGRESS",
  "10581": "TTV_WEBCAM_STOP",
  "10582": "OPENURL_NOLOGIN",
  "10583": "IF_GETINVCOUNT",
  "10584": "IF_GETINVOBJECT",
  "10585": "INVOTHER_GETVAR",
  "10586": "FORCE_INTERFACE_DRAG",
  "10587": "CC_SETMODELZOOM",
  "10588": "WORLDMAP_GETCONFIGZOOM",
  "10589": "WORLDMAP_SETMAP",
  "10590": "WORLDMAP_GETCURRENTMAP",
  "10591": "CC_SETONSCROLLWHEEL",
  "10592": "TTV_WEBCAM_START",
  "10593": "ACHIEVEMENT_TOTAL_RUNESCORE",
  "10594": "QUEST_QUESTREQ",
  "10595": "QUEST_QUESTREQ_COUNT",
  "10596": "CHAT_SENDABUSEREPORT",
  "10597": "RESUME_NAMEDIALOG",
  "10598": "USERDETAIL_LOBBY_PLAYAGE",
  "10599": "STOCKMARKET_GETOFFERPRICE",
  "10600": "STOCKMARKET_GETOFFERCOUNT",
  "10601": "NOTIFICATIONS_ISLOCALSCHEDULED",
  "10602": "UNKNOWN_COMMAND_480",
  "10603": "IF_GETOP",
  "10604": "AUTOSETUP_SETCUSTOM",
  "10605": "AUTOSETUP_SETULTRA",
  "10606": "AUTOSETUP_SETHIGH",
  "10607": "AUTOSETUP_SETMEDIUM",
  "10608": "AUTOSETUP_SETLOW",
  "10609": "SHOP_REQUESTDATASTATUS",
  "10610": "FPS_STATS",
  "10611": "APPEND_NUM",
  "10612": "WORLDMAP_SETMAP_COORD_OVERRIDE",
  "10613": "WORLDMAP_GETMAP",
  "10614": "MAP_ISOWNER",
  "10615": "TTV_LOGOUT",
  "10616": "ACTIVECHATPHRASE_SETDYNAMICINT",
  "10617": "ACTIVECHATPHRASE_SETDYNAMICOBJ",
  "10618": "IF_SETONCLICKREPEAT",
  "10619": "SHADER_PRELOAD_THROTTLE",
  "10620": "CC_LIST_SETDROPDOWNNUMENTRIES",
  "10621": "IF_GETGRAPHICDIMENSIONS",
  "10622": "MIN_LONG",
  "10623": "DATE_ISLEAPYEAR",
  "10624": "CC_ANIM_PLAY",
  "10625": "CC_ANIM_KILL",
  "10626": "CLAN_GETCHATUSERRANK",
  "10627": "CLAN_ISSELF",
  "10628": "CC_GETSCROLLY",
  "10629": "CC_SETLINKPLAYERGROUP",
  "10630": "CC_SETLINKACTIVECLANCHANNEL",
  "10631": "CC_SETLINKFRIEND",
  "10632": "CC_RESETLINKPLAYER",
  "10633": "TTV_STREAM_GETQUALITY",
  "10634": "APPEND_CHAR",
  "10635": "CHAR_ISPRINTABLE",
  "10636": "ACHIEVEMENT_SPRITE",
  "10637": "CAM2_GETLOOKATMODE",
  "10638": "IF_GETCHARINDEXATPOS",
  "10639": "MAP_QUICKCHAT",
  "10640": "CC_CRMVIEW_SETONUPDATED",
  "10641": "CC_CRMVIEW_SETAVAILABLEFONTS",
  "10642": "CC_CRMVIEW_INIT",
  "10643": "ACHIEVEMENT_GETPROGRESS",
  "10644": "UNKNOWN_COMMAND_727",
  "10645": "IF_GRID_GETCELLHEIGHT",
  "10646": "IF_GETCHILDSPACING",
  "10647": "IF_GRID_GETNUMCOLUMNS",
  "10648": "IF_GRID_GETNUMROWS",
  "10649": "UNKNOWN_COMMAND_732",
  "10650": "NOTIFICATIONS_SENDGROUPEDLOCAL",
  "10651": "TTV_LIVESTREAMS_GETSTREAM_NEXT",
  "10652": "TTV_LIVESTREAMS_GETSTREAM_START",
  "10653": "SHOP_GETPRODUCTDETAILS",
  "10654": "SHOP_GETPRODUCTCOUNT",
  "10655": "SHOP_GETINDEXFORCATEGORYID",
  "10656": "CAM2_SETSPRINGPROPERTIES",
  "10657": "AUTOSETUP_DOSETUPSTATUS",
  "10658": "CC_GRID_GETNUMCOLUMNS",
  "10659": "CC_GRID_GETNUMROWS",
  "10660": "USERDETAIL_LOBBY_MEMBERSHIP",
  "10661": "BATTERY_ISCHARGING",
  "10662": "BATTERY_GETLEVELPERCENT",
  "10663": "UNKNOWN_COMMAND_477",
  "10664": "CHATPHRASE_GETDYNAMICCOMMAND",
  "10665": "UNKNOWN_COMMAND_725",
  "10666": "ACHIEVEMENT_GETDESC",
  "10667": "GET_MOUSEBUTTONS",
  "10668": "FULLSCREEN_ENTER",
  "10669": "FULLSCREEN_MODECOUNT",
  "10670": "SETDEFAULTWINDOWMODE",
  "10671": "SETWINDOWMODE",
  "10672": "CC_COMBO_SELECT",
  "10673": "CC_COMBO_ADDENTRY",
  "10674": "CC_COMBO_SETENTRIES",
  "10675": "CC_LIST_SETISSELECTED",
  "10676": "CC_LIST_SETENTRIES",
  "10677": "WORLDMAP_GETDISPLAYPOSITION",
  "10678": "UNKNOWN_COMMAND_180",
  "10679": "WORLDMAP_GETDISPLAYCOORD",
  "10680": "ADDPERCENT",
  "10681": "ARRAY_SORT",
  "10682": "ACTIVECLANSETTINGS_GETAFFINEDDISPLAYNAME",
  "10683": "ACTIVECLANSETTINGS_GETCURRENTOWNER_SLOT",
  "10684": "ACTIVECLANCHANNEL_GETRANKTALK",
  "10685": "ACTIVECLANSETTINGS_GETAFFINEDEXTRAINFO",
  "10686": "TOSTRING_LONG",
  "10687": "MODULO_LONG",
  "10688": "ACTIVECLANCHANNEL_GETCLANNAME",
  "10689": "CC_SETTARGETVERB",
  "10690": "USERDETAIL_LOBBY_UNREADMESSAGES",
  "10691": "ACTIVECHATPHRASE_SEND",
  "10692": "ACTIVECHATPHRASE_PREPARE",
  "10693": "ACTIVECLANCHANNEL_KICKUSER",
  "10694": "CHAT_GETHISTORY_BYUID",
  "10695": "UNKNOWN_COMMAND_127",
  "10696": "ACHIEVEMENT_GETGRACEDCOUNT",
  "10697": "IF_SETDRAGRENDERBEHAVIOUR",
  "10698": "GETDEFAULTWINDOWMODE",
  "10699": "CHAT_GETNEXTUID",
  "10700": "IGNORE_GETNOTES",
  "10701": "FRIEND_GETNOTES",
  "10702": "IF_NPC_SETCUSTOMBODYMODEL",
  "10703": "USERDETAIL_LOBBY_EMAILSTATUS",
  "10704": "PARALINE",
  "10705": "CAM2_SETLOOKATORIENTATION_XROTATION",
  "10706": "CAM2_SETLOOKATORIENTATION_YROTATION",
  "10707": "CAM2_SETLOOKATORIENTATION_ZMOVEMENT",
  "10708": "CAM2_SETLOOKATORIENTATION_XMOVEMENT",
  "10709": "DB_FIND_REFINE",
  "10710": "LOBBY_ENTERLOBBY",
  "10711": "INTERPOLATE",
  "10712": "PRELOAD_PERCENT",
  "10713": "CC_GETSCROLLHEIGHT",
  "10714": "CC_TEXT_SETTRANS",
  "10715": "TTV_STREAM_STOP",
  "10716": "QUEST_GETMEMBERS",
  "10717": "CAM_DEC_X",
  "10718": "CAM_INC_X",
  "10719": "CAM_INC_Y",
  "10720": "CAM_DEC_Y",
  "10721": "TTV_STREAM_SETTITLE",
  "10722": "TTV_STREAM_START",
  "10723": "CC_SETONSTATTRANSMIT",
  "10724": "IF_SETHFLIP",
  "10725": "SHOP_ISPRODUCTAVAILABLE",
  "10726": "INVOTHER_GETNUM",
  "10727": "QUEST_POINTS",
  "10728": "ACHIEVEMENT_GETSUBCATCOUNT",
  "10729": "FRIEND_COUNT",
  "10730": "CC_SETALPHA",
  "10731": "IF_SETPLAYERHEAD_SELF",
  "10732": "LOGIN_ACCOUNTAPPEAL",
  "10733": "CC_SETONTARGETLEAVE",
  "10734": "CC_SETONTARGETENTER",
  "10735": "CLIENTOPTION_CANSET",
  "10736": "CLIENTOPTION_CANMOD",
  "10737": "CLIENTOPTION_EXISTS",
  "10738": "IF_GRID_GETLAYOUTPARAMS",
  "10739": "ACTIVECLANCHANNEL_GETUSERDISPLAYNAME",
  "10740": "ACTIVECLANCHANNEL_GETUSERCOUNT",
  "10741": "ACHIEVEMENT_GETMEMBERS",
  "10742": "NOT",
  "10743": "TTV_WEBCAM_GETCAP_BYINDEX",
  "10744": "TTV_WEBCAM_GETCAP_BYUNIQUEID",
  "10745": "TTV_WEBCAM_GETCAP_COUNT",
  "10746": "DB_FIND_GET",
  "10747": "WORLDLIST_SORT",
  "10748": "ACHIEVEMENT_GETCATEGORYCOUNT",
  "10749": "CC_SETRETEX",
  "10750": "IF_SETOBJECT_LONG",
  "10751": "TTV_WEBCAM_GETDEVICE_BYINDEX",
  "10752": "TTV_WEBCAM_GETDEVICE_COUNT",
  "10753": "TTV_WEBCAM_SUPPORTED",
  "10754": "CC_SETCLICKMASK",
  "10755": "GET_CURRENTCURSOR",
  "10756": "NPC_TYPE",
  "10757": "GET_NPC_STAT",
  "10758": "IS_NPC_ACTIVE",
  "10759": "IF_SETTARGETCURSORS",
  "10760": "SOUND_SYNTH_VOLUME",
  "10761": "BUG_REPORT",
  "10762": "STRING_DISTANCE",
  "10763": "TTV_WEBCAM_FLIP",
  "10764": "OS_DRIVER_OUTDATED",
  "10765": "IF_GETCHARPOSATINDEX",
  "10766": "CC_NPC_SETCUSTOMBODYMODEL",
  "10767": "PRELOAD_DOWNLOAD_RATE",
  "10768": "PRELOAD_DOWNLOAD_TOTALSIZE",
  "10769": "PRELOAD_DOWNLOAD_DOWNLOADEDSIZE",
  "10770": "PRELOAD_PROGRESS",
  "10771": "PRELOAD_DOWNLOAD_COMPLETE",
  "10772": "FROMDATE",
  "10773": "PLAYER_GROUP_GET_MAX_SIZE",
  "10774": "VIDEO_ADVERT_PLAY",
  "10775": "VIDEO_ADVERT_HAS_FINISHED",
  "10776": "IGNORE_COUNT",
  "10777": "WORLDMAP_GETSIZE",
  "10778": "SOUND_JINGLE_VOLUME",
  "10779": "UNKNOWN_COMMAND_174",
  "10780": "IGNORE_GETNAME_UNFILTERED",
  "10781": "IF_RESETMODELLIGHTING",
  "10782": "WORLDMAP_FLASHELEMENTCATEGORY",
  "10783": "IF_SETTILING",
  "10784": "STOCKMARKET_GETOFFERTYPE",
  "10785": "LOBBY_ENTERLOBBY_SOCIAL_NETWORK",
  "10786": "CREATE_CONNECT_REPLY",
  "10787": "CC_UNKNOWN2",
  "10788": "CC_SETTARGETCURSORS",
  "10789": "CC_SETTARGETOPCURSOR",
  "10790": "OC_TRADEABLE",
  "10791": "CHAT_SENDPRIVATE",
  "10792": "WORLDLIST_AUTOWORLD",
  "10793": "IF_BUTTON_GETTOGGLED",
  "10794": "WORLDMAP_GETCONFIGBOUNDS",
  "10795": "WORLDMAP_3DVIEW_GETCOORDFINE",
  "10796": "PLAYER_GROUP_BANNED_GET_DISPLAYNAME",
  "10797": "PLAYER_GROUP_BANNED_COUNT",
  "10798": "LC_PARAM",
  "10799": "CC_SETOBJECT_LONG",
  "10800": "CC_SETMODELORIGIN",
  "10801": "STOCKMARKET_ISOFFERADDING",
  "10802": "STOCKMARKET_GETOFFERCOMPLETEDGOLD",
  "10803": "STOCKMARKET_GETOFFERCOMPLETEDCOUNT",
  "10804": "SETOBJ",
  "10805": "IF_NPC_SETCUSTOMRECOL",
  "10806": "OS_ISMAC",
  "10807": "IF_SETONHOLD",
  "10808": "CC_SETLINKFRIENDCHAT",
  "10809": "PLAYER_GROUP_GET_DISPLAYNAME",
  "10810": "CHATPHRASE_GETTEXT",
  "10811": "OC_FINDNEXT",
  "10812": "OC_FIND",
  "10813": "OPPLAYER",
  "10814": "CC_NPC_SETCUSTOMRECOL",
  "10815": "WORLDMAP_LISTELEMENT_NEXT",
  "10816": "MEC_TEXT",
  "10817": "WORLDMAP_LISTELEMENT_START",
  "10818": "FRIEND_GETRANK",
  "10819": "CHATPHRASE_FINDNEXT",
  "10820": "CHATPHRASE_FIND",
  "10821": "TEXT_GENDER",
  "10822": "TTV_LOGIN_GETSTATE",
  "10823": "OS_ISLINUX",
  "10824": "OS_ISWINDOWS",
  "10825": "TTV_HASPREREQUISITES",
  "10826": "TTV_LIBRARY_GETSTATE",
  "10827": "WORLDLIST_NEXT",
  "10828": "WORLDLIST_START",
  "10829": "IS_TARGETED_ENTITY",
  "10830": "NPC_FIND_ACTIVE_MINIMENU_ENTRY",
  "10831": "GET_MINIMENU_TARGET",
  "10832": "GET_MINIMENU_LENGTH",
  "10833": "GET_ACTIVE_MINIMENU_ENTRY",
  "10834": "USERDETAIL_LOBBY_LASTLOGINDAY",
  "10835": "ATAN2_DEG",
  "10836": "CC_SETPLAYERHEAD_SELF",
  "10837": "CAM2_SETLOOKATORIENTATION_VECTOR",
  "10838": "CAM2_SETLOOKATORIENTATION_MAXDISTANCECLAMPING",
  "10839": "COORDLEVEL_FINE",
  "10840": "FACING_FINE",
  "10841": "CC_TEXT_SETCOLOUR",
  "10842": "CC_UNKNOWN1",
  "10843": "CC_SETONRESIZE",
  "10844": "WORLDMAP_COORDINMAP",
  "10845": "CLAN_KICKUSER",
  "10846": "CC_SETOBJECT_WEARCOL",
  "10847": "FULLSCREEN_LASTMODE",
  "10848": "SHOP_GETCATEGORYDESCRIPTION",
  "10849": "CC_RADIOGROUP_ADDOPTION",
  "10850": "ACTIVECLANSETTINGS_GETBANNEDCOUNT",
  "10851": "CC_SETLINEWID",
  "10852": "CC_SETLINEDIRECTION",
  "10853": "CLEARBIT_RANGE",
  "10854": "LOGIN_LAST_TRANSFER_REPLY",
  "10855": "USERDETAIL_LOBBY_GRACEEXPIRY",
  "10856": "USERDETAIL_LOBBY_CCEXPIRY",
  "10857": "ACTIVECLANSETTINGS_GETRANKTALK",
  "10858": "SHOP_ISPRODUCTRECOMMENDED",
  "10859": "IF_UNKNOWN2",
  "10860": "CONSOLE_ENABLESNOW",
  "10861": "SETUP_MESSAGEBOX",
  "10862": "PLAYER_GROUP_GET_OVERALL_STATUS",
  "10863": "TTV_CHAT_SENDMESSAGE",
  "10864": "IF_SETLINEDIRECTION",
  "10865": "ACHIEVEMENT_FINDPARENTS",
  "10866": "CHAR_TOLOWERCASE",
  "10867": "CHAR_ISALPHANUMERIC",
  "10868": "ACTIVECLANCHANNEL_GETSORTEDUSERSLOT",
  "10869": "CHATPHRASE_GETAUTORESPONSE",
  "10870": "CHATPHRASE_GETDYNAMICCOMMANDPARAM_ENUM",
  "10871": "MEC_CATEGORY",
  "10872": "ACTIVECLANSETTINGS_GETSORTEDAFFINEDSLOT",
  "10873": "ACTIVECLANSETTINGS_GETAFFINEDJOINRUNEDAY",
  "10874": "FRIEND_GETWORLDFLAGS",
  "10875": "FRIEND_GETWORLDNAME",
  "10876": "GET_NPC_VISLEVEL",
  "10877": "ACTIVECHATPHRASE_SENDPRIVATE",
  "10878": "UNKNOWN_COMMAND_488",
  "10879": "UNKNOWN_COMMAND_206",
  "10880": "CC_SETRECOL",
  "10881": "CHAT_GETPREVUID",
  "10882": "FRIEND_IS_REFERRED",
  "10883": "FRIEND_IS_REFERRER",
  "10884": "CHATCAT_GETPHRASE",
  "10885": "CHAR_ISNUMERIC",
  "10886": "CHATCAT_GETSUBCAT",
  "10887": "CHAR_TOUPPERCASE",
  "10888": "CHATCAT_GETSUBCATSHORTCUT",
  "10889": "CHATCAT_GETPHRASECOUNT",
  "10890": "CHATCAT_GETSUBCATCOUNT",
  "10891": "ACHIEVEMENT_ACHIEVEMENT_REQ",
  "10892": "ACHIEVEMENT_ACHIEVEMENT_REQ_MET",
  "10893": "ACHIEVEMENT_QUEST_REQ",
  "10894": "ACHIEVEMENT_QUEST_REQ_MET",
  "10895": "ACHIEVEMENT_QUEST_REQ_COUNT",
  "10896": "ACHIEVEMENT_ACHIEVEMENT_PREREQ_MET",
  "10897": "ACHIEVEMENT_ACHIEVEMENT_PREREQ",
  "10898": "ACHIEVEMENT_ACHIEVEMENT_PREREQ_COUNT",
  "10899": "ACHIEVEMENT_QUEST_PREREQ_MET",
  "10900": "ACHIEVEMENT_QUEST_PREREQ",
  "10901": "ACHIEVEMENT_QUEST_PREREQ_COUNT",
  "10902": "ACHIEVEMENT_VARBIT_TESTBIT_PREREQ_MET",
  "10903": "ACHIEVEMENT_VARBIT_TESTBIT_PREREQ_DESCRIPTION",
  "10904": "ACHIEVEMENT_VARBIT_TESTBIT_PREREQ_COUNT",
  "10905": "ACHIEVEMENT_VARP_TESTBIT_PREREQ_MET",
  "10906": "ACHIEVEMENT_VARP_TESTBIT_PREREQ_DESCRIPTION",
  "10907": "ACHIEVEMENT_VARP_TESTBIT_PREREQ_COUNT",
  "10908": "ACHIEVEMENT_VARBIT_PREREQ_MET",
  "10909": "ACHIEVEMENT_VARBIT_PREREQ_DESCRIPTION",
  "10910": "ACHIEVEMENT_VARBIT_PREREQ_COUNT",
  "10911": "ACHIEVEMENT_VARP_PREREQ_MET",
  "10912": "ACHIEVEMENT_VARP_PREREQ_DESCRIPTION",
  "10913": "ACHIEVEMENT_VARP_PREREQ_COUNT",
  "10914": "ACHIEVEMENT_STAT_PREREQ_MET",
  "10915": "ACHIEVEMENT_STAT_PREREQ_DESCRIPTION",
  "10916": "ACHIEVEMENT_PREREQ_MET",
  "10917": "ACHIEVEMENT_STAT_PREREQ_COUNT",
  "10918": "ACHIEVEMENT_LARGEST_PREREQ",
  "10919": "ACHIEVEMENT_GETGRACEDAY",
  "10920": "ACHIEVEMENT_VARBIT_TESTBIT_REQ_MET",
  "10921": "ACHIEVEMENT_VARBIT_TESTBIT_REQ_NAME",
  "10922": "ACHIEVEMENT_VARBIT_TESTBIT_REQ_COUNT",
  "10923": "ACHIEVEMENT_VARP_TESTBIT_REQ_MET",
  "10924": "ACHIEVEMENT_VARP_TESTBIT_REQ_NAME",
  "10925": "ACHIEVEMENT_VARP_TESTBIT_REQ_COUNT",
  "10926": "ACHIEVEMENT_VARBIT_REQ_MET",
  "10927": "ACHIEVEMENT_VARBIT_REQ_NAME",
  "10928": "ACHIEVEMENT_VARBIT_REQ_COUNT",
  "10929": "ACHIEVEMENT_VARP_REQ_MET",
  "10930": "ACHIEVEMENT_VARP_REQ_NAME",
  "10931": "ACHIEVEMENT_VARP_REQ_COUNT",
  "10932": "ACHIEVEMENT_STAT_REQ_MET",
  "10933": "ACHIEVEMENT_STAT_REQ_NAME",
  "10934": "ACHIEVEMENT_STAT_REQ_COUNT",
  "10935": "CC_SETONMISCTRANSMIT",
  "10936": "PLAYER_GROUP_MEMBER_GET_LAST_SEEN_NODE_ID",
  "10937": "PLAYER_GROUP_MEMBER_GET_TEAM",
  "10938": "PLAYER_GROUP_MEMBER_GET_SAME_WORLD_VAR",
  "10939": "PLAYER_GROUP_MEMBER_IS_ONLINE",
  "10940": "CLAN_GETCHATOWNERNAME",
  "10941": "CLAN_GETCHATUSERNAME_UNFILTERED",
  "10942": "CLAN_GETCHATUSERNAME",
  "10943": "CHATCAT_GETDESC",
  "10944": "LOGIN_DISALLOWTRIGGER",
  "10945": "LOGIN_DISALLOWRESULT",
  "10946": "LOGIN_QUEUE_POSITION",
  "10947": "VIDEO_ADVERT_ALLOW_SKIP",
  "10948": "LOGIN_HOPTIME",
  "10949": "LOGIN_BAN_DURATION",
  "10950": "LOGIN_CONTINUE",
  "10951": "IF_SETOPTKEY",
  "10952": "CC_CAROUSEL_ADDTEXTENTRY",
  "10953": "CC_PAGEDLAYER_CREATEHEADER",
  "10954": "ACHIEVEMENT_GETHIDE",
  "10955": "ACHIEVEMENT_RUNESCORE",
  "10956": "QUEST_TYPE",
  "10957": "TELEMETRY_GET_COLUMN_COUNT",
  "10958": "TELEMETRY_IS_ROW_PINNED",
  "10959": "TELEMETRY_GET_ROW_ID",
  "10960": "TELEMETRY_GET_COLUMN_ID",
  "10961": "TELEMETRY_GET_ROW_COUNT",
  "10962": "TELEMETRY_GET_GROUP_ID",
  "10963": "TELEMETRY_GET_GROUP_COUNT",
  "10964": "WORLDMAP_GETDISABLEELEMENTS",
  "10965": "SETBIT_RANGE",
  "10966": "WORLDMAP_3DVIEW_DISABLE",
  "10967": "WORLDMAP_3DVIEW_ACTIVE",
  "10968": "CAM2_SETLOOKATMAXSPEED_AXIS",
  "10969": "CAM2_SETLOOKATACCELERATION_AXIS",
  "10970": "CAM2_SETPOSITIONMAXSPEED_AXIS",
  "10971": "CAM2_SETPOSITIONACCELERATION_AXIS",
  "10972": "CAM2_SETSNAPDISTANCES",
  "10973": "CAM2_ENABLE",
  "10974": "WORLDMAP_3DVIEW_ENABLE",
  "10975": "CREATE_EMAIL_VALIDATE_REPLY",
  "10976": "ACTIVECLANSETTINGS_GETALLOWUNAFFINED",
  "10977": "CAM2_RESETSNAPDISTANCES"
};

// rsmv/src/clientscript/definitions.ts
var variableSources = {
  player: { key: 0, index: cacheConfigPages.varplayer },
  npc: { key: 1, index: cacheConfigPages.varnpc },
  client: { key: 2, index: cacheConfigPages.varclient },
  world: { key: 3, index: cacheConfigPages.varworld },
  region: { key: 4, index: cacheConfigPages.varregion },
  object: { key: 5, index: cacheConfigPages.varobject },
  clan: { key: 6, index: cacheConfigPages.varclan },
  clansettings: { key: 7, index: cacheConfigPages.varclansettings },
  // campaign: { key: 8, index: cacheConfigPages.varcampaign },//seems incorrect after 30oct2023
  playergroup: { key: 9, index: cacheConfigPages.varplayergroup }
  //not sure about 75
};
var namedClientScriptOps = {
  //old caches only
  pushint: 0,
  pushlong: 54,
  pushstring: 3,
  //local var assign
  pushlocalint: 33,
  poplocalint: 34,
  pushlocalstring: 35,
  poplocalstring: 36,
  pushlocallong: 10024,
  poplocallong: 10237,
  //pop discard
  popdiscardint: 10004,
  popdiscardlong: 9104,
  //op not seen yet
  popdiscardstring: 10360,
  //variable number of args
  joinstring: 37,
  gosub: 40,
  //complicated types
  pushvar: 42,
  popvar: 43,
  pushvarbit: 10022,
  popvarbit: 10023,
  //control flow
  jump: 6,
  branch_not: 7,
  branch_eq: 8,
  branch_lt: 9,
  branch_gt: 10,
  branch_lteq: 31,
  branch_gteq: 32,
  branch_eq_long: 10153,
  branch_not_long: 10449,
  branch_lt_long: 10411,
  branch_gt_long: 10321,
  branch_lteq_long: 10491,
  branch_gteq_long: 10349,
  switch: 51,
  return: 21,
  //unknown original ids
  pushconst: 9001,
  tribyte1: 9002,
  tribyte2: 9003,
  //non-existent opcodes
  shorting_or: 9100,
  shorting_and: 9101,
  //math stuff
  plus: 4e3,
  minus: 4001,
  intdiv: 4003,
  intmul: 4002,
  strcmp: 4107,
  //0 for equal, might be string - operator
  strconcat: 4101,
  inttostring: 10064,
  //enums
  enum_getvalue: 3408,
  struct_getparam: 4500,
  item_getparam: 4208,
  quest_getparam: 10262,
  npc_getparam: 10076,
  cc_getparam: 10049,
  mec_getparam: 10192,
  dbrow_getfield: 10094,
  dbrow_findnext: 10112,
  //dynamic subtype ops
  cc_setparam: 10098,
  db_find_with_count: 10100,
  lc_getparam: 10798,
  enum_getstring: 10047,
  enum_getreverseindex: 10154,
  enum_getreversecount: 10240,
  enum_hasoutput: 10244,
  //arrays
  define_array: 10569,
  pop_array: 46,
  push_array: 45,
  //interface stuff
  printmessage: 3100
};
var subtypes = {
  int: 0,
  boolean: 1,
  type_2: 2,
  quest: 3,
  questhelp: 4,
  cursor: 5,
  seq: 6,
  colour: 7,
  loc_shape: 8,
  component: 9,
  idkit: 10,
  midi: 11,
  npc_mode: 12,
  namedobj: 13,
  synth: 14,
  type_15: 15,
  area: 16,
  stat: 17,
  npc_stat: 18,
  writeinv: 19,
  mesh: 20,
  maparea: 21,
  coordgrid: 22,
  graphic: 23,
  chatphrase: 24,
  fontmetrics: 25,
  enum: 26,
  type_27: 27,
  jingle: 28,
  chatcat: 29,
  loc: 30,
  model: 31,
  npc: 32,
  obj: 33,
  player_uid: 34,
  type_35: 35,
  string: 36,
  spotanim: 37,
  npc_uid: 38,
  inv: 39,
  texture: 40,
  category: 41,
  char: 42,
  laser: 43,
  bas: 44,
  type_45: 45,
  collision_geometry: 46,
  physics_model: 47,
  physics_control_modifier: 48,
  clanhash: 49,
  coordfine: 50,
  cutscene: 51,
  itemcode: 53,
  type_54: 54,
  mapsceneicon: 55,
  clanforumqfc: 56,
  vorbis: 57,
  verify_object: 58,
  mapelement: 59,
  categorytype: 60,
  social_network: 61,
  hitmark: 62,
  package: 63,
  particle_effector: 64,
  type_65: 65,
  particle_emitter: 66,
  plogtype: 67,
  unsigned_int: 68,
  skybox: 69,
  skydecor: 70,
  hash64: 71,
  inputtype: 72,
  struct: 73,
  dbrow: 74,
  type_75: 75,
  type_76: 76,
  type_77: 77,
  type_78: 78,
  type_79: 79,
  type_80: 80,
  type_81: 81,
  type_83: 83,
  type_84: 84,
  type_85: 85,
  type_86: 86,
  type_87: 87,
  type_88: 88,
  gwc_platform: 89,
  type_90: 90,
  type_91: 91,
  type_92: 92,
  type_93: 93,
  bug_template: 94,
  billing_auth_flag: 95,
  account_feature_flag: 96,
  interface: 97,
  toplevelinterface: 98,
  overlayinterface: 99,
  clientinterface: 100,
  movespeed: 101,
  material: 102,
  seqgroup: 103,
  temp_hiscore: 104,
  temp_hiscore_length_type: 105,
  temp_hiscore_display_type: 106,
  temp_hiscore_contribute_result: 107,
  audiogroup: 108,
  audiomixbuss: 109,
  long: 110,
  crm_channel: 111,
  http_image: 112,
  pop_up_display_behaviour: 113,
  poll: 114,
  type_115: 115,
  type_116: 116,
  pointlight: 117,
  player_group: 118,
  player_group_status: 119,
  player_group_invite_result: 120,
  player_group_modify_result: 121,
  player_group_join_or_create_result: 122,
  player_group_affinity_modify_result: 123,
  player_group_delta_type: 124,
  client_type: 125,
  telemetry_interval: 126,
  type_127: 127,
  type_128: 128,
  type_129: 129,
  type_130: 130,
  achievement: 131,
  stylesheet: 133,
  type_138: 138,
  type_200: 200,
  type_201: 201,
  type_202: 202,
  type_203: 203,
  type_204: 204,
  type_205: 205,
  type_206: 206,
  type_207: 207,
  type_208: 208,
  var_reference: 209,
  //TODO try to remove this, no longer required but still used for unknown subtypes
  unknown_int: 501,
  unknown_long: 502,
  unknown_string: 503,
  scriptref: 504,
  scriptsubref: 505
  //max 511 (9bit) or overflow elsewhere in code
};
var stacktypekeys = ["int", "long", "string"];
var grouptypekeys = ["known", "opin", "opout", "scriptargvar", "scriptret", "uuid"];
function primitiveToId(prim) {
  return stacktypekeys.indexOf(prim);
}
function dependentToId(dep) {
  return grouptypekeys.indexOf(dep);
}
function dependencyGroup(deptype, id) {
  return dependentToId(deptype) << 27 | id << 9;
}
function dependencyIndex(subtype, index) {
  return primitiveToId(subtype) << 25 | index;
}
function knownDependency(fulltype) {
  return primitiveToId(typeToPrimitive(fulltype)) << 25 | fulltype;
}
function keyToPrimitive(key) {
  let deptype = key >> 27 & 7;
  if (deptype == 0) {
    return typeToPrimitive(key & 511);
  }
  let typekey = key >> 25 & 3;
  return typekey == 0 ? "int" : typekey == 1 ? "long" : "string";
}
function decomposeKey(key) {
  let sourcetype = grouptypekeys[key >> 27 & 7];
  let stacktype = stacktypekeys[key >> 25 & 3];
  let group = key >> 9 & 65535;
  let index = key & 511;
  if (sourcetype == "uuid") {
    index = key & 33554431;
    group = 0;
  }
  return [sourcetype, stacktype, group, index];
}
function debugKey(key) {
  let [sourcetype, stackstring, group, index] = decomposeKey(key);
  if (sourcetype == "known") {
    return `known type ${index} ${Object.entries(subtypes).find((q) => q[1] == index)?.[0]}`;
  }
  if (sourcetype == "opin") {
    return `opin ${group} ${getOpName(group)} ${index} ${stackstring}`;
  }
  if (sourcetype == "opout") {
    return `opout ${group} ${getOpName(group)} ${index} ${stackstring}`;
  }
  if (sourcetype == "scriptargvar") {
    return `script ${group} arg/local ${index} ${stackstring}`;
  }
  if (sourcetype == "scriptret") {
    return `script ${group} return ${index} ${stackstring}`;
  }
  if (sourcetype == "uuid") {
    return `uuid ${index} ${stackstring}`;
  }
}
globalThis.debugkey = debugKey;
var typeuuids = {
  int: dependencyGroup("uuid", 0) | dependencyIndex("int", 0),
  long: dependencyGroup("uuid", 0) | dependencyIndex("long", 0),
  string: dependencyGroup("uuid", 0) | dependencyIndex("string", 0)
};
function getOpName(id) {
  return knownClientScriptOpNames[id] ?? `unk${id}`;
}
function longJsonToBigInt(tuple) {
  let res = BigInt(tuple[0] >>> 0) << 32n | BigInt(tuple[1] >>> 0);
  if (tuple[0] & 2147483648) {
    res = res - 0x10000000000000000n;
  }
  return res;
}
function longBigIntToJson(long) {
  let bigint = long & 0xffffffffffffffffn;
  let upper = Number(bigint >> 32n & 0xffffffffn);
  let lower = Number(bigint & 0xffffffffn);
  return [upper, lower];
}
function subtypeToTs(subt) {
  let resentry = Object.entries(subtypes).find((q) => q[1] == subt);
  if (!resentry) {
    return `type_${subt}`;
  }
  let res = resentry[0];
  if (res == "enum") {
    res = "cs2enum";
  }
  return res;
}
function tsToSubtype(tscode) {
  if (tscode == "cs2bool") {
    return subtypes.boolean;
  }
  if (tscode == "cs2enum") {
    return subtypes.enum;
  }
  if (!Object.hasOwn(subtypes, tscode)) {
    let m = tscode.match(/^type_(\d+)$/);
    if (!m) {
      throw new Error("unknown subtype " + tscode);
    }
    return +m[1];
  }
  return subtypes[tscode];
}
var stringtypes = [
  subtypes.string,
  subtypes.coordfine,
  subtypes.unknown_string
];
var longtypes = [
  subtypes.type_35,
  subtypes.clanhash,
  subtypes.clanforumqfc,
  subtypes.hash64,
  subtypes.long,
  subtypes.type_115,
  subtypes.type_116,
  subtypes.unknown_long
];
function typeToPrimitive(typeint) {
  if (stringtypes.includes(typeint)) {
    return "string";
  } else if (longtypes.includes(typeint)) {
    return "long";
  } else {
    return "int";
  }
}
function primitiveToUknownExact(stacktype) {
  if (stacktype == "int") {
    return subtypes.unknown_int;
  }
  if (stacktype == "long") {
    return subtypes.unknown_long;
  }
  if (stacktype == "string") {
    return subtypes.unknown_string;
  }
  throw new Error(`uknown stack type ${stacktype}`);
}
var knownClientScriptOpNames = {
  ...rs3opnames,
  ...Object.fromEntries(Object.entries(namedClientScriptOps).map((q) => [q[1], q[0]]))
};
globalThis.knownClientScriptOpNames = knownClientScriptOpNames;
var popDiscardOps = [
  namedClientScriptOps.popdiscardint,
  namedClientScriptOps.popdiscardlong,
  namedClientScriptOps.popdiscardstring
];
var popLocalOps = [
  namedClientScriptOps.poplocalint,
  namedClientScriptOps.poplocallong,
  namedClientScriptOps.poplocalstring
];
var pushLocalOps = [
  namedClientScriptOps.pushlocalint,
  namedClientScriptOps.pushlocallong,
  namedClientScriptOps.pushlocalstring
];
var pushOrPopLocalOps = [
  ...popDiscardOps,
  ...popLocalOps,
  ...pushLocalOps
];
var branchInstructionsInt = [
  namedClientScriptOps.branch_not,
  namedClientScriptOps.branch_eq,
  namedClientScriptOps.branch_lt,
  namedClientScriptOps.branch_gt,
  namedClientScriptOps.branch_lteq,
  namedClientScriptOps.branch_gteq
];
var branchInstructionsLong = [
  namedClientScriptOps.branch_not_long,
  namedClientScriptOps.branch_eq_long,
  namedClientScriptOps.branch_lt_long,
  namedClientScriptOps.branch_gt_long,
  namedClientScriptOps.branch_lteq_long,
  namedClientScriptOps.branch_gteq_long
];
var branchInstructions = [
  ...branchInstructionsInt,
  ...branchInstructionsLong
];
var binaryOpSymbols = /* @__PURE__ */ new Map([
  [namedClientScriptOps.shorting_or, "||"],
  [namedClientScriptOps.shorting_and, "&&"],
  //compare longs
  // [namedClientScriptOps.branch_not_long, ":!="],
  // [namedClientScriptOps.branch_eq_long, ":=="],
  // [namedClientScriptOps.branch_lteq_long, ":<="],
  // [namedClientScriptOps.branch_gteq_long, ":>="],
  // [namedClientScriptOps.branch_lt_long, ":<"],
  // [namedClientScriptOps.branch_gt_long, ":>"],
  //ints
  [namedClientScriptOps.branch_not, "!="],
  [namedClientScriptOps.branch_eq, "=="],
  [namedClientScriptOps.branch_lteq, "<="],
  [namedClientScriptOps.branch_gteq, ">="],
  [namedClientScriptOps.branch_lt, "<"],
  //make sure shorter ops are after longer ones
  [namedClientScriptOps.branch_gt, ">"],
  //math
  [namedClientScriptOps.plus, "+"],
  [namedClientScriptOps.minus, "-"],
  [namedClientScriptOps.intdiv, "/"],
  [namedClientScriptOps.intmul, "*"]
]);
var int32MathOps = /* @__PURE__ */ new Set([
  namedClientScriptOps.plus,
  namedClientScriptOps.minus,
  namedClientScriptOps.intdiv,
  namedClientScriptOps.intmul
]);
var binaryOpIds = new Map([...binaryOpSymbols].map((q) => [q[1], q[0]]));
var branchInstructionsOrJump = [
  ...branchInstructions,
  namedClientScriptOps.jump
];
var getParamOps = [
  namedClientScriptOps.cc_getparam,
  namedClientScriptOps.mec_getparam,
  namedClientScriptOps.npc_getparam,
  namedClientScriptOps.item_getparam,
  namedClientScriptOps.quest_getparam,
  namedClientScriptOps.struct_getparam
];
var dynamicOps = [
  ...getParamOps,
  namedClientScriptOps.pushvar,
  namedClientScriptOps.popvar,
  namedClientScriptOps.enum_getvalue,
  namedClientScriptOps.dbrow_getfield,
  namedClientScriptOps.dbrow_findnext
];
function makeop(opcode, imm = 0, imm_obj = null) {
  return { opcode, imm, imm_obj };
}
function makejump(label) {
  return { opcode: namedClientScriptOps.jump, imm: 0, imm_obj: { type: "jumplabel", value: label } };
}
var StackConstants = class {
  constructor(v) {
    this.values = [];
    if (v !== void 0) {
      this.values.push(v);
    }
  }
  applyInOut(other) {
    let addedlength = other.out.values.length - other.in.values.length;
    if (this.values.length < other.in.values.length) {
    }
    if (addedlength > 0) {
      for (let i = 0; i < addedlength; i++) {
        this.values.push(null);
      }
    } else {
      this.values.length = Math.max(0, this.values.length + addedlength);
    }
  }
  popList(other, endoffset) {
    this.values.length -= other.total(endoffset);
  }
  pushOne(other) {
    this.values.push(other ?? null);
  }
  pushList(other, endoffset) {
    for (let i = other.total(endoffset); i > 0; i--) {
      this.values.push(null);
    }
  }
  push(other) {
    this.values.push(...other.values);
  }
  pop() {
    if (this.values.length == 0) {
      throw new Error("tried to pop empty StackConsts");
    }
    return this.values.pop();
  }
};
var StackList = class _StackList {
  constructor(values = []) {
    this.values = values;
  }
  pushone(type) {
    this.values.push(type);
  }
  int() {
    this.values.push("int");
  }
  long() {
    this.values.push("long");
  }
  string() {
    this.values.push("string");
  }
  isEmpty() {
    return this.values.every((q) => q instanceof StackDiff && q.isEmpty());
  }
  total(endoffset = 0) {
    let r = 0;
    for (let i = this.values.length - 1; i >= endoffset; i--) {
      let v = this.values[i];
      if (v instanceof StackDiff) {
        r += v.total();
      } else {
        r++;
      }
    }
    return r;
  }
  tryShift(n) {
    let count = 0;
    let sliceindex = -1;
    for (let i = 0; i < this.values.length; i++) {
      let val = this.values[i];
      if (val instanceof StackDiff) {
        count += val.total();
      } else {
        count++;
      }
      if (count >= n) {
        sliceindex = i + 1;
        break;
      }
    }
    if (count != n) {
      return false;
    }
    this.values.splice(0, sliceindex);
    return true;
  }
  hasSimple(other) {
    let len = other.values.length - 1;
    if (this.values.length < len) {
      return false;
    }
    for (let i = 0; i <= len; i++) {
      let otherval = other.values[len - i];
      if (typeof otherval != "string") {
        return false;
      }
      let val = this.values[this.values.length - 1 - i];
      if (typeof val != "string" || val != otherval) {
        return false;
      }
    }
    return true;
  }
  pop(list, limit = 0) {
    if (this.tryPop(list, limit) != 0) {
      throw new Error("missing pop values on stack");
    }
  }
  tryPopReverse(list, limit = 0) {
    this.values.reverse();
    list.values.reverse();
    try {
      return this.tryPop(list, limit);
    } finally {
      this.values.reverse();
      list.values.reverse();
    }
  }
  tryPopUnordered(otherval) {
    while (!otherval.isEmpty()) {
      if (this.values.length == 0) {
        return false;
      }
      let val = this.values[this.values.length - 1];
      if (val instanceof StackDiff) {
        if (otherval.lteq(val)) {
          val.sub(otherval);
          otherval.sub(otherval);
        } else if (val.lteq(otherval)) {
          otherval.sub(val);
          val.sub(val);
          this.values.pop();
        } else {
          return false;
        }
      } else {
        let amount = otherval.getSingle(val);
        if (amount <= 0) {
          return false;
        }
        otherval.setSingle(val, amount - 1);
        this.values.pop();
      }
    }
    return true;
  }
  tryPopSingle(otherval) {
    if (this.values.length == 0) {
      return false;
    }
    let val = this.values[this.values.length - 1];
    if (val instanceof StackDiff) {
      let amount = val.getSingle(otherval);
      if (amount <= 0) {
        return false;
      }
      val.setSingle(otherval, amount - 1);
      if (val.isEmpty()) {
        this.values.pop();
      }
    } else {
      if (val != otherval) {
        return false;
      }
      this.values.pop();
    }
    return true;
  }
  tryPop(list, limit = 0) {
    let otherindex = list.values.length;
    while (otherindex > limit) {
      let otherval = list.values[otherindex - 1];
      if (otherval instanceof StackDiff) {
        if (!this.tryPopUnordered(otherval.clone())) {
          break;
        }
        otherindex--;
      } else {
        if (!this.tryPopSingle(otherval)) {
          break;
        }
        otherindex--;
      }
    }
    return otherindex - limit;
  }
  push(list) {
    for (let val of list.values) {
      if (val instanceof StackDiff) {
        this.values.push(val.clone());
      } else {
        this.values.push(val);
      }
    }
  }
  clone() {
    return new _StackList(this.values.map((q) => q instanceof StackDiff ? q.clone() : q));
  }
  toString() {
    let res = [];
    let lastdiff = null;
    for (let v of this.values) {
      if (typeof v == "string") {
        res.push(v);
      } else if (v == lastdiff) {
        continue;
      } else {
        lastdiff = v;
        res.push(v.toString());
      }
    }
    return res.join(",");
  }
  toFunctionBindString() {
    let res = "";
    for (let part of this.values) {
      if (part instanceof StackDiff) {
        res += part.toFunctionBindString();
      } else if (part == "int") {
        res += "i";
      } else if (part == "long") {
        res += "l";
      } else if (part == "string") {
        res += "s";
      } else throw new Error("unsupported stack type");
    }
    return res;
  }
  toTypeScriptVarlist(withnames, withtypes, exacttype) {
    let res = "";
    let counts = new StackDiff();
    for (let i = 0; i < this.values.length; i++) {
      let part = this.values[i];
      if (part instanceof StackDiff) {
        res += part.toTypeScriptVarlist(counts, withnames, withtypes, exacttype);
      } else if (part == "int" && i + 1 < this.values.length && this.values[i + 1] == "vararg") {
        if (withnames) {
          res += `vararg${withtypes ? ": " : ""}`;
        }
        if (withtypes) {
          res += "BoundFunction";
        }
        counts.vararg++;
        i++;
      } else if (part == "int") {
        if (withnames) {
          res += `int${counts.int}${withtypes ? ": " : ""}`;
        }
        if (withtypes) {
          res += exacttype ? subtypeToTs(exacttype.int[counts.int]) : "number";
        }
        counts.int++;
      } else if (part == "long") {
        if (withnames) {
          res += `long${counts.long}${withtypes ? ": " : ""}`;
        }
        if (withtypes) {
          res += exacttype ? subtypeToTs(exacttype.long[counts.long]) : "BigInt";
        }
        counts.long++;
      } else if (part == "string") {
        if (withnames) {
          res += `string${counts.string}${withtypes ? ": " : ""}`;
        }
        if (withtypes) {
          res += exacttype ? subtypeToTs(exacttype.string[counts.string]) : "string";
        }
        counts.string++;
      } else throw new Error("unsupported stack type");
      if (i != this.values.length - 1) {
        res += ", ";
      }
    }
    return res;
  }
  toTypeScriptReturnType(exacttype) {
    if (this.values.length == 0) {
      return "void";
    }
    if (this.values.length == 1) {
      return this.toTypeScriptVarlist(false, true, exacttype);
    }
    return `[${this.toTypeScriptVarlist(false, true, exacttype)}]`;
  }
  toJson() {
    return this.values.map((q) => typeof q == "string" ? q : q.toJson());
  }
  static fromJson(v) {
    return new _StackList(v.map((q) => typeof q == "string" ? q : StackDiff.fromJson(q)));
  }
  getStackdiff() {
    let r = new StackDiff();
    for (let v of this.values) {
      if (v === "int") {
        r.int++;
      } else if (v === "string") {
        r.string++;
      } else if (v === "long") {
        r.long++;
      } else if (v === "vararg") {
        r.vararg++;
      } else if (v instanceof StackDiff) {
        r.add(v);
      } else {
        throw new Error("unexpected");
      }
    }
    return r;
  }
  toStackDiff() {
    let res = new StackDiff();
    for (let part of this.values) {
      if (part instanceof StackDiff) {
        res.add(part);
      } else {
        res.setSingle(part, res.getSingle(part) + 1);
      }
    }
    return res;
  }
  toLooseSubtypes() {
    let res = [];
    for (let value of this.values) {
      if (value instanceof StackDiff) {
        if (value.vararg != 0) {
          throw new Error("vararg doesn't have a vm type");
        }
        for (let i = 0; i < value.int; i++) {
          res.push(typeuuids.int++);
        }
        for (let i = 0; i < value.long; i++) {
          res.push(typeuuids.long++);
        }
        for (let i = 0; i < value.string; i++) {
          res.push(typeuuids.string++);
        }
      } else if (value == "int") {
        res.push(typeuuids.int++);
      } else if (value == "long") {
        res.push(typeuuids.long++);
      } else if (value == "string") {
        res.push(typeuuids.string++);
      } else throw new Error("vararg doesn't have a vm type");
    }
    return res;
  }
};
var ExactStack = class _ExactStack {
  constructor() {
    this.int = [];
    this.long = [];
    this.string = [];
  }
  all() {
    return this.int.concat(this.long, this.string);
  }
  static fromList(types) {
    let res = new _ExactStack();
    for (let type of types) {
      res[keyToPrimitive(type)].push(type);
    }
    return res;
  }
  static fromJson(json) {
    let res = new _ExactStack();
    res.int = json.int;
    res.long = json.long;
    res.string = json.string;
    return res;
  }
  toJson() {
    return this;
  }
};
var StackInOut = class _StackInOut {
  constructor(inlist, outlist) {
    this.in = new StackList();
    this.out = new StackList();
    this.exactin = null;
    this.exactout = null;
    this.constout = null;
    this.initializedin = false;
    this.initializedout = false;
    this.initializedthrough = false;
    this.in = inlist ?? new StackList();
    this.out = outlist ?? new StackList();
    this.initializedin = !!inlist;
    this.initializedout = !!outlist;
    this.initializedthrough = this.initializedin && this.initializedout;
  }
  static fromExact(inlist, outlist) {
    let res = new _StackInOut(new StackList(inlist.map(keyToPrimitive)), new StackList(outlist.map(keyToPrimitive)));
    res.exactin = ExactStack.fromList(inlist);
    res.exactout = ExactStack.fromList(outlist);
    return res;
  }
  getBottomOverlap() {
    let maxlen = Math.min(this.in.values.length, this.out.values.length);
    for (let i = 0; i < maxlen; i++) {
      if (this.in.values[i] != this.out.values[i]) {
        return i;
      }
    }
    return maxlen;
  }
  totalChange() {
    return this.out.total() - this.in.total();
  }
  getCode() {
    return `${this.out.values.join(",")}(${this.in.values.join(",")})`;
  }
  toString() {
    return `${this.out + "" || "void"}${this.initializedthrough ? "" : "??"}(${this.in})`;
  }
  toJson() {
    return {
      in: this.in.toJson(),
      out: this.out.toJson(),
      initializedthrough: this.initializedthrough,
      exactin: this.exactin?.toJson(),
      exactout: this.exactout?.toJson()
    };
  }
  static fromJson(json) {
    let res = new _StackInOut(StackList.fromJson(json.in), StackList.fromJson(json.out));
    res.initializedthrough = json.initializedthrough;
    res.initializedin = json.initializedthrough;
    res.initializedout = json.initializedthrough;
    res.exactin = json.exactin ? ExactStack.fromJson(json.exactin) : null;
    res.exactout = json.exactout ? ExactStack.fromJson(json.exactout) : null;
    return res;
  }
};
var StackDiff = class _StackDiff {
  static fromJson(json) {
    if (!json) {
      return null;
    }
    return new _StackDiff(json.int, json.long, json.string, json.vararg);
  }
  toJson() {
    return { ...this };
  }
  constructor(int2 = 0, long = 0, string3 = 0, vararg = 0) {
    this.int = int2;
    this.long = long;
    this.string = string3;
    this.vararg = vararg;
  }
  sub(other) {
    this.int -= other.int;
    this.long -= other.long;
    this.string -= other.string;
    this.vararg -= other.vararg;
    return this;
  }
  add(other) {
    this.int += other.int;
    this.long += other.long;
    this.string += other.string;
    this.vararg += other.vararg;
    return this;
  }
  min(other) {
    this.int = Math.min(other.int, this.int);
    this.long = Math.min(other.long, this.long);
    this.string = Math.min(other.string, this.string);
    this.vararg = Math.min(other.vararg, this.vararg);
  }
  max(other) {
    this.int = Math.max(other.int, this.int);
    this.long = Math.max(other.long, this.long);
    this.string = Math.max(other.string, this.string);
    this.vararg = Math.max(other.vararg, this.vararg);
  }
  mult(n) {
    this.int *= n;
    this.long *= n;
    this.string *= n;
    this.vararg *= n;
    return this;
  }
  intdiv(n) {
    if (this.int % n != 0 || this.long % n != 0 || this.string % n != 0 || this.vararg % n != 0) {
      throw new Error("attempted stackdiv division leading to remainder");
    }
    this.int /= n;
    this.long /= n;
    this.string /= n;
    this.vararg /= n;
    return this;
  }
  lteq(other) {
    return this.int <= other.int && this.long <= other.long && this.string <= other.string && this.vararg <= other.vararg;
  }
  equals(other) {
    return this.int == other.int && this.long == other.long && this.string == other.string && this.vararg == other.vararg;
  }
  isEmpty() {
    return this.int == 0 && this.long == 0 && this.string == 0 && this.vararg == 0;
  }
  isNonNegative() {
    return this.int >= 0 && this.long >= 0 && this.string >= 0 && this.vararg >= 0;
  }
  toString() {
    return `(${this.int},${this.long},${this.string},${this.vararg})`;
  }
  total() {
    return this.int + this.long + this.string + this.vararg;
  }
  clone() {
    return new _StackDiff().add(this);
  }
  isMonoType() {
    if (this.vararg != 0) {
      return "multi";
    }
    if (this.int != 0 && this.long == 0 && this.string == 0) {
      return "int";
    }
    if (this.int == 0 && this.long != 0 && this.string == 0) {
      return "long";
    }
    if (this.int == 0 && this.long == 0 && this.string != 0) {
      return "string";
    }
    return "multi";
  }
  getSingle(stack) {
    if (stack == "int") {
      return this.int;
    } else if (stack == "long") {
      return this.long;
    } else if (stack == "string") {
      return this.string;
    } else if (stack == "vararg") {
      return this.vararg;
    } else {
      throw new Error("unknown stack type");
    }
  }
  setSingle(stack, value) {
    if (stack == "int") {
      this.int = value;
    } else if (stack == "long") {
      this.long = value;
    } else if (stack == "string") {
      this.string = value;
    } else if (stack == "vararg") {
      this.vararg = value;
    } else {
      throw new Error("unknown stack type");
    }
  }
  getArglist() {
    let inargs = new StackList();
    let ntypes = +!!this.int + +!!this.string + +!!this.long + +!!this.vararg;
    if (ntypes > 1) {
      inargs.values.push(this.clone());
    } else {
      inargs.values.push(...Array(this.int).fill("int"));
      inargs.values.push(...Array(this.string).fill("string"));
      inargs.values.push(...Array(this.long).fill("long"));
      inargs.values.push(...Array(this.vararg).fill("vararg"));
    }
    return inargs;
  }
  toFunctionBindString() {
    let res = "";
    res += "i".repeat(this.int);
    res += "l".repeat(this.long);
    res += "s".repeat(this.string);
    if (this.vararg != 0) {
      throw new Error("vararg not supported");
    }
    return res;
  }
  toTypeScriptVarlist(nameoffset, withnames, withtypes, exacttype) {
    let res = "";
    for (let i = 0; i < this.int; i++) {
      if (withnames) {
        res += `int${nameoffset.int}${withtypes ? ": " : ""}`;
      }
      if (withtypes) {
        res += exacttype ? subtypeToTs(exacttype.int[nameoffset.int]) : "number";
      }
      res += ", ";
      nameoffset.int++;
    }
    for (let i = 0; i < this.long; i++) {
      if (withnames) {
        res += `long${nameoffset.long}${withtypes ? ": " : ""}`;
      }
      if (withtypes) {
        res += exacttype ? subtypeToTs(exacttype.long[nameoffset.long]) : "BigInt";
      }
      res += ", ";
      nameoffset.long++;
    }
    for (let i = 0; i < this.string; i++) {
      if (withnames) {
        res += `string${nameoffset.string}${withtypes ? ": " : ""}`;
      }
      if (withtypes) {
        res += exacttype ? subtypeToTs(exacttype.string[nameoffset.string]) : "string";
      }
      res += ", ";
      nameoffset.string++;
    }
    for (let i = 0; i < this.vararg; i++) {
      if (withnames) {
        res += `vararg${nameoffset.vararg}${withtypes ? ": " : ""}`;
      }
      if (withtypes) {
        res += "BoundFunction";
      }
      res += ", ";
      nameoffset.vararg++;
    }
    res = res.replace(/, $/, "");
    return res;
  }
};

// rsmv/src/libs/rshashnames.ts
var reverseHashes = /* @__PURE__ */ new Map([
  [1969878989, "emotes,40"],
  [2992884335, "hitsplat"],
  [2675166940, "emotes_locked,20"],
  [4136226178, "hint_headicons"],
  [880917333, "hint_mapmarkers"],
  [385880929, "hint_mapedge"],
  [2129339088, "magicon,0"],
  [2129339089, "magicon,1"],
  [2129339090, "magicon,2"],
  [2129339091, "magicon,3"],
  [2129339092, "magicon,4"],
  [2129339093, "magicon,5"],
  [2129339094, "magicon,6"],
  [2129339095, "magicon,7"],
  [2129339096, "magicon,8"],
  [2129339097, "magicon,9"],
  [1585002367, "magicon,10"],
  [1585002368, "magicon,11"],
  [1585002369, "magicon,12"],
  [1585002370, "magicon,13"],
  [1585002371, "magicon,14"],
  [1585002372, "magicon,15"],
  [1585002373, "magicon,16"],
  [1585002374, "magicon,17"],
  [1585002375, "magicon,18"],
  [1585002376, "magicon,19"],
  [1585002398, "magicon,20"],
  [1585002399, "magicon,21"],
  [1585002400, "magicon,22"],
  [1585002401, "magicon,23"],
  [1585002402, "magicon,24"],
  [1585002403, "magicon,25"],
  [1585002404, "magicon,26"],
  [1585002405, "magicon,27"],
  [1585002406, "magicon,28"],
  [1585002407, "magicon,29"],
  [1585002429, "magicon,30"],
  [1585002430, "magicon,31"],
  [1585002431, "magicon,32"],
  [1585002432, "magicon,33"],
  [1585002433, "magicon,34"],
  [1585002434, "magicon,35"],
  [1585002435, "magicon,36"],
  [1585002436, "magicon,37"],
  [1585002437, "magicon,38"],
  [1585002438, "magicon,39"],
  [1585002460, "magicon,40"],
  [1585002461, "magicon,41"],
  [1585002462, "magicon,42"],
  [1585002463, "magicon,43"],
  [1585002464, "magicon,44"],
  [1585002465, "magicon,45"],
  [1585002466, "magicon,46"],
  [1585002467, "magicon,47"],
  [1585002468, "magicon,48"],
  [1585002469, "magicon,49"],
  [950484242, "compass"],
  [2431330107, "miscgraphics,0"],
  [2431330108, "miscgraphics,1"],
  [2431330109, "miscgraphics,2"],
  [2431330110, "miscgraphics,3"],
  [2431330111, "miscgraphics,4"],
  [2431330112, "miscgraphics,5"],
  [2431330113, "miscgraphics,6"],
  [2431330114, "miscgraphics,7"],
  [2431330115, "miscgraphics,8"],
  [2431330116, "miscgraphics,9"],
  [2356789364, "miscgraphics,10"],
  [2356789365, "miscgraphics,11"],
  [2356789366, "miscgraphics,12"],
  [2356789367, "miscgraphics,13"],
  [2356789368, "miscgraphics,14"],
  [900197706, "staticons,0"],
  [900197707, "staticons,1"],
  [900197708, "staticons,2"],
  [900197709, "staticons,3"],
  [900197710, "staticons,4"],
  [900197711, "staticons,5"],
  [900197712, "staticons,6"],
  [900197713, "staticons,7"],
  [900197714, "staticons,8"],
  [900197715, "staticons,9"],
  [2136325189, "staticons,10"],
  [2136325190, "staticons,11"],
  [2136325191, "staticons,12"],
  [2136325192, "staticons,13"],
  [2136325193, "staticons,14"],
  [2136325194, "staticons,15"],
  [2136325195, "staticons,16"],
  [2136325196, "staticons,17"],
  [2136330800, "staticons2,0"],
  [2136330801, "staticons2,1"],
  [2136330802, "staticons2,2"],
  [2136330804, "staticons2,4"],
  [2136330805, "staticons2,5"],
  [2136330806, "staticons2,6"],
  [2136330807, "staticons2,7"],
  [500433066, "combaticons,0"],
  [500433067, "combaticons,1"],
  [500433068, "combaticons,2"],
  [500433069, "combaticons,3"],
  [500433070, "combaticons,4"],
  [500433071, "combaticons,5"],
  [500433072, "combaticons,6"],
  [500433073, "combaticons,7"],
  [500433074, "combaticons,8"],
  [500433075, "combaticons,9"],
  [2628523237, "combaticons,10"],
  [2628523238, "combaticons,11"],
  [2628523239, "combaticons,12"],
  [2628523240, "combaticons,13"],
  [2628523241, "combaticons,14"],
  [2628523242, "combaticons,15"],
  [2628523243, "combaticons,16"],
  [2628523244, "combaticons,17"],
  [2628523245, "combaticons,18"],
  [2628523246, "combaticons,19"],
  [2628528848, "combaticons2,0"],
  [2628528849, "combaticons2,1"],
  [2628528850, "combaticons2,2"],
  [2628528851, "combaticons2,3"],
  [2628528852, "combaticons2,4"],
  [2628528853, "combaticons2,5"],
  [2628528854, "combaticons2,6"],
  [2628528855, "combaticons2,7"],
  [2628528856, "combaticons2,8"],
  [2628528857, "combaticons2,9"],
  [4174983039, "combaticons2,10"],
  [4174983040, "combaticons2,11"],
  [4174983041, "combaticons2,12"],
  [4174983042, "combaticons2,13"],
  [4174983043, "combaticons2,14"],
  [4174983044, "combaticons2,15"],
  [4174983045, "combaticons2,16"],
  [4174983046, "combaticons2,17"],
  [4174983047, "combaticons2,18"],
  [4174983048, "combaticons2,19"],
  [3229435273, "combatboxes,0"],
  [3229435274, "combatboxes,1"],
  [3229435275, "combatboxes,2"],
  [3229435276, "combatboxes,3"],
  [738888631, "tradebacking"],
  [2986902419, "hitmarks"],
  [94935104, "cross"],
  [837204902, "mapdots"],
  [2371042572, "sworddecor,0"],
  [2371042573, "sworddecor,1"],
  [2371042574, "sworddecor,2"],
  [2371042575, "sworddecor,3"],
  [2368304475, "friendslist_font"],
  [1708131472, "tutorial_font"],
  [1743765602, "leftarrow"],
  [2909119341, "rightarrow"],
  [1585007978, "magicon2,0"],
  [1585007979, "magicon2,1"],
  [1585007980, "magicon2,2"],
  [1585007981, "magicon2,3"],
  [1585007982, "magicon2,4"],
  [1585007983, "magicon2,5"],
  [1585007984, "magicon2,6"],
  [1585007985, "magicon2,7"],
  [1585007986, "magicon2,8"],
  [1585007987, "magicon2,9"],
  [1890607141, "magicon2,10"],
  [1890607142, "magicon2,11"],
  [1890607143, "magicon2,12"],
  [1890607144, "magicon2,13"],
  [1890607145, "magicon2,14"],
  [1890607146, "magicon2,15"],
  [1890607147, "magicon2,16"],
  [1890607148, "magicon2,17"],
  [1890607149, "magicon2,18"],
  [1890607150, "magicon2,19"],
  [1890607172, "magicon2,20"],
  [1890607173, "magicon2,21"],
  [1890607174, "magicon2,22"],
  [1890607175, "magicon2,23"],
  [1890607176, "magicon2,24"],
  [1890607177, "magicon2,25"],
  [1890607178, "magicon2,26"],
  [1890607179, "magicon2,27"],
  [1890607180, "magicon2,28"],
  [1890607181, "magicon2,29"],
  [1890607203, "magicon2,30"],
  [1890607204, "magicon2,31"],
  [1890607205, "magicon2,32"],
  [1890607206, "magicon2,33"],
  [1890607207, "magicon2,34"],
  [1890607208, "magicon2,35"],
  [1890607209, "magicon2,36"],
  [1890607210, "magicon2,37"],
  [1890607211, "magicon2,38"],
  [1890607212, "magicon2,39"],
  [4110410652, "v2_stone_close_button,2"],
  [4110410653, "v2_stone_close_button,3"],
  [4110410654, "v2_stone_close_button,4"],
  [4110410655, "v2_stone_close_button,5"],
  [1014749829, "gnomeball_buttons,0"],
  [1014749830, "gnomeball_buttons,1"],
  [1014749831, "gnomeball_buttons,2"],
  [94839810, "coins"],
  [755433248, "headicons_pk"],
  [1170407052, "headicons_prayer"],
  [3639182885, "overlay_multiway"],
  [285466503, "overlay_duel"],
  [2658904862, "tex_brown"],
  [2876521593, "tex_red"],
  [3506388, "roof"],
  [1222630137, "leafytree"],
  [114464611, "railings"],
  [561438836, "fountain"],
  [4290304097, "cargonet"],
  [25205919, "elfroof2"],
  [3318248980, "welcome_font_small"],
  [2633212403, "elfroof"],
  [3311443016, "welcome_font_large"],
  [2898583284, "bamboo"],
  [1182935334, "willowtex3"],
  [1614826739, "mapletree"],
  [109757537, "stars"],
  [1318818808, "chainmail"],
  [2429813794, "lava_animated"],
  [1609617336, "red_green_arrows,0"],
  [2429794466, "hitbar_default"],
  [3952954078, "p11_full"],
  [3981583229, "p12_full"],
  [1057075019, "b12_full"],
  [3197789671, "q8_full"],
  [3327403, "logo"],
  [4124313204, "otherlevel"],
  [1890607240, "magicon2,46"],
  [1890607241, "magicon2,47"],
  [953669988, "mapdots_interface,0"],
  [953669989, "mapdots_interface,1"],
  [953669990, "mapdots_interface,2"],
  [953669991, "mapdots_interface,3"],
  [953669992, "mapdots_interface,4"],
  [2273419006, "cross_interface,0"],
  [2273419007, "cross_interface,1"],
  [2273419008, "cross_interface,2"],
  [2273419009, "cross_interface,3"],
  [2273419010, "cross_interface,4"],
  [2273419011, "cross_interface,5"],
  [2273419012, "cross_interface,6"],
  [2273419013, "cross_interface,7"],
  [2031924702, "headicons_pk_interface,0"],
  [2031924703, "headicons_pk_interface,1"],
  [2031924704, "headicons_pk_interface,2"],
  [2031924705, "headicons_pk_interface,3"],
  [2031924706, "headicons_pk_interface,4"],
  [2031924707, "headicons_pk_interface,5"],
  [2849529566, "hloading2"],
  [1867160429, "old_tiles"],
  [1609617337, "red_green_arrows,1"],
  [1328851774, "close_buttons,0"],
  [1328851775, "close_buttons,1"],
  [1328851776, "close_buttons,2"],
  [1328851777, "close_buttons,3"],
  [1328851778, "close_buttons,4"],
  [1328851779, "close_buttons,5"],
  [1328851780, "close_buttons,6"],
  [1328851781, "close_buttons,7"],
  [3008784350, "lunar_magic_on,0"],
  [3008784351, "lunar_magic_on,1"],
  [3008784352, "lunar_magic_on,2"],
  [3008784353, "lunar_magic_on,3"],
  [3008784354, "lunar_magic_on,4"],
  [3008784355, "lunar_magic_on,5"],
  [3008784356, "lunar_magic_on,6"],
  [3008784357, "lunar_magic_on,7"],
  [3008784358, "lunar_magic_on,8"],
  [3008784359, "lunar_magic_on,9"],
  [3078001713, "lunar_magic_on,10"],
  [3078001714, "lunar_magic_on,11"],
  [3078001715, "lunar_magic_on,12"],
  [3078001716, "lunar_magic_on,13"],
  [3078001717, "lunar_magic_on,14"],
  [3078001718, "lunar_magic_on,15"],
  [3078001719, "lunar_magic_on,16"],
  [3078001720, "lunar_magic_on,17"],
  [3078001721, "lunar_magic_on,18"],
  [3078001722, "lunar_magic_on,19"],
  [3078001744, "lunar_magic_on,20"],
  [3078001745, "lunar_magic_on,21"],
  [3078001746, "lunar_magic_on,22"],
  [3078001747, "lunar_magic_on,23"],
  [3078001748, "lunar_magic_on,24"],
  [3078001749, "lunar_magic_on,25"],
  [3078001750, "lunar_magic_on,26"],
  [3078001751, "lunar_magic_on,27"],
  [3078001752, "lunar_magic_on,28"],
  [3078001753, "lunar_magic_on,29"],
  [3078001775, "lunar_magic_on,30"],
  [3078001776, "lunar_magic_on,31"],
  [3078001777, "lunar_magic_on,32"],
  [3078001778, "lunar_magic_on,33"],
  [3078001779, "lunar_magic_on,34"],
  [3078001780, "lunar_magic_on,35"],
  [3078001781, "lunar_magic_on,36"],
  [3078001782, "lunar_magic_on,37"],
  [3078001783, "lunar_magic_on,38"],
  [3078001784, "lunar_magic_on,39"],
  [3078001806, "lunar_magic_on,40"],
  [1044900049, "tutorial_font_big"],
  [2196753399, "menu_font_small"],
  [2891766129, "old_tiles_lighter"],
  [1787935731, "quill_oblique_large"],
  [3929683415, "quill_caps_large"],
  [1157777820, "lunar_alphabet"],
  [24702590, "lunar_alphabet_lrg"],
  [3485068549, "combatboxes_large,0"],
  [3485068550, "combatboxes_large,1"],
  [3265888432, "combatboxes_very_large,0"],
  [3265888433, "combatboxes_very_large,1"],
  [303737213, "options_icons,0"],
  [303737214, "options_icons,1"],
  [303737215, "options_icons,2"],
  [303737216, "options_icons,3"],
  [303737217, "options_icons,4"],
  [303737218, "options_icons,5"],
  [303737219, "options_icons,6"],
  [303737220, "options_icons,7"],
  [303737221, "options_icons,8"],
  [303737222, "options_icons,9"],
  [825919090, "options_icons,10"],
  [825919091, "options_icons,11"],
  [825919092, "options_icons,12"],
  [825919093, "options_icons,13"],
  [825919094, "options_icons,14"],
  [825919095, "options_icons,15"],
  [825919096, "options_icons,16"],
  [825919097, "options_icons,17"],
  [1956141536, "options_radio_buttons,0"],
  [1956141537, "options_radio_buttons,1"],
  [1956141538, "options_radio_buttons,2"],
  [1171923135, "emotes,0"],
  [1171923136, "emotes,1"],
  [1171923137, "emotes,2"],
  [1171923138, "emotes,3"],
  [1171923139, "emotes,4"],
  [1171923140, "emotes,5"],
  [1171923141, "emotes,6"],
  [1171923142, "emotes,7"],
  [1171923143, "emotes,8"],
  [1171923144, "emotes,9"],
  [1969878896, "emotes,10"],
  [1969878897, "emotes,11"],
  [1969878898, "emotes,12"],
  [1969878899, "emotes,13"],
  [1969878900, "emotes,14"],
  [1969878901, "emotes,15"],
  [1969878902, "emotes,16"],
  [1969878903, "emotes,17"],
  [1969878904, "emotes,18"],
  [1969878905, "emotes,19"],
  [1969878927, "emotes,20"],
  [1969878928, "emotes,21"],
  [1969878929, "emotes,22"],
  [1969878930, "emotes,23"],
  [1969878931, "emotes,24"],
  [1969878932, "emotes,25"],
  [1969878933, "emotes,26"],
  [1969878934, "emotes,27"],
  [1969878935, "emotes,28"],
  [1969878936, "emotes,29"],
  [1969878958, "emotes,30"],
  [1969878959, "emotes,31"],
  [1969878960, "emotes,32"],
  [1969878961, "emotes,33"],
  [1969878962, "emotes,34"],
  [1969878963, "emotes,35"],
  [1969878964, "emotes,36"],
  [1969878965, "emotes,37"],
  [1969878966, "emotes,38"],
  [1969878967, "emotes,39"],
  [2025958354, "emotes_locked,0"],
  [2025958355, "emotes_locked,1"],
  [2025958356, "emotes_locked,2"],
  [2025958357, "emotes_locked,3"],
  [2025958358, "emotes_locked,4"],
  [2025958359, "emotes_locked,5"],
  [2025958360, "emotes_locked,6"],
  [2025958361, "emotes_locked,7"],
  [2025958362, "emotes_locked,8"],
  [2025958363, "emotes_locked,9"],
  [2675166909, "emotes_locked,10"],
  [2675166910, "emotes_locked,11"],
  [2675166911, "emotes_locked,12"],
  [2675166912, "emotes_locked,13"],
  [2675166913, "emotes_locked,14"],
  [2675166914, "emotes_locked,15"],
  [2675166915, "emotes_locked,16"],
  [2675166916, "emotes_locked,17"],
  [2675166917, "emotes_locked,18"],
  [2675166918, "emotes_locked,19"],
  [3762335482, "xmas_snowflake"],
  [2537929920, "barbassault_font"],
  [1185785869, "barbassault_icons,0"],
  [1185785870, "barbassault_icons,1"],
  [1185785871, "barbassault_icons,2"],
  [1185785872, "barbassault_icons,3"],
  [1185785873, "barbassault_icons,4"],
  [1185785874, "barbassault_icons,5"],
  [1185785875, "barbassault_icons,6"],
  [1185785876, "barbassault_icons,7"],
  [3805675385, "scrollbar_v2,0"],
  [962781051, "tzhaar_numbers"],
  [3386777705, "scales"],
  [4003908656, "feathers"],
  [1329954711, "topstat_icon,4"],
  [3805675386, "scrollbar_v2,1"],
  [197053880, "scrollbar_dragger_v2,0"],
  [197053881, "scrollbar_dragger_v2,1"],
  [197053882, "scrollbar_dragger_v2,2"],
  [197053883, "scrollbar_dragger_v2,3"],
  [1859825780, "scrollbar_parchment_v2,0"],
  [1859825781, "scrollbar_parchment_v2,1"],
  [3207353267, "scrollbar_parchment_dragger_v2,0"],
  [3207353268, "scrollbar_parchment_dragger_v2,1"],
  [3207353269, "scrollbar_parchment_dragger_v2,2"],
  [3207353270, "scrollbar_parchment_dragger_v2,3"],
  [4051286896, "peng_emotes,0"],
  [4051286897, "peng_emotes,1"],
  [4051286898, "peng_emotes,2"],
  [4051286899, "peng_emotes,3"],
  [4051286900, "peng_emotes,4"],
  [4051286901, "peng_emotes,5"],
  [4051286902, "peng_emotes,6"],
  [4051286903, "peng_emotes,7"],
  [1890607242, "magicon2,48"],
  [1890607243, "magicon2,49"],
  [1851754626, "surok_font"],
  [4110410650, "v2_stone_close_button,0"],
  [4110410651, "v2_stone_close_button,1"],
  [1083716754, "achievement_diary_icons,0"],
  [1083716755, "achievement_diary_icons,1"],
  [2387264634, "dream_monster_icon"],
  [2826396546, "ii_impling_icons,0"],
  [2826396547, "ii_impling_icons,1"],
  [2826396548, "ii_impling_icons,2"],
  [2826396549, "ii_impling_icons,3"],
  [2826396550, "ii_impling_icons,4"],
  [2826396551, "ii_impling_icons,5"],
  [2826396552, "ii_impling_icons,6"],
  [2826396553, "ii_impling_icons,7"],
  [2826396554, "ii_impling_icons,8"],
  [2826396555, "ii_impling_icons,9"],
  [1718947085, "ii_impling_icons,10"],
  [1718947086, "ii_impling_icons,11"],
  [1440119963, "ame_confirm_button,0"],
  [1440119964, "ame_confirm_button,1"],
  [2340648885, "bronze_border,0"],
  [825919098, "options_icons,18"],
  [1883892063, "exclamation_mark"],
  [2111304827, "warning_icons,0"],
  [2111304828, "warning_icons,1"],
  [2111304829, "warning_icons,2"],
  [2340648886, "bronze_border,1"],
  [2340648887, "bronze_border,2"],
  [2340648888, "bronze_border,3"],
  [2340648889, "bronze_border,4"],
  [452534144, "clan_chat_icons,0"],
  [452534145, "clan_chat_icons,1"],
  [452534146, "clan_chat_icons,2"],
  [452534147, "clan_chat_icons,3"],
  [452534148, "clan_chat_icons,4"],
  [452534149, "clan_chat_icons,5"],
  [452534150, "clan_chat_icons,6"],
  [452534151, "clan_chat_icons,7"],
  [452534152, "clan_chat_icons,8"],
  [422652266, "small_button"],
  [3588912159, "small_button_highlight"],
  [2926252559, "small_button_blue"],
  [736457293, "small_button_pressed"],
  [1890532674, "small_button_pressed_highlight"],
  [1694458038, "large_button"],
  [2391080043, "large_button_highlight"],
  [4153032334, "tradebacking_light"],
  [452534153, "clan_chat_icons,9"],
  [2013525114, "assist_overlay"],
  [3111128288, "staticons2_off,0"],
  [3111128289, "staticons2_off,1"],
  [3111128290, "staticons2_off,2"],
  [3111128292, "staticons2_off,4"],
  [3111128293, "staticons2_off,5"],
  [3111128294, "staticons2_off,6"],
  [3111128295, "staticons2_off,7"],
  [1246117048, "map_image"],
  [1400783165, "compass_ring"],
  [179009331, "map_ring"],
  [585464193, "radio_buttons,0"],
  [585464194, "radio_buttons,1"],
  [465118053, "bank_slot,0"],
  [465118054, "bank_slot,1"],
  [465118055, "bank_slot,2"],
  [465118056, "bank_slot,3"],
  [141184642, "bank_buttons,0"],
  [141184643, "bank_buttons,1"],
  [141184644, "bank_buttons,2"],
  [141184645, "bank_buttons,3"],
  [141184646, "bank_buttons,4"],
  [141184647, "bank_buttons,5"],
  [141184648, "bank_buttons,6"],
  [141184649, "bank_buttons,7"],
  [141184650, "bank_buttons,8"],
  [3347949, "mesh"],
  [67965397, "lore_icons,0"],
  [67965398, "lore_icons,1"],
  [67965399, "lore_icons,2"],
  [67965400, "lore_icons,3"],
  [67965401, "lore_icons,4"],
  [67965402, "lore_icons,5"],
  [67965403, "lore_icons,6"],
  [2031924708, "headicons_pk_interface,6"],
  [2031924709, "headicons_pk_interface,7"],
  [1329954707, "topstat_icon,0"],
  [1329954708, "topstat_icon,1"],
  [1329954709, "topstat_icon,2"],
  [1329954710, "topstat_icon,3"],
  [1969878995, "emotes,46"],
  [837261e3, "mapflag"],
  [3547865543, "floorshadows"],
  [141184651, "bank_buttons,9"],
  [81756685, "bank_buttons,10"],
  [81756686, "bank_buttons,11"],
  [81756687, "bank_buttons,12"],
  [81756688, "bank_buttons,13"],
  [81756689, "bank_buttons,14"],
  [81756690, "bank_buttons,15"],
  [81756691, "bank_buttons,16"],
  [81756692, "bank_buttons,17"],
  [1969878990, "emotes,41"],
  [2675166941, "emotes_locked,21"],
  [483200229, "bank_tabs,0"],
  [483200230, "bank_tabs,1"],
  [483200231, "bank_tabs,2"],
  [483200232, "bank_tabs,3"],
  [483200233, "bank_tabs,4"],
  [3880049766, "name_icons"],
  [2666305510, "overlay_multiway_big"],
  [1890607234, "magicon2,40"],
  [1890607235, "magicon2,41"],
  [1890607236, "magicon2,42"],
  [1890607237, "magicon2,43"],
  [1890607238, "magicon2,44"],
  [1890607239, "magicon2,45"],
  [1969878991, "emotes,42"],
  [1969878993, "emotes,44"],
  [2675166942, "emotes_locked,22"],
  [2675166943, "emotes_locked,23"],
  [2675166944, "emotes_locked,24"],
  [1969878994, "emotes,45"],
  [2675166945, "emotes_locked,25"],
  [1083716756, "achievement_diary_icons,2"],
  [1083716757, "achievement_diary_icons,3"],
  [1083716758, "achievement_diary_icons,4"],
  [1083716759, "achievement_diary_icons,5"],
  [2436182917, "bank_bag"],
  [2675166946, "emotes_locked,26"],
  [67965404, "lore_icons,7"],
  [81756693, "bank_buttons,18"],
  [1329954712, "topstat_icon,5"],
  [1329954713, "topstat_icon,6"],
  [2547340467, "login_tick"],
  [3078001807, "lunar_magic_on,41"],
  [695589409, "cursors,0"],
  [695589410, "cursors,1"],
  [695589411, "cursors,2"],
  [695589412, "cursors,3"],
  [695589413, "cursors,4"],
  [695589414, "cursors,5"],
  [695589415, "cursors,6"],
  [695589416, "cursors,7"],
  [695589417, "cursors,8"],
  [695589418, "cursors,9"],
  [88435278, "cursors,10"],
  [88435279, "cursors,11"],
  [88435280, "cursors,12"],
  [88435281, "cursors,13"],
  [88435282, "cursors,14"],
  [88435283, "cursors,15"],
  [88435284, "cursors,16"],
  [88435285, "cursors,17"],
  [88435286, "cursors,18"],
  [88435287, "cursors,19"],
  [88435309, "cursors,20"],
  [88435310, "cursors,21"],
  [88435311, "cursors,22"],
  [88435312, "cursors,23"],
  [88435313, "cursors,24"],
  [88435314, "cursors,25"],
  [88435315, "cursors,26"],
  [88435316, "cursors,27"],
  [88435317, "cursors,28"],
  [88435318, "cursors,29"],
  [88435340, "cursors,30"],
  [88435341, "cursors,31"],
  [88435342, "cursors,32"],
  [88435343, "cursors,33"],
  [88435344, "cursors,34"],
  [88435345, "cursors,35"],
  [88435346, "cursors,36"],
  [88435347, "cursors,37"],
  [88435348, "cursors,38"],
  [88435349, "cursors,39"],
  [88435371, "cursors,40"],
  [88435372, "cursors,41"],
  [88435373, "cursors,42"],
  [88435374, "cursors,43"],
  [88435375, "cursors,44"],
  [88435376, "cursors,45"],
  [88435377, "cursors,46"],
  [88435378, "cursors,47"],
  [88435379, "cursors,48"],
  [88435380, "cursors,49"],
  [88435402, "cursors,50"],
  [88435403, "cursors,51"],
  [88435404, "cursors,52"],
  [88435405, "cursors,53"],
  [88435406, "cursors,54"],
  [88435407, "cursors,55"],
  [88435408, "cursors,56"],
  [88435409, "cursors,57"],
  [88435410, "cursors,58"],
  [88435411, "cursors,59"],
  [88435433, "cursors,60"],
  [88435434, "cursors,61"],
  [88435435, "cursors,62"],
  [88435436, "cursors,63"],
  [88435437, "cursors,64"],
  [88435438, "cursors,65"],
  [88435439, "cursors,66"],
  [88435440, "cursors,67"],
  [88435441, "cursors,68"],
  [88435442, "cursors,69"],
  [88435464, "cursors,70"],
  [88435465, "cursors,71"],
  [88435466, "cursors,72"],
  [88435467, "cursors,73"],
  [88435468, "cursors,74"],
  [88435469, "cursors,75"],
  [88435470, "cursors,76"],
  [88435471, "cursors,77"],
  [88435472, "cursors,78"],
  [88435473, "cursors,79"],
  [88435495, "cursors,80"],
  [88435496, "cursors,81"],
  [88435497, "cursors,82"],
  [88435498, "cursors,83"],
  [88435499, "cursors,84"],
  [88435500, "cursors,85"],
  [88435501, "cursors,86"],
  [88435502, "cursors,87"],
  [88435503, "cursors,88"],
  [88435504, "cursors,89"],
  [88435526, "cursors,90"],
  [88435527, "cursors,91"],
  [88435528, "cursors,92"],
  [88435529, "cursors,93"],
  [88435530, "cursors,94"],
  [88435531, "cursors,95"],
  [88435532, "cursors,96"],
  [88435533, "cursors,97"],
  [88435534, "cursors,98"],
  [88435535, "cursors,99"],
  [2741493666, "cursors,100"],
  [2741493667, "cursors,101"],
  [2741493668, "cursors,102"],
  [2741493669, "cursors,103"],
  [2741493670, "cursors,104"],
  [2741493671, "cursors,105"],
  [2741493672, "cursors,106"],
  [2741493673, "cursors,107"],
  [2741493674, "cursors,108"],
  [2741493675, "cursors,109"],
  [2741493697, "cursors,110"],
  [2741493698, "cursors,111"],
  [2741493699, "cursors,112"],
  [2741493700, "cursors,113"],
  [2741493701, "cursors,114"],
  [2741493702, "cursors,115"],
  [2741493703, "cursors,116"],
  [2741493704, "cursors,117"],
  [2741493705, "cursors,118"],
  [2741493706, "cursors,119"],
  [2741493728, "cursors,120"],
  [2741493729, "cursors,121"],
  [2741493730, "cursors,122"],
  [2741493731, "cursors,123"],
  [2741493732, "cursors,124"],
  [2741493733, "cursors,125"],
  [90507597, "gravestone_background"],
  [1764850592, "friends_changed_name"],
  [1969878996, "emotes,47"],
  [2675166947, "emotes_locked,27"],
  [3656616378, "quest_icon,0"],
  [3656616379, "quest_icon,1"],
  [3656616380, "quest_icon,2"],
  [3656616381, "quest_icon,3"],
  [3656616382, "quest_icon,4"],
  [3656616383, "quest_icon,5"],
  [3656616384, "quest_icon,6"],
  [3656616385, "quest_icon,7"],
  [3656616386, "quest_icon,8"],
  [3656616387, "quest_icon,9"],
  [1685958101, "quest_icon,10"],
  [1685958102, "quest_icon,11"],
  [1685958103, "quest_icon,12"],
  [1685958104, "quest_icon,13"],
  [1685958105, "quest_icon,14"],
  [1685958106, "quest_icon,15"],
  [1685958107, "quest_icon,16"],
  [1685958108, "quest_icon,17"],
  [1685958109, "quest_icon,18"],
  [1685958110, "quest_icon,19"],
  [1685958132, "quest_icon,20"],
  [1685958133, "quest_icon,21"],
  [1685958134, "quest_icon,22"],
  [1685958135, "quest_icon,23"],
  [1685958136, "quest_icon,24"],
  [1685958137, "quest_icon,25"],
  [1969878997, "emotes,48"],
  [2675166948, "emotes_locked,28"],
  [1718947087, "ii_impling_icons,12"],
  [1718947088, "ii_impling_icons,13"],
  [1718947089, "ii_impling_icons,14"],
  [3378698595, "loadingwheel,0"],
  [3378698596, "loadingwheel,1"],
  [3378698597, "loadingwheel,2"],
  [3378698598, "loadingwheel,3"],
  [3378698599, "loadingwheel,4"],
  [3378698600, "loadingwheel,5"],
  [3378698601, "loadingwheel,6"],
  [3378698602, "loadingwheel,7"],
  [3378698603, "loadingwheel,8"],
  [3378698604, "loadingwheel,9"],
  [1660441420, "loadingwheel,10"],
  [1660441421, "loadingwheel,11"],
  [1660441422, "loadingwheel,12"],
  [1660441423, "loadingwheel,13"],
  [2046729299, "welcome_font_tiny"],
  [2830983928, "xp_token,2"],
  [2830983929, "xp_token,3"],
  [2830983926, "xp_token,0"],
  [2830983927, "xp_token,1"],
  [153728854, "easter_colours,0"],
  [153728855, "easter_colours,1"],
  [153728856, "easter_colours,2"],
  [153728857, "easter_colours,3"],
  [153728858, "easter_colours,4"],
  [153728859, "easter_colours,5"],
  [153728860, "easter_colours,6"],
  [153728861, "easter_colours,7"],
  [153728862, "easter_colours,8"],
  [153728863, "easter_colours,9"],
  [470627257, "easter_colours,10"],
  [470627258, "easter_colours,11"],
  [953669993, "mapdots_interface,5"],
  [953669994, "mapdots_interface,6"],
  [4153510063, "rand_map_rooms_off,0"],
  [4153510064, "rand_map_rooms_off,1"],
  [4153510065, "rand_map_rooms_off,2"],
  [4153510066, "rand_map_rooms_off,3"],
  [4153510067, "rand_map_rooms_off,4"],
  [4153510068, "rand_map_rooms_off,5"],
  [4153510069, "rand_map_rooms_off,6"],
  [4153510070, "rand_map_rooms_off,7"],
  [4153510071, "rand_map_rooms_off,8"],
  [4153510072, "rand_map_rooms_off,9"],
  [4204760448, "rand_map_rooms_off,10"],
  [4204760449, "rand_map_rooms_off,11"],
  [4204760450, "rand_map_rooms_off,12"],
  [4204760451, "rand_map_rooms_off,13"],
  [4204760452, "rand_map_rooms_off,14"],
  [4204760453, "rand_map_rooms_off,15"],
  [4204760454, "rand_map_rooms_off,16"],
  [4204760455, "rand_map_rooms_off,17"],
  [4204760456, "rand_map_rooms_off,18"],
  [3320578727, "rand_map_rooms_on,0"],
  [3320578728, "rand_map_rooms_on,1"],
  [3320578729, "rand_map_rooms_on,2"],
  [3320578730, "rand_map_rooms_on,3"],
  [3320578731, "rand_map_rooms_on,4"],
  [3320578732, "rand_map_rooms_on,5"],
  [3320578733, "rand_map_rooms_on,6"],
  [3320578734, "rand_map_rooms_on,7"],
  [3320578735, "rand_map_rooms_on,8"],
  [3320578736, "rand_map_rooms_on,9"],
  [4153692808, "rand_map_rooms_on,10"],
  [4153692809, "rand_map_rooms_on,11"],
  [4153692810, "rand_map_rooms_on,12"],
  [4153692811, "rand_map_rooms_on,13"],
  [4153692812, "rand_map_rooms_on,14"],
  [4153692813, "rand_map_rooms_on,15"],
  [4153692814, "rand_map_rooms_on,16"],
  [4153692815, "rand_map_rooms_on,17"],
  [4153692816, "rand_map_rooms_on,18"],
  [164497227, "rand_map_background"],
  [2178727222, "rand_map_room_special,0"],
  [2178727223, "rand_map_room_special,1"],
  [2178727224, "rand_map_room_special,2"],
  [3383183810, "rand_death_icon,0"],
  [3383183811, "rand_death_icon,1"],
  [1416173308, "rand_journal_read,0"],
  [1416173309, "rand_journal_read,1"],
  [1416173310, "rand_journal_read,2"],
  [1416173311, "rand_journal_read,3"],
  [1416173312, "rand_journal_read,4"],
  [1416173313, "rand_journal_read,5"],
  [1416173314, "rand_journal_read,6"],
  [1416173315, "rand_journal_read,7"],
  [1416173316, "rand_journal_read,8"],
  [698044768, "rand_button_glow"],
  [949071073, "rand_checkbox,0"],
  [949071074, "rand_checkbox,1"],
  [949071075, "rand_checkbox,2"],
  [949071076, "rand_checkbox,3"],
  [1801745442, "staticons2,13"],
  [1955696498, "staticons2_off,13"],
  [1890607265, "magicon2,50"],
  [1890607266, "magicon2,51"],
  [3078001841, "lunar_magic_on,54"],
  [3078001842, "lunar_magic_on,55"],
  [3078001843, "lunar_magic_on,56"],
  [3078001844, "lunar_magic_on,57"],
  [1399804477, "conq_arrow,0"],
  [1399804478, "conq_arrow,1"],
  [3886328121, "female_hair,0"],
  [3886328122, "female_hair,1"],
  [3886328123, "female_hair,2"],
  [3886328124, "female_hair,3"],
  [3886328125, "female_hair,4"],
  [3886328126, "female_hair,5"],
  [3886328127, "female_hair,6"],
  [3886328128, "female_hair,7"],
  [3886328129, "female_hair,8"],
  [3886328130, "female_hair,9"],
  [217087542, "female_hair,10"],
  [217087543, "female_hair,11"],
  [217087544, "female_hair,12"],
  [217087545, "female_hair,13"],
  [217087546, "female_hair,14"],
  [217087547, "female_hair,15"],
  [217087548, "female_hair,16"],
  [217087549, "female_hair,17"],
  [217087550, "female_hair,18"],
  [217087551, "female_hair,19"],
  [217087573, "female_hair,20"],
  [217087574, "female_hair,21"],
  [217087575, "female_hair,22"],
  [217087576, "female_hair,23"],
  [217087577, "female_hair,24"],
  [217087578, "female_hair,25"],
  [217087579, "female_hair,26"],
  [217087580, "female_hair,27"],
  [217087581, "female_hair,28"],
  [217087582, "female_hair,29"],
  [217087604, "female_hair,30"],
  [217087605, "female_hair,31"],
  [217087606, "female_hair,32"],
  [217087607, "female_hair,33"],
  [2686410948, "female_torso,0"],
  [2686410949, "female_torso,1"],
  [2686410950, "female_torso,2"],
  [2686410951, "female_torso,3"],
  [2686410952, "female_torso,4"],
  [2686410953, "female_torso,5"],
  [2686410954, "female_torso,6"],
  [2686410955, "female_torso,7"],
  [2686410956, "female_torso,8"],
  [2686410957, "female_torso,9"],
  [1674360843, "female_torso,10"],
  [1674360844, "female_torso,11"],
  [1674360845, "female_torso,12"],
  [1674360846, "female_torso,13"],
  [1674360847, "female_torso,14"],
  [1674360848, "female_torso,15"],
  [1674360849, "female_torso,16"],
  [1674360850, "female_torso,17"],
  [1674360851, "female_torso,18"],
  [1674360852, "female_torso,19"],
  [1674360874, "female_torso,20"],
  [1674360875, "female_torso,21"],
  [1674360876, "female_torso,22"],
  [1674360877, "female_torso,23"],
  [1674360878, "female_torso,24"],
  [1674360879, "female_torso,25"],
  [1674360880, "female_torso,26"],
  [1674360881, "female_torso,27"],
  [1674360882, "female_torso,28"],
  [1674360883, "female_torso,29"],
  [1674360905, "female_torso,30"],
  [1674360906, "female_torso,31"],
  [4004480188, "female_legs,0"],
  [4004480189, "female_legs,1"],
  [4004480190, "female_legs,2"],
  [4004480191, "female_legs,3"],
  [4004480192, "female_legs,4"],
  [4004480193, "female_legs,5"],
  [4004480194, "female_legs,6"],
  [4004480195, "female_legs,7"],
  [4004480196, "female_legs,8"],
  [4004480197, "female_legs,9"],
  [3879801619, "female_legs,10"],
  [3879801620, "female_legs,11"],
  [3879801621, "female_legs,12"],
  [3879801622, "female_legs,13"],
  [3879801623, "female_legs,14"],
  [3879801624, "female_legs,15"],
  [3879801625, "female_legs,16"],
  [3879801626, "female_legs,17"],
  [3879801627, "female_legs,18"],
  [3879801628, "female_legs,19"],
  [3879801650, "female_legs,20"],
  [3879801651, "female_legs,21"],
  [3879801652, "female_legs,22"],
  [3879801653, "female_legs,23"],
  [3879801654, "female_legs,24"],
  [3879801655, "female_legs,25"],
  [3879801656, "female_legs,26"],
  [3879801657, "female_legs,27"],
  [3879801658, "female_legs,28"],
  [3879801659, "female_legs,29"],
  [3879801681, "female_legs,30"],
  [3879801682, "female_legs,31"],
  [2282715781, "male_torso,0"],
  [2282715782, "male_torso,1"],
  [2282715783, "male_torso,2"],
  [2282715784, "male_torso,3"],
  [2282715785, "male_torso,4"],
  [2282715786, "male_torso,5"],
  [2282715787, "male_torso,6"],
  [2282715788, "male_torso,7"],
  [2282715789, "male_torso,8"],
  [2282715790, "male_torso,9"],
  [2044712554, "male_torso,10"],
  [2044712555, "male_torso,11"],
  [2044712556, "male_torso,12"],
  [2044712557, "male_torso,13"],
  [2044712558, "male_torso,14"],
  [2044712559, "male_torso,15"],
  [2044712560, "male_torso,16"],
  [2044712561, "male_torso,17"],
  [2044712562, "male_torso,18"],
  [2044712563, "male_torso,19"],
  [2044712585, "male_torso,20"],
  [2044712586, "male_torso,21"],
  [2044712587, "male_torso,22"],
  [2044712588, "male_torso,23"],
  [2044712589, "male_torso,24"],
  [2044712590, "male_torso,25"],
  [2044712591, "male_torso,26"],
  [2044712592, "male_torso,27"],
  [2044712593, "male_torso,28"],
  [2044712594, "male_torso,29"],
  [2044712616, "male_torso,30"],
  [2044712617, "male_torso,31"],
  [2044712618, "male_torso,32"],
  [217087608, "female_hair,34"],
  [217087609, "female_hair,35"],
  [217087610, "female_hair,36"],
  [217087611, "female_hair,37"],
  [217087612, "female_hair,38"],
  [217087613, "female_hair,39"],
  [3596211032, "male_hair,0"],
  [3596211033, "male_hair,1"],
  [3596211034, "male_hair,2"],
  [3596211035, "male_hair,3"],
  [3596211036, "male_hair,4"],
  [3596211037, "male_hair,5"],
  [3596211038, "male_hair,6"],
  [3596211039, "male_hair,7"],
  [3596211040, "male_hair,8"],
  [3596211041, "male_hair,9"],
  [4108359671, "male_hair,10"],
  [4108359672, "male_hair,11"],
  [4108359673, "male_hair,12"],
  [4108359674, "male_hair,13"],
  [4108359675, "male_hair,14"],
  [4108359676, "male_hair,15"],
  [4108359677, "male_hair,16"],
  [3714363099, "male_legs,0"],
  [3714363100, "male_legs,1"],
  [3714363101, "male_legs,2"],
  [3714363102, "male_legs,3"],
  [3714363103, "male_legs,4"],
  [3714363104, "male_legs,5"],
  [3714363105, "male_legs,6"],
  [3714363106, "male_legs,7"],
  [3714363107, "male_legs,8"],
  [3714363108, "male_legs,9"],
  [3476106452, "male_legs,10"],
  [3476106453, "male_legs,11"],
  [3476106454, "male_legs,12"],
  [3476106455, "male_legs,13"],
  [3476106456, "male_legs,14"],
  [3476106457, "male_legs,15"],
  [3476106458, "male_legs,16"],
  [3476106459, "male_legs,17"],
  [3476106460, "male_legs,18"],
  [3476106461, "male_legs,19"],
  [3476106483, "male_legs,20"],
  [3476106484, "male_legs,21"],
  [3476106485, "male_legs,22"],
  [3476106486, "male_legs,23"],
  [3476106487, "male_legs,24"],
  [3476106488, "male_legs,25"],
  [3476106489, "male_legs,26"],
  [3476106490, "male_legs,27"],
  [3476106491, "male_legs,28"],
  [3476106492, "male_legs,29"],
  [3476106514, "male_legs,30"],
  [3476106515, "male_legs,31"],
  [1969878998, "emotes,49"],
  [2675166949, "emotes_locked,29"],
  [1585002491, "magicon,50"],
  [4120166957, "verdana_11pt_regular"],
  [1227328817, "verdana_15pt_regular"],
  [3963936616, "cursors_skills,0"],
  [3963936617, "cursors_skills,1"],
  [3963936619, "cursors_skills,3"],
  [3963936622, "cursors_skills,6"],
  [3963936625, "cursors_skills,9"],
  [2622950887, "cursors_skills,10"],
  [2622950888, "cursors_skills,11"],
  [2622950889, "cursors_skills,12"],
  [2622950890, "cursors_skills,13"],
  [2622950891, "cursors_skills,14"],
  [2622950894, "cursors_skills,17"],
  [2622950895, "cursors_skills,18"],
  [2622950919, "cursors_skills,21"],
  [2622950920, "cursors_skills,22"],
  [2622950921, "cursors_skills,23"],
  [2622950922, "cursors_skills,24"],
  [2622950923, "cursors_skills,25"],
  [2622950924, "cursors_skills,26"],
  [2622950925, "cursors_skills,27"],
  [3078001845, "lunar_magic_on,58"],
  [2622950927, "cursors_skills,29"],
  [2622950949, "cursors_skills,30"],
  [2622950950, "cursors_skills,31"],
  [2622950951, "cursors_skills,32"],
  [2622950952, "cursors_skills,33"],
  [3078001846, "lunar_magic_on,59"],
  [2622950954, "cursors_skills,35"],
  [2622950955, "cursors_skills,36"],
  [1969879020, "emotes,50"],
  [1969879021, "emotes,51"],
  [2675166971, "emotes_locked,30"],
  [3991971121, "cursors_spells,0"],
  [3991971122, "cursors_spells,1"],
  [3991971123, "cursors_spells,2"],
  [3991971124, "cursors_spells,3"],
  [3991971125, "cursors_spells,4"],
  [3991971126, "cursors_spells,5"],
  [3991971127, "cursors_spells,6"],
  [3991971128, "cursors_spells,7"],
  [3991971129, "cursors_spells,8"],
  [3991971130, "cursors_spells,9"],
  [3492020542, "cursors_spells,10"],
  [3492020543, "cursors_spells,11"],
  [3492020544, "cursors_spells,12"],
  [3492020545, "cursors_spells,13"],
  [3492020546, "cursors_spells,14"],
  [3492020547, "cursors_spells,15"],
  [3492020548, "cursors_spells,16"],
  [3492020549, "cursors_spells,17"],
  [3492020550, "cursors_spells,18"],
  [3492020551, "cursors_spells,19"],
  [3492020573, "cursors_spells,20"],
  [3492020574, "cursors_spells,21"],
  [3492020575, "cursors_spells,22"],
  [3492020576, "cursors_spells,23"],
  [3492020577, "cursors_spells,24"],
  [3492020578, "cursors_spells,25"],
  [3492020579, "cursors_spells,26"],
  [3492020580, "cursors_spells,27"],
  [3492020581, "cursors_spells,28"],
  [3492020582, "cursors_spells,29"],
  [3492020604, "cursors_spells,30"],
  [3492020605, "cursors_spells,31"],
  [3492020606, "cursors_spells,32"],
  [3492020607, "cursors_spells,33"],
  [3492020608, "cursors_spells,34"],
  [3492020609, "cursors_spells,35"],
  [3492020610, "cursors_spells,36"],
  [3492020611, "cursors_spells,37"],
  [3492020612, "cursors_spells,38"],
  [3492020613, "cursors_spells,39"],
  [3492020635, "cursors_spells,40"],
  [3492020636, "cursors_spells,41"],
  [3492020637, "cursors_spells,42"],
  [3492020638, "cursors_spells,43"],
  [3492020639, "cursors_spells,44"],
  [3492020640, "cursors_spells,45"],
  [3492020641, "cursors_spells,46"],
  [3492020642, "cursors_spells,47"],
  [3492020643, "cursors_spells,48"],
  [3492020644, "cursors_spells,49"],
  [3492020666, "cursors_spells,50"],
  [3492020667, "cursors_spells,51"],
  [3492020668, "cursors_spells,52"],
  [3492020669, "cursors_spells,53"],
  [3492020670, "cursors_spells,54"],
  [3492020671, "cursors_spells,55"],
  [3492020672, "cursors_spells,56"],
  [3492020673, "cursors_spells,57"],
  [3492020674, "cursors_spells,58"],
  [3492020675, "cursors_spells,59"],
  [3492020697, "cursors_spells,60"],
  [3492020698, "cursors_spells,61"],
  [3492020699, "cursors_spells,62"],
  [3492020700, "cursors_spells,63"],
  [3492020701, "cursors_spells,64"],
  [3492020702, "cursors_spells,65"],
  [3492020703, "cursors_spells,66"],
  [3492020704, "cursors_spells,67"],
  [3492020705, "cursors_spells,68"],
  [3492020706, "cursors_spells,69"],
  [3492020728, "cursors_spells,70"],
  [3492020729, "cursors_spells,71"],
  [3492020730, "cursors_spells,72"],
  [3492020731, "cursors_spells,73"],
  [3492020732, "cursors_spells,74"],
  [3492020733, "cursors_spells,75"],
  [3492020734, "cursors_spells,76"],
  [3492020735, "cursors_spells,77"],
  [3492020736, "cursors_spells,78"],
  [3492020737, "cursors_spells,79"],
  [3492020759, "cursors_spells,80"],
  [918083513, "cursors_generic,0"],
  [918083514, "cursors_generic,1"],
  [918083515, "cursors_generic,2"],
  [918083516, "cursors_generic,3"],
  [918083517, "cursors_generic,4"],
  [918083518, "cursors_generic,5"],
  [918083519, "cursors_generic,6"],
  [918083520, "cursors_generic,7"],
  [918083521, "cursors_generic,8"],
  [918083522, "cursors_generic,9"],
  [2690785206, "cursors_generic,10"],
  [2690785207, "cursors_generic,11"],
  [2690785208, "cursors_generic,12"],
  [2690785209, "cursors_generic,13"],
  [2690785210, "cursors_generic,14"],
  [2690785211, "cursors_generic,15"],
  [2690785212, "cursors_generic,16"],
  [2690785213, "cursors_generic,17"],
  [2690785214, "cursors_generic,18"],
  [2690785215, "cursors_generic,19"],
  [2690785237, "cursors_generic,20"],
  [2690785238, "cursors_generic,21"],
  [2690785239, "cursors_generic,22"],
  [2690785240, "cursors_generic,23"],
  [2690785241, "cursors_generic,24"],
  [2690785242, "cursors_generic,25"],
  [2690785243, "cursors_generic,26"],
  [2690785244, "cursors_generic,27"],
  [2690785245, "cursors_generic,28"],
  [2690785246, "cursors_generic,29"],
  [2690785268, "cursors_generic,30"],
  [2690785269, "cursors_generic,31"],
  [2690785270, "cursors_generic,32"],
  [2690785271, "cursors_generic,33"],
  [2690785272, "cursors_generic,34"],
  [2690785273, "cursors_generic,35"],
  [2690785274, "cursors_generic,36"],
  [2690785275, "cursors_generic,37"],
  [2690785276, "cursors_generic,38"],
  [2690785277, "cursors_generic,39"],
  [2690785299, "cursors_generic,40"],
  [2690785300, "cursors_generic,41"],
  [2690785301, "cursors_generic,42"],
  [2690785302, "cursors_generic,43"],
  [2690785303, "cursors_generic,44"],
  [2690785304, "cursors_generic,45"],
  [2690785305, "cursors_generic,46"],
  [526264239, "verdana_13pt_regular"],
  [3078001868, "lunar_magic_on,60"],
  [3078001869, "lunar_magic_on,61"],
  [857796910, "shields,0"],
  [857796911, "shields,1"],
  [857796912, "shields,2"],
  [857796913, "shields,3"],
  [857796914, "shields,4"],
  [857796915, "shields,5"],
  [857796916, "shields,6"],
  [857796917, "shields,7"],
  [857796918, "shields,8"],
  [857796919, "shields,9"],
  [821900513, "shields,10"],
  [821900514, "shields,11"],
  [821900515, "shields,12"],
  [821900516, "shields,13"],
  [821900517, "shields,14"],
  [821900518, "shields,15"],
  [821900519, "shields,16"],
  [821900520, "shields,17"],
  [821900521, "shields,18"],
  [821900522, "shields,19"],
  [821900544, "shields,20"],
  [821900545, "shields,21"],
  [821900546, "shields,22"],
  [821900547, "shields,23"],
  [821900548, "shields,24"],
  [821900549, "shields,25"],
  [821900550, "shields,26"],
  [821900551, "shields,27"],
  [1969879022, "emotes,52"],
  [2675166972, "emotes_locked,31"],
  [2675166973, "emotes_locked,32"],
  [3078001808, "lunar_magic_on,42"],
  [3078001809, "lunar_magic_on,43"],
  [3078001810, "lunar_magic_on,44"],
  [3078001811, "lunar_magic_on,45"],
  [3078001812, "lunar_magic_on,46"],
  [3078001813, "lunar_magic_on,47"],
  [3078001814, "lunar_magic_on,48"],
  [3078001815, "lunar_magic_on,49"],
  [1376903010, "roles_d"],
  [1376903011, "roles_e"],
  [1376903012, "roles_f"],
  [1376903013, "roles_g"],
  [1376903014, "roles_h"],
  [1376903015, "roles_i"],
  [1376903016, "roles_j"],
  [1376903017, "roles_k"],
  [1376903018, "roles_l"],
  [1376903019, "roles_m"],
  [1969879058, "emotes,67"],
  [2675167009, "emotes_locked,47"],
  [1969879023, "emotes,53"],
  [2690785306, "cursors_generic,47"],
  [1969879024, "emotes,54"],
  [1969879025, "emotes,55"],
  [1969879026, "emotes,56"],
  [1969879027, "emotes,57"],
  [1969879028, "emotes,58"],
  [1969879029, "emotes,59"],
  [1969879051, "emotes,60"],
  [1969879052, "emotes,61"],
  [1969879053, "emotes,62"],
  [1969879054, "emotes,63"],
  [1969879055, "emotes,64"],
  [1969879056, "emotes,65"],
  [1969879057, "emotes,66"],
  [2675166974, "emotes_locked,33"],
  [2675166975, "emotes_locked,34"],
  [2675166976, "emotes_locked,35"],
  [2675166977, "emotes_locked,36"],
  [2675166978, "emotes_locked,37"],
  [2675166979, "emotes_locked,38"],
  [2675166980, "emotes_locked,39"],
  [2675167002, "emotes_locked,40"],
  [2675167003, "emotes_locked,41"],
  [2675167004, "emotes_locked,42"],
  [2675167006, "emotes_locked,44"],
  [2675167007, "emotes_locked,45"],
  [2675167008, "emotes_locked,46"],
  [1959803992, "invback"],
  [3078001837, "lunar_magic_on,50"],
  [3078001838, "lunar_magic_on,51"],
  [3078001839, "lunar_magic_on,52"],
  [3078001840, "lunar_magic_on,53"],
  [1585002492, "magicon,51"],
  [1969879059, "emotes,68"],
  [1969879060, "emotes,69"],
  [1969879082, "emotes,70"],
  [1969879083, "emotes,71"],
  [1969879084, "emotes,72"],
  [1969879085, "emotes,73"],
  [1969879086, "emotes,74"],
  [1969879087, "emotes,75"],
  [2675167010, "emotes_locked,48"],
  [2675167011, "emotes_locked,49"],
  [2675167033, "emotes_locked,50"],
  [2675167034, "emotes_locked,51"],
  [2675167035, "emotes_locked,52"],
  [2675167036, "emotes_locked,53"],
  [2675167037, "emotes_locked,54"],
  [2675167038, "emotes_locked,55"],
  [825919099, "options_icons,19"],
  [860008241, "compassmask_2"],
  [1969879088, "emotes,76"],
  [1969879089, "emotes,77"],
  [1969879090, "emotes,78"],
  [1969879091, "emotes,79"],
  [1969879113, "emotes,80"],
  [1969879114, "emotes,81"],
  [1969879115, "emotes,82"],
  [1969879116, "emotes,83"],
  [2675167039, "emotes_locked,56"],
  [2675167040, "emotes_locked,57"],
  [2675167041, "emotes_locked,58"],
  [2675167042, "emotes_locked,59"],
  [2675167064, "emotes_locked,60"],
  [2675167065, "emotes_locked,61"],
  [2675167066, "emotes_locked,62"],
  [2675167067, "emotes_locked,63"],
  [2031924710, "headicons_pk_interface,8"],
  [2031924711, "headicons_pk_interface,9"],
  [2860123697, "headicons_pk_interface,10"],
  [2860123698, "headicons_pk_interface,11"],
  [2860123699, "headicons_pk_interface,12"],
  [2860123700, "headicons_pk_interface,13"],
  [2356789369, "miscgraphics,15"],
  [2356789370, "miscgraphics,16"],
  [2356789371, "miscgraphics,17"],
  [1801745443, "staticons2,14"],
  [1955696499, "staticons2_off,14"],
  [2628523268, "combaticons,20"],
  [2628523269, "combaticons,21"],
  [2628523270, "combaticons,22"],
  [2628523271, "combaticons,23"],
  [2628523272, "combaticons,24"],
  [2628523273, "combaticons,25"],
  [2628523274, "combaticons,26"],
  [2628523275, "combaticons,27"],
  [2628523276, "combaticons,28"],
  [2628523277, "combaticons,29"],
  [3485068551, "combatboxes_large,2"],
  [3485068552, "combatboxes_large,3"],
  [3265888434, "combatboxes_very_large,2"],
  [3265888435, "combatboxes_very_large,3"],
  [2356789372, "miscgraphics,18"],
  [2356789373, "miscgraphics,19"],
  [3078001870, "lunar_magic_on,62"],
  [3078001871, "lunar_magic_on,63"],
  [3078001872, "lunar_magic_on,64"],
  [3078001873, "lunar_magic_on,65"],
  [821900552, "shields,28"],
  [821900553, "shields,29"],
  [821900575, "shields,30"],
  [821900576, "shields,31"],
  [821900577, "shields,32"],
  [821900578, "shields,33"],
  [821900579, "shields,34"],
  [821900580, "shields,35"],
  [821900581, "shields,36"],
  [821900582, "shields,37"],
  [821900583, "shields,38"],
  [821900584, "shields,39"],
  [821900606, "shields,40"],
  [821900607, "shields,41"],
  [821900608, "shields,42"],
  [821900609, "shields,43"],
  [821900610, "shields,44"],
  [821900611, "shields,45"],
  [821900612, "shields,46"],
  [821900613, "shields,47"],
  [821900614, "shields,48"],
  [821900615, "shields,49"],
  [821900637, "shields,50"],
  [821900638, "shields,51"],
  [821900639, "shields,52"],
  [821900640, "shields,53"],
  [821900641, "shields,54"],
  [821900642, "shields,55"],
  [821900643, "shields,56"],
  [821900644, "shields,57"],
  [821900645, "shields,58"],
  [821900646, "shields,59"],
  [821900668, "shields,60"],
  [821900669, "shields,61"],
  [821900670, "shields,62"],
  [821900671, "shields,63"],
  [3078001874, "lunar_magic_on,66"],
  [1969879146, "emotes,92"],
  [1969879147, "emotes,93"],
  [825919121, "options_icons,20"],
  [825919122, "options_icons,21"],
  [1969879117, "emotes,84"],
  [1969879118, "emotes,85"],
  [1969879119, "emotes,86"],
  [1969879120, "emotes,87"],
  [2675167068, "emotes_locked,64"],
  [2675167069, "emotes_locked,65"],
  [2675167070, "emotes_locked,66"],
  [2675167071, "emotes_locked,67"],
  [1969879148, "emotes,94"],
  [1969879149, "emotes,95"],
  [2675167159, "emotes_locked,92"],
  [1660441424, "loadingwheel,14"],
  [1660441425, "loadingwheel,15"],
  [2818168646, "l192_49"],
  [2136330803, "staticons2,3"],
  [1801745444, "staticons2,15"],
  [1955696500, "staticons2_off,15"],
  [3963936618, "cursors_skills,2"],
  [3963936620, "cursors_skills,4"],
  [3963936621, "cursors_skills,5"],
  [2860123701, "headicons_pk_interface,14"],
  [2860123702, "headicons_pk_interface,15"],
  [3078001875, "lunar_magic_on,67"],
  [3078001876, "lunar_magic_on,68"],
  [3963936623, "cursors_skills,7"],
  [1536891843, "checkbox"],
  [1660441426, "loadingwheel,16"],
  [1583090068, "verdana_11pt_bold"],
  [773743442, "verdana_13pt_bold"],
  [3699237408, "m123_28"],
  [3078001877, "lunar_magic_on,69"],
  [3078001899, "lunar_magic_on,70"],
  [3492020760, "cursors_spells,81"],
  [3492020761, "cursors_spells,82"],
  [3492020762, "cursors_spells,83"],
  [3492020763, "cursors_spells,84"],
  [2860123703, "headicons_pk_interface,16"],
  [2860123704, "headicons_pk_interface,17"],
  [2860123705, "headicons_pk_interface,18"],
  [2860123706, "headicons_pk_interface,19"],
  [2690785307, "cursors_generic,48"],
  [3078001900, "lunar_magic_on,71"],
  [4108359678, "male_hair,17"],
  [4108359679, "male_hair,18"],
  [4108359680, "male_hair,19"],
  [4108359702, "male_hair,20"],
  [4108359703, "male_hair,21"],
  [4108359704, "male_hair,22"],
  [4108359705, "male_hair,23"],
  [4108359706, "male_hair,24"],
  [4108359707, "male_hair,25"],
  [4108359708, "male_hair,26"],
  [4108359709, "male_hair,27"],
  [4108359710, "male_hair,28"],
  [4108359711, "male_hair,29"],
  [4108359733, "male_hair,30"],
  [4108359734, "male_hair,31"],
  [3078001901, "lunar_magic_on,72"],
  [3078001902, "lunar_magic_on,73"],
  [3078001903, "lunar_magic_on,74"],
  [3805675387, "scrollbar_v2,2"],
  [3805675388, "scrollbar_v2,3"],
  [3805675389, "scrollbar_v2,4"],
  [3805675390, "scrollbar_v2,5"],
  [3805675391, "scrollbar_v2,6"],
  [3805675392, "scrollbar_v2,7"],
  [105001967, "nomad"],
  [3782377587, "zamorak"],
  [2622950956, "cursors_skills,37"],
  [1969879121, "emotes,88"],
  [1969879122, "emotes,89"],
  [1969879144, "emotes,90"],
  [1969879145, "emotes,91"],
  [2675167072, "emotes_locked,68"],
  [2675167073, "emotes_locked,69"],
  [2675167095, "emotes_locked,70"],
  [2675167096, "emotes_locked,71"],
  [2675167097, "emotes_locked,72"],
  [2675167098, "emotes_locked,73"],
  [2675167099, "emotes_locked,74"],
  [2675167100, "emotes_locked,75"],
  [2675167101, "emotes_locked,76"],
  [2675167102, "emotes_locked,77"],
  [2675167103, "emotes_locked,78"],
  [2675167104, "emotes_locked,79"],
  [2675167126, "emotes_locked,80"],
  [2675167127, "emotes_locked,81"],
  [2675167128, "emotes_locked,82"],
  [2675167129, "emotes_locked,83"],
  [2675167130, "emotes_locked,84"],
  [2675167131, "emotes_locked,85"],
  [2675167132, "emotes_locked,86"],
  [2675167133, "emotes_locked,87"],
  [2675167134, "emotes_locked,88"],
  [2675167135, "emotes_locked,89"],
  [2675167157, "emotes_locked,90"],
  [2675167158, "emotes_locked,91"],
  [2675167160, "emotes_locked,93"],
  [2675167161, "emotes_locked,94"],
  [2675167162, "emotes_locked,95"],
  [3532157, "skin"],
  [3138990, "feet"],
  [3441879594, "fingers"],
  [2690785308, "cursors_generic,49"],
  [2690785330, "cursors_generic,50"],
  [2690785331, "cursors_generic,51"],
  [2690785332, "cursors_generic,52"],
  [2690785333, "cursors_generic,53"],
  [1718947090, "ii_impling_icons,15"],
  [821900672, "shields,64"],
  [821900673, "shields,65"],
  [821900674, "shields,66"],
  [821900675, "shields,67"],
  [821900676, "shields,68"],
  [821900677, "shields,69"],
  [821900699, "shields,70"],
  [821900700, "shields,71"],
  [821900701, "shields,72"],
  [821900702, "shields,73"],
  [821900703, "shields,74"],
  [821900704, "shields,75"],
  [821900705, "shields,76"],
  [821900706, "shields,77"],
  [821900707, "shields,78"],
  [821900708, "shields,79"],
  [821900730, "shields,80"],
  [821900731, "shields,81"],
  [821900732, "shields,82"],
  [821900733, "shields,83"],
  [821900734, "shields,84"],
  [821900735, "shields,85"],
  [821900736, "shields,86"],
  [821900737, "shields,87"],
  [821900738, "shields,88"],
  [821900739, "shields,89"],
  [1969879150, "emotes,96"],
  [1969879151, "emotes,97"],
  [1969879152, "emotes,98"],
  [1969879153, "emotes,99"],
  [2675167163, "emotes_locked,96"],
  [2675167164, "emotes_locked,97"],
  [2675167165, "emotes_locked,98"],
  [2675167166, "emotes_locked,99"],
  [821900761, "shields,90"],
  [821900762, "shields,91"],
  [936703680, "emotes,100"],
  [936703681, "emotes,101"],
  [936703682, "emotes,102"],
  [936703683, "emotes,103"],
  [1325795603, "emotes_locked,100"],
  [1325795604, "emotes_locked,101"],
  [1325795605, "emotes_locked,102"],
  [1325795606, "emotes_locked,103"],
  [953669995, "mapdots_interface,7"],
  [953669996, "mapdots_interface,8"],
  [1718947091, "ii_impling_icons,16"],
  [821900763, "shields,92"],
  [821900764, "shields,93"],
  [821900765, "shields,94"],
  [821900766, "shields,95"],
  [104396, "k12"],
  [118, "v"],
  [2622950957, "cursors_skills,38"],
  [2622950958, "cursors_skills,39"],
  [2860123728, "headicons_pk_interface,20"],
  [2860123729, "headicons_pk_interface,21"],
  [2860123730, "headicons_pk_interface,22"],
  [1258058669, "huffman"],
  [1956833037, "[proc,quicksort]"],
  [345345464, "[proc,inv_total_available]"],
  [449115492, "[proc,worldmap_arrow_update]"],
  [209897848, "[clientscript,magic_deltooltip]"],
  [2688127745, "[clientscript,quickchat_tutorial_init]"],
  [3469354622, "[clientscript,magic_entertargetmode]"],
  [2152238399, "[clientscript,magic_leavetargetmode]"],
  [1268880597, "[proc,magic_runecount]"],
  [2487759364, "[proc,magic_tostring]"],
  [3839738228, "[clientscript,magictraining_shop]"],
  [3846245796, "[clientscript,magictraining_shop_points]"],
  [2666282981, "[clientscript,closebutton_click]"],
  [1741043411, "[clientscript,scrollbar_vertical]"],
  [2050974931, "[proc,scrollbar_vertical]"],
  [456153146, "[clientscript,scrollbar_vertical_jump]"],
  [450510836, "[clientscript,scrollbar_vertical_drag]"],
  [1615770487, "[clientscript,scrollbar_vertical_wheel]"],
  [4129357584, "[proc,scrollbar_vertical_doscroll]"],
  [2103178442, "[clientscript,deltooltip]"],
  [971155611, "[proc,deltooltip_action]"],
  [740865240, "[proc,bool_to_int]"],
  [1110526249, "[clientscript,trail_reward_generation]"],
  [1003841157, "[clientscript,graphic_swapper]"],
  [3237377935, "[clientscript,text_colour_swapper]"],
  [1910507737, "[proc,tostring_spacer]"],
  [3413408330, "[clientscript,prayer_varupdate]"],
  [309378350, "[clientscript,topstat_prayer_button_update]"],
  [3280976340, "[proc,toplevel_minimenu_setup]"],
  [3801005283, "[clientscript,prayer_statupdate]"],
  [2182721123, "[clientscript,wilderness_level_update]"],
  [682911585, "[clientscript,dream_bank_init]"],
  [2129584024, "[clientscript,dream_chest_init]"],
  [1869690317, "[proc,quicksort_enum]"],
  [1879461885, "[clientscript,scrollbar_vertical_graphics]"],
  [304324745, "[clientscript,vm_kudos_set]"],
  [3912481340, "[clientscript,set_spinner]"],
  [510688383, "[clientscript,spinner]"],
  [3256689188, "[clientscript,model_swapper]"],
  [4197695370, "[clientscript,text_swapper]"],
  [2705280302, "[clientscript,comp_sethide]"],
  [2462588638, "[clientscript,tzhaar_fightpit_foesremaining]"],
  [1140994645, "[proc,scrollbar_resize]"],
  [3381268237, "[proc,add_to_inputstring]"],
  [3525225400, "[clientscript,trail_puzzle_generation]"],
  [2613144708, "[clientscript,chatdefault_updatechatbox]"],
  [3973535466, "[proc,rebuildchatbox]"],
  [3956469840, "[clientscript,chat_op]"],
  [3335121156, "[clientscript,macro_pinball_score]"],
  [2763309555, "[clientscript,meslayer_close]"],
  [1613394365, "[proc,meslayer_mode1]"],
  [3052028892, "[clientscript,meslayer_mode2]"],
  [3052028923, "[clientscript,meslayer_mode3]"],
  [3052028954, "[clientscript,meslayer_mode4]"],
  [3630063234, "[clientscript,trail_puzzle_click]"],
  [1613394520, "[proc,meslayer_mode6]"],
  [3052029047, "[clientscript,meslayer_mode7]"],
  [3052029078, "[clientscript,meslayer_mode8]"],
  [3052029109, "[clientscript,meslayer_mode9]"],
  [2770583757, "[proc,meslayer_mode10]"],
  [3108574411, "[clientscript,meslayer_onkey]"],
  [3162289, "[clientscript,pattern_spin]"],
  [2075566599, "[clientscript,friend_init]"],
  [3932683111, "[clientscript,friend_transmit]"],
  [4236120302, "[proc,friend_update]"],
  [685963734, "[clientscript,friend_op]"],
  [2440977979, "[clientscript,ignore_init]"],
  [550403483, "[clientscript,ignore_transmit]"],
  [3209138210, "[proc,ignore_update]"],
  [3323212554, "[clientscript,ignore_op]"],
  [273048563, "[clientscript,snapshot_open]"],
  [104114097, "[proc,inzone]"],
  [2764466761, "[clientscript,snapshot_report]"],
  [812897378, "[clientscript,meslayer_ondialogabort]"],
  [2087073245, "[clientscript,subchanged_init]"],
  [1084222830, "[clientscript,subchanged]"],
  [125608312, "[clientscript,trade_confirm_init]"],
  [3204967375, "[clientscript,interface_flash_slot]"],
  [3192622865, "[clientscript,interface_flash_fade]"],
  [3547486718, "[clientscript,interface_inv_init]"],
  [3202579805, "[clientscript,interface_inv_init_big]"],
  [933940484, "[clientscript,interface_inv_update_big]"],
  [705264388, "[proc,interface_inv_update_big]"],
  [2438008882, "[proc,interface_inv_draw_slot_big]"],
  [3419540134, "[clientscript,interface_inv_dragcomplete_swap_big]"],
  [1112898470, "[clientscript,interface_inv_dragcomplete_shuffle_big]"],
  [4153282541, "[proc,scrollbar_ondrag_doscroll]"],
  [1752721326, "[clientscript,interface_invother_init]"],
  [2138822324, "[clientscript,interface_invother_update_big]"],
  [1125771444, "[proc,interface_invother_update_big]"],
  [1344111746, "[proc,interface_invother_draw_slot_big]"],
  [3143981379, "[clientscript,interface_inv_drag_slot]"],
  [2501495071, "[clientscript,cws_mouseover]"],
  [2234277979, "[clientscript,pattern_cards_select]"],
  [3004896417, "[clientscript,kr_mouseleave_colour]"],
  [1107414237, "[clientscript,kr_tumbler_height]"],
  [1693587891, "[clientscript,kr_display_riddle]"],
  [2608018646, "[clientscript,friends_chat_onload]"],
  [2024904380, "[clientscript,friendschat_setrank]"],
  [1938340776, "[clientscript,friendschat_list_op]"],
  [3276238774, "[clientscript,friends_chat_onclantransmit]"],
  [2430073087, "[clientscript,friends_chat_minimenu_timer]"],
  [1353093728, "[clientscript,snapshot_name_update]"],
  [373416259, "[clientscript,snapshot_ignore_yes]"],
  [3475718703, "[clientscript,snapshot_ignore_no]"],
  [3587879263, "[proc,snapshot_hide_help]"],
  [3897908419, "[clientscript,snapshot_help_close]"],
  [1709978003, "[clientscript,snapshot_confirm_name]"],
  [854619885, "[clientscript,snapshot_selected_highlight]"],
  [183175405, "[proc,snapshot_selected_highlight]"],
  [1263834887, "[clientscript,snapshot_main_exit_v1]"],
  [3692916363, "[clientscript,fishcomp_overlay_load]"],
  [4158408703, "[clientscript,fishcomp_refresh]"],
  [315160063, "[proc,fishcomp_refresh]"],
  [1617307663, "[clientscript,worldmap_key_toggle]"],
  [2118822521, "[clientscript,worldmap_flashelementcategory]"],
  [3567941095, "[clientscript,worldmap_showmenu]"],
  [391350247, "[proc,worldmap_showmenu]"],
  [3179418640, "[proc,worldmap_quicksort_menu]"],
  [3742872050, "[clientscript,worldmap_choosemap]"],
  [1330093254, "[proc,worldmap_elements_update]"],
  [3084225071, "[proc,worldmap_elements_chooseposition]"],
  [252373197, "[proc,worldmap_elements_textbox]"],
  [3126200251, "[clientscript,ntk_text]"],
  [2426279981, "[clientscript,ntk_timer]"],
  [1605690577, "[clientscript,worldmap_button]"],
  [191046555, "[clientscript,cws_setup]"],
  [3688488969, "[proc,playerdesign4_getoutfit]"],
  [1627449556, "[clientscript,xbows_pouch_num]"],
  [740250955, "[clientscript,conq_ranking_overlay_onload]"],
  [1696794404, "[clientscript,conq_ranking_overlay_ontimer]"],
  [216004266, "[clientscript,conq_skull_swapper]"],
  [2283230075, "[clientscript,conq_scroll_camera]"],
  [4108907626, "[clientscript,conq_fade_in]"],
  [2872477154, "[clientscript,conq_action_cam]"],
  [1826166738, "[clientscript,conq_action_cam_reset]"],
  [2560581346, "[proc,partnercheck]"],
  [3395810705, "[clientscript,snapshot_main_load]"],
  [613869191, "[clientscript,initialise_stat_xp]"],
  [3314938891, "[clientscript,assist_skill_update]"],
  [3991101657, "[proc,enum_var]"],
  [3771544558, "[clientscript,stats_stat]"],
  [1873674926, "[clientscript,assist_comp_sethide]"],
  [3845798028, "[clientscript,assist_display_icon]"],
  [1944166572, "[proc,assist_set_icon]"],
  [2391398077, "[clientscript,stats_statbase]"],
  [2194073953, "[clientscript,assist_flash_button]"],
  [2824012478, "[clientscript,assist_clear_button]"],
  [3115505675, "[clientscript,assist_overlay_flash_icon]"],
  [3190325882, "[clientscript,assist_flash_icon]"],
  [4008496884, "[clientscript,xbows_init]"],
  [3804928728, "[clientscript,xbows_bolts]"],
  [4082268306, "[clientscript,xbows_level]"],
  [1042195195, "[clientscript,crafting_level]"],
  [190545534, "[clientscript,crafting_level_hide]"],
  [536027846, "[proc,assist_switch_var]"],
  [288171727, "[clientscript,stats_skilltotal]"],
  [2453186623, "[clientscript,stats_mouseover]"],
  [771856344, "[proc,sideinit_comp_close]"],
  [401041792, "[proc,stats_mouseover_create]"],
  [1164643033, "[clientscript,stats_update]"],
  [4043475017, "[clientscript,objdialog_reset]"],
  [3620396224, "[clientscript,objdialog_close]"],
  [2610745903, "[clientscript,objdialog_ondialogabort]"],
  [1972399808, "[proc,objdialog_close]"],
  [3965661080, "[clientscript,objdialog_onkey]"],
  [3740780303, "[clientscript,objdialog_delay_timer]"],
  [3280593621, "[proc,objdialog_refreshsearch]"],
  [2587349391, "[proc,objdialog_dosearch]"],
  [3019618013, "[proc,objdialog_doscrollbar]"],
  [2584600580, "[clientscript,objdialog_highlight]"],
  [1674697446, "[clientscript,objdialog_select]"],
  [1943362384, "[clientscript,stockmarket_onload]"],
  [3307998814, "[clientscript,stockmarket_onstocktransmit]"],
  [4234434349, "[clientscript,stockmarket_onvartransmit]"],
  [4179741091, "[clientscript,stockmarket_oninvtransmit]"],
  [4283473604, "[clientscript,stockmarket_choosecancel]"],
  [2741298709, "[clientscript,stock_offercount_minus]"],
  [506937563, "[clientscript,stock_offercount_plus]"],
  [3880927303, "[clientscript,friends_chat_drag]"],
  [3716460699, "[clientscript,stock_offerprice_minus]"],
  [122752405, "[clientscript,stock_offerprice_plus]"],
  [4191826024, "[clientscript,stockcollect_onload]"],
  [3450649361, "[clientscript,lore_magic_entertargetmode]"],
  [2133533138, "[clientscript,lore_magic_leavetargetmode]"],
  [38928639, "[clientscript,gravestone_plaque_setup]"],
  [2427492562, "[proc,lore_updateicon_v2]"],
  [1990313151, "[proc,scale_round]"],
  [2529120309, "[clientscript,letter_lj_setscrollpos]"],
  [855810399, "[clientscript,partyroom_interface_setup]"],
  [3486303877, "[clientscript,gravestone_shop_setup]"],
  [2783709258, "[proc,gravestone_shop_createbutton]"],
  [2313497945, "[proc,gravestone_shop_model]"],
  [693361276, "[clientscript,gravestone_shop_select]"],
  [89788014, "[clientscript,cc_graphic_swapper]"],
  [3563406607, "[clientscript,worldmap_keysort_button]"],
  [2140486521, "[proc,rgb_to_hex]"],
  [1589568985, "[proc,lightcombine]"],
  [566965005, "[clientscript,interface_invother_init_big]"],
  [1448476994, "[clientscript,bankpin_cancel]"],
  [1154868597, "[clientscript,imp_bank_setup]"],
  [2903201470, "[clientscript,interface_flash_slot_static]"],
  [3362070320, "[clientscript,rcguild_overlay_load]"],
  [4143386711, "[clientscript,fade_out_darkness]"],
  [755632318, "[clientscript,fade_in_darkness]"],
  [1827543514, "[proc,int_to_bool]"],
  [3435133763, "[clientscript,lore_head_update]"],
  [4222815955, "[clientscript,lore_pouch_counter]"],
  [1092933536, "[clientscript,topstat_run_text_init]"],
  [1894284823, "[clientscript,lore_deltooltip]"],
  [3510789731, "[proc,lore_tostring]"],
  [3081039143, "[proc,lore_tostring_pouch]"],
  [1409420104, "[clientscript,lore_blanktip]"],
  [4178932150, "[clientscript,quickchat_tutorial_loadcontent]"],
  [2456340101, "[clientscript,quickchat_tutorial_showpage]"],
  [460219700, "[clientscript,stats_scrollbar_setup]"],
  [859010524, "[clientscript,music_v3_setcolour]"],
  [1823616535, "[proc,music_getvar]"],
  [154350151, "[clientscript,topstat_run_text_update]"],
  [2308957732, "[proc,obj_warning]"],
  [513804110, "[clientscript,rabbit_shop_init]"],
  [1281689458, "[clientscript,rabbit_shop_pointsupdate]"],
  [3752402689, "[clientscript,fairyrings_clockwise]"],
  [2159187171, "[clientscript,fairyrings_anticlockwise]"],
  [3482052860, "[clientscript,fairyrings_vartransmit]"],
  [1527134220, "[clientscript,fairyrings_rotate]"],
  [3027309454, "[proc,fairyrings_rotate_component]"],
  [1784895621, "[proc,quickchat_tutorial_showpage]"],
  [3806649405, "[proc,quickchat_tutorial_displaydata]"],
  [148549787, "[proc,quickchat_tutorial_addtext]"],
  [838459535, "[proc,quickchat_phrase_objdialog]"],
  [3892822741, "[proc,quickchat_objdialog_dosearch]"],
  [1987824975, "[proc,quickchat_objdialog_refreshsearch]"],
  [3447322583, "[proc,quickchat_objdialog_doscrollbar]"],
  [2135594878, "[clientscript,quickchat_objdialog_highlight]"],
  [664789303, "[proc,quickchat_phrase_countdialog]"],
  [4087775869, "[clientscript,quickchat_open_onop]"],
  [932493278, "[proc,quickchat_open]"],
  [3908982894, "[proc,quickchat_open_context]"],
  [222932477, "[proc,quickchat_respond]"],
  [143576122, "[clientscript,quickchat_close]"],
  [2790547002, "[proc,quickchat_close]"],
  [488840978, "[clientscript,quickchat_onkey]"],
  [2539327254, "[clientscript,quickchat_menu_select]"],
  [1529553174, "[proc,quickchat_menu_select]"],
  [3048708551, "[proc,quickchat_menu_add]"],
  [3942718117, "[proc,quickchat_response_add]"],
  [1478142309, "[proc,quickchat_menu_scroll]"],
  [2487916389, "[clientscript,quickchat_menu_scroll]"],
  [1306251819, "[proc,quickchat_path_scroll]"],
  [387832056, "[clientscript,quickchat_return]"],
  [839550712, "[proc,quickchat_return]"],
  [4092219345, "[proc,quickchat_phrase_resend]"],
  [2991237263, "[clientscript,quickchat_phrase]"],
  [3442955919, "[proc,quickchat_phrase]"],
  [3762912081, "[proc,quickchat_phrase_setup]"],
  [3303235167, "[clientscript,quickchat_phrase_int]"],
  [499715167, "[proc,quickchat_phrase_int]"],
  [3303402071, "[clientscript,quickchat_phrase_obj]"],
  [499882071, "[proc,quickchat_phrase_obj]"],
  [2615229924, "[proc,quickchat_phrase_send]"],
  [685798911, "[proc,quickchat_phrase_setint]"],
  [685965815, "[proc,quickchat_phrase_setobj]"],
  [4059893459, "[clientscript,clanwars_setup_createbox]"],
  [3831217363, "[proc,clanwars_setup_createbox]"],
  [1955019231, "[proc,quickchat_friend_status]"],
  [2559383852, "[clientscript,bankpin_init]"],
  [1744235652, "[clientscript,bankpin_resynch]"],
  [1139613578, "[clientscript,bankpin_button]"],
  [667843985, "[proc,cursors_login]"],
  [1881684709, "[proc,scrollbar_horizontal]"],
  [1508390833, "[proc,dream_instance]"],
  [123612939, "[clientscript,meslayer_mode12]"],
  [1239709650, "[clientscript,loginscreen_load]"],
  [1721916603, "[clientscript,loginscreen_setactivemenu]"],
  [3222892219, "[proc,loginscreen_setactivemenu]"],
  [1500845733, "[clientscript,lobby_friends_join]"],
  [1810777253, "[proc,lobby_friends_join]"],
  [2046475594, "[clientscript,boardgames_rank_update]"],
  [424068167, "[proc,topstat_run_text_update]"],
  [1732692871, "[proc,loginscreen_brightness]"],
  [1348328603, "[clientscript,model_wobble]"],
  [2340187306, "[clientscript,model_wobble_magnitude]"],
  [551376714, "[proc,model_wobble_proc]"],
  [2437085339, "[proc,model_wobble_magnitude_proc]"],
  [3840642455, "[clientscript,rand_model_wobble]"],
  [1607340710, "[clientscript,rand_model_wobble_magnitude]"],
  [3761419662, "[clientscript,loginscreen_slider_click]"],
  [4278850768, "[clientscript,loginscreen_slider_drag]"],
  [1846914474, "[proc,loginscreen_musicvol]"],
  [3099023796, "[clientscript,loginscreen_keypress]"],
  [1788527159, "[clientscript,tzhaar_fightcave_init]"],
  [3620112635, "[clientscript,trawler_reward_setup]"],
  [3233248376, "[clientscript,prayer_load_buttons]"],
  [4251190904, "[proc,prayer_load_buttons]"],
  [1477182426, "[clientscript,zep_mouse_over]"],
  [2741279957, "[clientscript,zep_mouse_leave]"],
  [1359104264, "[clientscript,boardgames_options_ranked]"],
  [106291654, "[clientscript,boardgames_options_time]"],
  [246074949, "[proc,bankpin_shuffle]"],
  [3012031187, "[clientscript,agilityarena_set_model]"],
  [2575339581, "[clientscript,draughts_inv_init]"],
  [3112384420, "[clientscript,draughts_inv_update]"],
  [4130326948, "[proc,draughts_inv_update]"],
  [3213596180, "[clientscript,hauntedmine_controls_load]"],
  [3055081151, "[proc,lobbyscreen_load]"],
  [3941334181, "[clientscript,topstat_run_button_init]"],
  [1626449422, "[clientscript,topstat_run_button_vartransmit]"],
  [1721959160, "[clientscript,cc_text_colour_swapper]"],
  [2303346140, "[clientscript,settrans]"],
  [66322620, "[clientscript,chatdefault_init]"],
  [2116492142, "[proc,subchanged]"],
  [3359867955, "[clientscript,worldmap_init]"],
  [1236876578, "[proc,worldmap_setzoom]"],
  [2439177366, "[clientscript,worldmap_toggleoverview]"],
  [3754362509, "[proc,worldmap_showoverview]"],
  [1248512535, "[clientscript,worldmap_onkey]"],
  [1193031704, "[clientscript,barrows_killcount_update]"],
  [2169184960, "[clientscript,worldmap_vartransmit]"],
  [3362007758, "[clientscript,boardgames_options_onload]"],
  [2860079880, "[proc,boardgames_options_ranked]"],
  [376009670, "[proc,boardgames_options_time]"],
  [3052028985, "[clientscript,meslayer_mode5]"],
  [1356691599, "[clientscript,agilityarena_overlay]"],
  [2225707103, "[proc,comlevel]"],
  [4006445621, "[clientscript,toplevel_fovchange]"],
  [449966646, "[clientscript,tutorial_progress_bar]"],
  [337184915, "[clientscript,sidebook_build]"],
  [3193517715, "[proc,sidebook_build]"],
  [3636647948, "[clientscript,tog_update_interface]"],
  [2800964792, "[clientscript,bank_cert_button]"],
  [3252683448, "[proc,bank_cert_button]"],
  [813686113, "[clientscript,player_kit_feet_initialise]"],
  [3545631532, "[clientscript,player_kit_feet_varctransmit]"],
  [186874273, "[proc,player_kit_feet_redraw]"],
  [1452714554, "[clientscript,player_kit_feet_colourbutton]"],
  [4084982613, "[clientscript,player_kit_body_initialise]"],
  [2447137655, "[clientscript,player_kit_body_vartransmit]"],
  [3345507360, "[clientscript,player_kit_body_varctransmit]"],
  [2925042069, "[proc,player_kit_body_redraw]"],
  [1252590382, "[clientscript,player_kit_body_colourbutton]"],
  [131443311, "[proc,player_kit_player_create]"],
  [715738096, "[clientscript,player_kit_player_rotate]"],
  [1909282860, "[clientscript,topstat_run_button_mouseover]"],
  [3561645044, "[clientscript,topstat_run_button_op]"],
  [653756319, "[clientscript,meslayer_varc_update]"],
  [1324675059, "[proc,meslayer_close]"],
  [4114120324, "[proc,chatdefault_updatechatbox]"],
  [343221442, "[proc,meslayer_setupinput]"],
  [4105878160, "[clientscript,if_settrans]"],
  [3214651364, "[clientscript,letter_lj_settitle]"],
  [3866885870, "[clientscript,friend_update]"],
  [861116549, "[clientscript,barbassault_name_transmit]"],
  [2652449176, "[proc,boardgames_status_output]"],
  [3512499331, "[clientscript,loot_toggle_client]"],
  [996999635, "[clientscript,loot_ontimer]"],
  [1256909645, "[proc,worldmap_arrowkey]"],
  [225975945, "[clientscript,booth_init]"],
  [279709137, "[clientscript,wornitems_slot]"],
  [2969482543, "[clientscript,inventory_init]"],
  [1511088779, "[clientscript,inventory_targetmode]"],
  [2964976011, "[clientscript,inventory_drag]"],
  [922568650, "[proc,friendschat_kick]"],
  [1784320521, "[proc,chatbox_resize_window]"],
  [3745412916, "[proc,stats_scrollbar_setup]"],
  [3734282232, "[proc,updatemodel]"],
  [3313579405, "[clientscript,champions_onop]"],
  [3921254692, "[clientscript,poh_bookcase_build]"],
  [3896699256, "[proc,curse_get_stat]"],
  [2561736040, "[clientscript,scrollbar_horizontal_jump]"],
  [2556093730, "[clientscript,scrollbar_horizontal_drag]"],
  [2464330761, "[clientscript,scrollbar_horizontal_wheel]"],
  [3069369662, "[proc,scrollbar_horizontal_doscroll]"],
  [484107896, "[proc,prayer_refresh_scrollbar]"],
  [527179209, "[clientscript,barrows_show_head]"],
  [367392142, "[proc,prayer_init_buttons]"],
  [1488061455, "[clientscript,contact_spell]"],
  [1594423111, "[clientscript,component_flash_start]"],
  [584649031, "[proc,component_flash_start]"],
  [1613238468, "[clientscript,component_flash_timer]"],
  [1575467023, "[clientscript,component_flash_stop]"],
  [3066914319, "[proc,component_flash_stop]"],
  [1573202444, "[clientscript,topstat_run_button_update]"],
  [3074178060, "[proc,topstat_run_button_update]"],
  [3911809611, "[clientscript,brew_boiler1]"],
  [3911809642, "[clientscript,brew_boiler2]"],
  [3911809673, "[clientscript,brew_boiler3]"],
  [2000482577, "[proc,durationmes]"],
  [3910427718, "[clientscript,brew_bitternut]"],
  [474202646, "[clientscript,brew_buckets]"],
  [2135772756, "[clientscript,brew_colourwater]"],
  [1454686083, "[clientscript,brew_bark]"],
  [1960258490, "[clientscript,brew_redscore]"],
  [190203079, "[clientscript,brew_bluescore]"],
  [1471542798, "[clientscript,brew_time]"],
  [1033581464, "[clientscript,worldmap_search_start]"],
  [3975454401, "[clientscript,clanwars_orb]"],
  [2690089489, "[proc,clanwars_resynch_melee]"],
  [2686250232, "[proc,clanwars_resynch_magic]"],
  [1818336974, "[proc,clanwars_resynch_ranged]"],
  [518556078, "[proc,clanwars_resynch_prayer]"],
  [3841595844, "[proc,clanwars_resynch_summoning]"],
  [2990107159, "[proc,clanwars_resynch_food]"],
  [1057297861, "[proc,clanwars_resynch_potions]"],
  [3957694637, "[proc,clanwars_resynch_accept]"],
  [2574156609, "[proc,clanwars_focuslayer]"],
  [3887465978, "[proc,clanwars_updateside]"],
  [3748818075, "[proc,clanwars_updateside_textbox]"],
  [1495934386, "[clientscript,clanwars_overlay_status_init]"],
  [675327097, "[clientscript,clanwars_overlay_status]"],
  [1677159337, "[clientscript,clanwars_overlay_status_timecounter]"],
  [2072602296, "[clientscript,clanwars_overlay_rules]"],
  [1622323204, "[clientscript,clanwars_ffa_warning_setup]"],
  [3447046831, "[clientscript,clanwars_setup_maininit]"],
  [2431536857, "[clientscript,clanwars_setup_acceptlayer]"],
  [4274095970, "[clientscript,clanwars_setup_magictooltip]"],
  [2277148807, "[clientscript,clanwars_end_setup]"],
  [3393983442, "[proc,clanwars_end_victory]"],
  [2449005923, "[proc,clanwars_end_defeat]"],
  [1039801778, "[proc,clanwars_end_draw]"],
  [1703639912, "[proc,clanwars_setup_clicktest]"],
  [864152526, "[clientscript,clanwars_setup_melee]"],
  [860313269, "[clientscript,clanwars_setup_magic]"],
  [1048865969, "[clientscript,clanwars_setup_ranged]"],
  [4044052369, "[clientscript,clanwars_setup_prayer]"],
  [2771344641, "[clientscript,clanwars_setup_summoning]"],
  [2238469306, "[clientscript,clanwars_setup_food]"],
  [2973500482, "[clientscript,clanwars_setup_potions]"],
  [4144900249, "[clientscript,clanwars_setup_accept_button]"],
  [3975174719, "[clientscript,clanwars_ffa]"],
  [4027941643, "[clientscript,clanwars_setup_vartransmit]"],
  [810823436, "[clientscript,clanwars_setup_varctransmit]"],
  [251187421, "[clientscript,clanwars_setup_varcstrtransmit]"],
  [2069140585, "[proc,worldmap_key_build]"],
  [2269675475, "[proc,worldmap_createline]"],
  [1869682011, "[proc,worldmap_createtitle]"],
  [1111323351, "[proc,worldmap_quicksort_alphabetical]"],
  [4292966225, "[proc,worldmap_quicksort_category]"],
  [4200886279, "[clientscript,lobby_hop_abort]"],
  [2552889863, "[proc,lobby_hop_abort]"],
  [434295001, "[clientscript,quickchat_enter_search]"],
  [1685034926, "[proc,friendschat_kick_mes]"],
  [726013380, "[clientscript,friendschatsetup_onload]"],
  [2724789276, "[clientscript,friendschatsetup_onfriendtransmit]"],
  [3491036889, "[proc,quickchat_enter_search]"],
  [1335606747, "[clientscript,sc_remaining_clay_help]"],
  [2065783093, "[clientscript,sc_processing_init]"],
  [1946054991, "[clientscript,agilityarena_colour]"],
  [2055006674, "[clientscript,pest_mouseover]"],
  [3473962461, "[clientscript,pest_mouseleave]"],
  [3868947121, "[clientscript,pest_confirm_mouseover]"],
  [3546449442, "[proc,battlestaff_number]"],
  [1053013362, "[proc,rabbit_shop_pointsupdate]"],
  [1206294388, "[clientscript,loginscreen_slider_click_icon]"],
  [3532743566, "[proc,loginscreen_slider_click]"],
  [3743667126, "[clientscript,trawler_water_level]"],
  [814340540, "[clientscript,blast_furnace_bar_stock]"],
  [4169583975, "[clientscript,worldmap_overlay]"],
  [1898617945, "[proc,worldmap_overlay_clear]"],
  [3640863448, "[proc,worldmap_setupgraphic]"],
  [4292484625, "[proc,worldmap_hidegraphic]"],
  [3117904717, "[proc,worldmap_setuptext]"],
  [3042604802, "[clientscript,worldmap_op]"],
  [1864228840, "[proc,mescoord]"],
  [3932389342, "[clientscript,evilbob_load]"],
  [1850021236, "[clientscript,evilbob_start]"],
  [132301331, "[clientscript,cc_settrans]"],
  [2790082928, "[clientscript,trade_pricechecker_init]"],
  [871534013, "[clientscript,trade_pricechecker_setup]"],
  [642857917, "[proc,trade_pricechecker_setup]"],
  [4244988801, "[proc,lobbyscreen_input_full]"],
  [1096425515, "[clientscript,godwars_overlay_init]"],
  [2710757273, "[clientscript,rand_rewards_populate]"],
  [1517824410, "[clientscript,rand_rewards_onhover]"],
  [323542246, "[clientscript,rand_rewards_onexit]"],
  [3161116447, "[clientscript,rand_rewards_clickinformation]"],
  [1302972525, "[clientscript,rand_load_shop]"],
  [2527630203, "[proc,rand_buyprice]"],
  [571735141, "[clientscript,topstat_prayer_custom]"],
  [661706774, "[clientscript,topstat_prayer_button_op]"],
  [969435950, "[proc,topstat_prayer_button_update]"],
  [3251491523, "[clientscript,topstat_run_button_mouseleave]"],
  [4044799584, "[proc,topstat_button_mouseover]"],
  [733033231, "[proc,topstat_button_mouseleave]"],
  [4090981323, "[clientscript,barbassault_tutorial_colours]"],
  [856792583, "[clientscript,show_component]"],
  [1851977378, "[clientscript,hide_component]"],
  [3150159816, "[clientscript,godwars_overlay_vartransmit]"],
  [319019304, "[clientscript,xbows_rune_update]"],
  [1437395752, "[proc,xbows_rune_update]"],
  [582696090, "[clientscript,xbows_bolts_update]"],
  [892627610, "[proc,xbows_bolts_update]"],
  [1013245893, "[clientscript,xbows_setfont]"],
  [3568416708, "[clientscript,player_kit_scroll]"],
  [443236725, "[proc,player_kit_select]"],
  [2337247561, "[clientscript,login_register]"],
  [1642909186, "[clientscript,makeover_headsetup]"],
  [110400287, "[clientscript,makeover_gender_resynch]"],
  [4286972974, "[clientscript,makeover_gender_force]"],
  [139655258, "[proc,makeover_gender]"],
  [934806644, "[clientscript,makeover_colour_resynch]"],
  [739231427, "[clientscript,makeover_colour_force]"],
  [1169395375, "[proc,makeover_colour]"],
  [1372782649, "[clientscript,cc_setoutline]"],
  [2214164565, "[proc,hex_to_rgb]"],
  [3659841862, "[proc,lobbyscreen_leavelobby]"],
  [3474742053, "[clientscript,boardgames_sandtimer]"],
  [168729214, "[clientscript,boardgames_names]"],
  [1611510626, "[clientscript,boardgames_status]"],
  [2976127626, "[clientscript,gravestone_update_timer]"],
  [150467121, "[proc,gravestone_stop_timer]"],
  [2715906233, "[clientscript,trawler_time_left]"],
  [490313044, "[clientscript,notes_init]"],
  [856642299, "[clientscript,notes_update]"],
  [4056433288, "[proc,notes_build]"],
  [2141164718, "[clientscript,notes_click]"],
  [4076742318, "[proc,notes_click]"],
  [485806512, "[clientscript,notes_drag]"],
  [236993428, "[clientscript,notes_drag_end]"],
  [252056329, "[proc,notes_get_note]"],
  [528294127, "[proc,notes_get_colour]"],
  [3701753548, "[proc,notes_convert_colour]"],
  [778503687, "[clientscript,notes_colour_abort]"],
  [123612970, "[clientscript,meslayer_mode13]"],
  [1194941023, "[proc,player_prefix_check]"],
  [2844028720, "[clientscript,mob_locator_switch_tab]"],
  [1111936469, "[clientscript,mob_locator_onload]"],
  [1195116014, "[clientscript,mob_locator_resource_setup]"],
  [480719854, "[proc,mob_locator_resource_setup]"],
  [2360001810, "[proc,graphics_options_detailget]"],
  [2360359302, "[proc,graphics_options_detailset]"],
  [3808937363, "[clientscript,graphics_options_init]"],
  [2799163283, "[proc,graphics_options_init]"],
  [1992121244, "[proc,graphics_options_rebuild]"],
  [657973301, "[clientscript,dob_confirm_load]"],
  [123613032, "[clientscript,meslayer_mode15]"],
  [620626257, "[proc,graphics_options_reviewoptions]"],
  [3394926320, "[proc,graphics_options_resolutions]"],
  [2352609584, "[proc,graphics_options_message]"],
  [1616350722, "[clientscript,graphics_options_setwindowmode]"],
  [3880033517, "[clientscript,create_focus]"],
  [3753396973, "[proc,create_focus]"],
  [3791364223, "[proc,buyprice]"],
  [1872924219, "[proc,meslayer_setupdynamicbutton]"],
  [2625707790, "[clientscript,meslayer_lastname]"],
  [2620080175, "[proc,skilltotal]"],
  [3848538175, "[proc,clanwars_ffa]"],
  [969730300, "[clientscript,fade2_in_generic]"],
  [3323421482, "[proc,fade2_generic]"],
  [2510758524, "[clientscript,fade2_timer]"],
  [699637145, "[clientscript,fade2_flash_generic]"],
  [1717579673, "[proc,fade2_flash_generic]"],
  [3522936491, "[clientscript,fade2_flash_timer]"],
  [528691528, "[clientscript,fade2_flash_stop]"],
  [2277684260, "[proc,inventory_setophelds]"],
  [3474518444, "[clientscript,barbassault_onload]"],
  [3166652204, "[clientscript,ii_storage_update]"],
  [3753497464, "[clientscript,ii_storage_update_side]"],
  [418552743, "[clientscript,ii_mouseleave]"],
  [2140497881, "[clientscript,ii_timer_display]"],
  [2734915830, "[clientscript,ii_timer_update]"],
  [628787993, "[clientscript,ii_resize_if]"],
  [233070860, "[clientscript,settings_init]"],
  [2030646385, "[clientscript,loginscreen_button_highlight]"],
  [2690703985, "[proc,loginscreen_button_highlight]"],
  [4126927209, "[clientscript,loginscreen_link_highlight]"],
  [3412531049, "[proc,loginscreen_link_highlight]"],
  [1239543614, "[clientscript,loginscreen_link]"],
  [516662869, "[clientscript,loginscreen_link_nologin]"],
  [1087941634, "[proc,login_open]"],
  [3314478742, "[proc,login_close]"],
  [1467204022, "[clientscript,login_focus]"],
  [2294917456, "[clientscript,login_dologin]"],
  [2664151888, "[proc,login_dologin]"],
  [1801897444, "[clientscript,login_reply]"],
  [2498009784, "[proc,login_getreply]"],
  [3689460322, "[proc,login_popup]"],
  [3783916571, "[clientscript,login_popup_throbber]"],
  [2037851849, "[clientscript,login_popup_close]"],
  [3156228297, "[proc,login_popup_close]"],
  [627960241, "[clientscript,ecosystem_tutorial_camera]"],
  [899951555, "[proc,ecosystem_tutorial_cam_1]"],
  [899951586, "[proc,ecosystem_tutorial_cam_2]"],
  [899951617, "[proc,ecosystem_tutorial_cam_3]"],
  [899951648, "[proc,ecosystem_tutorial_cam_4]"],
  [899951679, "[proc,ecosystem_tutorial_cam_5]"],
  [899951710, "[proc,ecosystem_tutorial_cam_6]"],
  [899951741, "[proc,ecosystem_tutorial_cam_7]"],
  [899951772, "[proc,ecosystem_tutorial_cam_8]"],
  [2279626121, "[clientscript,ecosystem_tutorial_cam_8_2]"],
  [3028744160, "[proc,cc_add]"],
  [3221921879, "[proc,cc_add_graphic]"],
  [880084526, "[proc,cc_add_text]"],
  [878217303, "[proc,cc_add_rect]"],
  [1321038006, "[proc,cc_add_model]"],
  [131888203, "[proc,lobbyscreen_input]"],
  [2381813234, "[clientscript,lobbyscreen_input_close]"],
  [2651531250, "[proc,lobbyscreen_input_close]"],
  [2651216445, "[proc,lobbyscreen_input_clear]"],
  [1990069396, "[clientscript,lobbyscreen_input_ok]"],
  [3481516692, "[proc,lobbyscreen_input_ok]"],
  [2656693673, "[clientscript,lobbyscreen_input_keyboard]"],
  [2603362495, "[clientscript,lobbyscreen_load]"],
  [1113748204, "[clientscript,lobbyscreen_tabswitch]"],
  [103974124, "[proc,lobbyscreen_tabswitch]"],
  [3659495243, "[clientscript,lobbyscreen_entergame]"],
  [2649721163, "[proc,lobbyscreen_entergame]"],
  [1596493706, "[clientscript,lobbyscreen_entergametimer]"],
  [603099974, "[clientscript,lobbyscreen_leavelobby]"],
  [2603196459, "[clientscript,lobbyscreen_link]"],
  [2430617284, "[proc,lobbyscreen_countdown]"],
  [1748580398, "[clientscript,lobbyscreen_pvp_warning]"],
  [2135384405, "[proc,lobby_popup]"],
  [1361417084, "[clientscript,lobby_popup_close]"],
  [2479793532, "[proc,lobby_popup_close]"],
  [3757500491, "[proc,lobby_worldswitcher_drawlist]"],
  [3565711912, "[clientscript,lobby_worldswitcher_timer]"],
  [3727979453, "[proc,create_error]"],
  [4230839734, "[proc,create_suggestions]"],
  [2570585870, "[proc,task_requirements_fulfilled]"],
  [92935137, "[clientscript,create_suggestions_highlight]"],
  [752992737, "[proc,create_suggestions_highlight]"],
  [2431904840, "[proc,task_get_progress]"],
  [26928408, "[clientscript,login_resize]"],
  [4195259160, "[proc,login_resize]"],
  [3291438026, "[proc,login_popup_full]"],
  [2494329492, "[clientscript,login_hop_abort]"],
  [846333076, "[proc,login_hop_abort]"],
  [1693675281, "[proc,loginscreen_setactivemenu_full]"],
  [3325056826, "[clientscript,rand_interface_click]"],
  [1402160656, "[clientscript,rand_map_reset]"],
  [1529664866, "[clientscript,rand_map_add_room]"],
  [3550632988, "[clientscript,rand_map_add_player]"],
  [1200364771, "[clientscript,rand_map_start_room]"],
  [1972669362, "[clientscript,rand_map_boss_room]"],
  [2519345500, "[clientscript,rand_map_tooltip]"],
  [464922395, "[clientscript,scrollbar_vertical_text]"],
  [4173486214, "[clientscript,rand_inspect_examine]"],
  [4207373291, "[clientscript,trail_compasspoint]"],
  [1244514185, "[clientscript,loginscreen_quit]"],
  [2961982538, "[clientscript,autosetup]"],
  [778524234, "[proc,autosetup]"],
  [3883055143, "[proc,firstrun]"],
  [2520806556, "[clientscript,graphics_options_button_highlight]"],
  [1485145756, "[proc,graphics_options_button_highlight]"],
  [3562781666, "[clientscript,lobbyscreen_chat_handler]"],
  [1585201277, "[proc,lobbyscreen_chat_count]"],
  [4091811805, "[clientscript,objbox_set_zoom]"],
  [3033481489, "[clientscript,loginscreen_setactivemenu_full]"],
  [675911350, "[proc,love_instance]"],
  [3233433286, "[clientscript,love_cutscenes]"],
  [879294718, "[clientscript,love_puzzle_init]"],
  [1005876261, "[clientscript,love_puzzle_update]"],
  [1315807781, "[proc,love_puzzle_update]"],
  [1335655500, "[proc,love_puzzle_node]"],
  [3848765151, "[clientscript,love_puzzle_sourceclick]"],
  [2630640390, "[proc,love_puzzle_read_1]"],
  [2630640421, "[proc,love_puzzle_read_2]"],
  [1402686335, "[proc,love_puzzle_used_1]"],
  [1402686366, "[proc,love_puzzle_used_2]"],
  [3186281300, "[clientscript,love_puzzle_side_init]"],
  [1861070922, "[proc,userflowflags]"],
  [841315543, "[clientscript,rand_ring_interface_init]"],
  [3814962041, "[clientscript,trail_compass_timer]"],
  [3030111179, "[proc,rough_angle]"],
  [1502710231, "[clientscript,rand_herbburner_onhover]"],
  [1569980681, "[clientscript,rand_herbburner_onexit]"],
  [2558710742, "[clientscript,statue_bag_init]"],
  [1200764559, "[proc,music_v3_refresh]"],
  [1093385031, "[proc,music_search_close]"],
  [2770583881, "[proc,meslayer_mode14]"],
  [3954515392, "[proc,create_check_email]"],
  [3687734141, "[clientscript,login_link_highlight]"],
  [884214141, "[proc,login_link_highlight]"],
  [3390182533, "[clientscript,lobby_resize]"],
  [3263545989, "[proc,lobby_resize]"],
  [2823046782, "[clientscript,warguild_tag_setup]"],
  [923376034, "[clientscript,warguild_tag_tick]"],
  [1357847676, "[clientscript,warguild_overlay_arrow]"],
  [119622268, "[proc,warguild_overlay_arrow]"],
  [2464582706, "[clientscript,stockcollect_refresh]"],
  [3956030002, "[proc,stockcollect_refresh]"],
  [3993327093, "[proc,guesscolour]"],
  [2140499603, "[proc,rgb_to_hsl]"],
  [1054303555, "[clientscript,graphic_swapper2]"],
  [1054303586, "[clientscript,graphic_swapper3]"],
  [3853237005, "[clientscript,closebutton_click_book]"],
  [3874133752, "[clientscript,closebutton_click_paper]"],
  [3002396774, "[proc,fadeout]"],
  [3044892262, "[clientscript,fadeout]"],
  [1343771489, "[proc,fadein]"],
  [3284804961, "[clientscript,fadein]"],
  [1755755652, "[clientscript,valentine_setup]"],
  [2806854053, "[clientscript,bankpin_buttonbox]"],
  [2044840507, "[clientscript,bankpin_settings_setup]"],
  [3403460585, "[clientscript,clan_join_invite_onload]"],
  [2239541240, "[clientscript,clan_create_return]"],
  [2549472760, "[proc,clan_create_return]"],
  [3376774797, "[clientscript,clansettings_onload]"],
  [2422215987, "[clientscript,clansettings_interface_refresh]"],
  [1082409779, "[proc,clansettings_interface_refresh]"],
  [3146675397, "[clientscript,clansettings_list_build]"],
  [3416393413, "[proc,clansettings_list_build]"],
  [3816256838, "[clientscript,clan_setup_flags]"],
  [3943525262, "[clientscript,clan_flag_highlight]"],
  [2059686692, "[clientscript,clan_flag_highlight_update]"],
  [666500494, "[proc,clan_flag_highlight]"],
  [3159180403, "[proc,clan_offset_tostring]"],
  [950091181, "[proc,clan_time_tostring]"],
  [3534677166, "[clientscript,clan_run_time]"],
  [803607787, "[proc,clan_keyword_get]"],
  [959843501, "[clientscript,clan_keywords_update]"],
  [383729166, "[clientscript,clan_noticeboard_build]"],
  [3440471054, "[proc,clan_noticeboard_build]"],
  [3403050012, "[clientscript,clan_noticeboard_event_show]"],
  [774882958, "[clientscript,clan_qfc_return]"],
  [3421853838, "[proc,clan_qfc_return]"],
  [1664466295, "[clientscript,clan_vote_cast]"],
  [2071952732, "[proc,clan_vote_disable]"],
  [346009718, "[clientscript,clan_vote_restore]"],
  [111071091, "[proc,clan_vote_enable]"],
  [1034516205, "[clientscript,clan_vote_update]"],
  [961454523, "[clientscript,clan_motto_text_init]"],
  [4035496741, "[clientscript,clan_motto_text_input]"],
  [3861648679, "[clientscript,clan_motto_text_click]"],
  [682792749, "[clientscript,clan_motto_return]"],
  [1801169197, "[proc,clan_motto_return]"],
  [3493996753, "[proc,clan_motif_decode]"],
  [463148884, "[clientscript,clan_build_preview]"],
  [2885368025, "[clientscript,clan_motif_set]"],
  [1086136315, "[proc,clan_build_motif_layer]"],
  [2053465413, "[clientscript,clan_switch_tab]"],
  [405468997, "[proc,clan_switch_tab]"],
  [939191011, "[clientscript,clan_set_colour1]"],
  [939191042, "[clientscript,clan_set_colour2]"],
  [3395901300, "[clientscript,clan_info_load]"],
  [2039658235, "[clientscript,clan_click_pm]"],
  [3882886751, "[clientscript,clan_chat_onload]"],
  [226375491, "[clientscript,clan_invite_button]"],
  [3049345404, "[clientscript,clan_chat_onclansettingstransmit]"],
  [3985768316, "[proc,clan_chat_onclansettingstransmit]"],
  [685263562, "[clientscript,clan_chat_list_refresh]"],
  [3060697419, "[proc,clan_chat_clearlist]"],
  [409126975, "[clientscript,clan_chat_onclantransmit]"],
  [3857928584, "[clientscript,clan_chat_minimenu_timer]"],
  [3160934020, "[proc,clan_chat_kick_find]"],
  [1113506622, "[proc,clan_chat_kick]"],
  [3534330804, "[clientscript,clan_chat_list_op]"],
  [812018461, "[proc,aif_checkbox_build_layer]"],
  [790005299, "[clientscript,aif_textinputbox]"],
  [1241723955, "[proc,aif_textinputbox]"],
  [3911896464, "[clientscript,aif_progressbar_set]"],
  [634871696, "[proc,aif_progressbar_set]"],
  [123613063, "[clientscript,meslayer_mode16]"],
  [81588283, "[proc,ignore_init]"],
  [4011144199, "[proc,friend_init]"],
  [2505446143, "[clientscript,friends2_switchmode]"],
  [3331131675, "[proc,date_tostring]"],
  [1190281186, "[proc,text_plural]"],
  [2581030282, "[proc,clan_keyword_construct]"],
  [1932739337, "[clientscript,clan_colour_mouseover]"],
  [81002439, "[proc,displayname_simplify]"],
  [1890192988, "[clientscript,skillcape_build_preview]"],
  [165898984, "[clientscript,clan_noticeboard_event_mouseover]"],
  [746198919, "[clientscript,clan_noticeboard_event_mouseleave]"],
  [4005505415, "[proc,clan_noticeboard_event_mouseleave]"],
  [3220029995, "[clientscript,clan_chat_kick_button]"],
  [2429103799, "[proc,divide_up]"],
  [1887979583, "[proc,string_to_int]"],
  [1127565377, "[clientscript,cc_text_swapper]"],
  [4290883894, "[proc,tostring_minutes]"],
  [363054717, "[clientscript,mes]"],
  [2368304475, "friendslist_font"],
  [1708131472, "tutorial_font"],
  [3318248980, "welcome_font_small"],
  [3311443016, "welcome_font_large"],
  [3952954078, "p11_full"],
  [3981583229, "p12_full"],
  [1057075019, "b12_full"],
  [3197789671, "q8_full"],
  [1044900049, "tutorial_font_big"],
  [2196753399, "menu_font_small"],
  [1787935731, "quill_oblique_large"],
  [3929683415, "quill_caps_large"],
  [1157777820, "lunar_alphabet"],
  [24702590, "lunar_alphabet_lrg"],
  [2537929920, "barbassault_font"],
  [962781051, "tzhaar_numbers"],
  [1851754626, "surok_font"],
  [2046729299, "welcome_font_tiny"],
  [4120166957, "verdana_11pt_regular"],
  [1227328817, "verdana_15pt_regular"],
  [526264239, "verdana_13pt_regular"],
  [1583090068, "verdana_11pt_bold"],
  [773743442, "verdana_13pt_bold"],
  [3952954078, "p11_full"],
  [3981583229, "p12_full"],
  [1057075019, "b12_full"],
  [530115961, "overview"],
  [3952954078, "p11_full"],
  [3981583229, "p12_full"],
  [1057075019, "b12_full"],
  [2367466341, "ardougne_underground"],
  [3782884290, "zanaris"],
  [666527204, "troll_stronghold"],
  [110542532, "tolna"],
  [3755693678, "slayer_cave"],
  [339955018, "wilderness_dungeons"],
  [3392903, "null"],
  [1307407612, "tzhaar_area"],
  [128295007, "karamja_underground"],
  [1009939806, "miscellania_underground"],
  [197428487, "godwars"],
  [1963869704, "waterbirth"],
  [2830869084, "dwarven_mines"],
  [2373387318, "braindeath_island"],
  [889241484, "kalphite"],
  [4122880542, "keldagrim"],
  [114071, "sos"],
  [3393803815, "asgarnia_ice_dungeon"],
  [2420028541, "dorgeshkaan"],
  [1003245557, "mosleharmless_cave"],
  [3343801, "main"],
  [3186551633, "ourania"],
  [4114385656, "undead_dungeon"],
  [614031419, "misthalin_underground"],
  [2502817264, "ancient_cavern"],
  [4204353360, "morytania_underground"],
  [2934750709, "circus"],
  [94427558, "canoe"],
  [2367466341, "ardougne_underground"],
  [3782884290, "zanaris"],
  [666527204, "troll_stronghold"],
  [110542532, "tolna"],
  [3755693678, "slayer_cave"],
  [339955018, "wilderness_dungeons"],
  [1307407612, "tzhaar_area"],
  [128295007, "karamja_underground"],
  [1009939806, "miscellania_underground"],
  [197428487, "godwars"],
  [1963869704, "waterbirth"],
  [2830869084, "dwarven_mines"],
  [2373387318, "braindeath_island"],
  [889241484, "kalphite"],
  [4122880542, "keldagrim"],
  [114071, "sos"],
  [3393803815, "asgarnia_ice_dungeon"],
  [2420028541, "dorgeshkaan"],
  [1003245557, "mosleharmless_cave"],
  [3343801, "main"],
  [3186551633, "ourania"],
  [4114385656, "undead_dungeon"],
  [614031419, "misthalin_underground"],
  [2502817264, "ancient_cavern"],
  [4204353360, "morytania_underground"],
  [1787935731, "quill_oblique_large"],
  [3929683415, "quill_caps_large"],
  [1157777820, "lunar_alphabet"],
  [24702590, "lunar_alphabet_lrg"],
  [2537929920, "barbassault_font"],
  [1851754626, "surok_font"],
  [1708131472, "tutorial_font"],
  [1044900049, "tutorial_font_big"],
  [962781051, "tzhaar_numbers"],
  [2368304475, "friendslist_font"],
  [2046729299, "welcome_font_tiny"],
  [3318248980, "welcome_font_small"],
  [3311443016, "welcome_font_large"],
  [2196753399, "menu_font_small"],
  [4120166957, "verdana_11pt_regular"],
  [526264239, "verdana_13pt_regular"],
  [1583090068, "verdana_11pt_bold"],
  [773743442, "verdana_13pt_bold"],
  [1227328817, "verdana_15pt_regular"],
  [3952954078, "p11_full"],
  [3981583229, "p12_full"],
  [3197789671, "q8_full"],
  [1057075019, "b12_full"]
]);

// rsmv/src/clientscript/subtypedetector.ts
var looseOps = [
  //TODO most of these have known types depending on literal args
  dependencyGroup("opin", namedClientScriptOps.enum_hasoutput) | dependencyIndex("int", 2),
  dependencyGroup("opout", namedClientScriptOps.enum_getreverseindex) | dependencyIndex("int", 0),
  dependencyGroup("opin", namedClientScriptOps.enum_getreverseindex) | dependencyIndex("int", 3),
  dependencyGroup("opin", namedClientScriptOps.enum_getreversecount) | dependencyIndex("int", 2),
  dependencyGroup("opin", namedClientScriptOps.enum_getstring) | dependencyIndex("int", 1),
  dependencyGroup("opin", namedClientScriptOps.popdiscardint) | dependencyIndex("int", 0),
  dependencyGroup("opout", namedClientScriptOps.lc_getparam) | dependencyIndex("int", 0),
  dependencyGroup("opin", namedClientScriptOps.cc_setparam) | dependencyIndex("int", 1),
  dependencyGroup("opin", namedClientScriptOps.db_find_with_count) | dependencyIndex("int", 1),
  dependencyGroup("opin", namedClientScriptOps.pop_array) | dependencyIndex("int", 1),
  dependencyGroup("opout", namedClientScriptOps.push_array) | dependencyIndex("int", 0),
  dependencyGroup("opin", namedClientScriptOps.switch) | dependencyIndex("int", 0),
  knownDependency(subtypes.unknown_int),
  knownDependency(subtypes.unknown_long),
  knownDependency(subtypes.unknown_string),
  ...branchInstructionsInt.flatMap((q) => [dependencyGroup("opin", q) | dependencyIndex("int", 0), dependencyGroup("opin", q) | dependencyIndex("int", 1)]),
  ...branchInstructionsLong.flatMap((q) => [dependencyGroup("opin", q) | dependencyIndex("long", 0), dependencyGroup("opin", q) | dependencyIndex("long", 1)])
];
var ClientScriptSubtypeSolver = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
    this.knowntypes = /* @__PURE__ */ new Map();
    this.uuidcounter = 1;
    for (let subtype of Object.values(subtypes)) {
      let key = knownDependency(subtype);
      this.knowntypes.set(key, subtype);
    }
  }
  entangle(key, other) {
    if (other == void 0) {
      return;
    }
    if (key == other) {
      return;
    }
    if (looseOps.includes(key) || looseOps.includes(other)) {
      return;
    }
    if (Array.isArray(globalThis.testkey) && key == globalThis.testkey[0] && other == globalThis.testkey[1]) {
      debugger;
    }
    if (Array.isArray(globalThis.testkey) && key == globalThis.testkey[1] && other == globalThis.testkey[0]) {
      debugger;
    }
    if (typeof globalThis.testboth == "number" && (key == globalThis.testboth || other == globalThis.testboth)) {
      debugger;
    }
    if (key < 512 && other < 512) {
      console.log(`unexpected exact type equation ${key} ${other}`);
    }
    let eqset = this.map.get(key);
    if (!eqset) {
      eqset = /* @__PURE__ */ new Set();
      this.map.set(key, eqset);
    }
    eqset.add(other);
    let otherset = this.map.get(other);
    if (!otherset) {
      otherset = /* @__PURE__ */ new Set();
      this.map.set(other, otherset);
    }
    otherset.add(key);
  }
  parseSections(sections) {
    for (let section of sections) {
      if (section.subfuncid != -1) {
        continue;
      }
      let stack = new CombinedExactStack(this);
      for (let op of section.children) {
        if (op instanceof RawOpcodeNode) {
          if (!stack.pushopcode(op, section.scriptid)) {
            break;
          }
        } else if (op instanceof ClientScriptFunction) {
          break;
        } else if (op instanceof SubcallNode) {
          break;
        } else {
          throw new Error("unexpected");
        }
      }
    }
  }
  addKnownFromCalli(calli) {
    for (let key of this.map.keys()) {
      let [type, stacktype, group, index] = decomposeKey(key);
      let isin = type == "opin" || type == "scriptargvar";
      let isscript = type == "scriptargvar" || type == "scriptret";
      let isop = type == "opin" || type == "opout";
      if (isscript || isop) {
        let stackinout = isscript ? calli.scriptargs.get(group)?.stack : calli.decodedMappings.get(group)?.stackinfo;
        if (stackinout) {
          let stack = isin ? stackinout.exactin : stackinout.exactout;
          if (stack) {
            let typedstack = stack[stacktype];
            if (index < typedstack.length) {
              this.knowntypes.set(key, typedstack[index]);
            }
          }
        }
      }
    }
  }
  solve() {
    let activekeys = new Set(this.knowntypes.keys());
    let itercount = 0;
    while (activekeys.size != 0) {
      let nextactivekeys = /* @__PURE__ */ new Set();
      for (let key of activekeys) {
        let links = this.map.get(key);
        if (links) {
          let known = this.knowntypes.get(key);
          for (let link of links) {
            let prevknown = this.knowntypes.get(link);
            if (typeof prevknown == "undefined") {
              nextactivekeys.add(link);
              this.knowntypes.set(link, known);
            } else if (prevknown != known) {
              globalThis.testkey = [key, link];
              throw new Error(`conflicting types old:${Object.entries(subtypes).find((q) => q[1] == prevknown)?.[0] ?? "??"}, new:${Object.entries(subtypes).find((q) => q[1] == known)?.[0] ?? "??"}
${key} - ${debugKey(key)}
${link} - ${debugKey(link)}`);
            }
          }
        }
      }
      activekeys = nextactivekeys;
    }
  }
};
function getScriptLocalDep(env, type, index) {
  return env;
}
function getPositionalDep(env, type, index) {
  return env | dependencyIndex(type, index);
}
var CombinedExactStack = class {
  constructor(ctx) {
    this.intstack = [];
    this.longstack = [];
    this.stringstack = [];
    this.consts = new StackConstants();
    this.ctx = ctx;
  }
  pushopcode(node, scriptid) {
    if (Array.isArray(globalThis.test) && globalThis.test[0] == scriptid && globalThis.test[1] == node.originalindex) {
      debugger;
    }
    let stackinout = node.knownStackDiff ?? node.opinfo.stackinfo;
    if (!stackinout.initializedthrough) {
      return false;
    }
    if (!node.knownStackDiff && dynamicOps.includes(node.op.opcode)) {
      return false;
    }
    let depenvin = 0;
    let depenvout = 0;
    let depfunc;
    let islocalint = node.opinfo.id == namedClientScriptOps.poplocalint || node.opinfo.id == namedClientScriptOps.pushlocalint;
    let islocallong = node.opinfo.id == namedClientScriptOps.poplocallong || node.opinfo.id == namedClientScriptOps.pushlocallong;
    let islocalstring = node.opinfo.id == namedClientScriptOps.poplocalstring || node.opinfo.id == namedClientScriptOps.pushlocalstring;
    if (islocalint || islocallong || islocalstring) {
      const typestr = islocalint ? "int" : islocallong ? "long" : "string";
      depenvin = dependencyGroup("scriptargvar", scriptid) | dependencyIndex(typestr, node.op.imm);
      depenvout = depenvin;
      depfunc = getScriptLocalDep;
    } else if (node.opinfo.id == namedClientScriptOps.gosub) {
      depenvin = dependencyGroup("scriptargvar", node.op.imm);
      depenvout = dependencyGroup("scriptret", node.op.imm);
      depfunc = getPositionalDep;
    } else if (node.opinfo.id == namedClientScriptOps.return) {
      depenvin = dependencyGroup("scriptret", scriptid);
      depenvout = depenvin;
      depfunc = getPositionalDep;
    } else {
      depenvin = dependencyGroup("opin", node.op.opcode);
      depenvout = dependencyGroup("opout", node.op.opcode);
      depfunc = getPositionalDep;
    }
    if (node.knownStackDiff?.exactin) {
      let exact = node.knownStackDiff.exactin;
      for (let i = exact.int.length - 1; i >= 0; i--) {
        this.ctx.entangle(knownDependency(exact.int[i]), this.intstack.pop());
      }
      for (let i = exact.long.length - 1; i >= 0; i--) {
        this.ctx.entangle(knownDependency(exact.long[i]), this.longstack.pop());
      }
      for (let i = exact.string.length - 1; i >= 0; i--) {
        this.ctx.entangle(knownDependency(exact.string[i]), this.stringstack.pop());
      }
    } else {
      let stackin = stackinout.in;
      let stackcounts = stackin.getStackdiff();
      for (let i = stackin.values.length - 1; i >= 0; i--) {
        let value = stackin.values[i];
        if (value instanceof StackDiff) {
          for (let i2 = value.int - 1; i2 >= 0; i2--) {
            this.ctx.entangle(depfunc(depenvin, "int", --stackcounts.int), this.intstack.pop());
          }
          for (let i2 = value.long - 1; i2 >= 0; i2--) {
            this.ctx.entangle(depfunc(depenvin, "long", --stackcounts.long), this.longstack.pop());
          }
          for (let i2 = value.string - 1; i2 >= 0; i2--) {
            this.ctx.entangle(depfunc(depenvin, "string", --stackcounts.string), this.stringstack.pop());
          }
        } else if (value == "int") {
          this.ctx.entangle(depfunc(depenvin, "int", --stackcounts.int), this.intstack.pop());
        } else if (value == "long") {
          this.ctx.entangle(depfunc(depenvin, "long", --stackcounts.long), this.longstack.pop());
        } else if (value == "string") {
          this.ctx.entangle(depfunc(depenvin, "string", --stackcounts.string), this.stringstack.pop());
        } else if (value == "vararg") {
          return false;
        } else {
          throw new Error("unexpected");
        }
      }
    }
    if (node.knownStackDiff?.exactout) {
      let exact = node.knownStackDiff.exactout;
      for (let i = 0; i < exact.int.length; i++) {
        this.intstack.push(knownDependency(exact.int[i]));
      }
      for (let i = 0; i < exact.long.length; i++) {
        this.longstack.push(knownDependency(exact.long[i]));
      }
      for (let i = 0; i < exact.string.length; i++) {
        this.stringstack.push(knownDependency(exact.string[i]));
      }
    } else {
      let totalout = stackinout.out.getStackdiff();
      if (totalout.vararg != 0) {
        return false;
      }
      if (!totalout.isNonNegative() || totalout.vararg != 0) {
        throw new Error("unexpected");
      }
      for (let i = 0; i < totalout.int; i++) {
        this.intstack.push(depfunc(depenvout, "int", i));
      }
      for (let i = 0; i < totalout.long; i++) {
        this.longstack.push(depfunc(depenvout, "long", i));
      }
      for (let i = 0; i < totalout.string; i++) {
        this.stringstack.push(depfunc(depenvout, "string", i));
      }
    }
    return true;
  }
};
function detectSubtypes(calli, candidates) {
  let ctx = new ClientScriptSubtypeSolver();
  for (let cand of candidates.values()) {
    if (!cand.scriptcontents) {
      continue;
    }
    let { sections } = generateAst(calli, cand.script, cand.scriptcontents.opcodedata, cand.id);
    ctx.parseSections(sections);
  }
  ctx.solve();
  assignKnownTypes(calli, ctx.knowntypes);
  calli.foundSubtypes = true;
}
function assignKnownTypes(calli, knowntypes) {
  for (let op of calli.mappings.values()) {
    if (!op.stackinfo.initializedthrough) {
      continue;
    }
    let exactin = new ExactStack();
    let diffin = op.stackinfo.in.getStackdiff();
    for (let i = 0; i < diffin.int; i++) {
      exactin.int.push(knowntypes.get(dependencyGroup("opin", op.id) | dependencyIndex("int", i)) ?? subtypes.unknown_int);
    }
    for (let i = 0; i < diffin.long; i++) {
      exactin.long.push(knowntypes.get(dependencyGroup("opin", op.id) | dependencyIndex("long", i)) ?? subtypes.unknown_long);
    }
    for (let i = 0; i < diffin.string; i++) {
      exactin.string.push(knowntypes.get(dependencyGroup("opin", op.id) | dependencyIndex("string", i)) ?? subtypes.unknown_string);
    }
    op.stackinfo.exactin = exactin;
    let exactout = new ExactStack();
    let diffout = op.stackinfo.out.getStackdiff();
    for (let i = 0; i < diffout.int; i++) {
      exactout.int.push(knowntypes.get(dependencyGroup("opout", op.id) | dependencyIndex("int", i)) ?? subtypes.unknown_int);
    }
    for (let i = 0; i < diffout.long; i++) {
      exactout.long.push(knowntypes.get(dependencyGroup("opout", op.id) | dependencyIndex("long", i)) ?? subtypes.unknown_long);
    }
    for (let i = 0; i < diffout.string; i++) {
      exactout.string.push(knowntypes.get(dependencyGroup("opout", op.id) | dependencyIndex("string", i)) ?? subtypes.unknown_string);
    }
    op.stackinfo.exactout = exactout;
  }
  for (let [id, func] of calli.scriptargs) {
    let exactin = new ExactStack();
    let diffin = func.stack.in.getStackdiff();
    for (let i = 0; i < diffin.int; i++) {
      exactin.int.push(knowntypes.get(dependencyGroup("scriptargvar", id) | dependencyIndex("int", i)) ?? subtypes.unknown_int);
    }
    for (let i = 0; i < diffin.long; i++) {
      exactin.long.push(knowntypes.get(dependencyGroup("scriptargvar", id) | dependencyIndex("long", i)) ?? subtypes.unknown_long);
    }
    for (let i = 0; i < diffin.string; i++) {
      exactin.string.push(knowntypes.get(dependencyGroup("scriptargvar", id) | dependencyIndex("string", i)) ?? subtypes.unknown_string);
    }
    func.stack.exactin = exactin;
    let exactout = new ExactStack();
    let diffout = func.stack.out.getStackdiff();
    for (let i = 0; i < diffout.int; i++) {
      exactout.int.push(knowntypes.get(dependencyGroup("scriptret", id) | dependencyIndex("int", i)) ?? subtypes.unknown_int);
    }
    for (let i = 0; i < diffout.long; i++) {
      exactout.long.push(knowntypes.get(dependencyGroup("scriptret", id) | dependencyIndex("long", i)) ?? subtypes.unknown_long);
    }
    for (let i = 0; i < diffout.string; i++) {
      exactout.string.push(knowntypes.get(dependencyGroup("scriptret", id) | dependencyIndex("string", i)) ?? subtypes.unknown_string);
    }
    func.stack.exactout = exactout;
  }
  return knowntypes;
}

// rsmv/src/clientscript/callibrator.ts
import * as datastore from "idb-keyval";

// rsmv/src/clientscript/util.ts
async function loadParams(source) {
  let paramindex = await source.getArchiveById(cacheMajors.config, cacheConfigPages.params);
  let parammeta = /* @__PURE__ */ new Map();
  for (let file of paramindex) {
    parammeta.set(file.fileid, parse.params.read(file.buffer, source));
  }
  return parammeta;
}
async function loadEnum(source, id) {
  return parse.enums.read(await source.getFileById(cacheMajors.enums, id), source);
}
async function loadStruct(source, structid) {
  return parse.structs.read(await source.getFileById(cacheMajors.structs, structid), source);
}
function getEnumInt(enumjson, key) {
  return (enumjson.intArrayValue1 ?? enumjson.intArrayValue2?.values)?.find((q) => q[0] == key)?.[1] ?? enumjson.intValue ?? 0;
}
function getStructInt(paramtable, struct, paramid) {
  let parammeta = paramtable.get(paramid);
  if (!parammeta) {
    throw new Error(`unkown param ${paramid}`);
  }
  let match = struct?.extra?.find((q) => q.prop == paramid);
  if (!match) {
    return parammeta.type?.defaultint ?? -1;
  }
  if (match.intvalue == void 0) {
    throw new Error("param is not of type int");
  }
  return match.intvalue;
}

// rsmv/src/clientscript/callibrator.ts
var detectableImmediates = ["byte", "int", "tribyte", "switch"];
var lastNonObfuscatedBuild = 668;
var firstModernOpsBuild = 751;
var varInfoParser = new FileParser({
  "0x03": { "name": "type", "read": "ubyte" },
  "0x04": { "name": "0x04", "read": "ubyte" },
  "0x07": { "name": "0x07", "read": true },
  "0x6e": { "name": "0x6e", "read": "ushort" }
});
var varbitInfoParser = new FileParser({
  "0x01": { "name": "varid", "read": "utribyte" },
  //[8bit domain][16bit id] read as tribyte since thats also how we read pushvar/popvar imm
  "0x02": { "name": "bits", "read": ["tuple", "ubyte", "ubyte"] }
});
var OpcodeInfo = class _OpcodeInfo {
  constructor(scrambledid, id, possibles) {
    this.stackinfo = new StackInOut();
    this.stackChangeConstraints = /* @__PURE__ */ new Set();
    this.scrambledid = scrambledid;
    this.id = id;
    this.possibleTypes = new Set(possibles);
    if (possibles.length == 1) {
      this.type = possibles[0];
    } else {
      this.type = "unknown";
    }
  }
  static fromJson(json) {
    let r = new _OpcodeInfo(json.scrambledid, json.id, json.type == "unknown" ? detectableImmediates : [json.type]);
    r.stackinfo = StackInOut.fromJson(json.stackinfo);
    return r;
  }
  toJson() {
    return {
      id: this.id,
      scrambledid: this.scrambledid,
      stackinfo: this.stackinfo.toJson(),
      type: this.type
    };
  }
};
function getClassicImmType(op) {
  let type = "byte";
  if (op == namedClientScriptOps.pushstring) {
    type = "string";
  } else if (op == namedClientScriptOps.pushlong) {
    type = "long";
  } else if (op == namedClientScriptOps.return) {
    type = "byte";
  } else if (op == 38) {
    type = "byte";
  } else if (op == 39) {
    type = "byte";
  } else if (op == 102) {
    type = "byte";
  } else if (op < 128) {
    type = "int";
  }
  return type;
}
function cannonicalOp(operation, buildnr, immtype) {
  let op = operation.opcode;
  let imm = operation.imm;
  let imm_obj = operation.imm_obj;
  if (op == namedClientScriptOps.pushint) {
    imm_obj = imm;
    op = namedClientScriptOps.pushconst;
    immtype = "switch";
    imm = 0;
  }
  if (op == namedClientScriptOps.pushlong) {
    imm_obj = imm_obj;
    op = namedClientScriptOps.pushconst;
    immtype = "switch";
    imm = 1;
  }
  if (op == namedClientScriptOps.pushstring) {
    imm_obj = imm_obj;
    op = namedClientScriptOps.pushconst;
    immtype = "switch";
    imm = 2;
  }
  if (buildnr < firstModernOpsBuild) {
    if (op == namedClientScriptOps.pushvar || op == namedClientScriptOps.popvar) {
      imm = 2 << 24 | imm << 8;
    }
  }
  return { opcode: op, imm, imm_obj, immtype };
}
function isOpEqual(a, b) {
  if (a.opcode != b.opcode) {
    return false;
  }
  if (a.imm != b.imm) {
    if (Math.sign(a.imm) != Math.sign(b.imm)) {
      return false;
    }
    if (a.imm >= 0 && a.imm < 10) {
      return false;
    }
    if (b.imm >= 0 && b.imm < 10) {
      return false;
    }
    if (Math.abs(a.imm - b.imm) > Math.max(a.imm + b.imm) / 2 * 0.2 + 10) {
      return false;
    }
  }
  if (typeof a.imm_obj != typeof b.imm_obj) {
    return false;
  }
  if (Array.isArray(a.imm_obj)) {
    if (!Array.isArray(b.imm_obj)) {
      return false;
    }
  } else if (typeof a.imm_obj == "string") {
  } else if (typeof a.imm_obj == "number") {
    if (Math.abs(a.imm - b.imm) > Math.max(a.imm + b.imm) / 2 * 0.2 + 10) {
      return false;
    }
  } else if (a.imm_obj != b.imm_obj) {
    return false;
  }
  return true;
}
function parseImm(buf, offset, type) {
  let imm = 0;
  let imm_obj = null;
  if (type == "byte") {
    if (buf.length < offset + 1) {
      return null;
    }
    imm = buf.readUint8(offset);
    offset += 1;
  } else if (type == "int") {
    if (buf.length < offset + 4) {
      return null;
    }
    imm = buf.readInt32BE(offset);
    offset += 4;
  } else if (type == "tribyte") {
    if (buf.length < offset + 3) {
      return null;
    }
    imm = buf.readUintBE(offset, 3);
    offset += 3;
  } else if (type == "switch") {
    if (buf.length < offset + 1) {
      return null;
    }
    let subtype = buf.readUint8(offset++);
    imm = subtype;
    if (subtype == 0) {
      if (buf.length < offset + 4) {
        return null;
      }
      imm_obj = buf.readInt32BE(offset);
      offset += 4;
    } else if (subtype == 1) {
      if (buf.length < offset + 8) {
        return null;
      }
      imm_obj = [
        buf.readUint32BE(offset),
        buf.readUint32BE(offset + 4)
      ];
      offset += 8;
    } else if (subtype == 2) {
      let end = offset;
      while (true) {
        if (end == buf.length) {
          return null;
        }
        if (buf.readUInt8(end) == 0) {
          break;
        }
        end++;
      }
      imm_obj = buf.toString("latin1", offset, end);
      offset = end + 1;
    }
  } else if (type == "string") {
    let end = offset;
    while (true) {
      if (end == buf.length) {
        return null;
      }
      if (buf.readUInt8(end) == 0) {
        break;
      }
      end++;
    }
    imm_obj = buf.toString("latin1", offset, end);
    offset = end + 1;
  } else if (type == "long") {
    if (buf.length < offset + 8) {
      return null;
    }
    imm_obj = [
      buf.readUint32BE(offset),
      buf.readUint32BE(offset + 4)
    ];
    offset += 8;
  } else {
    throw new Error("unknown imm type");
  }
  return {
    imm,
    imm_obj,
    offset
  };
}
var referenceOpcodeDump = null;
async function getReferenceOpcodeDump() {
  referenceOpcodeDump ??= (async () => {
    let rootcalli = await ClientscriptObfuscation.create(await Openrs2CacheSource.fromId(1383));
    let bounce1 = await ClientscriptObfuscation.create(await Openrs2CacheSource.fromId(1572));
    rootcalli.setNonObbedMappings();
    await bounce1.runCallibrationFrom(rootcalli.generateDump());
    return bounce1.generateDump();
  })();
  return referenceOpcodeDump;
}
var ClientscriptObfuscation = class _ClientscriptObfuscation {
  constructor(source) {
    this.mappings = /* @__PURE__ */ new Map();
    this.decodedMappings = /* @__PURE__ */ new Map();
    this.isNonObbedCache = false;
    this.candidatesLoaded = false;
    this.foundEncodings = false;
    this.foundParameters = false;
    this.foundSubtypes = false;
    this.opidcounter = 1e4;
    this.dbtables = /* @__PURE__ */ new Map();
    this.varmeta = /* @__PURE__ */ new Map();
    this.varbitmeta = /* @__PURE__ */ new Map();
    this.parammeta = /* @__PURE__ */ new Map();
    this.scriptargs = /* @__PURE__ */ new Map();
    this.candidates = /* @__PURE__ */ new Map();
    // don't want them to be methods, use this to expose them to console
    this.findOpcodeImmidiates = findOpcodeImmidiates;
    this.callibrateOperants = callibrateOperants;
    this.callibrateSubtypes = detectSubtypes;
    this.writeOpCode = (state, v) => {
      if (!this.foundEncodings) {
        throw new Error("clientscript deob not callibrated yet");
      }
      if (typeof v != "object" || !v) {
        throw new Error("opcode is expected to be an object");
      }
      if (!("opcode" in v) || typeof v.opcode != "number") {
        throw new Error("opcode prop expectec");
      }
      if (!("imm" in v) || typeof v.imm != "number") {
        throw new Error("imm prop expected");
      }
      let op = this.getNamedOp(v.opcode);
      state.buffer.writeUint16BE(op.scrambledid, state.scan);
      state.scan += 2;
      if (op.type == "byte") {
        state.buffer.writeUint8(v.imm, state.scan);
        state.scan++;
      } else if (op.type == "int") {
        state.buffer.writeInt32BE(v.imm, state.scan);
        state.scan += 4;
      } else if (op.type == "tribyte") {
        state.buffer.writeUIntBE(v.imm, state.scan, 3);
        state.scan += 3;
      } else if (op.type == "switch") {
        if (!("imm_obj" in v)) {
          throw new Error("imm_obj prop expected");
        }
        state.buffer.writeUInt8(v.imm, state.scan);
        state.scan++;
        if (v.imm == 0) {
          if (typeof v.imm_obj != "number") {
            throw new Error("int expected");
          }
          state.buffer.writeInt32BE(v.imm_obj, state.scan);
          state.scan += 4;
        } else if (v.imm == 1) {
          if (!Array.isArray(v.imm_obj) || v.imm_obj.length != 2 || typeof v.imm_obj[0] != "number" || typeof v.imm_obj[1] != "number") {
            throw new Error("array with 2 ints expected");
          }
          state.buffer.writeUInt32BE(v.imm_obj[0], state.scan + 0);
          state.buffer.writeUInt32BE(v.imm_obj[0], state.scan + 4);
          state.scan += 8;
        } else if (v.imm == 2) {
          if (typeof v.imm_obj != "string") {
            throw new Error("string expected");
          }
          state.buffer.write(v.imm_obj, state.scan, "latin1");
          state.scan += v.imm_obj.length;
          state.buffer.writeUint8(0, state.scan);
          state.scan++;
        } else {
          throw new Error("unknown switch imm type " + v.imm);
        }
      } else {
        throw new Error("op type write not implemented " + op.type);
      }
    };
    this.readOpcode = (state) => {
      if (!this.foundEncodings) {
        throw new Error("clientscript deob not callibrated yet");
      }
      let opcode = state.buffer.readUint16BE(state.scan);
      state.scan += 2;
      let res = this.mappings.get(opcode);
      if (!res || res.type == "unknown") {
        if (this.isNonObbedCache) {
          res = new OpcodeInfo(opcode, opcode, [getClassicImmType(opcode)]);
          this.mappings.set(opcode, res);
          this.decodedMappings.set(opcode, res);
        } else {
          if (res) {
            res.type = "byte";
            res.possibleTypes = new Set(res.type);
          } else {
            res = this.declareOp(opcode, ["byte"]);
          }
          console.log(`op type not resolved: 0x${opcode.toString(16)} (opid:${res.id}), guessing imm type byte`);
        }
      }
      let imm = parseImm(state.buffer, state.scan, res.type);
      if (!imm) {
        throw new Error("failed to read immidiate");
      }
      state.scan = imm.offset;
      let opname = getOpName(res.id);
      return { opcode: res.id, imm: imm.imm, imm_obj: imm.imm_obj, opname };
    };
    this.source = source;
  }
  static async fromJson(source, deobjson, scriptjson) {
    if (deobjson.buildnr != source.getBuildNr()) {
      throw new Error("build numbers of json deob and loaded cache don't match");
    }
    let r = new _ClientscriptObfuscation(source);
    for (let opjson of deobjson.mappings) {
      let op = OpcodeInfo.fromJson(opjson);
      r.mappings.set(op.scrambledid, op);
      r.decodedMappings.set(op.id, op);
    }
    r.opidcounter = deobjson.opidcounter;
    r.foundEncodings = true;
    await r.preloadData();
    if (scriptjson) {
      r.scriptargs = new Map(scriptjson.scriptargs.map((v) => {
        return [v.id, {
          scriptname: v.scriptname ?? "",
          stack: StackInOut.fromJson(v.stack)
        }];
      }));
    } else {
      await r.loadCandidates();
      r.parseCandidateContents();
      detectSubtypes(r, r.candidates);
    }
    return r;
  }
  toJson() {
    let r = {
      buildnr: this.source.getBuildNr(),
      mappings: [...this.mappings.values()].map((v) => v.toJson()),
      opidcounter: this.opidcounter
    };
    return r;
  }
  getScriptJson() {
    let r = {
      scriptargs: [...this.scriptargs].map(([k, v]) => ({ id: k, scriptname: v.scriptname, stack: v.stack.toJson() }))
    };
    return r;
  }
  static async getSaveName(source) {
    let index = await source.getCacheIndex(cacheMajors.clientscript);
    let firstindex = index.find((q) => q);
    if (!firstindex) {
      throw new Error("cache has no clientscripts");
    }
    let firstscript = await source.getFileById(firstindex.major, firstindex.minor);
    let crc = crc32(firstscript);
    let scripthash = 0;
    for (let i = 0; i < index.length; i++) {
      if (!index[i]) {
        continue;
      }
      scripthash = crc32addInt(index[i].crc, scripthash);
    }
    return {
      opcodename: `opcodes-build${source.getBuildNr()}-${crc}.json`,
      scriptname: `scripts-build${source.getBuildNr()}-${scripthash}.json`
    };
  }
  async save() {
    let { opcodename, scriptname } = await _ClientscriptObfuscation.getSaveName(this.source);
    let filedata = JSON.stringify(this.toJson());
    let scriptfiledata = JSON.stringify(this.getScriptJson());
    if (fs2.constants) {
      await fs2.mkdir("cache", { recursive: true });
      await fs2.writeFile(`cache/${opcodename}`, filedata);
      await fs2.writeFile(`cache/${scriptname}`, scriptfiledata);
    } else if (datastore.set) {
      await datastore.set(opcodename, filedata);
      await datastore.set(scriptname, scriptfiledata);
    } else {
      console.log(`did not save cs2 callibration since there is no fs and no browser indexeddb`);
    }
  }
  static async create(source, nocached = false) {
    if (!nocached) {
      try {
        let { opcodename, scriptname } = await this.getSaveName(source);
        let file = void 0;
        let scriptfile = void 0;
        if (fs2.constants) {
          file = await fs2.readFile(`cache/${opcodename}`, "utf8");
          scriptfile = await fs2.readFile(`cache/${scriptname}`, "utf8").catch(() => void 0);
        } else if (datastore.get) {
          file = await datastore.get(opcodename);
          scriptfile = await datastore.get(scriptname).catch(() => void 0);
        }
        if (file) {
          let json = JSON.parse(file);
          let scriptjson = scriptfile ? JSON.parse(scriptfile) : null;
          return this.fromJson(source, json, scriptjson);
        }
      } catch {
      }
    }
    let res = new _ClientscriptObfuscation(source);
    globalThis.deob = res;
    await res.preloadData();
    await res.loadCandidates();
    return res;
  }
  declareOp(rawopid, types) {
    let op = new OpcodeInfo(rawopid, this.opidcounter++, types);
    if (this.mappings.has(rawopid)) {
      throw new Error("op already exists");
    }
    if (this.decodedMappings.has(op.id)) {
      throw new Error("allocated op id alerady exists");
    }
    this.mappings.set(rawopid, op);
    this.decodedMappings.set(op.id, op);
    return op;
  }
  async preloadData() {
    let loadVars = async (subid) => {
      let archieve = await this.source.getArchiveById(cacheMajors.config, subid);
      let last = archieve.at(-1)?.fileid ?? 0;
      return { last, vars: new Map(archieve.map((q) => [q.fileid, varInfoParser.read(q.buffer, this.source)])) };
    };
    let dbtables = await this.source.getArchiveById(cacheMajors.config, cacheConfigPages.dbtables);
    this.dbtables = new Map(dbtables.map((q) => [q.fileid, parse.dbtables.read(q.buffer, this.source)]));
    if (this.source.getBuildNr() > 900) {
      this.varmeta = new Map(await Promise.all(Object.entries(variableSources).map(async (q) => {
        let vardata = await loadVars(q[1].index);
        return [q[1].key, { name: q[0], vars: vardata.vars, maxid: vardata.last }];
      })));
      let varbitarchieve = await this.source.getArchiveById(cacheMajors.config, cacheConfigPages.varbits);
      this.varbitmeta = new Map(varbitarchieve.map((q) => [q.fileid, varbitInfoParser.read(q.buffer, this.source)]));
      this.parammeta = await loadParams(this.source);
    }
  }
  async loadCandidates(idstart = 0, idend = 16777215) {
    let index = await this.source.getCacheIndex(cacheMajors.clientscript);
    this.candidates.clear();
    let source = this.source;
    await trickleTasksTwoStep(10, function* () {
      for (let entry of index) {
        if (!entry) {
          continue;
        }
        if (entry.minor < idstart || entry.minor > idend) {
          continue;
        }
        yield source.getFile(entry.major, entry.minor, entry.crc).then((buf) => ({
          id: entry.minor,
          scriptname: reverseHashes.get(index[entry.minor].name) ?? "",
          solutioncount: 0,
          buf,
          script: parse.clientscriptdata.read(buf, source),
          scriptcontents: null,
          argtype: null,
          returnType: null,
          unknowns: /* @__PURE__ */ new Map(),
          didmatch: false
        }));
      }
    }, (q) => this.candidates.set(q.id, q));
    this.candidatesLoaded = true;
  }
  parseCandidateContents() {
    if (!this.candidatesLoaded) {
      throw new Error("candidates not loaded");
    }
    if (!this.foundEncodings) {
      throw new Error("can't parse candidates because op encodings are not yet callibrated");
    }
    for (let cand of this.candidates.values()) {
      try {
        cand.scriptcontents ??= parse.clientscript.read(cand.buf, this.source, { clientScriptDeob: this });
      } catch (e) {
      }
      if (!cand.scriptcontents) {
        continue;
      }
      cand.returnType = getReturnType(this, cand.scriptcontents.opcodedata);
      cand.argtype = getArgType(cand.script);
      this.scriptargs.set(cand.id, {
        scriptname: cand.scriptname,
        stack: new StackInOut(
          cand.argtype.getArglist(),
          //need to get rid of known stack order here since the runescript compiler doesn't adhere to it
          //known cases:
          // pop_intstring_discard order seems to not care about order
          cand.returnType.toStackDiff().getArglist()
        )
      });
    }
  }
  generateDump() {
    let cands = this.candidates;
    let scripts = [];
    this.parseCandidateContents();
    for (let cand of cands.values()) {
      if (cand.scriptcontents) {
        scripts.push({ id: cand.id, scriptdata: cand.script, scriptops: cand.scriptcontents.opcodedata });
      }
    }
    console.log(`dumped ${scripts.length} /${cands.size} scripts`);
    return {
      buildnr: this.source.getBuildNr(),
      scripts,
      decodedMappings: this.decodedMappings,
      opidcounter: this.opidcounter
    };
  }
  async runAutoCallibrate(source) {
    if (source.getBuildNr() <= lastNonObfuscatedBuild) {
      this.setNonObbedMappings();
    } else if (!this.foundEncodings) {
      let ref = await getReferenceOpcodeDump();
      await this.runCallibrationFrom(ref);
    }
  }
  async runCallibrationFrom(refscript) {
    console.log(`callibrating buildnr ${this.source.getBuildNr()}`);
    copyOpcodesFrom(this, refscript);
    findOpcodeImmidiates(this);
    this.parseCandidateContents();
    callibrateOperants(this, this.candidates);
    callibrateOperants(this, this.candidates);
    callibrateOperants(this, this.candidates);
    callibrateOperants(this, this.candidates);
    try {
      detectSubtypes(this, this.candidates);
    } catch (e) {
      console.log("subtype callibration failed, types info might not be accurate");
    }
  }
  setNonObbedMappings() {
    this.foundEncodings = true;
    this.isNonObbedCache = true;
  }
  getClientVarMeta(varint) {
    let groupid = varint >> 24 & 255;
    let varid = varint >> 8 & 65535;
    let group = this.varmeta.get(groupid);
    let varmeta = group?.vars.get(varid);
    if (!group || !varmeta) {
      return null;
    }
    let fulltype = varmeta.type;
    let type = typeToPrimitive(fulltype);
    return { name: group.name, varid, type, fulltype };
  }
  getNamedOp(id) {
    let opinfo = this.decodedMappings.get(id);
    if (!opinfo) {
      throw new Error(`op with named id ${id} not found`);
    }
    return opinfo;
  }
};
function copyOpcodesFrom(deob, refcalli) {
  let candidates = deob.candidates;
  let newbuildnr = deob.source.getBuildNr();
  deob.opidcounter = refcalli.opidcounter;
  let testCandidate = (cand, refops) => {
    if (cand.script.instructioncount != refops.length) {
      return false;
    }
    let unconfirmed = /* @__PURE__ */ new Map();
    let offset = 0;
    let buf = cand.script.opcodedata;
    for (let i = 0; i < cand.script.instructioncount; i++) {
      let refopinfo = refcalli.decodedMappings.get(refops[i].opcode);
      if (!refopinfo || refopinfo.type == "unknown") {
        return false;
      }
      let refop = cannonicalOp(refops[i], refcalli.buildnr, refopinfo.type);
      if (buf.byteLength < offset + 2) {
        return false;
      }
      let opid = buf.readUint16BE(offset);
      offset += 2;
      let imm = parseImm(buf, offset, refop.immtype);
      if (!imm) {
        return false;
      }
      offset = imm.offset;
      let op = { opcode: refop.opcode, imm: imm.imm, imm_obj: imm.imm_obj };
      if (!isOpEqual(cannonicalOp(op, newbuildnr, refop.immtype), refop)) {
        return false;
      }
      unconfirmed.set(opid, refop);
    }
    if (offset != buf.byteLength) {
      return false;
    }
    cand.didmatch = true;
    for (let [k, v] of unconfirmed) {
      let info = new OpcodeInfo(k, v.opcode, [v.immtype]);
      deob.mappings.set(k, info);
      deob.decodedMappings.set(v.opcode, info);
    }
    return true;
  };
  for (let [index, ref] of refcalli.scripts.entries()) {
    let cand = candidates.get(ref.id);
    if (!cand) {
      continue;
    }
    testCandidate(cand, ref.scriptops);
  }
  deob.opidcounter = refcalli.opidcounter;
  console.log(`copied ${deob.mappings.size} opcodes from reference cache, idcount:${deob.opidcounter}`);
}
function findOpcodeImmidiates(calli) {
  let switchcompleted = false;
  let tribytecompleted = false;
  function* tryMakeOp(script, offset, parent, opsleft) {
    if (opsleft == -1) {
      return;
    }
    if (script.opcodedata.length < offset + 2) {
      return;
    }
    let opid = script.opcodedata.readUint16BE(offset);
    if (opid == 0) {
      return;
    }
    offset += 2;
    let previoustheory = parent;
    while (previoustheory) {
      if (previoustheory.opid == opid) {
        break;
      }
      previoustheory = previoustheory.parent;
    }
    let op = calli.mappings.get(opid);
    let options = previoustheory ? [previoustheory.type] : op ? [...op.possibleTypes] : detectableImmediates;
    for (let type of options) {
      if (type == "switch" && switchcompleted && (!op || op.type == "unknown")) {
        continue;
      }
      if (type == "tribyte" && tribytecompleted && (!op || op.type == "unknown")) {
        continue;
      }
      let imm = parseImm(script.opcodedata, offset, type);
      if (!imm) {
        continue;
      }
      yield new ScriptState2(script, opid, imm.offset, type, parent, opsleft);
    }
  }
  class ScriptState2 {
    constructor(script, opid, endoffset, type, parent, opsleft) {
      this.children = [];
      this.script = script;
      this.opid = opid;
      this.endoffset = endoffset;
      this.type = type;
      this.parent = parent;
      this.opsleft = opsleft;
    }
  }
  let candidates = [...calli.candidates.values()];
  candidates.sort((a, b) => a.script.instructioncount - b.script.instructioncount || a.script.opcodedata.length - b.script.opcodedata.length);
  let runtheories = (cand, chained) => {
    let statesa = [];
    let statesb = [];
    let solutions = [];
    let totalstates = 0;
    for (let prev of chained) {
      statesa.push(...tryMakeOp(cand.script, 0, prev, cand.script.instructioncount - 1));
    }
    let bailed = false;
    while (statesa.length != 0) {
      if (statesa.length > 1e3) {
        bailed = true;
        break;
      }
      totalstates += statesa.length;
      let sub = void 0;
      while (sub = statesa.pop()) {
        if (sub.opsleft == 0 && sub.endoffset == sub.script.opcodedata.byteLength) {
          solutions.push(sub);
        } else {
          statesb.push(...tryMakeOp(cand.script, sub.endoffset, sub, sub.opsleft - 1));
        }
      }
      totalstates += statesb.length;
      while (sub = statesb.pop()) {
        if (sub.opsleft == 0 && sub.endoffset == sub.script.opcodedata.byteLength) {
          solutions.push(sub);
        } else {
          statesa.push(...tryMakeOp(cand.script, sub.endoffset, sub, sub.opsleft - 1));
        }
      }
    }
    return bailed ? null : solutions;
  };
  let evaluateSolution = (updateCandidate, solutions, maxsols = 10) => {
    let infocount = 0;
    if (solutions.length <= maxsols) {
      let row = solutions;
      updateCandidate?.unknowns.clear();
      while (row.length != 0) {
        let nextrow = [];
        let opid = row[0].opid;
        let types = /* @__PURE__ */ new Set();
        let matched = true;
        for (let sol of row) {
          if (sol.opid == opid) {
            types.add(sol.type);
          } else {
            matched = false;
          }
          if (sol.parent) {
            nextrow.push(sol.parent);
          }
          row = nextrow;
        }
        if (matched) {
          let op = calli.mappings.get(opid);
          if (!op) {
            op = calli.declareOp(opid, detectableImmediates);
          }
          for (let t of op.possibleTypes) {
            if (!types.has(t)) {
              op.possibleTypes.delete(t);
              infocount++;
            }
          }
          if (op.possibleTypes.size == 1 && op.type == "unknown") {
            op.type = op.possibleTypes.values().next().value;
          }
          if (op.type == "unknown" && updateCandidate) {
            updateCandidate.unknowns.set(op.id, op);
          }
        }
      }
    }
    if (updateCandidate) {
      updateCandidate.solutioncount = solutions.length;
    }
    return infocount;
  };
  let runfixedaddition = () => {
    for (let limit of [10, 10, 10, 20, 30, 40, 50, 100, 1e10, 1e10, 1e10, 1e10]) {
      for (let cand of candidates) {
        if (cand.solutioncount == 1) {
          continue;
        }
        if (cand.script.instructioncount > limit) {
          break;
        }
        let nswitch = 0;
        let ntribyte = 0;
        for (let op of calli.mappings.values()) {
          if (op.type == "switch") {
            nswitch++;
          }
          if (op.type == "tribyte") {
            ntribyte++;
          }
        }
        if (!switchcompleted && nswitch == 1) {
          switchcompleted = true;
          console.log("switch completed");
        }
        if (!tribytecompleted && ntribyte == 2) {
          tribytecompleted = true;
          console.log("tribyte completed");
        }
        if (nswitch > 1) {
          throw new Error("");
        }
        if (ntribyte > 2) {
          throw new Error("");
        }
        let solutions = runtheories(cand, [null]);
        if (solutions) {
          evaluateSolution(cand, solutions);
        }
      }
      let combinable = candidates.filter((q) => q.unknowns.size >= 1).sort((a, b) => a.unknowns.size - b.unknowns.size || firstKey(a.unknowns) - firstKey(b.unknowns));
      let run2 = () => {
        if (index == lastindex + 1) {
          return;
        }
        let solutions = null;
        for (let i = lastindex; i < index; i++) {
          let cand = combinable[i];
          let res = runtheories(cand, solutions ?? [null]);
          if (!res) {
            return;
          }
          solutions = res;
        }
        if (solutions) {
          evaluateSolution(null, solutions);
        }
      };
      let lastkey = -1;
      let lastindex = -1;
      let index = 0;
      for (; index < combinable.length; index++) {
        let cand = combinable[index];
        let key = firstKey(cand.unknowns);
        if (key != lastkey) {
          run2();
          lastkey = key;
          lastindex = index;
        }
      }
      run2();
      console.log(limit, calli.mappings.size);
    }
  };
  runfixedaddition();
  calli.foundEncodings = true;
  return {
    test(id) {
      let cand = candidates.find((q) => q.id == id);
      runtheories(cand, [null]);
    },
    getop(opid) {
      let cands = candidates.filter((q) => q.unknowns.has(opid));
      return cands;
    },
    candidates,
    runtheories,
    evaluateSolution,
    testCascade(ipop) {
      let target = [ipop];
      outerloop: while (true) {
        let cands = candidates.filter((q) => target.some((w) => q.unknowns.has(w)));
        console.log(cands);
        let sols = null;
        for (let cand of cands) {
          sols = runtheories(cand, sols ?? [null]);
          if (!sols) {
            return "too many states";
          }
        }
        console.log(sols);
        let changecount = evaluateSolution(null, sols, 500);
        if (changecount != 0) {
          return changecount;
        }
        for (let cand of cands) {
          for (let unk of cand.unknowns.keys()) {
            if (!target.includes(unk)) {
              target.push(unk);
              continue outerloop;
            }
          }
        }
        return "could not expand problem further";
      }
    }
  };
}
function callibrateOperants(calli, candidates) {
  let allsections = [];
  for (let cand of candidates.values()) {
    if (!cand.scriptcontents) {
      continue;
    }
    let { sections } = generateAst(calli, cand.script, cand.scriptcontents.opcodedata, cand.id);
    allsections.push(...sections);
  }
  allsections.sort((a, b) => a.children.length - b.children.length);
  globalThis.allsections = allsections;
  let testSection = (eq) => {
    let { section, unknowns } = eq;
    let frontstack = new StackList();
    let frontstackconsts = new StackConstants();
    for (let i = 0; i < section.children.length; i++) {
      let node = section.children[i];
      if (!(node instanceof RawOpcodeNode) || node.unknownstack) {
        break;
      }
      if (node.knownStackDiff) {
        frontstack.pop(node.knownStackDiff.in);
        frontstack.push(node.knownStackDiff.out);
        frontstackconsts.popList(node.knownStackDiff.in);
        if (node.knownStackDiff.constout != null) {
          frontstackconsts.pushOne(node.knownStackDiff.constout);
        } else {
          frontstackconsts.pushList(node.knownStackDiff.out);
        }
      } else {
        let info = node.opinfo.stackinfo;
        if (!info.initializedin) {
          info.in = frontstack.clone();
          info.initializedin = true;
        } else {
          let shortage = frontstack.tryPop(info.in);
          if (shortage > 0) {
            if (info.initializedthrough) {
              if (info.out.tryPopReverse(info.in, info.in.values.length - shortage) != 0) {
                throw new Error("not compatible");
              }
            }
            info.in.values.splice(0, shortage);
          }
          frontstackconsts.popList(info.in);
        }
        if (!info.initializedthrough || !info.initializedout) {
          break;
        }
        frontstack.push(info.out);
        frontstackconsts.pushList(info.out);
      }
    }
    let backstack = new StackList();
    for (let i = 0; i < section.children.length; i++) {
      let node = section.children[section.children.length - 1 - i];
      if (!(node instanceof RawOpcodeNode) || node.unknownstack) {
        break;
      }
      if (node.knownStackDiff) {
        backstack.pop(node.knownStackDiff.out);
        backstack.push(node.knownStackDiff.in);
      } else {
        let info = node.opinfo.stackinfo;
        if (!info.initializedout) {
          info.out = backstack.clone();
          info.initializedout = true;
        } else {
          let shortage = backstack.tryPop(info.out);
          if (shortage > 0) {
            if (info.initializedthrough) {
              if (info.in.tryPopReverse(info.out, info.out.values.length - shortage) != 0) {
                throw new Error("not compatible");
              }
            }
            info.out.values.splice(0, shortage);
          }
        }
        if (!info.initializedthrough || !info.initializedin) {
          break;
        }
        backstack.push(info.in);
      }
    }
    let unkcount = 0;
    let unktype = null;
    let totalstack = 0;
    let hasproblemops = false;
    unknowns.clear();
    for (let child of section.children) {
      if (!(child instanceof RawOpcodeNode) || child.unknownstack) {
        hasproblemops = true;
        break;
      }
      if (child.knownStackDiff) {
        totalstack += child.knownStackDiff.totalChange();
      } else if (child.opinfo.stackinfo.initializedthrough) {
        totalstack += child.opinfo.stackinfo.totalChange();
      } else {
        unktype = child.opinfo;
        unknowns.add(child.opinfo);
        unkcount++;
      }
    }
    if (!hasproblemops && !unktype && totalstack != 0) {
      throw new Error("total stack doesn't add up to 0");
    }
    if (!hasproblemops && unktype && unknowns.size == 1) {
      if (posmod(totalstack, unkcount) != 0) {
        throw new Error("stack different is not evenly dividable between equal ops");
      }
      let diffeach = totalstack / unkcount + unktype.stackinfo.totalChange();
      let success = true;
      if (diffeach > 0) {
        success = unktype.stackinfo.out.tryShift(diffeach);
      } else if (diffeach < 0) {
        success = unktype.stackinfo.in.tryShift(-diffeach);
      }
      if (success) {
        unktype.stackinfo.initializedthrough = true;
        unknowns.delete(unktype);
        foundset.add(unktype.id);
      }
    }
    for (let unk of unknowns) {
      let prev = opmap.get(unk.id);
      if (!prev) {
        prev = /* @__PURE__ */ new Set();
        prev.add(eq);
        opmap.set(unk.id, prev);
      }
      prev.add(eq);
    }
  };
  let opmap = /* @__PURE__ */ new Map();
  let pendingEquations = [];
  let foundset = /* @__PURE__ */ new Set();
  for (let section of allsections) {
    let eq = { section, unknowns: /* @__PURE__ */ new Set() };
    for (let op of section.children) {
      if (op instanceof RawOpcodeNode) {
        op.opinfo.stackChangeConstraints.add(eq);
      }
    }
    testSection(eq);
    pendingEquations.push(eq);
  }
  for (let i = 0; i < 3; i++) {
    for (let eq of pendingEquations) {
      testSection(eq);
    }
    let total = 0;
    let partial = 0;
    let done = 0;
    let missing = /* @__PURE__ */ new Set();
    for (let op of calli.mappings.values()) {
      if (op.stackinfo.initializedthrough) {
        done++;
      } else if (op.stackinfo.initializedin || op.stackinfo.initializedout) {
        partial++;
      } else {
        missing.add(op);
      }
      total++;
    }
    console.log("total", total, "done", done, "partial", partial, "incomplete", missing.size);
  }
  calli.foundParameters = true;
}
function getArgType(script) {
  let res = new StackDiff();
  res.int = script.intargcount;
  res.long = script.longargcount;
  res.string = script.stringargcount;
  return res;
}
function getReturnType(calli, ops, endindex = ops.length) {
  let res = new StackList();
  for (let i = endindex - 2; i >= 0; i--) {
    let op = ops[i];
    let opinfo = calli.getNamedOp(op.opcode);
    if (opinfo.id == namedClientScriptOps.pushconst) {
      if (op.imm == 0) {
        res.int();
      }
      if (op.imm == 1) {
        res.long();
      }
      if (op.imm == 2) {
        res.string();
      }
    } else if (opinfo.id == namedClientScriptOps.pushint) {
      res.int();
    } else if (opinfo.id == namedClientScriptOps.pushlong) {
      res.long();
    } else if (opinfo.id == namedClientScriptOps.pushstring) {
      res.string();
    } else {
      break;
    }
  }
  res.values.reverse();
  return res;
}
globalThis.getop = (opid) => {
  let id = -1;
  if (opid.startsWith("unk")) {
    id = +opid.slice(3);
  } else {
    for (let op in knownClientScriptOpNames) {
      if (knownClientScriptOpNames[op] == opid) {
        id = +op;
      }
    }
  }
  let calli = globalThis.deob;
  return calli.decodedMappings.get(id);
};
function firstKey(map) {
  return map.keys().next().value;
}

// rsmv/src/clientscript/jsonwriter.ts
var tmplocaloffset = 65536;
var OpcodeWriterContext = class {
  constructor(calli) {
    this.tempcounts = new StackDiff();
    this.labels = /* @__PURE__ */ new Map();
    this.namedLabels = /* @__PURE__ */ new Map();
    this.subfunctions = /* @__PURE__ */ new Map();
    this.returntableLabel = null;
    this.returnsites = /* @__PURE__ */ new Map();
    this.returnsiteidcounter = 1;
    this.calli = calli;
  }
  makeReturnOp() {
    if (!this.returntableLabel) {
      this.returntableLabel = makeop(namedClientScriptOps.jump, 0);
      this.declareLabel(this.returntableLabel);
    }
    return makejump(this.returntableLabel);
  }
  getSubfunctionLabel(name) {
    return getOrInsert(this.namedLabels, name, () => {
      let label = makeop(namedClientScriptOps.jump, 0);
      this.declareLabel(label);
      return label;
    });
  }
  makeSubCallOps(funcname) {
    let returnid = this.returnsiteidcounter++;
    let body = [];
    let labelobj = this.getSubfunctionLabel(funcname);
    if (!labelobj) {
      throw new Error("subcall func does not exist");
    }
    body.push(makeop(namedClientScriptOps.pushconst, 0, returnid));
    body.push(makejump(labelobj));
    let returnsite = makeop(namedClientScriptOps.jump, 0);
    body.push(returnsite);
    this.returnsites.set(returnid, returnsite);
    this.declareLabel(returnsite);
    return body;
  }
  declareLabel(op) {
    this.labels.set(op, -1);
  }
  addSubfunction(func) {
    if (this.subfunctions.has(func.scriptname)) {
      throw new Error(`subfunction ${func.scriptname} already exists`);
    }
    let label = this.getSubfunctionLabel(func.scriptname);
    this.subfunctions.set(func.scriptname, { label, func });
  }
};
function tracerNops(text) {
  return [
    makeop(namedClientScriptOps.pushconst, 2, text),
    makeop(namedClientScriptOps.popdiscardstring)
  ];
}
var intrinsics = /* @__PURE__ */ new Map();
intrinsics.set("varbittable", {
  in: new StackList(),
  out: new StackList(["string"]),
  write(ctx) {
    let body = [];
    let lookupstr = ",";
    for (let [id, meta] of ctx.calli.varbitmeta) {
      let group = meta.varid >> 16;
      let varid = meta.varid & 65535;
      lookupstr += `${id}:${group}/${varid}/${meta.bits[0]}/${meta.bits[1]},`;
    }
    body.push(makeop(namedClientScriptOps.pushconst, 2, lookupstr));
    body.push(ctx.makeReturnOp());
    return body;
  }
});
intrinsics.set("opnametoid", {
  in: new StackList(["string"]),
  out: new StackList(["int"]),
  write(ctx) {
    let body = [];
    ctx.tempcounts.int = Math.max(ctx.tempcounts.int, 1);
    ctx.tempcounts.string = Math.max(ctx.tempcounts.string, 1);
    body.push(makeop(namedClientScriptOps.poplocalint, tmplocaloffset + 0));
    body.push(makeop(namedClientScriptOps.poplocalstring, tmplocaloffset + 0));
    let endlabel = makeop(namedClientScriptOps.jump, 0);
    ctx.declareLabel(endlabel);
    for (let [id, opinfo] of ctx.calli.decodedMappings) {
      let name = getOpName(id).toLowerCase();
      body.push(makeop(namedClientScriptOps.pushconst, 2, name));
      body.push(makeop(namedClientScriptOps.pushlocalstring, tmplocaloffset + 0));
      body.push(makeop(namedClientScriptOps.strcmp));
      body.push(makeop(namedClientScriptOps.pushconst, 0, 0));
      body.push(makeop(namedClientScriptOps.branch_eq, 1));
      body.push(makeop(namedClientScriptOps.jump, 2));
      body.push(makeop(namedClientScriptOps.pushconst, 0, id));
      body.push(makejump(endlabel));
    }
    body.push(makeop(namedClientScriptOps.pushconst, 2, "no opcode id found for : "));
    body.push(makeop(namedClientScriptOps.pushlocalstring, tmplocaloffset + 0));
    body.push(makeop(namedClientScriptOps.joinstring, 2));
    body.push(makeop(namedClientScriptOps.printmessage));
    body.push(makeop(namedClientScriptOps.pushconst, 0, -1));
    body.push(endlabel);
    body.push(makeop(namedClientScriptOps.pushlocalint, tmplocaloffset + 0));
    body.push(ctx.makeReturnOp());
    return body;
  }
});
function partialCallIntrinsic(idstart, idend) {
  return (ctx) => {
    let body = [];
    let jumptable = [];
    ctx.tempcounts.int = Math.max(ctx.tempcounts.int, 2);
    body.push(makeop(namedClientScriptOps.poplocalint, tmplocaloffset + 1));
    let jumpstart = body.length;
    let endlabel = makeop(namedClientScriptOps.jump, 0);
    ctx.declareLabel(endlabel);
    body.push(makeop(namedClientScriptOps.pushconst, 2, "no script matched"));
    body.push(makeop(namedClientScriptOps.printmessage));
    body.push(makejump(endlabel));
    for (let id = idstart; id < idend; id++) {
      jumptable.push({ value: id, jump: body.length - jumpstart });
      body.push(makeop(namedClientScriptOps.gosub, id));
      body.push(makejump(endlabel));
    }
    body.push(endlabel);
    ctx.tempcounts.int = Math.max(ctx.tempcounts.int, 1);
    body.splice(jumpstart, 0, ...jumptableToBTree(jumptable, tmplocaloffset + 0));
    body.push(makeop(namedClientScriptOps.pushlocalint, tmplocaloffset + 1));
    body.push(ctx.makeReturnOp());
    return body;
  };
}
function partialVarIntrinsic(iswrite, dottarget, sectionindex) {
  return (ctx) => {
    let body = [];
    let jumptable = [];
    let keys = [];
    function addgroup(key, start, maxcount) {
      let maxid = ctx.calli.varmeta.get(key)?.maxid ?? 0;
      maxid = Math.ceil((maxid + 200) / 100) * 100;
      maxid = Math.min(maxid, start + maxcount);
      for (let i = start; i < maxid; i++) {
        keys.push(key << 24 | i << 8 | dottarget);
      }
    }
    if (sectionindex == 0) {
      addgroup(variableSources.player.key, 0, 1e4);
    } else if (sectionindex == 1) {
      addgroup(variableSources.client.key, 0, 1e4);
    } else if (sectionindex == 2) {
      for (let group of Object.values(variableSources)) {
        if (group == variableSources.player) {
          continue;
        }
        if (group == variableSources.client) {
          continue;
        }
        addgroup(group.key, 0, 1e4);
      }
      addgroup(variableSources.player.key, 1e4, 1e4);
    } else {
      throw new Error("unexpected");
    }
    ctx.tempcounts.int = Math.max(ctx.tempcounts.int, 2);
    body.push(makeop(namedClientScriptOps.poplocalint, tmplocaloffset + 1));
    let jumpstart = body.length;
    let endlabel = makeop(namedClientScriptOps.jump, 0);
    ctx.declareLabel(endlabel);
    body.push(makeop(namedClientScriptOps.pushconst, 2, "no var matched"));
    body.push(makeop(namedClientScriptOps.printmessage));
    body.push(makejump(endlabel));
    for (let key of keys) {
      jumptable.push({ value: key, jump: body.length - jumpstart });
      body.push(makeop(iswrite ? namedClientScriptOps.popvar : namedClientScriptOps.pushvar, key));
      body.push(makejump(endlabel));
    }
    body.push(endlabel);
    ctx.tempcounts.int = Math.max(ctx.tempcounts.int, 1);
    body.splice(jumpstart, 0, ...jumptableToBTree(jumptable, tmplocaloffset + 0));
    body.push(makeop(namedClientScriptOps.pushlocalint, tmplocaloffset + 1));
    body.push(ctx.makeReturnOp());
    return body;
  };
}
intrinsics.set("call0", { in: new StackList(["int"]), out: new StackList(), write: partialCallIntrinsic(0, 1e4) });
intrinsics.set("call1", { in: new StackList(["int"]), out: new StackList(), write: partialCallIntrinsic(1e4, 2e4) });
intrinsics.set("getvar0", { in: new StackList(["int"]), out: new StackList(), write: partialVarIntrinsic(false, 0, 0) });
intrinsics.set("getvar1", { in: new StackList(["int"]), out: new StackList(), write: partialVarIntrinsic(false, 0, 1) });
intrinsics.set("getvar2", { in: new StackList(["int"]), out: new StackList(), write: partialVarIntrinsic(false, 0, 2) });
intrinsics.set("getvarother0", { in: new StackList(["int"]), out: new StackList(), write: partialVarIntrinsic(false, 1, 0) });
intrinsics.set("getvarother1", { in: new StackList(["int"]), out: new StackList(), write: partialVarIntrinsic(false, 1, 1) });
intrinsics.set("getvarother2", { in: new StackList(["int"]), out: new StackList(), write: partialVarIntrinsic(false, 1, 2) });
intrinsics.set("setvar0", { in: new StackList(["int"]), out: new StackList(), write: partialVarIntrinsic(true, 0, 0) });
intrinsics.set("setvar1", { in: new StackList(["int"]), out: new StackList(), write: partialVarIntrinsic(true, 0, 1) });
intrinsics.set("setvar2", { in: new StackList(["int"]), out: new StackList(), write: partialVarIntrinsic(true, 0, 2) });
intrinsics.set("op", {
  in: new StackList(["int"]),
  out: new StackList(),
  write(ctx) {
    let body = [];
    ctx.tempcounts.int = Math.max(ctx.tempcounts.int, 1);
    body.push(makeop(namedClientScriptOps.poplocalint, tmplocaloffset + 0));
    let jumptable = { type: "switchvalues", value: [] };
    let switchop = makeop(namedClientScriptOps.switch, 0, jumptable);
    body.push(switchop);
    let jumpstart = body.length;
    let endlabel = makeop(namedClientScriptOps.jump, 0);
    ctx.declareLabel(endlabel);
    body.push(makeop(namedClientScriptOps.pushconst, 2, "no opcodes matched"));
    body.push(makeop(namedClientScriptOps.printmessage));
    body.push(makejump(endlabel));
    for (let id of ctx.calli.decodedMappings.keys()) {
      let opid = +id;
      if (branchInstructionsOrJump.includes(opid)) {
        continue;
      }
      if (opid == namedClientScriptOps.switch) {
        continue;
      }
      if (opid == namedClientScriptOps.return) {
        continue;
      }
      if (opid == namedClientScriptOps.pushconst) {
        continue;
      }
      jumptable.value.push({ value: opid, jump: body.length - jumpstart });
      body.push({ opcode: opid, imm: 0, imm_obj: null });
      body.push(makejump(endlabel));
    }
    body.push(endlabel);
    body.push(makeop(namedClientScriptOps.pushlocalint, tmplocaloffset + 0));
    body.push(ctx.makeReturnOp());
    return body;
  }
});
function jumptableToBTree(table, tmpintlocal) {
  const bucketsize = 16;
  table.sort((a, b) => a.value - b.value);
  let body = [];
  body.push(makeop(namedClientScriptOps.poplocalint, tmpintlocal));
  let branch = (start, end) => {
    let len = end - start;
    if (len < bucketsize) {
      for (let i = 0; i < len; i++) {
        let entry = table[start + i];
        body.push(makeop(namedClientScriptOps.pushlocalint, tmpintlocal));
        body.push(makeop(namedClientScriptOps.pushconst, 0, entry.value));
        body.push(makeop(namedClientScriptOps.branch_eq, entry.jump));
      }
      body.push(makeop(namedClientScriptOps.jump, 0));
    } else {
      let split = start + Math.ceil(len / 2);
      let branchop = makeop(namedClientScriptOps.branch_gteq, 0);
      body.push(makeop(namedClientScriptOps.pushlocalint, tmpintlocal));
      body.push(makeop(namedClientScriptOps.pushconst, 0, table[split].value));
      body.push(branchop);
      let branchbase = body.length;
      branch(start, split);
      branchop.imm = body.length - branchbase;
      branch(split, end);
    }
  };
  branch(0, table.length);
  for (let i = 0; i < body.length; i++) {
    let op = body[i];
    if (op.opcode == namedClientScriptOps.branch_eq || op.opcode == namedClientScriptOps.jump) {
      op.imm += body.length - i - 1;
    }
  }
  return body;
}
function writeRawStackSubFunction(ctx, subfunc) {
  let opdata = [];
  let intype = subfunc.func.argtype.getStackdiff();
  let outtype = subfunc.func.returntype.getStackdiff();
  ctx.tempcounts.int = Math.max(ctx.tempcounts.int, subfunc.func.localCounts.int + 1, outtype.int + 1);
  ctx.tempcounts.long = Math.max(ctx.tempcounts.long, subfunc.func.localCounts.long, outtype.long);
  ctx.tempcounts.string = Math.max(ctx.tempcounts.string, subfunc.func.localCounts.string, outtype.string);
  let headerindex = opdata.length;
  let headerop = makeop(namedClientScriptOps.pushconst, 2, "");
  opdata.push(headerop);
  let jumptarget = opdata.length;
  opdata.push(subfunc.label);
  let returnaddrtemp = tmplocaloffset + subfunc.func.localCounts.int;
  opdata.push(makeop(namedClientScriptOps.poplocalint, returnaddrtemp));
  for (let i = intype.int - 1; i >= 0; i--) {
    opdata.push(makeop(namedClientScriptOps.poplocalint, tmplocaloffset + i));
  }
  for (let i = intype.long - 1; i >= 0; i--) {
    opdata.push(makeop(namedClientScriptOps.poplocallong, tmplocaloffset + i));
  }
  for (let i = intype.string - 1; i >= 0; i--) {
    opdata.push(makeop(namedClientScriptOps.poplocalstring, tmplocaloffset + i));
  }
  let funcbody = subfunc.func.getOpcodes(ctx);
  let endlabel = makeop(namedClientScriptOps.jump, 0);
  ctx.declareLabel(endlabel);
  funcbody.forEach((op, i) => {
    if (op.opcode == namedClientScriptOps.jump) {
      if (typeof op.imm_obj == "object" && op.imm_obj && "type" in op.imm_obj && op.imm_obj.type == "jumplabel") {
        throw new Error("subcalls not allowed in rawstack subfunction");
      }
    }
    if (op.opcode == namedClientScriptOps.return) {
      funcbody[i] = makejump(endlabel);
    }
    if (pushOrPopLocalOps.includes(op.opcode)) {
      funcbody[i] = { ...op, imm: tmplocaloffset + op.imm };
    }
  });
  opdata.push(...tracerNops(`subfunc ${subfunc.func.scriptname} body`));
  let bodyindex = opdata.length;
  opdata.push(...funcbody);
  let footindex = opdata.length;
  opdata.push(endlabel);
  opdata.push(...tracerNops(`subfunc ${subfunc.func.scriptname} footer`));
  opdata.push(makeop(namedClientScriptOps.pushlocalint, returnaddrtemp));
  opdata.push(ctx.makeReturnOp());
  opdata.push(...tracerNops(`subfunc ${subfunc.func.scriptname} end`));
  headerop.imm_obj = `${subfunclabel("subfunc", jumptarget - headerindex, opdata.length - headerindex, intype, outtype)} body=${bodyindex - headerindex} foot=${footindex - headerindex} rawstack=true`;
  return opdata;
}
function writeSubFunction(ctx, subfunc) {
  let opdata = [];
  let intype = subfunc.func.argtype.getStackdiff();
  let outtype = subfunc.func.returntype.getStackdiff();
  let localtype = subfunc.func.localCounts.clone();
  ctx.tempcounts.int = Math.max(ctx.tempcounts.int, intype.int + 1, outtype.int + 1);
  ctx.tempcounts.long = Math.max(ctx.tempcounts.long, intype.long, outtype.long);
  ctx.tempcounts.string = Math.max(ctx.tempcounts.string, intype.string, outtype.string);
  let headerindex = opdata.length;
  let headerop = makeop(namedClientScriptOps.pushconst, 2, "");
  opdata.push(headerop);
  let jumptarget = opdata.length;
  opdata.push(subfunc.label);
  let returnaddrtemp = tmplocaloffset + Math.max(intype.int, outtype.int);
  opdata.push(makeop(namedClientScriptOps.poplocalint, returnaddrtemp));
  for (let i = intype.int - 1; i >= 0; i--) {
    opdata.push(makeop(namedClientScriptOps.poplocalint, tmplocaloffset + i));
  }
  for (let i = intype.long - 1; i >= 0; i--) {
    opdata.push(makeop(namedClientScriptOps.poplocallong, tmplocaloffset + i));
  }
  for (let i = intype.string - 1; i >= 0; i--) {
    opdata.push(makeop(namedClientScriptOps.poplocalstring, tmplocaloffset + i));
  }
  for (let i = 0; i < localtype.int; i++) {
    opdata.push(makeop(namedClientScriptOps.pushlocalint, i));
  }
  for (let i = 0; i < localtype.long; i++) {
    opdata.push(makeop(namedClientScriptOps.pushlocallong, i));
  }
  for (let i = 0; i < localtype.string; i++) {
    opdata.push(makeop(namedClientScriptOps.pushlocalstring, i));
  }
  opdata.push(makeop(namedClientScriptOps.pushlocalint, returnaddrtemp));
  for (let i = 0; i < intype.int; i++) {
    opdata.push(makeop(namedClientScriptOps.pushlocalint, tmplocaloffset + i), makeop(namedClientScriptOps.poplocalint, i));
  }
  for (let i = 0; i < intype.long; i++) {
    opdata.push(makeop(namedClientScriptOps.pushlocallong, tmplocaloffset + i), makeop(namedClientScriptOps.poplocallong, i));
  }
  for (let i = 0; i < intype.string; i++) {
    opdata.push(makeop(namedClientScriptOps.pushlocalstring, tmplocaloffset + i), makeop(namedClientScriptOps.poplocalstring, i));
  }
  let funcbody = subfunc.func.getOpcodes(ctx);
  let endlabel = makeop(namedClientScriptOps.jump, 0);
  ctx.declareLabel(endlabel);
  funcbody.forEach((op, i) => {
    if (op.opcode == namedClientScriptOps.return) {
      funcbody[i] = makejump(endlabel);
    }
  });
  opdata.push(...tracerNops(`subfunc ${subfunc.func.scriptname} body`));
  let bodyindex = opdata.length;
  opdata.push(...funcbody);
  let footindex = opdata.length;
  opdata.push(endlabel);
  opdata.push(...tracerNops(`subfunc ${subfunc.func.scriptname} footer`));
  for (let i = outtype.int - 1; i >= 0; i--) {
    opdata.push(makeop(namedClientScriptOps.poplocalint, tmplocaloffset + i));
  }
  for (let i = outtype.long - 1; i >= 0; i--) {
    opdata.push(makeop(namedClientScriptOps.poplocallong, tmplocaloffset + i));
  }
  for (let i = outtype.string - 1; i >= 0; i--) {
    opdata.push(makeop(namedClientScriptOps.poplocalstring, tmplocaloffset + i));
  }
  opdata.push(makeop(namedClientScriptOps.poplocalint, returnaddrtemp));
  for (let i = localtype.int - 1; i >= 0; i--) {
    opdata.push(makeop(namedClientScriptOps.poplocalint, i));
  }
  for (let i = localtype.long - 1; i >= 0; i--) {
    opdata.push(makeop(namedClientScriptOps.poplocallong, i));
  }
  for (let i = localtype.string - 1; i >= 0; i--) {
    opdata.push(makeop(namedClientScriptOps.poplocalstring, i));
  }
  for (let i = 0; i < outtype.int; i++) {
    opdata.push(makeop(namedClientScriptOps.pushlocalint, tmplocaloffset + i));
  }
  for (let i = 0; i < outtype.long; i++) {
    opdata.push(makeop(namedClientScriptOps.pushlocallong, tmplocaloffset + i));
  }
  for (let i = 0; i < outtype.string; i++) {
    opdata.push(makeop(namedClientScriptOps.pushlocalstring, tmplocaloffset + i));
  }
  opdata.push(makeop(namedClientScriptOps.pushlocalint, returnaddrtemp));
  opdata.push(ctx.makeReturnOp());
  opdata.push(...tracerNops(`subfunc ${subfunc.func.scriptname} end`));
  headerop.imm_obj = `${subfunclabel("subfunc", jumptarget - headerindex, opdata.length - headerindex, intype, outtype)} body=${bodyindex - headerindex} foot=${footindex - headerindex}`;
  return opdata;
}
function subfunclabel(type, entry, end, arg, returns) {
  return `type=${type} entry=${entry} end=${end} in=${arg.int},${arg.long},${arg.string} out=${returns.int},${returns.long},${returns.string}`;
}
function calcSwitchSize(switches) {
  return 1 + switches.reduce((a, v) => a + 2 + v.length * (4 + 4), 0);
}
function astToImJson(calli, func) {
  let ctx = new OpcodeWriterContext(calli);
  let opdata = [];
  let funcbody = func.getOpcodes(ctx);
  let switches = [];
  let returnsitejumps = [];
  if (ctx.subfunctions.size != 0 || ctx.returnsites.size != 0) {
    let footerendlabel = makeop(namedClientScriptOps.jump, 0);
    ctx.declareLabel(footerendlabel);
    opdata.push(makejump(footerendlabel));
    opdata.push(makeop(namedClientScriptOps.pushconst, 2, subfunclabel("returnjumps", 1, 6, new StackDiff(1, 0, 0), new StackDiff())));
    opdata.push(ctx.makeReturnOp().imm_obj.value);
    opdata.push(makeop(namedClientScriptOps.switch, 0, { type: "switchvalues", value: returnsitejumps }));
    opdata.push(makeop(namedClientScriptOps.pushconst, 2, "unknown return address on stack (stack is corrupt)"));
    opdata.push(makeop(namedClientScriptOps.printmessage));
    opdata.push(makeop(namedClientScriptOps.return));
    for (let funcname of ctx.namedLabels.keys()) {
      let intr = intrinsics.get(funcname);
      if (intr) {
        let tagop = makeop(namedClientScriptOps.pushconst, 2);
        let startindex = opdata.length;
        opdata.push(tagop);
        opdata.push(ctx.getSubfunctionLabel(funcname));
        opdata.push(...intr.write(ctx));
        let intype = intr.in.getStackdiff();
        let outtype = intr.out.getStackdiff();
        tagop.imm_obj = `${subfunclabel("intrinsic", 1, opdata.length - startindex, intype, outtype)} name=${funcname}`;
      } else {
        let func2 = ctx.subfunctions.get(funcname);
        if (!func2) {
          throw new Error(`func ${funcname} is not declared`);
        }
        if (func2.func.isRawStack) {
          opdata.push(...writeRawStackSubFunction(ctx, func2));
        } else {
          opdata.push(...writeSubFunction(ctx, func2));
        }
      }
    }
    opdata.push(footerendlabel);
  }
  opdata.push(...funcbody);
  let allargs = func.argtype.getStackdiff();
  let localcounts = func.localCounts.clone().add(ctx.tempcounts);
  let script = {
    byte0: 0,
    switchsize: -1,
    switches,
    longargcount: allargs.long,
    stringargcount: allargs.string,
    intargcount: allargs.int,
    locallongcount: localcounts.long + ctx.tempcounts.long,
    localstringcount: localcounts.string + ctx.tempcounts.string,
    localintcount: localcounts.int + ctx.tempcounts.int,
    instructioncount: opdata.length,
    opcodedata: opdata
  };
  let labelmap = ctx.labels;
  for (let index = 0; index < opdata.length; index++) {
    let op = opdata[index];
    if (labelmap.get(op) !== void 0) {
      labelmap.set(op, index);
    }
  }
  for (let index = 0; index < opdata.length; index++) {
    let op = opdata[index];
    if (typeof op.imm_obj == "object" && op.imm_obj && !Array.isArray(op.imm_obj)) {
      if (op.imm_obj.type == "switchvalues") {
        op.imm = script.switches.push(op.imm_obj.value) - 1;
      } else if (op.imm_obj.type == "jumplabel") {
        let target = labelmap.get(op.imm_obj.value);
        if (typeof target != "number" || target == -1) {
          throw new Error("label not found");
        }
        op.imm = target - (index + 1);
      }
      op.imm_obj = null;
    }
    if (pushOrPopLocalOps.includes(op.opcode)) {
      if (op.imm & tmplocaloffset) {
        if (op.opcode == namedClientScriptOps.pushlocalint || op.opcode == namedClientScriptOps.poplocalint || op.opcode == namedClientScriptOps.popdiscardint) {
          op.imm = func.localCounts.int + (op.imm & 65535);
        }
        if (op.opcode == namedClientScriptOps.pushlocallong || op.opcode == namedClientScriptOps.poplocallong || op.opcode == namedClientScriptOps.popdiscardlong) {
          op.imm = func.localCounts.long + (op.imm & 65535);
        }
        if (op.opcode == namedClientScriptOps.pushlocalstring || op.opcode == namedClientScriptOps.poplocalstring || op.opcode == namedClientScriptOps.popdiscardstring) {
          op.imm = func.localCounts.string + (op.imm & 65535);
        }
      }
    }
  }
  if (ctx.returnsites.size != 0) {
    let switchbaseaddress = labelmap.get(ctx.makeReturnOp().imm_obj.value);
    if (typeof switchbaseaddress != "number") {
      throw new Error("dynamicjump section not found");
    }
    switchbaseaddress += 2;
    for (let [label, targetop] of ctx.returnsites) {
      let target = labelmap.get(targetop);
      if (target == void 0) {
        throw new Error("dynamicjump return address not found");
      }
      returnsitejumps.push({ jump: target - switchbaseaddress, value: label });
    }
  }
  script.switchsize = calcSwitchSize(script.switches);
  if (script.switchsize > 65535) {
    throw new Error(`compiled script switch table size is larger than 65kb, this isn't supported by the binary format. This corresponds to a max of ~8k branches accross all switch statements, actual number: ${script.switches.reduce((a, v) => a + v.length, 0)}`);
  }
  if (script.opcodedata.length > 65535) {
    throw new Error(`compiled script is longer than max length of 0xffff, the Jagex VM will parse it incorrectly, actual length (${script.opcodedata.length})`);
  }
  return script;
}

// rsmv/src/clientscript/ast.ts
function getSingleChild(op, type) {
  if (!op || op.children.length != 1 || !(op.children[0] instanceof type)) {
    return null;
  }
  return op.children[0];
}
function isNamedOp(op, id) {
  return op instanceof RawOpcodeNode && op.op.opcode == id;
}
var AstNode = class {
  constructor(originalindex) {
    this.parent = null;
    this.knownStackDiff = null;
    this.children = [];
    this.originalindex = originalindex;
  }
  pushList(nodes) {
    for (let node of nodes) {
      if (node.parent == this) {
        continue;
      }
      node.parent = null;
      this.push(node);
    }
  }
  push(node) {
    if (node == this) {
      throw new Error("tried to add self to ast children");
    }
    node.parent?.remove(node);
    this.children.push(node);
    node.parent = this;
  }
  clear() {
    this.children.forEach((q) => q.parent = null);
    this.children.length = 0;
  }
  unshift(node) {
    node.parent?.remove(node);
    this.children.unshift(node);
    node.parent = this;
  }
  replaceChild(oldnode, newnode) {
    if (newnode == this) {
      throw new Error("tried to add self to ast children");
    }
    newnode.parent?.remove(newnode);
    let index = this.children.indexOf(oldnode);
    if (index == -1) {
      throw new Error("tried to replace node that isn't a child");
    }
    newnode.parent = this;
    oldnode.parent = null;
    this.children[index] = newnode;
  }
  remove(node) {
    let index = this.children.indexOf(node);
    if (index == -1) {
      throw new Error("tried to remove node that isn't a child");
    }
    this.children.splice(index, 1);
    node.parent = null;
  }
};
var SubcallNode = class extends AstNode {
  constructor(originalindex, funcname, argtype, returntype) {
    super(originalindex);
    this.funcname = funcname;
    let args = argtype.clone();
    args.pushone("int");
    this.knownStackDiff = new StackInOut(args, returntype);
  }
  getOpcodes(ctx) {
    let body = this.children.slice(0, -1).flatMap((q) => q.getOpcodes(ctx));
    body.push(...ctx.makeSubCallOps(this.funcname));
    return body;
  }
};
var ComposedOp = class extends AstNode {
  constructor(originalindex, type) {
    super(originalindex);
    this.internalOps = [];
    this.type = type;
  }
  getOpcodes(ctx) {
    if (this.type != "stack" && this.children.length != 0) {
      throw new Error("no children expected on composednode");
    }
    return this.children.flatMap((q) => q.getOpcodes(ctx)).concat(this.internalOps.flatMap((q) => q.getOpcodes(ctx)));
  }
};
var VarAssignNode = class extends AstNode {
  constructor() {
    super(...arguments);
    this.varops = [];
    this.knownStackDiff = new StackInOut(new StackList(), new StackList());
  }
  getOpcodes(ctx) {
    let res = this.children.flatMap((q) => q.getOpcodes(ctx));
    return res.concat(this.varops.flatMap((q) => q.getOpcodes(ctx)).reverse());
  }
  addVar(node) {
    this.varops.unshift(node);
    this.knownStackDiff.in.push(getNodeStackIn(node));
  }
};
var CodeBlockNode3 = class extends AstNode {
  constructor(scriptid, subfuncid, startindex, children) {
    super(startindex);
    this.possibleSuccessors = [];
    this.firstPointer = null;
    this.lastPointer = null;
    this.branchEndNode = null;
    this.maxEndIndex = -1;
    this.knownStackDiff = new StackInOut(new StackList(), new StackList());
    this.scriptid = scriptid;
    this.subfuncid = subfuncid;
    if (children) {
      this.pushList(children);
    }
  }
  addSuccessor(block) {
    if (this.originalindex < block.originalindex && (!block.firstPointer || this.originalindex < block.firstPointer.originalindex)) {
      block.firstPointer = this;
    }
    if (this.originalindex > block.originalindex && (!block.lastPointer || this.originalindex > block.lastPointer.originalindex)) {
      block.lastPointer = this;
      block.maxEndIndex = this.originalindex;
    }
    if (!block) {
      throw new Error("added null successor");
    }
    this.possibleSuccessors.push(block);
  }
  mergeBlock(block, flatten) {
    if (flatten) {
      this.pushList(block.children);
      block.children.length = 0;
    } else {
      this.push(block);
    }
    this.possibleSuccessors = block.possibleSuccessors;
    this.branchEndNode = block.branchEndNode;
  }
  findNext() {
    if (!this.branchEndNode) {
      if (this.possibleSuccessors.length == 0) {
        this.branchEndNode = null;
      } else if (this.possibleSuccessors.length == 1) {
        if (this.possibleSuccessors[0].originalindex < this.originalindex) {
          this.branchEndNode = null;
        } else {
          this.branchEndNode = this.possibleSuccessors[0];
        }
      } else {
        let optionstates = this.possibleSuccessors.slice();
        while (true) {
          let first = null;
          for (let op of optionstates) {
            if (op && (first == null || op.originalindex < first.originalindex)) {
              first = op;
            }
          }
          if (!first) {
            this.branchEndNode = null;
            break;
          }
          if (optionstates.every((q) => !q || q == first)) {
            this.branchEndNode = first;
            break;
          }
          optionstates[optionstates.indexOf(first)] = first.findNext();
        }
      }
    }
    return this.branchEndNode;
  }
  getOpcodes(ctx) {
    return this.children.flatMap((q) => {
      if (q instanceof ClientScriptFunction) {
        ctx.addSubfunction(q);
        return [];
      } else {
        return q.getOpcodes(ctx);
      }
    });
  }
  dump() {
    debugAst(this);
  }
};
function retargetJumps(ctx, code, from, to) {
  let lastop = code.at(-1);
  let insertedcount = 0;
  if (lastop && lastop.opcode != namedClientScriptOps.jump && from == 0) {
    let jumpop = ctx.calli.getNamedOp(namedClientScriptOps.jump);
    code.push({ opcode: jumpop.id, imm: to - 1, imm_obj: null });
    insertedcount++;
  }
  for (let index = 0; index < code.length; index++) {
    let op = code[index];
    if (branchInstructionsOrJump.includes(op.opcode)) {
      let target = index + 1 + op.imm;
      if (target >= code.length - insertedcount) {
        target += insertedcount;
      }
      if (target == code.length + from) {
        target = code.length + to;
      }
      op.imm = target - index - 1;
    }
  }
}
var BranchingStatement = class extends AstNode {
  //TODO not correct, we also use this for longs
  constructor(opcodeinfo, originalindex) {
    super(originalindex);
    this.knownStackDiff = new StackInOut(new StackList(["int", "int"]), new StackList(["int"]));
    this.op = opcodeinfo;
  }
  getOpcodes(ctx) {
    if (this.op.opcode == namedClientScriptOps.shorting_or || this.op.opcode == namedClientScriptOps.shorting_and) {
      if (this.children.length != 2) {
        throw new Error("unexpected");
      }
      let left = this.children[0].getOpcodes(ctx);
      let right = this.children[1].getOpcodes(ctx);
      if (this.op.opcode == namedClientScriptOps.shorting_or) {
        retargetJumps(ctx, left, 1, right.length + 1);
      } else {
        retargetJumps(ctx, left, 0, right.length);
        retargetJumps(ctx, left, 1, 0);
      }
      return [...left, ...right];
    }
    let op = { opcode: this.op.opcode, imm: 1, imm_obj: null };
    return this.children.flatMap((q) => q.getOpcodes(ctx)).concat(op);
  }
};
var WhileLoopStatementNode = class _WhileLoopStatementNode extends AstNode {
  constructor(originalindex, statement, body) {
    super(originalindex);
    this.knownStackDiff = new StackInOut(new StackList(), new StackList());
    this.statement = statement;
    this.body = body;
    this.push(statement);
    this.push(body);
  }
  static fromIfStatement(originalindex, originnode) {
    if (originnode.falsebranch) {
      throw new Error("cannot have else branch in loop");
    }
    if (!originnode.parent) {
      throw new Error("unexpected");
    }
    return new _WhileLoopStatementNode(originalindex, originnode.statement, originnode.truebranch);
  }
  getOpcodes(ctx) {
    let cond = this.statement.getOpcodes(ctx);
    let body = this.body.getOpcodes(ctx);
    let jump = ctx.calli.getNamedOp(namedClientScriptOps.jump);
    cond.push({ opcode: jump.id, imm: body.length + 1, imm_obj: null });
    body.push({ opcode: jump.id, imm: -(body.length + 1 + cond.length), imm_obj: null });
    return [...cond, ...body];
  }
};
var ControlStatementNode = class extends AstNode {
  constructor(originalindex, type) {
    super(originalindex);
    this.type = type;
  }
  getOpcodes(ctx) {
    throw new Error("break/continue statements failed to process. only break at end of switch case supported");
  }
};
var SwitchStatementNode = class _SwitchStatementNode extends AstNode {
  constructor(originalindex, valueop, defaultnode, branches) {
    super(originalindex);
    this.branches = [];
    this.defaultbranch = null;
    this.knownStackDiff = new StackInOut(new StackList(["int"]), new StackList());
    this.valueop = valueop;
    this.defaultbranch = defaultnode;
    this.branches = branches;
    if (valueop) {
      this.push(valueop);
    }
    this.pushList(branches.map((q) => q.block));
    if (defaultnode) {
      this.push(defaultnode);
    }
  }
  static create(switchop, scriptjson, nodes, endindex) {
    let valueop = switchop.children[0] ?? null;
    let branches = [];
    let cases = scriptjson.switches[switchop.op.imm];
    if (!cases) {
      throw new Error("no matching cases in script");
    }
    for (let casev of cases) {
      let node = nodes.find((q) => q.originalindex == switchop.originalindex + 1 + casev.jump);
      if (!node) {
        throw new Error("switch case branch not found");
      }
      branches.push({ value: casev.value, block: node });
      node.maxEndIndex = endindex;
      if (node.originalindex != switchop.originalindex + 1 + casev.jump) {
        throw new Error("switch branches don't match");
      }
    }
    let defaultblock = nodes.find((q) => q.originalindex == switchop.originalindex + 1) ?? null;
    let defaultblockjump = getSingleChild(defaultblock, RawOpcodeNode);
    if (defaultblock && defaultblockjump && defaultblockjump.opinfo.id == namedClientScriptOps.jump) {
      if (defaultblock.possibleSuccessors.length != 1) {
        throw new Error("jump successor branch expected");
      }
      defaultblock = defaultblock.possibleSuccessors[0];
      if (defaultblock.originalindex == endindex) {
        defaultblock = null;
      }
    }
    if (defaultblock) {
      defaultblock.maxEndIndex = endindex;
    }
    return new _SwitchStatementNode(switchop.originalindex, valueop, defaultblock, branches);
  }
  getOpcodes(ctx) {
    let body = [];
    if (this.valueop) {
      body.push(...this.valueop.getOpcodes(ctx));
    }
    let jump = ctx.calli.getNamedOp(namedClientScriptOps.jump);
    let switchopinfo = ctx.calli.getNamedOp(namedClientScriptOps.switch);
    let switchop = { opcode: switchopinfo.id, imm: -1, imm_obj: null };
    let defaultjmp = { opcode: jump.id, imm: -1, imm_obj: null };
    body.push(switchop);
    let jumpstart = body.length;
    body.push(defaultjmp);
    let endops = [];
    let jumptable = { type: "switchvalues", value: [] };
    let lastblock = null;
    let lastblockindex = 0;
    for (let i = 0; i < this.branches.length; i++) {
      let branch = this.branches[i];
      if (branch.block == lastblock) {
        jumptable.value.push({ value: branch.value, jump: lastblockindex });
        continue;
      }
      if (lastblock) {
        let jmp = { opcode: jump.id, imm: -1, imm_obj: null };
        body.push(jmp);
        endops.push(jmp);
      }
      lastblock = branch.block;
      lastblockindex = body.length - jumpstart;
      jumptable.value.push({ value: branch.value, jump: lastblockindex });
      body.push(...branch.block.getOpcodes(ctx));
    }
    if (this.defaultbranch) {
      if (lastblock) {
        let jmp = { opcode: jump.id, imm: -1, imm_obj: null };
        body.push(jmp);
        endops.push(jmp);
      }
      defaultjmp.imm = body.length - body.indexOf(defaultjmp) - 1;
      body.push(...this.defaultbranch.getOpcodes(ctx));
    } else {
      endops.push(defaultjmp);
    }
    for (let op of endops) {
      let index = body.indexOf(op);
      op.imm = body.length - index - 1;
    }
    switchop.imm_obj = jumptable;
    return body;
  }
};
var IfStatementNode = class extends AstNode {
  constructor(originalindex) {
    super(originalindex);
    this.knownStackDiff = new StackInOut(new StackList(["int"]), new StackList());
  }
  setBranches(statement, truebranch, falsebranch, endindex) {
    if (truebranch == falsebranch) {
      throw new Error("unexpected");
    }
    this.ifEndIndex = endindex;
    this.statement = statement;
    this.push(statement);
    this.truebranch = truebranch;
    truebranch.maxEndIndex = this.ifEndIndex;
    this.falsebranch = falsebranch;
    if (falsebranch) {
      falsebranch.maxEndIndex = this.ifEndIndex;
    }
    if (falsebranch && falsebranch.originalindex < truebranch.originalindex) {
      this.push(falsebranch);
    }
    this.push(truebranch);
    if (falsebranch && falsebranch.originalindex >= truebranch.originalindex) {
      this.push(falsebranch);
    }
  }
  getOpcodes(ctx) {
    let cond = this.statement.getOpcodes(ctx);
    let truebranch = this.truebranch.getOpcodes(ctx);
    let falsebranch = [];
    if (this.falsebranch) {
      falsebranch = this.falsebranch.getOpcodes(ctx);
      truebranch.push({ opcode: ctx.calli.getNamedOp(namedClientScriptOps.jump).id, imm: falsebranch.length, imm_obj: null });
    }
    retargetJumps(ctx, cond, 0, truebranch.length == 1 ? 2 : truebranch.length);
    retargetJumps(ctx, cond, 1, 0);
    if (truebranch.length == 1) {
      retargetJumps(ctx, cond, 2, 1);
    }
    return [...cond, ...truebranch, ...falsebranch];
  }
};
var FunctionBindNode = class extends AstNode {
  constructor(originalindex, types) {
    super(originalindex);
    let intype = types.clone();
    intype.values.unshift("int");
    this.knownStackDiff = new StackInOut(intype, new StackList(["int", "vararg"]));
  }
  getOpcodes(ctx) {
    let scriptid = this.children[0]?.knownStackDiff?.constout ?? -1;
    if (typeof scriptid != "number") {
      throw new Error("unexpected");
    }
    let typestring = "";
    if (scriptid != -1) {
      let func = ctx.calli.scriptargs.get(scriptid);
      if (!func) {
        throw new Error("unknown functionbind types");
      }
      typestring = func.stack.in.toFunctionBindString();
    }
    let ops = this.children.flatMap((q) => q.getOpcodes(ctx)).concat();
    ops.push({ opcode: namedClientScriptOps.pushconst, imm: 2, imm_obj: typestring });
    return ops;
  }
};
var RawOpcodeNode = class extends AstNode {
  //multiple possible explanations for stack usage
  constructor(index, op, opinfo) {
    super(index);
    this.unknownstack = false;
    this.op = op;
    this.opinfo = opinfo;
  }
  getOpcodes(ctx) {
    let body = this.children.flatMap((q) => q.getOpcodes(ctx));
    body.push({ ...this.op });
    return body;
  }
};
var RewriteCursor = class {
  constructor(node) {
    this.cursorStack = [];
    this.stalled = true;
    this.rootnode = node;
  }
  current() {
    return this.cursorStack.at(-1) ?? null;
  }
  setFirstChild(target, stall = false) {
    this.stalled = stall;
    if (target != this.cursorStack.at(-1)) {
      this.cursorStack.push(target);
    }
    while (target.children.length != 0) {
      target = target.children[0];
      this.cursorStack.push(target);
    }
    return this.cursorStack.at(-1) ?? null;
  }
  remove() {
    let node = this.current();
    let newcurrent = this.prev();
    if (!node) {
      throw new Error("no node selected");
    }
    if (!node.parent) {
      throw new Error("cannot remove root node");
    }
    node.parent.remove(node);
    return newcurrent;
  }
  rebuildStack() {
    let current = this.current();
    this.cursorStack.length = 0;
    for (let node = current; node; node = node.parent) {
      this.cursorStack.unshift(node);
    }
  }
  replaceNode(newnode) {
    let node = this.current();
    if (!node) {
      throw new Error("no node selected");
    }
    if (!node.parent) {
      throw new Error("cannot replace root node");
    }
    node.parent.replaceChild(node, newnode);
    this.cursorStack[this.cursorStack.length - 1] = newnode;
    return newnode;
  }
  next() {
    if (this.stalled) {
      this.stalled = false;
      if (this.cursorStack.length == 0) {
        this.goToStart();
      }
      return this.current();
    }
    let currentnode = this.cursorStack.at(-1);
    let parentnode = this.cursorStack.at(-2);
    if (!currentnode) {
      return null;
    }
    this.cursorStack.pop();
    if (!parentnode) {
      return null;
    }
    let index = parentnode.children.indexOf(currentnode);
    if (index == parentnode.children.length - 1) {
      return parentnode;
    }
    let newnode = parentnode.children[index + 1];
    return this.setFirstChild(newnode);
  }
  prev() {
    if (this.stalled) {
      this.stalled = false;
      return this.current();
    }
    let currentnode = this.cursorStack.at(-1);
    if (!currentnode) {
      return null;
    }
    if (currentnode.children.length != 0) {
      let newnode = currentnode.children.at(-1);
      this.cursorStack.push(newnode);
      return newnode;
    }
    while (true) {
      this.cursorStack.pop();
      let parentnode = this.cursorStack.at(-1);
      if (!parentnode || !currentnode) {
        this.cursorStack.length = 0;
        this.stalled = true;
        return null;
      }
      let index = parentnode.children.indexOf(currentnode);
      if (index >= 1) {
        let newnode = parentnode.children[index - 1];
        this.cursorStack.push(newnode);
        return newnode;
      }
      currentnode = parentnode;
    }
  }
  setNextNode(node) {
    this.stalled = true;
    this.cursorStack.length = 0;
    for (let current = node; current; current = current.parent) {
      this.cursorStack.unshift(current);
    }
  }
  goToStart() {
    this.stalled = false;
    this.cursorStack.length = 0;
    return this.setFirstChild(this.rootnode);
  }
  goToEnd() {
    this.stalled = false;
    this.cursorStack.length = 0;
    return null;
  }
};
function getNodeStackOut(node) {
  if (node.knownStackDiff) {
    return node.knownStackDiff.out;
  }
  if (node instanceof RawOpcodeNode && node.opinfo.stackinfo) {
    return node.opinfo.stackinfo.out;
  }
  console.log("unknown stack out");
  return new StackList();
}
function getNodeStackIn(node) {
  if (node.knownStackDiff) {
    return node.knownStackDiff.in;
  }
  if (node instanceof RawOpcodeNode && node.opinfo.stackinfo) {
    return node.opinfo.stackinfo.in;
  }
  console.log("unknown stack in");
  return new StackList();
}
function translateAst(ast) {
  let cursor = new RewriteCursor(ast);
  for (let i = 0; i < ast.children.length; i++) {
    let op = ast.children[i];
    if (isNamedOp(op, namedClientScriptOps.jump) && op.op.imm == 0) {
      ast.children.splice(i, 1);
      i--;
    }
  }
  for (let i = 0; i < ast.children.length - 3; i++) {
    let prepushx = ast.children[i - 1];
    let pushx = ast.children[i];
    let push1 = ast.children[i + 1];
    let plusminus = ast.children[i + 2];
    let popx = ast.children[i + 3];
    let postpushx = ast.children[i + 4];
    if (isNamedOp(pushx, namedClientScriptOps.pushlocalint) && isNamedOp(push1, namedClientScriptOps.pushconst) && (isNamedOp(plusminus, namedClientScriptOps.plus) || isNamedOp(plusminus, namedClientScriptOps.minus)) && isNamedOp(popx, namedClientScriptOps.poplocalint) && pushx.op.imm == popx.op.imm) {
      let isminus = plusminus.op.opcode == namedClientScriptOps.minus;
      let ispre = isNamedOp(prepushx, namedClientScriptOps.pushlocalint) && prepushx.op.imm == popx.op.imm;
      let ispost = !ispre && isNamedOp(postpushx, namedClientScriptOps.pushlocalint) && postpushx.op.imm == popx.op.imm;
      if (ispre || ispost) {
        let op = new ComposedOp(popx.originalindex, isminus ? ispre ? "x--" : "--x" : ispre ? "x++" : "++x");
        ast.remove(pushx);
        ast.remove(push1);
        ast.remove(plusminus);
        ast.replaceChild(popx, op);
        op.internalOps.push(pushx);
        op.internalOps.push(push1);
        op.internalOps.push(plusminus);
        op.internalOps.push(popx);
        if (ispre) {
          ast.remove(prepushx);
          op.internalOps.unshift(prepushx);
        } else {
          ast.remove(postpushx);
          op.internalOps.push(postpushx);
        }
        op.knownStackDiff = StackInOut.fromExact([], [subtypes.int]);
      }
    }
  }
  let currentassignnode = null;
  for (let node = cursor.goToStart(); node; node = cursor.next()) {
    if (node instanceof RawOpcodeNode && (node.op.opcode == namedClientScriptOps.poplocalint || node.op.opcode == namedClientScriptOps.poplocallong || node.op.opcode == namedClientScriptOps.poplocalstring || node.op.opcode == namedClientScriptOps.popvar || node.op.opcode == namedClientScriptOps.popvarbit || node.op.opcode == namedClientScriptOps.popdiscardint || node.op.opcode == namedClientScriptOps.popdiscardlong || node.op.opcode == namedClientScriptOps.popdiscardstring)) {
      if (currentassignnode && currentassignnode.parent != node.parent) {
        throw new Error("ast is expected to be flat at this stage");
      }
      if (!currentassignnode) {
        currentassignnode = new VarAssignNode(node.originalindex);
        cursor.replaceNode(currentassignnode);
      } else {
        cursor.remove();
      }
      currentassignnode.addVar(node);
    } else {
      currentassignnode = null;
    }
  }
  let expandNode = (node) => {
    if (!(node instanceof ComposedOp) && !(node instanceof CodeBlockNode3)) {
      let argtype = getNodeStackIn(node).clone();
      for (let i = node.children.length - 1; i >= 0; i--) {
        argtype.pop(getNodeStackOut(node.children[i]));
      }
      while (!argtype.isEmpty() && usablestackdata.length != 0) {
        let { stackel, stackconst } = usablestackdata.at(-1);
        let outtype2 = getNodeStackOut(stackel);
        if (argtype.hasSimple(bindargs)) {
          if (typeof stackconst != "string") {
            throw new Error("expected vararg string");
          }
          usablestackdata.pop();
          let bindnode;
          if (outtype2.values.length == 1 && outtype2.values[0] == "vararg") {
            if (!stackel.knownStackDiff) {
              throw new Error("unexpected");
            }
            bindnode = new FunctionBindNode(stackel.originalindex, stackel.knownStackDiff.in);
            bindnode.pushList(stackel.children);
          } else {
            let maybearraylen = usablestackdata.at(-1)?.stackconst;
            let args = varArgtype(stackconst, maybearraylen);
            if (!args) {
              throw new Error("vararg const string expected");
            }
            bindnode = new FunctionBindNode(stackel.originalindex, args);
          }
          expandNode(bindnode);
          stackel.parent.replaceChild(stackel, bindnode);
          outtype2 = getNodeStackOut(bindnode);
          stackel = bindnode;
        }
        if (outtype2.isEmpty() || argtype.tryPop(outtype2) != 0) {
          break;
        }
        node.unshift(stackel);
        usablestackdata.pop();
      }
      if (!argtype.isEmpty()) {
        node.unshift(new ComposedOp(node.originalindex, "stack"));
      }
    }
    let outtype = getNodeStackOut(node);
    if (outtype.isEmpty()) {
      usablestackdata.forEach(({ stackel }) => {
        let capnode = new ComposedOp(stackel.originalindex, "stack");
        if (!stackel.parent) {
          throw new Error("uncapped node without parent");
        }
        stackel.parent.replaceChild(stackel, capnode);
        capnode.push(stackel);
      });
      usablestackdata.length = 0;
    } else {
      usablestackdata.push({ stackel: node, stackconst: node.knownStackDiff?.constout ?? null });
    }
  };
  let bindargs = new StackList(["int", "vararg"]);
  let usablestackdata = [];
  for (let node = cursor.goToStart(); node; node = cursor.next()) {
    expandNode(node);
  }
  return ast;
}
function fixControlFlow(ast, scriptjson) {
  let cursor = new RewriteCursor(ast);
  oploop: for (let node = cursor.goToStart(); node; node = cursor.next()) {
    if (node instanceof IfStatementNode) {
      let falseif = getSingleChild(node.falsebranch, IfStatementNode);
      if (falseif && falseif.truebranch == node.truebranch) {
        let combined = new BranchingStatement({ opcode: namedClientScriptOps.shorting_or, imm: 0, imm_obj: null }, node.statement.originalindex);
        combined.push(node.statement);
        combined.push(falseif.statement);
        node.setBranches(combined, node.truebranch, falseif.falsebranch, falseif.ifEndIndex);
      }
      let trueif = getSingleChild(node.truebranch, IfStatementNode);
      if (trueif && trueif.falsebranch == node.falsebranch) {
        let combined = new BranchingStatement({ opcode: namedClientScriptOps.shorting_and, imm: 0, imm_obj: null }, node.statement.originalindex);
        combined.push(node.statement);
        combined.push(trueif.statement);
        node.setBranches(combined, trueif.truebranch, trueif.falsebranch, node.ifEndIndex);
      }
    }
    if (node instanceof RawOpcodeNode && branchInstructions.includes(node.opinfo.id)) {
      let parent = node.parent;
      if (!(parent instanceof CodeBlockNode3) || parent.possibleSuccessors.length != 2) {
        throw new Error("if op parent is not compatible");
      }
      if (parent.children.at(-1) != node) {
        throw new Error("if op is not last op in codeblock");
      }
      if (!parent.branchEndNode) {
        throw new Error("if statement parent end node expected");
      }
      let trueblock = parent.possibleSuccessors[1];
      let falseblock = parent.possibleSuccessors[0];
      let originalFalseblock = falseblock;
      let falseblockjump = getSingleChild(falseblock, RawOpcodeNode);
      if (falseblockjump && falseblockjump.opinfo.id == namedClientScriptOps.jump) {
        if (falseblock.possibleSuccessors.length != 1) {
          throw new Error("jump successor branch expected");
        }
        falseblock = falseblock.possibleSuccessors[0];
        if (falseblock == parent.branchEndNode) {
          falseblock = null;
        }
      }
      if (trueblock == parent.branchEndNode) {
        trueblock = new CodeBlockNode3(trueblock.scriptid, trueblock.subfuncid, trueblock.originalindex);
      }
      if (!(trueblock instanceof CodeBlockNode3)) {
        throw new Error("true branch isn't a codeblock");
      }
      if (falseblock && !(falseblock instanceof CodeBlockNode3)) {
        throw new Error("false branch exists but is not a codeblock");
      }
      if (trueblock.lastPointer) {
        let newblock = new CodeBlockNode3(trueblock.scriptid, trueblock.subfuncid, trueblock.originalindex);
        newblock.mergeBlock(trueblock, false);
        newblock.maxEndIndex = trueblock.maxEndIndex;
        trueblock = newblock;
      }
      if (falseblock && falseblock.lastPointer) {
        let newblock = new CodeBlockNode3(falseblock.scriptid, trueblock.subfuncid, falseblock.originalindex);
        newblock.mergeBlock(falseblock, false);
        newblock.maxEndIndex = falseblock.maxEndIndex;
        falseblock = newblock;
      }
      let condnode = new BranchingStatement(node.op, node.originalindex);
      condnode.pushList(node.children);
      let grandparent = parent?.parent;
      if (parent instanceof CodeBlockNode3 && grandparent instanceof IfStatementNode && grandparent.ifEndIndex == parent.branchEndNode.originalindex) {
        let equaltrue = grandparent.truebranch == trueblock;
        let equalfalse = grandparent.falsebranch == falseblock || grandparent.falsebranch == originalFalseblock;
        let isor = equaltrue && grandparent.falsebranch == parent;
        let isand = equalfalse && grandparent.truebranch == parent && parent.children.length == 1;
        if (isor || isand) {
          parent.remove(node);
          while (parent.children.length != 0) {
            condnode.unshift(parent.children[0]);
          }
          let fakeop = { opcode: isor ? namedClientScriptOps.shorting_or : namedClientScriptOps.shorting_and, imm: 0, imm_obj: null };
          let combinedcond = new BranchingStatement(fakeop, grandparent.originalindex);
          combinedcond.push(grandparent.statement);
          combinedcond.push(condnode);
          if (isor) {
            grandparent.setBranches(combinedcond, trueblock, falseblock, parent.branchEndNode.originalindex);
          } else {
            grandparent.setBranches(combinedcond, trueblock, falseblock, parent.branchEndNode.originalindex);
          }
          continue;
        }
      }
      let ifstatement = new IfStatementNode(condnode.originalindex);
      ifstatement.setBranches(condnode, trueblock, falseblock, parent.branchEndNode.originalindex);
      cursor.replaceNode(ifstatement);
      cursor.setFirstChild(ifstatement, true);
    }
    if (node instanceof RawOpcodeNode && node.opinfo.id == namedClientScriptOps.switch) {
      if (!(node.parent instanceof CodeBlockNode3) || !node.parent.branchEndNode) {
        throw new Error("code block expected");
      }
      let casestatement = SwitchStatementNode.create(node, scriptjson, node.parent.possibleSuccessors, node.parent.branchEndNode.originalindex);
      cursor.replaceNode(casestatement);
      cursor.setFirstChild(casestatement, true);
    }
    if (node instanceof RawOpcodeNode && node.opinfo.id == namedClientScriptOps.jump) {
      let target = node.originalindex + 1 + node.op.imm;
      let parent = node.parent;
      if (node.op.imm == 0) {
      } else if (parent instanceof CodeBlockNode3 && parent.maxEndIndex == target) {
      } else {
        for (let ifnode = node.parent; ifnode; ifnode = ifnode.parent) {
          if (ifnode instanceof IfStatementNode) {
            let codeblock = ifnode.parent;
            if (!(codeblock instanceof CodeBlockNode3) || !codeblock.parent) {
              throw new Error("unexpected");
            }
            if (codeblock.originalindex != target) {
              continue;
            }
            if (codeblock.children.at(-1) != ifnode) {
              throw new Error("unexpected");
            }
            for (let i = codeblock.children.length - 2; i >= 0; i--) {
              ifnode.statement.unshift(codeblock.children[i]);
            }
            let originalparent = codeblock.parent;
            let loopstatement = WhileLoopStatementNode.fromIfStatement(codeblock.originalindex, ifnode);
            originalparent.replaceChild(codeblock, loopstatement);
            cursor.rebuildStack();
            cursor.remove();
            continue oploop;
          }
        }
      }
      cursor.remove();
      continue;
    }
    if (node instanceof CodeBlockNode3 && node.branchEndNode) {
      if (node.maxEndIndex == -1 || node.branchEndNode.originalindex < node.maxEndIndex) {
        let subnode = node.branchEndNode;
        cursor.prev();
        if (subnode.lastPointer) {
          node.mergeBlock(subnode, false);
        } else {
          node.mergeBlock(subnode, true);
        }
      }
    }
  }
}
var ClientScriptFunction = class extends AstNode {
  constructor(scriptname, argtype, returntype, localCounts) {
    super(0);
    this.isRawStack = false;
    this.scriptname = scriptname;
    this.returntype = returntype;
    this.argtype = argtype;
    this.localCounts = localCounts;
    this.knownStackDiff = new StackInOut(new StackList(), new StackList());
  }
  getOpcodes(ctx) {
    let body = this.children[0].getOpcodes(ctx);
    if (!this.returntype.isEmpty() || body.at(-1)?.opcode != namedClientScriptOps.return) {
      let ret = this.returntype.clone();
      let pushconst = (type) => {
        if (type == "vararg") {
          throw new Error("unexpected");
        }
        body.push({
          opcode: namedClientScriptOps.pushconst,
          imm: { int: 0, long: 1, string: 2 }[type],
          imm_obj: { int: 0, long: [0, 0], string: "" }[type]
        });
      };
      while (!ret.isEmpty()) {
        let type = ret.values.pop();
        if (type instanceof StackDiff) {
          for (let i = 0; i < type.int; i++) {
            pushconst("int");
          }
          for (let i = 0; i < type.long; i++) {
            pushconst("long");
          }
          for (let i = 0; i < type.string; i++) {
            pushconst("string");
          }
          for (let i = 0; i < type.vararg; i++) {
            pushconst("vararg");
          }
        } else {
          pushconst(type);
        }
      }
      body.push({ opcode: namedClientScriptOps.return, imm: 0, imm_obj: null });
    }
    return body;
  }
};
function varArgtype(stringconst, lastintconst) {
  if (typeof stringconst != "string") {
    return null;
  }
  let varargmatch = stringconst.match(/^([ils]*)Y?$/);
  if (!varargmatch) {
    return null;
  }
  let indiff = new StackList(varargmatch[1].split("").flatMap((q) => q == "i" ? "int" : q == "l" ? "long" : q == "s" ? "string" : null));
  if (stringconst.includes("Y")) {
    if (typeof lastintconst != "number") {
      throw new Error("parsing vararg array, but length type was not an int");
    }
    for (let i = 0; i < lastintconst; i++) {
      indiff.int();
    }
    indiff.int();
  }
  return indiff;
}
function setRawOpcodeStackDiff(consts, calli, node) {
  if (branchInstructionsInt.includes(node.opinfo.id)) {
    let uuid = typeuuids.int++;
    node.knownStackDiff = StackInOut.fromExact([uuid, uuid], []);
  } else if (branchInstructionsLong.includes(node.opinfo.id)) {
    let uuid = typeuuids.long++;
    node.knownStackDiff = StackInOut.fromExact([uuid, uuid], []);
  } else if (node.opinfo.id == namedClientScriptOps.dbrow_getfield) {
    let tablefield = consts?.values.at(-2);
    if (typeof tablefield == "number") {
      let dbtable = tablefield >> 12 & 65535;
      let columnid = tablefield >> 4 & 255;
      let subfield = tablefield & 15;
      let table = calli.dbtables.get(dbtable);
      let column = table?.unk01?.columndata.find((q) => q.id == columnid) ?? table?.unk02?.columndata.find((q) => q.id == columnid);
      if (column) {
        node.knownStackDiff = StackInOut.fromExact(
          [subtypes.dbrow, subtypes.int, subtypes.int],
          subfield != 0 ? [column.columns[subfield - 1].type] : column.columns.map((q) => q.type)
        );
      }
    }
  } else if (getParamOps.includes(node.opinfo.id)) {
    let paramid = consts?.values.at(-1);
    if (typeof paramid == "number") {
      let param = calli.parammeta.get(paramid);
      if (!param) {
        console.log("unknown param " + paramid);
      } else {
        let outtype = [param.type ? param.type.vartype : 0];
        let inputs = new StackList();
        if (node.opinfo.id != namedClientScriptOps.cc_getparam) {
          inputs.pushone("int");
        }
        inputs.pushone("int");
        node.knownStackDiff = new StackInOut(inputs, new StackList(outtype.map(typeToPrimitive)));
        node.knownStackDiff.exactout = ExactStack.fromList(outtype);
      }
    }
  } else if (node.opinfo.id == namedClientScriptOps.enum_getvalue) {
    let outtypeid = consts?.values.at(-3);
    let intypeid = consts?.values.at(-4);
    if (typeof outtypeid == "number" && typeof intypeid == "number") {
      node.knownStackDiff = StackInOut.fromExact(
        [subtypes.int, subtypes.int, subtypes.enum, intypeid],
        [outtypeid]
      );
    }
  } else if (node.opinfo.id == namedClientScriptOps.return) {
    if (!node.knownStackDiff) {
      throw new Error("stackdiff or 'return' op should have been set at parser already");
    }
  } else if (node.opinfo.id == namedClientScriptOps.gosub) {
    let script = calli.scriptargs.get(node.op.imm);
    if (script) {
      node.knownStackDiff = script.stack;
    } else {
      node.knownStackDiff = new StackInOut();
    }
  } else if (node.opinfo.id == namedClientScriptOps.joinstring) {
    node.knownStackDiff = new StackInOut(
      new StackList(Array(node.op.imm).fill("string")),
      new StackList(["string"])
    );
  } else if (node.opinfo.id == namedClientScriptOps.pushvar || node.opinfo.id == namedClientScriptOps.popvar) {
    let varmeta = calli.getClientVarMeta(node.op.imm);
    if (varmeta) {
      let ispop = node.opinfo.id == namedClientScriptOps.popvar;
      let value = [varmeta.fulltype];
      node.knownStackDiff = StackInOut.fromExact(
        ispop ? value : [],
        ispop ? [] : value
      );
    }
  } else if (node.opinfo.id == namedClientScriptOps.pushconst) {
    if (node.op.imm == 0) {
      if (typeof node.op.imm_obj != "number") {
        throw new Error("unexpected");
      }
      node.knownStackDiff = StackInOut.fromExact([], [typeuuids.int++]);
      node.knownStackDiff.constout = node.op.imm_obj;
    } else if (node.op.imm == 1) {
      node.knownStackDiff = StackInOut.fromExact([], [typeuuids.long++]);
      node.knownStackDiff.constout = node.op.imm_obj;
    } else if (node.op.imm == 2) {
      let stringconst = node.op.imm_obj;
      node.knownStackDiff = StackInOut.fromExact([], [typeuuids.string++]);
      node.knownStackDiff.constout = node.op.imm_obj;
      let varargmatch = stringconst.match(/^([ils]*)Y?$/);
      if (consts && varargmatch && stringconst.length >= 3) {
        let argtype = varArgtype(stringconst, consts.values.at(-1));
        if (!argtype) {
          throw new Error("unexpected");
        }
        node.knownStackDiff = new StackInOut(argtype, new StackList(["vararg"]));
        node.knownStackDiff.constout = node.op.imm_obj;
        node.knownStackDiff.exactin = ExactStack.fromList(argtype.toLooseSubtypes());
      } else if (varargmatch) {
        node.unknownstack = true;
      }
    } else {
      throw new Error("unexpected");
    }
  }
  if (!node.knownStackDiff && dynamicOps.includes(node.op.opcode)) {
    node.unknownstack = true;
  }
}
function addKnownStackDiff(children, calli) {
  let consts = new StackConstants();
  let hasunknown = false;
  for (let node of children) {
    let stackinout = node.knownStackDiff;
    if (node instanceof RawOpcodeNode) {
      setRawOpcodeStackDiff(consts, calli, node);
      stackinout ??= node.knownStackDiff ?? node.opinfo.stackinfo;
      hasunknown ||= node.unknownstack;
    } else if (node instanceof ClientScriptFunction) {
    } else if (node instanceof SubcallNode) {
    } else {
      throw new Error("unexpected");
    }
    if (consts) {
      if (node.knownStackDiff?.constout != null) {
        consts.pushOne(node.knownStackDiff.constout);
      } else if (stackinout?.initializedthrough) {
        consts.applyInOut(stackinout);
      } else {
        consts = null;
      }
    }
  }
  return hasunknown;
}
function generateAst(calli, script, ops, scriptid) {
  let getorMakeSection = (index, subfuncid) => {
    if (index >= ops.length) {
      throw new Error("tried to jump outside script");
    }
    let section = sections.find((q) => q.originalindex == index);
    if (!section) {
      section = new CodeBlockNode3(scriptid, subfuncid, index);
      sections.push(section);
    }
    return section;
  };
  let parseSlice = (start, end, func, subfuncid) => {
    let currentsection = getorMakeSection(start, subfuncid);
    let localcounts = func.localCounts;
    subfuncs.push(func);
    for (let index = start; index < end; index++) {
      let op = ops[index];
      let info = calli.getNamedOp(op.opcode);
      if (branchInstructionsOrJump.includes(info.id)) {
        let nextindex = index + 1;
        let jumpindex = nextindex + op.imm;
        if (op.imm != 0 && jumpindex >= start && jumpindex < end) {
          getorMakeSection(nextindex, subfuncid);
          getorMakeSection(jumpindex, subfuncid);
        }
      }
    }
    for (let index = start; index < end; index++) {
      let op = ops[index];
      let nextindex = index + 1;
      if (op.opcode == namedClientScriptOps.poplocalint || op.opcode == namedClientScriptOps.pushlocalint) {
        localcounts.int = Math.max(localcounts.int, op.imm + 1);
      }
      if (op.opcode == namedClientScriptOps.poplocallong || op.opcode == namedClientScriptOps.pushlocallong) {
        localcounts.long = Math.max(localcounts.long, op.imm + 1);
      }
      if (op.opcode == namedClientScriptOps.poplocalstring || op.opcode == namedClientScriptOps.pushlocalstring) {
        localcounts.string = Math.max(localcounts.string, op.imm + 1);
      }
      if (op.opcode == namedClientScriptOps.jump) {
        let target = index + 1 + op.imm;
        if (func && target == end) {
          let opnode2 = new RawOpcodeNode(index, makeop(namedClientScriptOps.return), calli.getNamedOp(namedClientScriptOps.return));
          opnode2.knownStackDiff = new StackInOut(func.returntype, new StackList());
          currentsection.push(opnode2);
          if (index != ops.length - 1) {
            currentsection = getorMakeSection(nextindex, subfuncid);
          }
          continue;
        } else if (target < start || target > end) {
          let targetfn = subcalltargets.find((q) => q.index == target);
          if (targetfn) {
            currentsection.push(new SubcallNode(index, targetfn.name, targetfn.in, targetfn.out));
          } else {
            throw new Error("couldn't find subcall function target");
          }
          continue;
        }
      }
      let info = calli.getNamedOp(op.opcode);
      let opnode = new RawOpcodeNode(index, op, info);
      let addrsection = sections.find((q) => q.originalindex == index);
      if (addrsection && addrsection != currentsection) {
        currentsection.addSuccessor(addrsection);
        currentsection = addrsection;
      }
      if (opnode.op.opcode == namedClientScriptOps.return) {
        opnode.knownStackDiff = new StackInOut(getReturnType(calli, ops), new StackList());
      }
      currentsection.push(opnode);
      if (branchInstructionsOrJump.includes(info.id)) {
        let jumpindex = nextindex + op.imm;
        if (op.opcode == namedClientScriptOps.jump && jumpindex == index + 1) {
        } else {
          let nextblock = getorMakeSection(nextindex, subfuncid);
          let jumpblock = getorMakeSection(jumpindex, subfuncid);
          if (info.id != namedClientScriptOps.jump) {
            currentsection.addSuccessor(nextblock);
          }
          currentsection.addSuccessor(jumpblock);
          currentsection = nextblock;
        }
      } else if (opnode.opinfo.id == namedClientScriptOps.return) {
        if (index != ops.length - 1) {
          currentsection = getorMakeSection(nextindex, subfuncid);
        }
      } else if (opnode.opinfo.id == namedClientScriptOps.switch) {
        let cases = script.switches[opnode.op.imm];
        if (!cases) {
          throw new Error("no matching cases in script");
        }
        for (let cond of cases) {
          let jumpblock = getorMakeSection(nextindex + cond.jump, subfuncid);
          if (!currentsection.possibleSuccessors.includes(jumpblock)) {
            currentsection.addSuccessor(jumpblock);
          }
        }
        let nextblock = getorMakeSection(nextindex, subfuncid);
        currentsection.addSuccessor(nextblock);
        currentsection = nextblock;
      }
    }
  };
  let rootfunc = new ClientScriptFunction(`script${scriptid == -1 ? "_unk" : scriptid}`, new StackList([getArgType(script)]), getReturnType(calli, ops), new StackDiff());
  let headersection = new CodeBlockNode3(scriptid, -1, 0);
  let sections = [];
  let subfuncs = [];
  let subcalltargets = [];
  let headerend = 0;
  let currentindex = 0;
  if (ops[currentindex].opcode == namedClientScriptOps.jump) {
    headerend = currentindex + ops[currentindex].imm + 1;
    currentindex++;
    let namecounter = 0;
    let parseQueue = [];
    while (currentindex < headerend) {
      let op = ops[currentindex];
      if (op.opcode != namedClientScriptOps.pushconst || op.imm != 2 || typeof op.imm_obj != "string") {
        throw new Error("no header label text literal");
      }
      let values = {};
      for (let [, left, right] of op.imm_obj.matchAll(/(\S+)=(\S+)/g)) {
        values[left] = right;
      }
      let end = parseInt(values.end);
      let body = parseInt(values.body);
      let foot = parseInt(values.foot);
      let entry = parseInt(values.entry);
      let israwstack = values.rawstack == "true";
      let args = values.in?.match(/^\d+,\d+,\d+$/) ? new StackDiff(...values.in.split(",").map((q) => parseInt(q))) : new StackDiff();
      let returns = values.out?.match(/^\d+,\d+,\d+$/) ? new StackDiff(...values.out.split(",").map((q) => parseInt(q))) : new StackDiff();
      if (values.type == "returnjumps") {
      } else if (values.type == "subfunc") {
        if (isNaN(end) || isNaN(body) || isNaN(foot) || isNaN(entry)) {
          throw new Error("invalid subfunc header");
        }
        let returntype = getReturnType(calli, ops, currentindex + foot);
        if (!returns.equals(returntype.getStackdiff())) {
          throw new Error("detected subfunc return type not the same as declared return type");
        }
        let subfuncid = namecounter++;
        let subfunc = new ClientScriptFunction(`subfunc_${subfuncid}`, new StackList([args]), returntype, new StackDiff());
        subfunc.isRawStack = israwstack;
        subfunc.originalindex = currentindex + entry;
        subcalltargets.push({ name: subfunc.scriptname, index: subfunc.originalindex, in: subfunc.argtype, out: subfunc.returntype });
        parseQueue.push([currentindex + body, currentindex + foot, subfunc, subfuncid]);
        let entrynode = new CodeBlockNode3(scriptid, subfuncid, currentindex + entry);
        entrynode.addSuccessor(getorMakeSection(currentindex + body, subfuncid));
        subfunc.push(entrynode);
      } else if (values.type == "intrinsic") {
        let name = values.name;
        if (typeof name != "string") {
          throw new Error("intrinsic name not set");
        }
        let intrinsic = intrinsics.get(name);
        if (!intrinsic) {
          throw new Error(`intrinsic ${name} was references in bytecode, but does not exists in the version of rsmv`);
        }
        subcalltargets.push({ name, index: currentindex + entry, in: intrinsic.in, out: intrinsic.out });
      } else {
        console.log(`unknown header type "${values.type}"`);
      }
      if (isNaN(end)) {
        throw new Error("invalid subfunc header");
      }
      currentindex += end;
    }
    parseQueue.forEach((q) => parseSlice(...q));
    headersection.pushList(subfuncs);
    headersection.push(new RawOpcodeNode(0, ops[0], calli.getNamedOp(ops[0].opcode)));
  }
  headersection.addSuccessor(getorMakeSection(headerend, -1));
  rootfunc.push(headersection);
  subfuncs.push(rootfunc);
  parseSlice(headerend, ops.length, rootfunc, -1);
  sections.sort((a, b) => a.originalindex - b.originalindex);
  sections.forEach((q) => addKnownStackDiff(q.children, calli));
  subfuncs.forEach((q) => {
    for (let node = q.children[0]; node; node = node.findNext()) ;
  });
  return { sections, rootfunc, subfuncs };
}
function parseClientScriptIm2(calli, script, fileid = -1) {
  let { sections, rootfunc } = generateAst(calli, script, script.opcodedata, fileid);
  let typectx = new ClientScriptSubtypeSolver();
  typectx.parseSections(sections);
  typectx.addKnownFromCalli(calli);
  typectx.solve();
  sections.forEach(translateAst);
  fixControlFlow(rootfunc.children[0], script);
  return { rootfunc, sections, typectx };
}
globalThis.parseClientScriptIm = parseClientScriptIm2;

// rsmv/src/clientscript/codewriter.ts
function debugAst(node) {
  let writer = new TsWriterContext(globalThis.deob, new ClientScriptSubtypeSolver());
  let res = "";
  if (node instanceof CodeBlockNode3) {
    res += `//[${node.scriptid},${node.originalindex}]
`;
  }
  res += writer.getCode(node);
  console.log(res);
}
globalThis.debugAst = debugAst;
var TsWriterContext = class {
  constructor(calli, typectx) {
    this.indents = [];
    this.declaredVars = [];
    this.compoffsets = /* @__PURE__ */ new Map();
    this.usecompoffset = false;
    this.int32casts = false;
    this.typescript = true;
    this.calli = calli;
    this.typectx = typectx;
  }
  setCompOffsets(rootnode) {
    let cursor = new RewriteCursor(rootnode);
    for (let node = cursor.goToStart(); node; node = cursor.next()) {
      if (!isNamedOp(node, namedClientScriptOps.pushconst)) {
        continue;
      }
      if (!node.knownStackDiff?.exactout) {
        continue;
      }
      let all = node.knownStackDiff.exactout.all();
      if (all.length != 1) {
        throw new Error("unexpected");
      }
      let type = this.typectx.knowntypes.get(all[0]);
      if (typeof type != "number") {
        continue;
      }
      if (typeof node.op.imm_obj != "number") {
        continue;
      }
      let intf = node.op.imm_obj >> 16;
      let sub = node.op.imm_obj & 65535;
      let least = getOrInsert(this.compoffsets, intf, () => sub);
      if (sub < least) {
        this.compoffsets.set(intf, sub);
      }
    }
    this.usecompoffset = true;
  }
  codeIndent(linenr = -1, hasquestionmark = false) {
    return "    ".repeat(this.indents.length);
  }
  pushIndent(hasScope) {
    this.indents.push(hasScope);
    if (hasScope) {
      this.declaredVars.push(/* @__PURE__ */ new Set());
    }
  }
  popIndent() {
    let hadscope = this.indents.pop();
    if (hadscope == void 0) {
      throw new Error("negative indent");
    }
    if (hadscope) {
      this.declaredVars.pop();
    }
  }
  declareLocal(varname) {
    let set3 = this.declaredVars.at(-1);
    if (!set3) {
      throw new Error("no scope");
    }
    if (set3.has(varname)) {
      return true;
    } else {
      set3.add(varname);
      return false;
    }
  }
  getCode(node) {
    let writer = writermap.get(node.constructor);
    if (!writer) {
      throw new Error(`no writer defined for ${node.constructor.name} node`);
    }
    return writer(node, this);
  }
};
__decorateClass([
  boundMethod2
], TsWriterContext.prototype, "getCode", 1);
function getOpcodeName(calli, op) {
  if (op.opcode == namedClientScriptOps.poplocalint || op.opcode == namedClientScriptOps.pushlocalint) {
    return `int${op.imm}`;
  } else if (op.opcode == namedClientScriptOps.poplocalstring || op.opcode == namedClientScriptOps.pushlocalstring) {
    return `string${op.imm}`;
  } else if (op.opcode == namedClientScriptOps.poplocallong || op.opcode == namedClientScriptOps.pushlocallong) {
    return `long${op.imm}`;
  } else if (op.opcode == namedClientScriptOps.popdiscardint || op.opcode == namedClientScriptOps.popdiscardlong || op.opcode == namedClientScriptOps.popdiscardstring) {
    return "";
  } else if (op.opcode == namedClientScriptOps.popvar || op.opcode == namedClientScriptOps.pushvar) {
    let varmeta = calli.getClientVarMeta(op.imm);
    if (varmeta) {
      return `var${varmeta.name}_${varmeta.varid}`;
    } else {
      return `varunk_${op.imm}`;
    }
  } else if (op.opcode == namedClientScriptOps.popvarbit || op.opcode == namedClientScriptOps.pushvarbit) {
    let id = op.imm >> 8;
    let optarget = op.imm & 255;
    let varbitmeta = calli.varbitmeta.get(id);
    if (typeof varbitmeta?.varid != "number") {
      return `varbitunk_${op.imm}`;
    } else {
      let groupmeta = calli.varmeta.get(varbitmeta.varid >> 16);
      return `varbit${groupmeta?.name ?? "unk"}_${id}${optarget == 0 ? "" : `[${optarget}]`}`;
    }
  }
  return getOpName(op.opcode);
}
function valueList(ctx, nodes) {
  if (nodes.length == 1) {
    return ctx.getCode(nodes[0]);
  }
  return `[${nodes.map(ctx.getCode).join(", ")}]`;
}
function escapeStringLiteral(source, quotetype) {
  return source.replace(/[`"'\\\n\r\t\b\f\x00-\x1F]|\$\{/g, (m) => {
    switch (m) {
      case '"':
        return quotetype == "double" ? '\\"' : '"';
      case "'":
        return quotetype == "single" ? "\\'" : "'";
      case "\\":
        return "\\\\";
      case "\n":
        return "\\n";
      case "\r":
        return "\\r";
      case "	":
        return "\\t";
      case "\b":
        return "\\b";
      case "\f":
        return "\\f";
      case "${":
        return quotetype == "template" ? "\\${" : "${";
      case "`":
        return quotetype == "template" ? "\\`" : "`";
      default:
        return `\\x${m.charCodeAt(0).toString(16).padStart(2, "0")}`;
    }
  });
}
function writeCall(ctx, funcstring, children) {
  return `${funcstring}(${children.map(ctx.getCode).join(", ")})`;
}
function getOpcodeCallCode(ctx, op, children, originalindex) {
  let binarysymbol = binaryOpSymbols.get(op.opcode);
  if (binarysymbol) {
    if (children.length == 2) {
      if (ctx.int32casts && int32MathOps.has(op.opcode)) {
        return `(${ctx.getCode(children[0])} ${binarysymbol} ${ctx.getCode(children[1])} | 0)`;
      } else {
        return `(${ctx.getCode(children[0])} ${binarysymbol} ${ctx.getCode(children[1])})`;
      }
    } else {
      return `operator("${binarysymbol}", ${children.map(ctx.getCode).join(", ")})`;
    }
  }
  if (op.opcode == namedClientScriptOps.return) {
    if (children.length == 0) {
      return `return`;
    }
    return `return ${valueList(ctx, children)}`;
  }
  if (op.opcode == namedClientScriptOps.gosub) {
    return writeCall(ctx, `script${op.imm}`, children);
  }
  let metastr = "";
  if (branchInstructionsOrJump.includes(op.opcode)) {
    metastr = `[${op.imm + originalindex + 1}]`;
  } else if (op.opcode == namedClientScriptOps.gosub) {
    metastr = `[${op.imm}]`;
  } else if (op.imm != 0) {
    metastr = `[${op.imm}]`;
  }
  return writeCall(ctx, `${getOpcodeName(ctx.calli, op)}${metastr}`, children);
}
var writermap = /* @__PURE__ */ new Map();
function addWriter(type, writer) {
  writermap.set(type, writer);
}
addWriter(ComposedOp, (node, ctx) => {
  if (["++x", "--x", "x++", "x--"].includes(node.type)) {
    if (node.children.length != 0) {
      throw new Error("no children expected on composednode");
    }
    let varname = getOpcodeName(ctx.calli, node.internalOps[0].op);
    if (ctx.int32casts) {
      if (node.type == "++x") {
        return `(${varname} = ${varname} + 1 | 0)`;
      }
      if (node.type == "--x") {
        return `(${varname} = ${varname} - 1 | 0)`;
      }
      if (node.type == "x++") {
        return `(${varname} = ${varname} + 1 | 0, ${varname} - 1 | 0)`;
      }
      if (node.type == "x--") {
        return `(${varname} = ${varname} - 1 | 0, ${varname} + 1 | 0)`;
      }
    } else {
      if (node.type == "++x") {
        return `++${varname}`;
      }
      if (node.type == "--x") {
        return `--${varname}`;
      }
      if (node.type == "x++") {
        return `${varname}++`;
      }
      if (node.type == "x--") {
        return `${varname}--`;
      }
    }
  }
  if (node.type == "stack") {
    return writeCall(ctx, "stack", node.children);
  }
  throw new Error("unknown composed op type");
});
addWriter(VarAssignNode, (node, ctx) => {
  let res = "";
  let fulldiscard = node.varops.every((q) => popDiscardOps.includes(q.op.opcode));
  if (!fulldiscard) {
    let hasglobal = false;
    let hasundeclared = false;
    let varnames = [];
    let exacttypes = [];
    let vardeclared = [];
    for (let sub of node.varops) {
      let name = getOpcodeName(ctx.calli, sub.op);
      let exacttype = -1;
      if (node.knownStackDiff?.exactin) {
        let all = node.knownStackDiff.exactin.all();
        if (all.length != 1) {
          throw new Error("unexpected");
        }
        let type = ctx.typectx.knowntypes.get(all[0]);
        if (typeof type == "number") {
          exacttype = type;
        }
      }
      exacttypes.push(exacttype);
      if (popLocalOps.includes(sub.op.opcode)) {
        let isdeclared = ctx.declareLocal(name);
        hasundeclared ||= !isdeclared;
        vardeclared.push(isdeclared);
      } else {
        hasglobal = true;
      }
      varnames.push(name);
    }
    if (hasundeclared) {
      if (hasglobal) {
        for (let [index, name] of varnames.entries()) {
          if (vardeclared[index]) {
            continue;
          }
          res += `var ${name}${ctx.typescript ? ":" + subtypeToTs(exacttypes[index]) : ""};`;
          res += ctx.codeIndent();
        }
      } else {
        res += "var ";
      }
    }
    if (node.varops.length != 1) {
      res += "[";
    }
    res += `${varnames.join(", ")}`;
    if (node.varops.length != 1) {
      res += "]";
    }
    res += " = ";
  }
  res += valueList(ctx, node.children);
  return res;
});
addWriter(CodeBlockNode3, (node, ctx) => {
  let code = "";
  if (node.parent) {
    code += `{
`;
    ctx.pushIndent(node.parent instanceof ClientScriptFunction);
  }
  for (let child of node.children) {
    code += `${ctx.codeIndent(child.originalindex)}${ctx.getCode(child)};
`;
  }
  if (node.parent) {
    if (node.parent instanceof SwitchStatementNode && node.branchEndNode != null) {
      code += `${ctx.codeIndent()}break;
`;
    }
    ctx.popIndent();
    code += `${ctx.codeIndent()}}`;
  }
  return code;
});
addWriter(BranchingStatement, (node, ctx) => {
  return getOpcodeCallCode(ctx, node.op, node.children, node.originalindex);
});
addWriter(WhileLoopStatementNode, (node, ctx) => {
  let res = `while (${ctx.getCode(node.statement)}) `;
  res += ctx.getCode(node.body);
  return res;
});
addWriter(SwitchStatementNode, (node, ctx) => {
  let res = "";
  res += `switch (${node.valueop ? ctx.getCode(node.valueop) : ""}) {
`;
  ctx.pushIndent(false);
  for (let [i, branch] of node.branches.entries()) {
    res += `${ctx.codeIndent(branch.block.originalindex)}case ${branch.value}:`;
    if (i + 1 < node.branches.length && node.branches[i + 1].block == branch.block) {
      res += `
`;
    } else {
      res += " " + ctx.getCode(branch.block);
      res += "\n";
    }
  }
  if (node.defaultbranch) {
    res += `${ctx.codeIndent()}default: `;
    res += ctx.getCode(node.defaultbranch);
    res += `
`;
  }
  ctx.popIndent();
  res += `${ctx.codeIndent()}}`;
  return res;
});
addWriter(IfStatementNode, (node, ctx) => {
  let res = `if (${ctx.getCode(node.statement)}) `;
  res += ctx.getCode(node.truebranch);
  if (node.falsebranch) {
    res += ` else `;
    let subif = getSingleChild(node.falsebranch, IfStatementNode);
    if (subif) {
      res += ctx.getCode(subif);
    } else {
      res += ctx.getCode(node.falsebranch);
    }
  }
  return res;
});
addWriter(RawOpcodeNode, (node, ctx) => {
  if (node.op.opcode == namedClientScriptOps.pushconst) {
    let exacttype = -1;
    if (node.knownStackDiff?.exactout) {
      let all = node.knownStackDiff.exactout.all();
      if (all.length != 1) {
        throw new Error("unexpected");
      }
      let type = ctx.typectx.knowntypes.get(all[0]);
      if (typeof type == "number") {
        exacttype = type;
      }
    }
    let gettypecast = () => {
      if (!ctx.typescript) {
        return "";
      }
      if (exacttype == -1) {
        return "";
      }
      if (exacttype == subtypes.int || exacttype == subtypes.string || exacttype == subtypes.long) {
        return "";
      }
      if (exacttype == subtypes.unknown_int || exacttype == subtypes.unknown_string || exacttype == subtypes.unknown_long) {
        return "";
      }
      return ` as ${subtypeToTs(exacttype)}`;
    };
    if (typeof node.op.imm_obj == "string") {
      return `"${escapeStringLiteral(node.op.imm_obj, "double")}"${gettypecast()}`;
    } else if (Array.isArray(node.op.imm_obj)) {
      return `${longJsonToBigInt(node.op.imm_obj)}n${gettypecast()}`;
    } else if (typeof node.op.imm_obj == "number") {
      if (exacttype == subtypes.component) {
        let intf = node.op.imm_obj >> 16;
        let sub = node.op.imm_obj & 65535;
        if (ctx.usecompoffset && ctx.compoffsets.has(intf)) {
          return `comprel(${intf},${sub - ctx.compoffsets.get(intf)})`;
        } else {
          return `comp(${intf}, ${sub})`;
        }
      }
      if (exacttype == subtypes.coordgrid && node.op.imm_obj != -1) {
        let v = node.op.imm_obj;
        return `pos(${v >> 28 & 3},${v >> 20 & 255},${v >> 6 & 255},${v >> 12 & 63},${v & 63})`;
      }
      if (exacttype == subtypes.boolean) {
        return node.op.imm_obj == 1 ? "true" : "false";
      }
      return `${node.op.imm_obj}${gettypecast()}`;
    } else {
      throw new Error("unexpected");
    }
  }
  if (node.op.opcode == namedClientScriptOps.pushlocalint || node.op.opcode == namedClientScriptOps.pushlocallong || node.op.opcode == namedClientScriptOps.pushlocalstring || node.op.opcode == namedClientScriptOps.pushvar || node.op.opcode == namedClientScriptOps.pushvarbit) {
    return getOpcodeName(ctx.calli, node.op);
  }
  if (node.op.opcode == namedClientScriptOps.joinstring) {
    let res = "`";
    for (let child of node.children) {
      if (child instanceof RawOpcodeNode && child.opinfo.id == namedClientScriptOps.pushconst && typeof child.op.imm_obj == "string") {
        res += escapeStringLiteral(child.op.imm_obj, "template");
      } else {
        res += `\${${ctx.getCode(child)}}`;
      }
    }
    res += "`";
    return res;
  }
  return getOpcodeCallCode(ctx, node.op, node.children, node.originalindex);
});
addWriter(ClientScriptFunction, (node, ctx) => {
  let scriptidmatch = node.scriptname.match(/^script(\d+)$/);
  let meta = scriptidmatch ? ctx.calli.scriptargs.get(+scriptidmatch[1]) : null;
  let res = "";
  res += `//${meta?.scriptname ?? "unknown name"}
`;
  res += `${ctx.codeIndent()}function ${node.scriptname}(${node.argtype.toTypeScriptVarlist(true, ctx.typescript, meta?.stack.exactin)})`;
  if (ctx.typescript) {
    res += `: ${node.returntype.toTypeScriptReturnType(meta?.stack.exactout)} `;
  }
  res += ctx.getCode(node.children[0]);
  return res;
});
addWriter(FunctionBindNode, (node, ctx) => {
  let scriptid = node.children[0]?.knownStackDiff?.constout ?? -1;
  if (scriptid == -1 && node.children.length == 1) {
    return `callback()`;
  }
  return `callback(script${scriptid}${node.children.length > 1 ? ", " : ""}${node.children.slice(1).map(ctx.getCode).join(", ")})`;
});
addWriter(SubcallNode, (node, ctx) => {
  return writeCall(ctx, node.funcname, node.children.slice(0, -1));
});

// rsmv/src/libs/yieldparser.ts
function parse2(input, iterable) {
  let lastResult;
  let iterationCount = -1;
  const iterator = iterable[Symbol.iterator]();
  main: while (true) {
    const nestedErrors = [];
    iterationCount += 1;
    const next = iterator.next(lastResult);
    if (next.done) {
      if (next.value instanceof Error) {
        return {
          success: false,
          remaining: input,
          failedOn: {
            iterationCount,
            yielded: next.value
          }
        };
      }
      return {
        success: true,
        remaining: input,
        result: next.value
      };
    }
    const yielded = next.value;
    const choices = typeof yielded !== "string" && yielded[Symbol.iterator] ? yielded : [yielded];
    for (const choice of choices) {
      if (typeof choice === "string") {
        let found = false;
        const newInput = input.replace(choice, (_1, offset) => {
          found = offset === 0;
          return "";
        });
        if (found) {
          input = newInput;
          lastResult = choice;
          continue main;
        }
      } else if (choice instanceof RegExp) {
        if (["^", "$"].includes(choice.source[0]) === false) {
          throw new Error(`Regex must be from start: ${choice}`);
        }
        const match = input.match(choice);
        if (match) {
          lastResult = match;
          input = input.slice(match[0].length);
          continue main;
        }
      } else if (choice instanceof Function) {
        const choiceResult = parse2(input, choice());
        if (choiceResult.success) {
          lastResult = choiceResult.result;
          input = choiceResult.remaining;
          continue main;
        } else if (choiceResult.failedOn) {
          nestedErrors.push(choiceResult.failedOn);
        }
      }
    }
    return {
      success: false,
      remaining: input,
      failedOn: {
        iterationCount,
        yielded,
        nested: nestedErrors.length === 0 ? void 0 : nestedErrors
      }
    };
  }
}
function has(prefix) {
  return function* () {
    return (yield [prefix, ""]) !== "";
  };
}

// rsmv/src/clientscript/codeparser.ts
import prettyJson from "json-stringify-pretty-compact";
function* whitespace() {
  while (true) {
    let match = yield [/^\/\/.*\n/, /^\/\*[\s\S]*?\*\//, /^\s+/, ""];
    if (match === "") {
      break;
    }
  }
}
var unmatchable = /$./;
var reserverd = "if,while,break,continue,else,switch,script,return,var".split(",");
var binaryconditionals = "||,&&,>=,<=,==,!=,>,<".split(",");
var binaryops = [...binaryOpSymbols.values()];
var binaryopsoremtpy = binaryops.concat("");
globalThis.prettyjson = prettyJson;
var ParseContext = class {
  constructor(deob, parent) {
    this.rootfuncname = "";
    this.vars = /* @__PURE__ */ Object.create(null);
    this.scopefunctions = /* @__PURE__ */ new Map();
    this.varcounts = new StackDiff();
    this.deob = deob;
    this.parent = parent;
  }
  getVarType(varname) {
    if (Object.hasOwn(this.vars, varname)) {
      return this.vars[varname];
    } else if (this.parent) {
      return this.parent.getVarType(varname);
    }
    return null;
  }
  declareVar(varname, type) {
    if (Object.hasOwn(this.vars, varname)) {
      let res2 = this.vars[varname];
      if (res2.stacktype != typeToPrimitive(type)) {
        throw new Error(`tried to redeclare var ${varname} with incompatible stack type (was: ${res2.stacktype} new: ${typeToPrimitive(type)})`);
      }
      if (res2.type != type) {
        if (res2.type == subtypes.unknown_int) {
          res2.type = type;
        } else if (type == subtypes.unknown_int) {
        } else if (res2.type == subtypes.unknown_int) {
          res2.type = type;
        } else if (type == subtypes.unknown_int) {
        } else if (res2.type == subtypes.unknown_int) {
          res2.type = type;
        } else if (type == subtypes.unknown_int) {
        } else {
          throw new Error(`Tried to redeclare var ${varname} with incompatible subtype (was: ${subtypeToTs(res2.type)}, new: ${subtypeToTs(type)})`);
        }
      }
      return res2;
    }
    let stacktype = typeToPrimitive(type);
    let slot = this.varcounts.getSingle(stacktype);
    this.varcounts.setSingle(stacktype, slot + 1);
    let res = this.vars[varname] = { name: varname, slot, stacktype, type };
    return res;
  }
  declareFunction(name, func) {
    if (!this.parent && !this.rootfuncname) {
      this.rootfuncname = func.scriptname;
    } else {
      this.scopefunctions.set(name, func);
    }
  }
  getFunction(name) {
    let func = this.scopefunctions.get(name);
    if (func) {
      return func;
    }
    if (this.parent) {
      return this.parent.getFunction(name);
    }
    return null;
  }
};
function scriptContext(ctx) {
  let deob = ctx.deob;
  function getVarMeta(name, labeledtype = -1) {
    let varid = -1;
    let islocal = false;
    let readopid = -1;
    let writeopid = -1;
    let vartype = -1;
    let match = name.match(/^(int|long|string|script|var(bit)?(\w+?)_)(\d+)$/);
    if (!match) {
      islocal = true;
    } else if (match) {
      if (match[1] == "script") {
        vartype = subtypes.scriptref;
        varid = +match[4];
      } else if (match[3]) {
        if (match[2] == "bit") {
          let subindex = 0;
          varid = +match[4] << 8 | subindex;
          readopid = namedClientScriptOps.pushvarbit;
          writeopid = namedClientScriptOps.popvarbit;
          vartype = subtypes.unknown_int;
        } else {
          let source = variableSources[match[3]];
          if (!source) {
            throw new Error("unknown var source");
          }
          varid = source.key << 24 | +match[4] << 8;
          let meta = deob.getClientVarMeta(varid);
          if (!meta) {
            throw new Error("unknown clientvar " + varid);
          }
          readopid = namedClientScriptOps.pushvar;
          writeopid = namedClientScriptOps.popvar;
          vartype = meta.fulltype;
        }
      } else if (match[1] == "int" || match[1] == "long" || match[1] == "string") {
        islocal = true;
        labeledtype = primitiveToUknownExact(match[1]);
      } else {
        throw new Error("unexpected");
      }
    }
    if (islocal) {
      let existingvar = ctx.getVarType(name);
      if (!existingvar) {
        if (labeledtype == -1) {
          throw new Error(`no known type while declaring var ${name}`);
        }
        existingvar = ctx.declareVar(name, labeledtype);
      }
      varid = existingvar.slot;
      vartype = existingvar.type;
      let stacktype = existingvar.stacktype;
      if (readopid == -1 && stacktype == "int") {
        readopid = namedClientScriptOps.pushlocalint;
      }
      if (readopid == -1 && stacktype == "long") {
        readopid = namedClientScriptOps.pushlocallong;
      }
      if (readopid == -1 && stacktype == "string") {
        readopid = namedClientScriptOps.pushlocalstring;
      }
      if (writeopid == -1 && stacktype == "int") {
        writeopid = namedClientScriptOps.poplocalint;
      }
      if (writeopid == -1 && stacktype == "long") {
        writeopid = namedClientScriptOps.poplocallong;
      }
      if (writeopid == -1 && stacktype == "string") {
        writeopid = namedClientScriptOps.poplocalstring;
      }
    }
    if (vartype == -1) {
      throw new Error(`unkown var type for ${name}`);
    }
    return { readopid, writeopid, vartype, varid, islocal };
  }
  function makeStringConst(str, subtypestr) {
    let constop = getopinfo(namedClientScriptOps.pushconst);
    let node = new RawOpcodeNode(-1, { opcode: constop.id, imm: 2, imm_obj: str }, constop);
    node.knownStackDiff = new StackInOut(new StackList([]), new StackList(["string"]));
    node.knownStackDiff.constout = str;
    if (subtypestr != "") {
      node.knownStackDiff.exactout = new ExactStack();
      node.knownStackDiff.exactout.string.push(tsToSubtype(subtypestr));
    }
    return node;
  }
  function makeLongConst(long, subtypestr) {
    let constop = getopinfo(namedClientScriptOps.pushconst);
    let val = longBigIntToJson(long);
    let node = new RawOpcodeNode(-1, { opcode: constop.id, imm: 1, imm_obj: val }, constop);
    node.knownStackDiff = new StackInOut(new StackList([]), new StackList(["long"]));
    node.knownStackDiff.constout = val;
    if (subtypestr != "") {
      node.knownStackDiff.exactout = new ExactStack();
      node.knownStackDiff.exactout.long.push(tsToSubtype(subtypestr));
    }
    return node;
  }
  function makeIntConst(int2, subtypestr) {
    let constop = getopinfo(namedClientScriptOps.pushconst);
    let node = new RawOpcodeNode(-1, { opcode: constop.id, imm: 0, imm_obj: int2 }, constop);
    node.knownStackDiff = new StackInOut(new StackList([]), new StackList(["int"]));
    node.knownStackDiff.constout = int2;
    if (subtypestr != "") {
      node.knownStackDiff.exactout = new ExactStack();
      node.knownStackDiff.exactout.int.push(tsToSubtype(subtypestr));
    }
    return node;
  }
  function getopinfo(id) {
    return deob.getNamedOp(id);
  }
  function* argumentDeclaration() {
    let args = [];
    while (true) {
      let name = yield [varname, ""];
      if (!name) {
        break;
      }
      yield whitespace;
      let type = "";
      if (yield has(":")) {
        yield whitespace;
        [type] = yield /^\w+/;
      }
      args.push({ name, type });
      yield whitespace;
      if (!(yield has(","))) {
        break;
      }
      yield whitespace;
    }
    return args;
  }
  function* typeDeclaration() {
    let first = yield [/^\w+/, "["];
    if (first == "void") {
      return [];
    }
    if (first != "[") {
      return [first[0]];
    }
    let typelist = [];
    while (true) {
      if (yield has("]")) {
        break;
      }
      yield whitespace;
      typelist.push((yield /^\w+/)[0]);
      yield whitespace;
      yield [",", /^(?=])/];
      yield whitespace;
    }
    return typelist;
  }
  function* stringInterpolation() {
    yield "`";
    let parts = [];
    let str = "";
    while (true) {
      let next = yield ["${", "`", /^[\s\S]/];
      if (next == "\\") {
        let char = (yield /^[\s\S]/)[0];
        if (char == "n") {
          str += "\n";
        } else if (char == "t") {
          str += "	";
        } else if (char == "r") {
          str += "\r";
        } else if (char == "x") {
          str += String.fromCharCode(parseInt((yield /^[\da-fA-F]{2}/)[0], 16));
        } else {
          str += char;
        }
      } else if (next == "${") {
        if (str != "") {
          parts.push(makeStringConst(str, ""));
        }
        str = "";
        yield whitespace;
        let interpolant = yield valueStatement;
        let out = getNodeStackOut(interpolant).getStackdiff();
        if (out.total() != 1) {
          throw new Error("string interpolation with more than on value at interpolant");
        }
        if (out.string == 1) {
          parts.push(interpolant);
        } else if (out.int == 1) {
          let tostring = new RawOpcodeNode(-1, makeop(namedClientScriptOps.inttostring), getopinfo(namedClientScriptOps.inttostring));
          let base10 = new RawOpcodeNode(-1, makeop(namedClientScriptOps.pushconst, 0, 10), getopinfo(namedClientScriptOps.pushconst));
          tostring.push(interpolant);
          tostring.push(base10);
          parts.push(tostring);
        } else {
          throw new Error(`string interpolation only supports strings or ints`);
        }
        yield whitespace;
        yield "}";
      } else if (next == "`") {
        if (str != "") {
          parts.push(makeStringConst(str, ""));
        }
        break;
      } else {
        str += next;
      }
    }
    let strjoin = getopinfo(namedClientScriptOps.joinstring);
    let node = new RawOpcodeNode(-1, { opcode: strjoin.id, imm: parts.length, imm_obj: null }, strjoin);
    node.knownStackDiff = new StackInOut(new StackList(new Array(parts.length).fill("string")), new StackList(["string"]));
    node.pushList(parts);
    return node;
  }
  function* literalcast() {
    if (yield has("as")) {
      yield whitespace;
      return yield varname;
    }
    return "";
  }
  function* stringliteral() {
    yield '"';
    let str = "";
    while (!(yield has('"'))) {
      let char = yield ["\\", /^[^"]/];
      if (char == "\\") {
        let char2 = yield /^[\s\S]/;
        if (char2 == "n") {
          str += "\n";
        } else if (char2 == "t") {
          str += "	";
        } else if (char2 == "r") {
          str += "\r";
        } else if (char2 == "x") {
          str += String.fromCharCode(parseInt((yield /^[\da-fA-F]{2}/)[0], 16));
        } else {
          str += char2;
        }
      } else {
        str += char;
      }
    }
    yield whitespace;
    let subt = yield literalcast;
    return makeStringConst(str, subt || "string");
  }
  function* intliteral() {
    let [digits] = yield /^(-?\d+|0x[\da-fA-F]+)\b/;
    yield whitespace;
    let subt = yield literalcast;
    return makeIntConst(parseInt(digits) | 0, subt || "int");
  }
  function* longliteral() {
    let [match, int2] = yield /^(-?\d+)n\b/;
    let bigint = BigInt(int2) & 0xffffffffffffffffn;
    yield whitespace;
    let subt = yield literalcast;
    return makeLongConst(bigint, subt || "long");
  }
  function* varname() {
    const [name] = yield /^[a-zA-Z$][\w$]*/;
    if (reserverd.includes(name)) {
      yield unmatchable;
    }
    return name;
  }
  function* valueList2() {
    let args = [];
    while (true) {
      args.push(yield valueStatement);
      yield whitespace;
      if (!(yield has(","))) {
        break;
      }
      yield whitespace;
    }
    return args;
  }
  function* call() {
    let funcname = yield varname;
    let metaid = 0;
    yield whitespace;
    if (yield has("[")) {
      metaid = parseInt(yield /^-?\d+/, 10);
      yield whitespace;
      yield "]";
      yield whitespace;
    }
    yield "(";
    yield whitespace;
    let args;
    if (yield has(")")) {
      args = [];
    } else {
      args = yield valueList2;
      yield whitespace;
      yield ")";
    }
    if (funcname == "operator") {
      if (!isNamedOp(args[0], namedClientScriptOps.pushconst) || typeof args[0].op.imm_obj != "string") {
        throw new Error("string literal expected as 1st argument on operator() call");
      }
      let op = binaryOpIds.get(args[0].op.imm_obj);
      if (!op) {
        throw new Error(`unknown binary op '${args[0].op.imm_obj}'`);
      }
      let opinfo = getopinfo(op);
      let res = new RawOpcodeNode(-1, { opcode: op, imm: 0, imm_obj: null }, opinfo);
      res.pushList(args.slice(1));
      return res;
    }
    if (funcname == "callback") {
      let res = new FunctionBindNode(-1, new StackList());
      if (args.length == 0) {
        res.push(makeIntConst(-1, "int"));
      } else {
        res.pushList(args);
      }
      return res;
    }
    if (funcname == "comprel") {
      throw new Error("cannot compile code that contains 'comprel' function, run decompiler withour comprel flag to get the correct code.");
    }
    if (funcname == "comp") {
      if (args.length != 2 || !isNamedOp(args[0], namedClientScriptOps.pushconst) || !isNamedOp(args[1], namedClientScriptOps.pushconst)) {
        throw new Error("raw opcode expected");
      }
      if (typeof args[0].op.imm_obj != "number" || typeof args[1].op.imm_obj != "number") {
        throw new Error("two int literals expected");
      }
      return makeIntConst(args[0].op.imm_obj << 16 | args[1].op.imm_obj, "component");
    }
    if (funcname == "pos") {
      if (args.length != 5) {
        throw new Error("5 raw opcodes expected");
      }
      if (!isNamedOp(args[0], namedClientScriptOps.pushconst) || typeof args[0].op.imm_obj != "number") {
        throw new Error("5 int literals expected");
      }
      if (!isNamedOp(args[1], namedClientScriptOps.pushconst) || typeof args[1].op.imm_obj != "number") {
        throw new Error("5 int literals expected");
      }
      if (!isNamedOp(args[2], namedClientScriptOps.pushconst) || typeof args[2].op.imm_obj != "number") {
        throw new Error("5 int literals expected");
      }
      if (!isNamedOp(args[3], namedClientScriptOps.pushconst) || typeof args[3].op.imm_obj != "number") {
        throw new Error("5 int literals expected");
      }
      if (!isNamedOp(args[4], namedClientScriptOps.pushconst) || typeof args[4].op.imm_obj != "number") {
        throw new Error("5 int literals expected");
      }
      return makeIntConst(args[0].op.imm_obj << 28 | args[1].op.imm_obj << 20 | args[2].op.imm_obj << 6 | args[3].op.imm_obj << 12 | args[2].op.imm_obj << 0, "coordgrid");
    }
    if (funcname == "stack") {
      let op = new ComposedOp(-1, "stack");
      op.pushList(args);
      return op;
    }
    let intrinsicmatch = intrinsics.get(funcname);
    if (intrinsicmatch) {
      let node2 = new SubcallNode(-1, funcname, intrinsicmatch.in, intrinsicmatch.out);
      node2.pushList(args);
      node2.push(makeIntConst(-1, "int"));
      return node2;
    }
    let fnid = -1;
    let funcmatch = funcname.match(/^(unk|script)(\d+)$/);
    let subfunc = ctx.getFunction(funcname);
    if (subfunc) {
      let node2 = new SubcallNode(-1, subfunc.scriptname, subfunc.argtype, subfunc.returntype);
      node2.pushList(args);
      node2.push(makeIntConst(-1, "int"));
      return node2;
    } else if (funcmatch) {
      if (funcmatch[1] == "unk") {
        fnid = +funcmatch[2];
      } else {
        metaid = +funcmatch[2];
        fnid = namedClientScriptOps.gosub;
      }
    } else {
      for (let id in knownClientScriptOpNames) {
        if (funcname == knownClientScriptOpNames[id]) {
          fnid = +id;
        }
      }
    }
    let consts = new StackConstants();
    for (let arg of args) {
      if (arg.knownStackDiff?.constout != null) {
        consts.pushOne(arg.knownStackDiff.constout);
      } else {
        let out = getNodeStackOut(arg);
        consts.pushList(out);
      }
    }
    let fn = getopinfo(fnid);
    let node = new RawOpcodeNode(-1, { opcode: fnid, imm: metaid, imm_obj: null }, fn);
    setRawOpcodeStackDiff(consts, deob, node);
    node.pushList(args);
    return node;
  }
  function* returnStatement() {
    yield "return";
    yield whitespace;
    let returnop = getopinfo(namedClientScriptOps.return);
    let res = new RawOpcodeNode(-1, { opcode: returnop.id, imm: 0, imm_obj: null }, returnop);
    res.pushList(yield valueTuple);
    return res;
  }
  function* assignStatement() {
    let hasvarkeyword = yield [/^var\b/, ""];
    yield whitespace;
    let varnames = [];
    let first = yield [varname, "["];
    if (first == "[") {
      yield whitespace;
      while (!(yield has("]"))) {
        if (varnames.length != 0) {
          yield ",";
          yield whitespace;
        }
        varnames.push(yield [varname, ""]);
        yield whitespace;
      }
    } else {
      varnames.push(first);
    }
    yield whitespace;
    let typenames = null;
    if (hasvarkeyword) {
      let hastypes = yield [":", ""];
      if (hastypes == ":") {
        yield whitespace;
        typenames = yield typeDeclaration;
        if (typenames.length != varnames.length) {
          throw new Error("var assign types of different length as var names");
        }
        yield whitespace;
      }
    }
    yield whitespace;
    yield /^=(?!=)/;
    yield whitespace;
    let values = yield valueTuple;
    let node = new VarAssignNode(-1);
    let hasstackgrab = false;
    let stackout = new StackList();
    for (let val of values) {
      if (val instanceof ComposedOp && val.type == "stack") {
        hasstackgrab = true;
      } else {
        stackout.push(getNodeStackOut(val));
      }
    }
    if (!hasstackgrab && stackout.total() != varnames.length) {
      throw new Error(`var assign output count does not match variable count, out=${stackout}, vars=${varnames.join(",")}`);
    }
    for (let i = varnames.length - 1; i >= 0; i--) {
      let varname2 = varnames[i];
      let stacktype;
      let varslot = varname2 == "" ? null : ctx.getVarType(varname2);
      if (varslot) {
        stacktype = varslot.stacktype;
      } else if (typenames) {
        stacktype = typeToPrimitive(tsToSubtype(typenames[i]));
      } else {
        if (hasstackgrab) {
          throw new Error("can't infer var type when assigning from stack");
        }
        let val = stackout.values.at(-1);
        if (val instanceof StackDiff) {
          let monotype = val.isMonoType();
          if (monotype == "multi") {
            throw new Error(`ambiguous stack type order while assigning ${varname2}`);
          }
          stacktype = monotype;
        } else if (typeof val == "undefined") {
          throw new Error(`input output count mismatch at while assigning ${varname2}`);
        } else if (val == "vararg") {
          throw new Error("unexpected vararg");
        } else {
          stacktype = val;
        }
      }
      if (!hasstackgrab && !stackout.tryPopSingle(stacktype)) {
        throw new Error(`function output does not match variable type of ${varname2}, expected stack type ${stacktype}`);
      }
      if (varname2 == "") {
        let opid = stacktype == "int" ? namedClientScriptOps.popdiscardint : stacktype == "long" ? namedClientScriptOps.popdiscardlong : namedClientScriptOps.popdiscardstring;
        return new RawOpcodeNode(-1, makeop(opid), getopinfo(opid));
      } else {
        let { writeopid, varid, vartype } = getVarMeta(varname2, primitiveToUknownExact(stacktype));
        if (typeToPrimitive(vartype) != stacktype) {
          throw new Error(`type of value and target variable did not match for var ${varname2}:${subtypeToTs(vartype)}, ${subtypeToTs(primitiveToUknownExact(stacktype))}`);
        }
        let writeop = getopinfo(writeopid);
        node.varops.push(new RawOpcodeNode(-1, makeop(writeopid, varid), writeop));
      }
    }
    node.varops.reverse();
    node.pushList(values);
    return node;
  }
  function* switchCaseEntry() {
    let value = 0;
    let type = yield ["case", "default"];
    yield whitespace;
    if (type == "case") {
      value = parseInt(yield /^-?\d+/, 10);
      yield whitespace;
    }
    yield ":";
    return { type, value };
  }
  function* switchStatement() {
    yield "switch";
    yield whitespace;
    yield "(";
    yield whitespace;
    let switchvalue = yield valueStatement;
    yield whitespace;
    yield ")";
    yield whitespace;
    yield "{";
    yield whitespace;
    let cases = [];
    let defaultcase = null;
    while (!(yield has("}"))) {
      let entries = [];
      while (true) {
        let entry = yield [switchCaseEntry, ""];
        if (!entry) {
          break;
        }
        yield whitespace;
        entries.push(entry);
      }
      let block = yield [codeBlock];
      let lastchild = block.children.at(-1);
      if (lastchild instanceof ControlStatementNode && lastchild.type == "break") {
        block.remove(lastchild);
      }
      yield whitespace;
      for (let { type, value } of entries) {
        if (type == "case") {
          cases.push({ value, block });
        } else {
          defaultcase = block;
        }
      }
    }
    let node = new SwitchStatementNode(-1, switchvalue, defaultcase, cases);
    return node;
  }
  function* controlStatement() {
    let type = yield ["break", "continue"];
    yield whitespace;
    return new ControlStatementNode(-1, type);
  }
  function* ifStatement() {
    yield "if";
    yield whitespace;
    yield "(";
    yield whitespace;
    let condition = yield valueStatement;
    yield whitespace;
    yield ")";
    yield whitespace;
    let truebranch = yield codeBlock;
    yield whitespace;
    let falsebranch = null;
    if (yield has("else")) {
      yield whitespace;
      falsebranch = yield [ifStatement, codeBlock];
      if (falsebranch instanceof IfStatementNode) {
        falsebranch = new CodeBlockNode3(-1, -1, -1, [falsebranch]);
      }
    }
    let node = new IfStatementNode(-1);
    node.setBranches(condition, truebranch, falsebranch, -1);
    return node;
  }
  function* readVariable() {
    let preop = yield ["++", "--", ""];
    if (preop) {
      yield whitespace;
    }
    let name = yield varname;
    if (name == "true") {
      return makeIntConst(1, "boolean");
    }
    if (name == "false") {
      return makeIntConst(0, "boolean");
    }
    if (reserverd.includes(name)) {
      yield unmatchable;
    }
    yield whitespace;
    let { readopid, writeopid, vartype, varid } = getVarMeta(name);
    let postop = "";
    if (!preop) {
      postop = yield ["++", "--", ""];
    }
    if (vartype == subtypes.scriptref) {
      return makeIntConst(varid, "");
    }
    let readop = getopinfo(readopid);
    if (postop || preop) {
      let writeop = getopinfo(writeopid);
      let operationop = getopinfo(postop == "++" || preop == "++" ? namedClientScriptOps.plus : namedClientScriptOps.minus);
      let combined = new ComposedOp(-1, preop == "--" ? "--x" : preop == "++" ? "++x" : postop == "--" ? "x--" : "x++");
      combined.knownStackDiff = StackInOut.fromExact([], [subtypes.int]);
      if (postop) {
        combined.internalOps.push(new RawOpcodeNode(-1, { opcode: readop.id, imm: varid, imm_obj: null }, readop));
      }
      combined.internalOps.push(new RawOpcodeNode(-1, { opcode: readop.id, imm: varid, imm_obj: null }, readop));
      combined.internalOps.push(makeIntConst(1, "int"));
      combined.internalOps.push(new RawOpcodeNode(-1, { opcode: operationop.id, imm: 0, imm_obj: null }, operationop));
      combined.internalOps.push(new RawOpcodeNode(-1, { opcode: writeop.id, imm: varid, imm_obj: null }, writeop));
      if (preop) {
        combined.internalOps.push(new RawOpcodeNode(-1, { opcode: readop.id, imm: varid, imm_obj: null }, readop));
      }
      return combined;
    } else {
      let node = new RawOpcodeNode(-1, { opcode: readop.id, imm: varid, imm_obj: null }, readop);
      if (readop.id == namedClientScriptOps.pushvar) {
        node.knownStackDiff = StackInOut.fromExact([], [vartype]);
      }
      return node;
    }
  }
  function* bracketedValue() {
    yield "(";
    yield whitespace;
    let res = yield valueStatement;
    yield whitespace;
    yield ")";
    return res;
  }
  function* whileStatement() {
    yield "while";
    yield whitespace;
    yield "(";
    yield whitespace;
    let condition = yield valueStatement;
    yield whitespace;
    yield ")";
    yield whitespace;
    let code = yield codeBlock;
    return new WhileLoopStatementNode(-1, condition, code);
  }
  function* valueStatement() {
    let left = yield [bracketedValue, call, readVariable, stringInterpolation, literal2];
    yield whitespace;
    let op = yield binaryopsoremtpy;
    if (op == "") {
      return left;
    }
    yield whitespace;
    let right = yield valueStatement;
    let opid = binaryOpIds.get(op);
    if (!opid) {
      throw new Error("unexpected");
    }
    let node;
    if (binaryconditionals.includes(op)) {
      node = new BranchingStatement({ opcode: opid, imm: 0, imm_obj: null }, -1);
    } else {
      node = new RawOpcodeNode(-1, { opcode: opid, imm: 0, imm_obj: null }, ctx.deob.getNamedOp(opid));
    }
    node.children.push(left, right);
    return node;
  }
  function* valueTuple() {
    let first = yield [valueStatement, "[", ""];
    if (first instanceof AstNode) {
      return [first];
    } else if (first == "[") {
      yield whitespace;
      let values = yield valueList2;
      yield whitespace;
      yield "]";
      return values;
    } else {
      return [];
    }
  }
  function* literal2() {
    return yield [intliteral, stringliteral, longliteral];
  }
  function* statement() {
    return yield [functionStatement, ifStatement, whileStatement, switchStatement, returnStatement, controlStatement, assignStatement, valueStatement];
  }
  function* statementlist() {
    let statements = [];
    yield whitespace;
    while (true) {
      let next = yield [";", statement, ""];
      if (next == "") {
        break;
      }
      if (next != ";") {
        let out = getNodeStackOut(next);
        if (out.total() != 0) {
          let assign = new VarAssignNode(-1);
          assign.push(next);
          let diff = out.toStackDiff();
          for (let i = 0; i < diff.int; i++) {
            assign.varops.push(new RawOpcodeNode(-1, makeop(namedClientScriptOps.popdiscardint), getopinfo(namedClientScriptOps.popdiscardint)));
          }
          for (let i = 0; i < diff.long; i++) {
            assign.varops.push(new RawOpcodeNode(-1, makeop(namedClientScriptOps.popdiscardlong), getopinfo(namedClientScriptOps.popdiscardlong)));
          }
          for (let i = 0; i < diff.string; i++) {
            assign.varops.push(new RawOpcodeNode(-1, makeop(namedClientScriptOps.popdiscardstring), getopinfo(namedClientScriptOps.popdiscardstring)));
          }
          statements.push(assign);
        } else {
          statements.push(next);
        }
      }
      yield whitespace;
    }
    return statements;
  }
  function* codeBlock() {
    yield "{";
    let statements = yield statementlist;
    let closed = yield ["}", ""];
    if (!closed) {
      throw new Error("closing bracket expected");
    }
    return new CodeBlockNode3(-1, -1, -1, statements);
  }
  function* functionStatement() {
    yield whitespace;
    yield "function";
    yield whitespace;
    let name = yield varname;
    yield whitespace;
    yield "(";
    yield whitespace;
    let argtypes = yield argumentDeclaration;
    yield whitespace;
    yield ")";
    yield whitespace;
    yield ":";
    yield whitespace;
    let returntypes = yield typeDeclaration;
    yield whitespace;
    let subctx = new ParseContext(ctx.deob, ctx);
    argtypes.forEach((q) => subctx.declareVar(q.name, tsToSubtype(q.type)));
    let scope = scriptContext(subctx);
    let res = new ClientScriptFunction(
      name,
      new StackList(argtypes.map((q) => typeToPrimitive(tsToSubtype(q.type)))),
      new StackList(returntypes.map((q) => typeToPrimitive(tsToSubtype(q)))),
      new StackDiff()
    );
    res.isRawStack = name.startsWith("$$");
    ctx.declareFunction(name, res);
    let codeblock = yield scope.codeBlock;
    res.localCounts = subctx.varcounts.clone();
    for (let sub of subctx.scopefunctions.values()) {
      res.localCounts.max(sub.localCounts);
    }
    res.push(codeblock);
    return res;
  }
  return { functionStatement, codeBlock };
}
function parseClientscriptTs(deob, code) {
  let ctx = new ParseContext(deob, null);
  let scope = scriptContext(ctx);
  let res = parse2(code, scope.functionStatement());
  return res;
}
globalThis.testy = async (range = "0-1999") => {
  const fs7 = __require("fs");
  let codefs = await globalThis.cli(`extract -m clientscript -i ${range}`);
  let codefiles = [...codefs.extract.rootmemfsnode.files.entries()].filter((q) => q[0].startsWith("clientscript")).map((q) => q[1].data.replace(/^\d+:/gm, (m) => " ".repeat(m.length)));
  let jsonfs = await globalThis.cli(`extract -m clientscriptops -i ${range}`);
  let jsonfiles = [...jsonfs.extract.rootmemfsnode.files.values()].filter((q) => !q.name.startsWith("."));
  let testknown = () => {
    let tsfile = fs7.readFileSync("C:/Users/wilbe/tmp/clinetscript/input.ts", "utf8");
    let jsonfile = JSON.stringify({ opcodedata: [] });
    return testinner(tsfile, jsonfile);
  };
  let subtest = (index) => {
    return testinner(codefiles[index], jsonfiles[index].data, index);
  };
  let testinner = async (originalts, originaljson, fileid = -1) => {
    const deob = globalThis.deob;
    let parseresult = parseClientscriptTs(deob, originalts);
    if (!parseresult.success) {
      return parseresult;
    }
    let roundtripped = astToImJson(deob, parseresult.result);
    let jsondata = JSON.parse(originaljson);
    delete jsondata.$schema;
    roundtripped.opcodedata.forEach((q) => q.opname = getOpName(q.opcode));
    let source = globalThis.engine;
    await prepareClientScript(source);
    let binaryrountripped = parse.clientscript.write(roundtripped, source.getDecodeArgs());
    let original = prettyJson(jsondata.opcodedata);
    let rawinput = prettyJson(jsondata);
    let rawroundtrip = prettyJson(roundtripped);
    fs7.writeFileSync("C:/Users/wilbe/tmp/clinetscript/binary.dat", binaryrountripped);
    fs7.writeFileSync("C:/Users/wilbe/tmp/clinetscript/raw1.json", rawinput);
    fs7.writeFileSync("C:/Users/wilbe/tmp/clinetscript/raw2.json", rawroundtrip);
    fs7.writeFileSync("C:/Users/wilbe/tmp/clinetscript/json1.json", prettyJson(jsondata.opcodedata));
    fs7.writeFileSync("C:/Users/wilbe/tmp/clinetscript/json2.json", prettyJson(roundtripped.opcodedata));
    fs7.writeFileSync("C:/Users/wilbe/tmp/clinetscript/js1.ts", originalts);
    let { rootfunc: roundtrippedAst, typectx } = parseClientScriptIm2(deob, roundtripped, fileid);
    let roundtripts = new TsWriterContext(deob, typectx).getCode(roundtrippedAst);
    globalThis.cstest = roundtrippedAst;
    fs7.writeFileSync("C:/Users/wilbe/tmp/clinetscript/js2.ts", roundtripts);
    return { exact: rawinput == rawroundtrip, exactts: originalts == roundtripts, roundtripped, original };
  };
  return { subtest, testinner, testknown, codefiles, codefs, jsonfs, jsonfiles };
};
function writeOpcodeFile(calli) {
  let res = "";
  res += `// Need to be defined for the typescript compiler
`;
  res += "interface Boolean { }\n";
  res += "interface Function { }\n";
  res += "interface Number { }\n";
  res += "interface Object { }\n";
  res += "interface RegExp { }\n";
  res += "interface String { }\n";
  res += "interface IArguments { }\n";
  res += "interface BigInt { }\n";
  res += "interface Symbol { }\n";
  res += "interface Array<T> { [Symbol.iterator](): any; }\n";
  res += "declare var Symbol: { readonly iterator: unique symbol };\n";
  res += "\n";
  res += `// Language constructs
`;
  res += "declare class BoundFunction { }\n";
  res += "declare function operator(op: string, ...values:any[]): any;\n";
  res += "declare function callback(): BoundFunction;\n";
  res += "declare function callback<T extends (...args: any[]) => any>(fn: T, ...args: T extends (...args: (infer ARGS)[]) => any ? ARGS : never): BoundFunction;\n";
  res += "declare function comp(interf: number, element: number): component;\n";
  res += "declare function comprel(interf: number, elementrel: number): component;\n";
  res += "declare function pos(level: number, chunkx:number, chunkz:number, subx:number, subz:number): coordgrid;\n";
  res += "declare function stack(...args: any[]): any;\n";
  res += "\n";
  res += `// Compiler intrinsics
`;
  for (let [name, intr] of intrinsics) {
    res += `declare function ${name}(${intr.in.toTypeScriptVarlist(true, true)}): ${intr.out.toTypeScriptReturnType()};
`;
  }
  res += "\n";
  res += `// Clientscript types
`;
  for (let type of Object.values(subtypes)) {
    let prim = typeToPrimitive(type);
    let name = subtypeToTs(type);
    if (name == "string") {
      continue;
    }
    if (name == "boolean") {
      continue;
    }
    res += `type ${name} = ${prim == "int" ? "number" : prim == "long" ? "BigInt" : "string"}
`;
  }
  res += "\n";
  res += `// VM opcodes
`;
  for (let op of calli.mappings.values()) {
    let opname = getOpName(op.id);
    if (reserverd.includes(opname)) {
      continue;
    }
    if (op.id == namedClientScriptOps.enum_getvalue) {
      res += `declare function ${opname}(int0: number, int1: number, int2: number, int3: number): any;
`;
    } else if (op.id == namedClientScriptOps.dbrow_getfield) {
      res += `declare function ${opname}(int0: number, int1: number, int2: number): any;
`;
    } else if (!dynamicOps.includes(op.id) && op.stackinfo.initializedthrough) {
      let args = op.stackinfo.in.toTypeScriptVarlist(true, true, op.stackinfo.exactin);
      let returns = op.stackinfo.out.toTypeScriptReturnType(op.stackinfo.exactout);
      res += `declare function ${opname}(${args}): ${returns};
`;
    } else {
      res += `declare function ${opname}(...args: any[]): any;
`;
    }
  }
  return res;
}
function writeClientVarFile(calli) {
  let res = "";
  for (let domain of calli.varmeta.values()) {
    res += `// ===== ${domain.name} =====
`;
    for (let [id, meta] of domain.vars) {
      res += `declare var var${domain.name}_${id}: ${subtypeToTs(meta.type)};
`;
    }
  }
  res += `// ===== varbits =====
`;
  for (let [id, meta] of calli.varbitmeta) {
    let groupmeta = calli.varmeta.get(meta.varid >> 16);
    res += `declare var varbit${groupmeta?.name ?? "unk"}_${id}: number;
`;
  }
  return res;
}

// rsmv/src/clientscript/index.ts
async function compileClientScript(source, code) {
  let calli = await prepareClientScript(source);
  let parseresult = parseClientscriptTs(calli, code);
  if (!parseresult.success) {
    throw new Error("failed to parse clientscript", { cause: parseresult.failedOn });
  }
  if (parseresult.remaining != "") {
    throw new Error("failed to parse clientscript, left over: " + parseresult.remaining.slice(0, 100));
  }
  return astToImJson(calli, parseresult.result);
}
async function renderClientScript(source, buf, fileid, relativeComps = false, notypes = false, int32casts = false) {
  let calli = await prepareClientScript(source);
  let script = parse.clientscript.read(buf, source);
  let { rootfunc, sections, typectx } = parseClientScriptIm2(calli, script, fileid);
  let writer = new TsWriterContext(calli, typectx);
  if (relativeComps) {
    writer.setCompOffsets(rootfunc);
  }
  writer.typescript = !notypes;
  writer.int32casts = int32casts;
  let res = writer.getCode(rootfunc);
  return res;
}
async function prepareClientScript(source) {
  if (!source.decodeArgs.clientScriptDeob) {
    let deobsource = source;
    let deob = await ClientscriptObfuscation.create(deobsource);
    source.decodeArgs.clientScriptDeob = deob;
    await deob.runAutoCallibrate(source);
    await deob.save();
    globalThis.deob = deob;
  }
  return source.decodeArgs.clientScriptDeob;
}

// rsmv/src/clientscript/interpreter.ts
var ClientScriptInterpreter = class {
  constructor(calli, uictx = null) {
    this.intstack = [];
    this.longstack = [];
    this.stringstack = [];
    this.scopeStack = [];
    this.mockscripts = /* @__PURE__ */ new Map();
    this.scope = null;
    this.activecompid = -1;
    this.clientcomps = [void 0, void 0];
    this.stalled = void 0;
    this.uictx = null;
    this.calli = calli;
    this.uictx = uictx;
  }
  reset() {
    if (this.stalled) {
      console.log("resetting cs2 interpreter while an async op is running, everything is probably corrupt");
    }
    this.scopeStack.length = 0;
    this.scope = null;
    this.intstack.length = 0;
    this.longstack.length = 0;
    this.stringstack.length = 0;
    this.activecompid = -1;
    this.clientcomps.fill(void 0);
  }
  popComponent() {
    return this.getComponent(this.popint());
  }
  getClientComp(imm) {
    let comp = this.clientcomps[imm];
    if (!comp) {
      throw new Error(`clientcomp not set`);
    }
    return comp;
  }
  getComponent(compid) {
    if ((compid | 0) == MAGIC_CONST_CURRENTCOMP) {
      compid = this.activecompid;
    }
    let comp = this.uictx?.comps.get(compid);
    if (!comp) {
      return new CS2Api(null);
    }
    return comp.api;
  }
  async callscriptid(id) {
    let data = await this.calli.source.getFileById(cacheMajors.clientscript, id);
    this.callscript(parse.clientscript.read(data, this.calli.source), id);
  }
  async runToEnd() {
    while (true) {
      let res = this.next();
      if (res instanceof Promise) {
        res = await res;
      }
      if (!res) {
        break;
      }
    }
  }
  callscript(script, scriptid) {
    this.log(`calling script ${scriptid}`);
    this.scope = {
      scriptid,
      index: 0,
      ops: script.opcodedata,
      switches: script.switches,
      localints: new Array(script.localintcount).fill(0),
      locallongs: new Array(script.locallongcount).fill(0n),
      localstrings: new Array(script.localstringcount).fill("")
    };
    for (let i = script.intargcount - 1; i >= 0; i--) {
      this.scope.localints[i] = this.popint();
    }
    for (let i = script.longargcount - 1; i >= 0; i--) {
      this.scope.locallongs[i] = this.poplong();
    }
    for (let i = script.stringargcount - 1; i >= 0; i--) {
      this.scope.localstrings[i] = this.popstring();
    }
    this.scopeStack.push(this.scope);
  }
  log(text) {
    console.log(`CS2: ${"  ".repeat(this.scopeStack.length)} ${text}`);
  }
  pushStackdiff(diff) {
    if (diff.vararg != 0) {
      throw new Error("cannot push vararg");
    }
    for (let i = 0; i < diff.int; i++) {
      this.pushint(0);
    }
    for (let i = 0; i < diff.long; i++) {
      this.pushlong(0n);
    }
    for (let i = 0; i < diff.string; i++) {
      this.pushstring("");
    }
  }
  popStacklist(list) {
    for (let i = list.values.length - 1; i >= 0; i--) {
      let val = list.values[i];
      if (val instanceof StackDiff) {
        this.popStackdiff(val);
      } else if (val == "int") {
        this.popint();
      } else if (val == "long") {
        this.poplong();
      } else if (val == "string") {
        this.popstring();
      } else if (val == "vararg") {
        this.popvararg();
      } else {
        throw new Error("unexpected");
      }
    }
  }
  popvararg() {
    let str = this.popstring();
    for (let i = str.match(/Y/g)?.length ?? 0; i > 0; i--) {
      for (let ii = this.popint(); ii > 0; ii--) {
        this.popint();
      }
    }
    for (let i = str.match(/i/g)?.length ?? 0; i > 0; i--) {
      this.popint();
    }
    for (let i = str.match(/l/g)?.length ?? 0; i > 0; i--) {
      this.poplong();
    }
    for (let i = str.match(/s/g)?.length ?? 0; i > 0; i--) {
      this.popstring();
    }
  }
  popStackdiff(diff) {
    if (diff.vararg != 0) {
      throw new Error("can't pop vararg since the order of pops is ambiguous");
    }
    for (let i = 0; i < diff.int; i++) {
      this.popint();
    }
    for (let i = 0; i < diff.long; i++) {
      this.poplong();
    }
    for (let i = 0; i < diff.string; i++) {
      this.popstring();
    }
  }
  //shorthand for unordered stack access in implementation
  popdeep(depth) {
    if (this.intstack.length < depth) {
      throw new Error(`tried to pop int while none are on stack at index ${(this.scope?.index ?? 0) - 1}`);
    }
    return this.intstack.splice(this.intstack.length - 1 - depth, 1)[0];
  }
  //shorthand for unordered stack access in implementation
  popdeeplong(depth) {
    if (this.longstack.length < depth) {
      throw new Error(`tried to pop long while none are on stack at index ${(this.scope?.index ?? 0) - 1}`);
    }
    return this.longstack.splice(this.longstack.length - 1 - depth, 1)[0];
  }
  //shorthand for unordered stack access in implementation
  popdeepstr(depth) {
    if (this.stringstack.length < depth) {
      throw new Error(`tried to pop string while none are on stack at index ${(this.scope?.index ?? 0) - 1}`);
    }
    return this.stringstack.splice(this.stringstack.length - 1 - depth, 1)[0];
  }
  popint() {
    if (this.intstack.length == 0) {
      throw new Error(`tried to pop int while none are on stack at index ${(this.scope?.index ?? 0) - 1}`);
    }
    return this.intstack.pop();
  }
  poplong() {
    if (this.longstack.length == 0) {
      throw new Error(`tried to pop long while none are on stack at index ${(this.scope?.index ?? 0) - 1}`);
    }
    return this.longstack.pop();
  }
  popstring() {
    if (this.stringstack.length == 0) {
      throw new Error(`tried to pop string while none are on stack at index ${(this.scope?.index ?? 0) - 1}`);
    }
    return this.stringstack.pop();
  }
  pushlist(list) {
    for (let v of list) {
      if (typeof v == "number") {
        this.pushint(v);
      } else if (typeof v == "bigint") {
        this.pushlong(v);
      } else if (typeof v == "string") {
        this.pushstring(v);
      } else {
        throw new Error("unexpected");
      }
    }
  }
  pushint(v) {
    this.intstack.push(v);
  }
  pushlong(v) {
    this.longstack.push(v);
  }
  pushstring(v) {
    this.stringstack.push(v);
  }
  next() {
    if (this.stalled) {
      return this.stalled = this.stalled.then((res2) => res2 && this.next());
    }
    if (!this.scope) {
      throw new Error("no script");
    }
    if (this.scope.index < 0 || this.scope.index >= this.scope.ops.length) {
      throw new Error("jumped out of bounds");
    }
    let op = this.scope.ops[this.scope.index++];
    let implemented = implementedops.get(op.opcode);
    if (!implemented) {
      for (let [id, name] of Object.entries(rs3opnames)) {
        if (+id == op.opcode) {
          implemented = namedimplementations.get(name);
          break;
        }
      }
    }
    let res = void 0;
    if (op.opcode == namedClientScriptOps.return) {
      this.scopeStack.pop();
      this.scope = this.scopeStack.at(-1) ?? null;
      return !!this.scope;
    } else if (implemented) {
      res = implemented(this, op);
    } else {
      let opinfo = this.calli.decodedMappings.get(op.opcode);
      if (!opinfo) {
        throw new Error(`Uknown op with opcode ${op.opcode}`);
      }
      if (!opinfo.stackinfo.initializedthrough) {
        throw new Error(`Unknown params/returns for op ${op.opcode}`);
      }
      this.popStacklist(opinfo.stackinfo.in);
      this.pushStackdiff(opinfo.stackinfo.out.toStackDiff());
    }
    if (res instanceof Promise) {
      this.stalled = res.finally(() => this.stalled = void 0).then((q) => true).catch((q) => false);
      return this.stalled;
    } else {
      return true;
    }
  }
  dump() {
    let res = "";
    res += "locals:\n";
    res += `${this.scope?.localints.join(",") ?? "no scope"}
`;
    res += `${this.scope?.locallongs.join(",") ?? "no scope"}
`;
    res += `${this.scope?.localstrings.map((q) => `"${q}"`).join(",") ?? "no scope"}
`;
    res += "stack:\n";
    res += `${this.intstack.join(",")}
`;
    res += `${this.longstack.join(",")}
`;
    res += `${this.stringstack.map((q) => `"${q}"`).join(",")}
`;
    if (this.scope) {
      res += `script stack ${this.scopeStack.map((q) => q.scriptid).join(", ")}
`;
      for (let i = -5; i < 10; i++) {
        let index = this.scope.index + i;
        if (index < 0 || index >= this.scope.ops.length) {
          continue;
        }
        res += `${index} ${index == this.scope.index ? ">>" : "  "} `;
        let op = this.scope.ops[index];
        if (op) {
          let opinfo = this.calli.decodedMappings.get(op.opcode);
          let name = knownClientScriptOpNames[op.opcode];
          res += `${name.padEnd(12, " ").slice(0, 12)} ${op.imm} ${op.imm_obj ?? ""}
`;
        } else {
          res += `??
`;
        }
      }
    }
    console.log(res);
  }
};
function branchOp(inter, op) {
  let result = false;
  if (op.opcode == namedClientScriptOps.branch_eq) {
    result = inter.popdeep(1) == inter.popdeep(0);
  } else if (op.opcode == namedClientScriptOps.branch_not) {
    result = inter.popdeep(1) != inter.popdeep(0);
  } else if (op.opcode == namedClientScriptOps.branch_lt) {
    result = inter.popdeep(1) < inter.popdeep(0);
  } else if (op.opcode == namedClientScriptOps.branch_lteq) {
    result = inter.popdeep(1) <= inter.popdeep(0);
  } else if (op.opcode == namedClientScriptOps.branch_gt) {
    result = inter.popdeep(1) > inter.popdeep(0);
  } else if (op.opcode == namedClientScriptOps.branch_gteq) {
    result = inter.popdeep(1) >= inter.popdeep(0);
  } else {
    throw new Error("unknown branch op (branch long not implemented)");
  }
  if (result) {
    if (!inter.scope) {
      throw new Error("unexpected");
    }
    inter.scope.index += op.imm;
  }
}
function getParamOp(inter, op) {
  let paramid = inter.popint();
  let param = inter.calli.parammeta.get(paramid);
  if (!param) {
    throw new Error(`unknown param ${paramid}`);
  } else {
    let outtype = param.type ? param.type.vartype : 0;
    let target = op.opcode == namedClientScriptOps.cc_getparam ? 0 : inter.popint();
    let outprim = typeToPrimitive(outtype);
    if (outprim == "int") {
      inter.pushint(0);
    }
    if (outprim == "long") {
      inter.pushlong(0n);
    }
    if (outprim == "string") {
      inter.pushstring("");
    }
  }
}
var implementedops = /* @__PURE__ */ new Map();
branchInstructions.forEach((id) => implementedops.set(id, branchOp));
getParamOps.forEach((id) => implementedops.set(id, getParamOp));
implementedops.set(namedClientScriptOps.gosub, (inter, op) => {
  let mockreturn = inter.mockscripts.get(op.imm);
  if (mockreturn) {
    let func = inter.calli.scriptargs.get(op.imm);
    if (!func) {
      throw new Error(`calling unknown clientscript ${op.imm}`);
    }
    inter.log(`CS2 - calling sub ${op.imm}${mockreturn ? ` with mocked return value: ${mockreturn}` : ""}`);
    inter.popStacklist(func.stack.in);
    for (let val of mockreturn) {
      if (typeof val == "number") {
        inter.pushint(val);
      }
      if (typeof val == "bigint") {
        inter.pushlong(val);
      }
      if (typeof val == "string") {
        inter.pushstring(val);
      }
    }
  } else {
    return inter.callscriptid(op.imm);
  }
});
implementedops.set(namedClientScriptOps.enum_getvalue, async (inter) => {
  let key = inter.popint();
  let enumid = inter.popint();
  let outtype = inter.popint();
  let keytype = inter.popint();
  let outprim = typeToPrimitive(outtype);
  let enumjson = await loadEnum(inter.calli.source, enumid);
  if (outprim != "int") {
    throw new Error("enum_getvalue can only look up int values");
  }
  let res = getEnumInt(enumjson, key);
  inter.pushint(res);
});
implementedops.set(namedClientScriptOps.struct_getparam, async (inter) => {
  let param = inter.popint();
  let structid = inter.popint();
  let json = await loadStruct(inter.calli.source, structid).catch((q) => null);
  let res = getStructInt(inter.calli.parammeta, json, param);
  inter.pushint(res);
});
implementedops.set(namedClientScriptOps.dbrow_getfield, (inter) => {
  let subrow = inter.popint();
  let tablefield = inter.popint();
  let rowid = inter.popint();
  let dbtable = tablefield >> 12 & 65535;
  let columnid = tablefield >> 4 & 255;
  let subfield = tablefield & 15;
  let table = inter.calli.dbtables.get(dbtable);
  let column = table?.unk01?.columndata.find((q) => q.id == columnid) ?? table?.unk02?.columndata.find((q) => q.id == columnid);
  if (!column) {
    throw new Error(`couldn't find dbtable ${dbtable}.${columnid}`);
  }
  let types = subfield != 0 ? [column.columns[subfield - 1].type] : column.columns.map((q) => q.type);
  inter.pushStackdiff(new StackList(types.map(typeToPrimitive)).toStackDiff());
});
implementedops.set(namedClientScriptOps.joinstring, (inter, op) => {
  inter.pushstring(new Array(op.imm).fill("").map((q) => inter.popstring()).reverse().join(""));
});
implementedops.set(namedClientScriptOps.pushconst, (inter, op) => {
  if (op.imm == 0) {
    if (typeof op.imm_obj != "number") {
      throw new Error("expected imm_obj to be number in pushconst int");
    }
    inter.pushint(op.imm_obj);
  } else if (op.imm == 1) {
    if (!Array.isArray(op.imm_obj) || op.imm_obj.length != 2 || typeof op.imm_obj[0] != "number" || typeof op.imm_obj[1] != "number") {
      throw new Error("expected imm_obj to be [number,number] in pushconst long");
    }
    inter.pushlong(longJsonToBigInt(op.imm_obj));
  } else if (op.imm == 2) {
    if (typeof op.imm_obj != "string") {
      throw new Error("expected imm_obj to be string in pushconst string");
    }
    inter.pushstring(op.imm_obj);
  }
});
implementedops.set(namedClientScriptOps.switch, (inter, op) => {
  let branches = inter.scope.switches[op.imm];
  if (!branches) {
    throw new Error(`non-existant branches referenced switch at ${inter.scope.index}`);
  }
  let val = inter.popint();
  let match = branches.find((q) => q.value == val);
  if (match) {
    inter.scope.index += match.jump;
  }
});
implementedops.set(namedClientScriptOps.jump, (inter, op) => {
  inter.scope.index += op.imm;
});
implementedops.set(namedClientScriptOps.pushlocalint, (inter, op) => {
  if (op.imm >= inter.scope.localints.length) {
    throw new Error("invalid pushlocalint");
  }
  inter.pushint(inter.scope.localints[op.imm]);
});
implementedops.set(namedClientScriptOps.pushlocallong, (inter, op) => {
  if (op.imm >= inter.scope.locallongs.length) {
    throw new Error("invalid pushlocallong");
  }
  inter.pushlong(inter.scope.locallongs[op.imm]);
});
implementedops.set(namedClientScriptOps.pushlocalstring, (inter, op) => {
  if (op.imm >= inter.scope.localstrings.length) {
    throw new Error("invalid pushlocalstring");
  }
  inter.pushstring(inter.scope.localstrings[op.imm]);
});
implementedops.set(namedClientScriptOps.poplocalint, (inter, op) => {
  if (op.imm >= inter.scope.localints.length) {
    throw new Error("invalid poplocalint");
  }
  inter.scope.localints[op.imm] = inter.popint();
});
implementedops.set(namedClientScriptOps.poplocallong, (inter, op) => {
  if (op.imm >= inter.scope.locallongs.length) {
    throw new Error("invalid poplocallong");
  }
  inter.scope.locallongs[op.imm] = inter.poplong();
});
implementedops.set(namedClientScriptOps.poplocalstring, (inter, op) => {
  if (op.imm >= inter.scope.localstrings.length) {
    throw new Error("invalid poplocalstring");
  }
  inter.scope.localstrings[op.imm] = inter.popstring();
});
implementedops.set(namedClientScriptOps.printmessage, (inter) => inter.log(`>> ${inter.popstring()}`));
implementedops.set(namedClientScriptOps.inttostring, (inter) => inter.pushstring(inter.popdeep(1).toString(inter.popdeep(0))));
implementedops.set(namedClientScriptOps.strcmp, (inter) => {
  let right = inter.popstring();
  let left = inter.popstring();
  inter.pushint(left < right ? -1 : left > right ? 1 : 0);
});
implementedops.set(namedClientScriptOps.pushvar, (inter, op) => {
  let varmeta = inter.calli.getClientVarMeta(op.imm);
  if (!varmeta) {
    throw new Error(`unknown clientvar with id ${op.imm}`);
  }
  inter.pushStackdiff(new StackList([varmeta.type]).toStackDiff());
});
implementedops.set(namedClientScriptOps.popvar, (inter, op) => {
  let varmeta = inter.calli.getClientVarMeta(op.imm);
  if (!varmeta) {
    throw new Error(`unknown clientvar with id ${op.imm}`);
  }
  inter.popStacklist(new StackList([varmeta.type]));
});
var namedimplementations = /* @__PURE__ */ new Map();
namedimplementations.set("STRING_LENGTH", (inter) => inter.pushint(inter.popstring().length));
namedimplementations.set("SUBSTRING", (inter) => inter.pushstring(inter.popstring().substring(inter.popdeep(1), inter.popdeep(0))));
namedimplementations.set("STRING_INDEXOF_STRING", (inter) => inter.pushint(inter.popdeepstr(1).indexOf(inter.popdeepstr(0), inter.popint())));
namedimplementations.set("STRING_INDEXOF_CHAR", (inter) => inter.pushint(inter.popstring().indexOf(String.fromCharCode(inter.popdeep(1)), inter.popdeep(0))));
namedimplementations.set("MIN", (inter) => inter.pushint(Math.min(inter.popint(), inter.popint())));
namedimplementations.set("MAX", (inter) => inter.pushint(Math.max(inter.popint(), inter.popint())));
namedimplementations.set("ADD", (inter) => inter.pushint(inter.popint() + inter.popint() | 0));
namedimplementations.set("SUB", (inter) => inter.pushint(inter.popdeep(1) - inter.popint() | 0));
namedimplementations.set("DIVIDE", (inter) => inter.pushint(inter.popdeep(1) / inter.popint() | 0));
namedimplementations.set("MULTIPLY", (inter) => inter.pushint(Math.imul(inter.popdeep(1), inter.popint())));
namedimplementations.set("AND", (inter) => inter.pushint(inter.popint() & inter.popint()));
namedimplementations.set("OR", (inter) => inter.pushint(inter.popint() | inter.popint()));
namedimplementations.set("LOWERCASE", (inter) => inter.pushstring(inter.popstring().toLowerCase()));
namedimplementations.set("LONG_UNPACK", (inter) => {
  let long = longBigIntToJson(inter.poplong());
  inter.pushint(long[0] >> 0);
  inter.pushint(long[1] >> 0);
});
namedimplementations.set("MES_TYPED", (inter) => inter.log(`>> ${inter.popint()} ${inter.popint()} ${inter.popstring()}`));
namedimplementations.set("LONG_ADD", (inter) => inter.pushlong(inter.popdeeplong(1) + inter.popdeeplong(0)));
namedimplementations.set("LONG_SUB", (inter) => inter.pushlong(inter.popdeeplong(1) - inter.popdeeplong(0)));
namedimplementations.set("TOSTRING_LONG", (inter) => inter.pushstring(inter.poplong().toString()));
namedimplementations.set("INT_TO_LONG", (inter) => inter.pushlong(BigInt(inter.popint())));
namedimplementations.set("OPENURLRAW", (inter) => inter.log(`CS2 OPENURLRAW: ${inter.popint()}, ${inter.popstring()}`));
namedimplementations.set("ENUM_GETOUTPUTCOUNT", async (inter) => {
  let json = await loadEnum(inter.calli.source, inter.popint());
  inter.pushint((json.intArrayValue1 ?? json.intArrayValue2?.values ?? json.stringArrayValue1 ?? json.stringArrayValue2?.values)?.length ?? 0);
});
namedimplementations.set("CC_CREATE", (inter, op) => {
  inter.clientcomps[op.imm] = inter.getComponent(inter.popdeep(2)).createChild(inter.popint(), inter.popint());
});
namedimplementations.set("CC_FIND", (inter, op) => inter.pushint(+!!(inter.clientcomps[op.imm] = inter.getComponent(inter.popdeep(1)).findChild(inter.popint()))));
namedimplementations.set("IF_GETLAYER", (inter) => {
  inter.popint();
  inter.pushint(-1);
});
namedimplementations.set("IF_GETPARENTLAYER", (inter) => {
  inter.popint();
  inter.pushint(-1);
});
namedimplementations.set("IF_GETNEXTSUBID", (inter) => inter.pushint(inter.popComponent().getNextChildId()));
namedimplementations.set("ACHIEVEMENT_FINDNEXT", (inter) => inter.pushint(-1));
namedimplementations.set("IF_SETHIDE", (inter) => inter.popComponent().setHide(inter.popint()));
namedimplementations.set("IF_GETHEIGHT", (inter) => inter.pushint(inter.popComponent().getHeight()));
namedimplementations.set("IF_GETWIDTH", (inter) => inter.pushint(inter.popComponent().getWidth()));
namedimplementations.set("IF_GETX", (inter) => inter.pushint(inter.popComponent().getX()));
namedimplementations.set("IF_GETY", (inter) => inter.pushint(inter.popComponent().getY()));
namedimplementations.set("IF_SETOP", (inter) => inter.popComponent().setOp(inter.popint(), inter.popstring()));
namedimplementations.set("IF_GETHIDE", (inter) => inter.pushint(inter.popComponent().getHide()));
namedimplementations.set("IF_GETTEXT", (inter) => inter.pushstring(inter.popComponent().getText()));
namedimplementations.set("IF_SETTEXT", (inter) => inter.popComponent().setText(inter.popstring()));
namedimplementations.set("IF_SETTEXTALIGN", (inter) => inter.popComponent().setTextAlign(inter.popint(), inter.popint(), inter.popint()));
namedimplementations.set("IF_GETGRAPHIC", (inter) => inter.pushint(inter.popComponent().getGraphic()));
namedimplementations.set("IF_GETHFLIP", (inter) => inter.pushint(+inter.popComponent().getHFlip()));
namedimplementations.set("IF_GETVFLIP", (inter) => inter.pushint(+inter.popComponent().getVFlip()));
namedimplementations.set("IF_SETGRAPHIC", (inter) => inter.popComponent().setGraphic(inter.popint()));
namedimplementations.set("IF_SETHFLIP", (inter) => inter.popComponent().setHFlip(!!inter.popint()));
namedimplementations.set("IF_SETVFLIP", (inter) => inter.popComponent().setVFlip(!!inter.popint()));
namedimplementations.set("IF_SETMODEL", (inter) => inter.popComponent().setModel(inter.popint()));
namedimplementations.set("IF_GETTRANS", (inter) => inter.pushint(inter.popComponent().getTrans()));
namedimplementations.set("IF_GETCOLOUR", (inter) => inter.pushint(inter.popComponent().getColor()));
namedimplementations.set("IF_GETFILLED", (inter) => inter.pushint(inter.popComponent().getFilled()));
namedimplementations.set("IF_SETTRANS", (inter) => inter.popComponent().setTrans(inter.popint()));
namedimplementations.set("IF_SETCOLOUR", (inter) => inter.popComponent().setColor(inter.popint()));
namedimplementations.set("IF_SETFill", (inter) => inter.popComponent().setFilled(inter.popint()));
namedimplementations.set("IF_SETSIZE", (inter) => inter.popComponent().setSize(inter.popdeep(3), inter.popdeep(2), inter.popdeep(1), inter.popdeep(0)));
namedimplementations.set("IF_SETPOSITION", (inter) => inter.popComponent().setPosition(inter.popdeep(3), inter.popdeep(2), inter.popdeep(1), inter.popdeep(0)));
namedimplementations.set("IF_SETTILING", (inter) => inter.popComponent().setTiling(inter.popint()));
namedimplementations.set("IF_GETTILING", (inter) => inter.pushint(inter.popComponent().getTiling()));
namedimplementations.set("CC_SETHIDE", (inter, op) => inter.getClientComp(op.imm).setHide(inter.popint()));
namedimplementations.set("CC_GETHEIGHT", (inter, op) => inter.pushint(inter.getClientComp(op.imm).getHeight()));
namedimplementations.set("CC_GETWIDTH", (inter, op) => inter.pushint(inter.getClientComp(op.imm).getWidth()));
namedimplementations.set("CC_GETX", (inter, op) => inter.pushint(inter.getClientComp(op.imm).getX()));
namedimplementations.set("CC_GETY", (inter, op) => inter.pushint(inter.getClientComp(op.imm).getY()));
namedimplementations.set("CC_SETOP", (inter, op) => inter.getClientComp(op.imm).setOp(inter.popint(), inter.popstring()));
namedimplementations.set("CC_GETHIDE", (inter, op) => inter.pushint(inter.getClientComp(op.imm).getHide()));
namedimplementations.set("CC_GETTEXT", (inter, op) => inter.pushstring(inter.getClientComp(op.imm).getText()));
namedimplementations.set("CC_SETTEXT", (inter, op) => inter.getClientComp(op.imm).setText(inter.popstring()));
namedimplementations.set("CC_SETTEXTALIGN", (inter, op) => inter.getClientComp(op.imm).setTextAlign(inter.popint(), inter.popint(), inter.popint()));
namedimplementations.set("CC_GETGRAPHIC", (inter, op) => inter.pushint(inter.getClientComp(op.imm).getGraphic()));
namedimplementations.set("CC_GETHFLIP", (inter, op) => inter.pushint(+inter.getClientComp(op.imm).getHFlip()));
namedimplementations.set("CC_GETVFLIP", (inter, op) => inter.pushint(+inter.getClientComp(op.imm).getVFlip()));
namedimplementations.set("CC_SETGRAPHIC", (inter, op) => inter.getClientComp(op.imm).setGraphic(inter.popint()));
namedimplementations.set("CC_SETHFLIP", (inter, op) => inter.getClientComp(op.imm).setHFlip(!!inter.popint()));
namedimplementations.set("CC_SETVFLIP", (inter, op) => inter.getClientComp(op.imm).setVFlip(!!inter.popint()));
namedimplementations.set("CC_SETMODEL", (inter, op) => inter.getClientComp(op.imm).setModel(inter.popint()));
namedimplementations.set("CC_GETTRANS", (inter, op) => inter.pushint(inter.getClientComp(op.imm).getTrans()));
namedimplementations.set("CC_GETCOLOUR", (inter, op) => inter.pushint(inter.getClientComp(op.imm).getColor()));
namedimplementations.set("CC_GETFILLED", (inter, op) => inter.pushint(inter.getClientComp(op.imm).getFilled()));
namedimplementations.set("CC_SETTRANS", (inter, op) => inter.getClientComp(op.imm).setTrans(inter.popint()));
namedimplementations.set("CC_SETCOLOUR", (inter, op) => inter.getClientComp(op.imm).setColor(inter.popint()));
namedimplementations.set("CC_SETFill", (inter, op) => inter.getClientComp(op.imm).setFilled(inter.popint()));
namedimplementations.set("CC_SETSIZE", (inter, op) => inter.getClientComp(op.imm).setSize(inter.popdeep(3), inter.popdeep(2), inter.popdeep(1), inter.popdeep(0)));
namedimplementations.set("CC_SETPOSITION", (inter, op) => inter.getClientComp(op.imm).setPosition(inter.popdeep(3), inter.popdeep(2), inter.popdeep(1), inter.popdeep(0)));
namedimplementations.set("CC_SETTILING", (inter, op) => inter.getClientComp(op.imm).setTiling(inter.popint()));
namedimplementations.set("CC_GETTILING", (inter, op) => inter.pushint(inter.getClientComp(op.imm).getTiling()));

// rsmv/src/scripts/renderrsinterface.ts
var MAGIC_CONST_MOUSE_X = 2147483649 | 0;
var MAGIC_CONST_MOUSE_Y = 2147483650 | 0;
var MAGIC_CONST_CURRENTCOMP = 2147483651 | 0;
var MAGIC_CONST_OPNR = 2147483652 | 0;
var MAGIC_CONST_IF_AS_CC = 2147483653 | 0;
var MAGIC_UNK06 = 2147483654 | 0;
var UiRenderContext2 = class extends TypedEmitter {
  constructor(source) {
    super();
    this.sceneCache = null;
    this.renderer = null;
    this.comps = /* @__PURE__ */ new Map();
    this.highlightstack = [];
    this.interpreterprom = null;
    this.touchedComps = /* @__PURE__ */ new Set();
    this.runOnloadScripts = false;
    this.source = source;
  }
  toggleHighLightComp(subid, highlight) {
    let comp = this.comps.get(subid)?.element;
    if (comp) {
      if (highlight) {
        if (this.highlightstack.length != 0) {
          this.highlightstack.at(-1).classList.remove("rs-component--highlight");
        }
        comp.classList.add("rs-component--highlight");
        this.highlightstack.push(comp);
      } else {
        comp.classList.remove("rs-component--highlight");
        if (this.highlightstack.pop() != comp) {
          console.log("wrong unlightlight order");
        }
        if (this.highlightstack.length != 0) {
          this.highlightstack.at(-1).classList.add("rs-component--highlight");
        }
      }
    }
  }
  async runClientScriptCallback(compid, cbdata) {
    if (cbdata.length == 0) {
      return;
    }
    let inter = await (this.interpreterprom ??= prepareClientScript(this.source).then((q) => new ClientScriptInterpreter(q, this)));
    if (typeof cbdata[0] != "number") {
      throw new Error("expected callback script id but got string");
    }
    inter.reset();
    inter.pushlist(cbdata.slice(1));
    inter.activecompid = compid;
    await inter.callscriptid(cbdata[0]);
    await inter.runToEnd();
    this.updateInvalidatedComps();
  }
  updateInvalidatedComps() {
    this.touchedComps.forEach((q) => q.updateDom());
    this.touchedComps.clear();
  }
};
function rsInterfaceStyleSheet() {
  let css = "";
  css += `html{color:white;font-size:12px;}
`;
  css += ".rs-component{position:absolute;pointer-events:none;}\n";
  css += ".rs-component--highlight{outline:1px solid red;}\n";
  css += ".rs-image{width:100%;height:100%;}\n";
  css += ".rs-image--cover{background-size:100% 100%; background-repeat:no-repeat;}";
  css += ".rs-interface-container{position:absolute;top:0px;left:0px;right:0px;bottom:0px;display:flex;align-items:center;justify-content:center;}";
  css += ".rs-interface-container-sub{position:relative;outline:1px solid green;}";
  css += ".rs-model{position:absolute;top:0px;left:0px;width:100%;height:100%;}";
  css += ".rs-componentmeta{}";
  css += ".rs-componentmeta--active{outline:1px solid red;}";
  css += ".rs-componentmeta-children{padding-left:15px;}";
  return css;
}
function embeddedjsmodule(comps) {
  let getcomp = (id) => comps[id];
  let click = (event) => {
    console.log(getcomp(+event.target.dataset.compid));
    event.stopPropagation();
  };
  return { getcomp, click };
}
async function loadRsInterfaceData(ctx, id) {
  let arch = await ctx.source.getArchiveById(cacheMajors.interfaces, id);
  let comps = /* @__PURE__ */ new Map();
  for (let sub of arch) {
    try {
      let compid = id << 16 | sub.fileid;
      if (ctx.comps.has(compid)) {
        throw new Error("ui render context already had comp with same id");
      }
      let comp = new RsInterfaceComponent(ctx, parse.interfaces.read(sub.buffer, ctx.source), compid);
      comps.set(sub.fileid, comp);
      ctx.comps.set(compid, comp);
    } catch (e) {
      console.log(`failed to parse interface ${id}:${sub.fileid}`);
    }
  }
  for (let [id2, comp] of comps) {
    if (comp.data.parentid != 65535) {
      let parent = comps.get(comp.data.parentid);
      if (!parent) {
        console.log("missing parent");
        continue;
      }
      parent.children.push(comp);
    }
  }
  let rootcomps = [];
  for (let comp of comps.values()) {
    if (comp.data.parentid == 65535 || !comps.has(comp.data.parentid)) {
      rootcomps.push(comp);
    }
  }
  let basewidth = 520;
  let baseheight = 340;
  return { comps, rootcomps, basewidth, baseheight, id };
}
async function renderRsInterfaceHTML(ctx, id) {
  let { comps, rootcomps, basewidth, baseheight } = await loadRsInterfaceData(ctx, id);
  let html = "";
  for (let comp of rootcomps) {
    html += await comp.toHtml(ctx);
  }
  let doc = `<!DOCTYPE html>
`;
  doc += `<html>
`;
  doc += `<head>
`;
  doc += `<style>
`;
  doc += rsInterfaceStyleSheet();
  doc += `</style>
`;
  doc += "<script>\n";
  doc += `var mod=(${embeddedjsmodule + ""})(${JSON.stringify(Object.fromEntries([...comps].map((q) => [q[0], q[1].data])))});
`;
  doc += "</script>\n";
  doc += `</head>
`;
  doc += `<body>
`;
  doc += `<div class="rs-interface-container">
`;
  doc += `<div style="width:${basewidth}px; height:${baseheight}px;">
`;
  doc += html;
  doc += `</div>
`;
  doc += `</div>
`;
  doc += `</body>
`;
  doc += `</html>
`;
  return doc;
}
function cssColor(col) {
  return `#${(col & 16777215).toString(16).padStart(6, "0")}`;
}
function cssPosition(data) {
  let css = "";
  const defaulttranslate = "0px";
  let translatex = defaulttranslate;
  let translatey = defaulttranslate;
  if (data.aspectxtype == 0) {
    css += `left:${data.baseposx}px;`;
  } else if (data.aspectxtype == 1) {
    css += `left:50%;margin-left:${data.baseposx}px;`;
    translatex = "-50%";
  } else if (data.aspectxtype == 2) {
    css += `right:${data.baseposx}px;`;
  } else if (data.aspectxtype == 3) {
    css += `left:${data.baseposx * 100 / (1 << 14)}%;`;
  } else if (data.aspectxtype == 4) {
    css += `left:${50 + data.baseposx * 100 / (1 << 14)}%;`;
    translatex = "-50%";
  } else if (data.aspectxtype == 5) {
    css += `right:${data.baseposx * 100 / (1 << 14)}%;`;
  }
  if (data.aspectytype == 0) {
    css += `top:${data.baseposy}px;`;
  } else if (data.aspectytype == 1) {
    css += `top:50%;margin-top:${data.baseposy}px;`;
    translatey = "-50%";
  } else if (data.aspectytype == 2) {
    css += `bottom:${data.baseposy}px;`;
  } else if (data.aspectytype == 3) {
    css += `top:${data.baseposy * 100 / (1 << 14)};`;
  } else if (data.aspectytype == 4) {
    css += `top:${50 + data.baseposy * 100 / (1 << 14)}%;`;
    translatey = "-50%";
  } else if (data.aspectytype == 5) {
    css += `bottom:${data.baseposy * 100 / (1 << 14)}%;`;
  }
  if (translatex != defaulttranslate || translatey != defaulttranslate) {
    css += `translate:${translatex} ${translatey};`;
  }
  return css;
}
function cssSize(data) {
  let css = "";
  if (data.aspectwidthtype == 0) {
    css += `width:${data.basewidth}px;`;
  } else if (data.aspectwidthtype == 1) {
    css += `width:calc(100% - ${data.basewidth}px);`;
  } else if (data.aspectwidthtype == 2) {
    css += `width:${data.basewidth * 100 / (1 << 14)}%;`;
  }
  if (data.aspectheighttype == 0) {
    css += `height:${data.baseheight}px;`;
  } else if (data.aspectheighttype == 1) {
    css += `height:calc(100% - ${data.baseheight}px);`;
  } else if (data.aspectheighttype == 2) {
    css += `height:${data.baseheight * 100 / (1 << 14)}%;`;
  }
  return css;
}
function uiModelRenderer(renderer, sceneCache, camdata) {
  let camconfig = {
    rotx: camdata.rotate_x,
    roty: camdata.rotate_y,
    rotz: camdata.rotate_z,
    translatex: camdata.translate_x / 4,
    translatey: camdata.translate_y / 4,
    zoom: camdata.zoom * 8
  };
  let canvas = document.createElement("canvas");
  canvas.classList.add("rs-model");
  let modelrender = renderer.makeUIRenderer();
  let model = null;
  let setmodel = (modelid) => {
    model = new RSModel(sceneCache, [{ modelid, mods: {} }], `model_${modelid}`);
    modelrender.setmodel(model.getSceneElements(), 0);
    model.model.then(render);
  };
  let render = () => {
    let width = canvas.clientWidth;
    let height = canvas.clientHeight;
    if (width == 0 || height == 0) {
      return;
    }
    let img = modelrender.takePicture(width, height, camconfig);
    canvas.width = img.width;
    canvas.height = img.height;
    let ctx2d = canvas.getContext("2d");
    ctx2d.putImageData(img, 0, 0);
    if (animated && !animcb) {
      requestAnimationFrame(render);
    }
  };
  let animcb = 0;
  let animated = false;
  let setanim = (animid) => {
    if (animid == 32767 || animid == 65535) {
      animid = -1;
    }
    model?.setAnimation(animid);
    animated = animid != -1;
    render();
  };
  let observer = new ResizeObserver(render);
  observer.observe(canvas);
  let dispose = () => {
    cancelAnimationFrame(animcb);
    animcb = 0;
    observer.disconnect();
    modelrender.dispose();
    canvas.remove();
  };
  canvas.render = render;
  return { dispose, canvas, setmodel, setanim };
}
function spriteCss(spritedata) {
  let imgstyle = "";
  if (spritedata.hflip || spritedata.vflip) {
    imgstyle += `scale:${spritedata.hflip ? -1 : 1} ${spritedata.vflip ? -1 : 1};`;
  }
  if (spritedata.rotation != 0) {
    imgstyle += `rotate:${(-spritedata.rotation / 65536 * 360).toFixed(2)}deg;`;
  }
  if ((spritedata.color & 16777215) != 16777215) {
    imgstyle += `background-color:${cssColor(spritedata.color)};background-blend-mode:multiply;`;
  }
  return imgstyle;
}
async function spritePromise(ctx, spriteid) {
  let imgcss = "none";
  let actualid = spriteid & 16777215;
  if (actualid != 16777215) {
    let flags = spriteid >> 24;
    if (flags != 0) {
      console.log("sprite flags", flags);
    }
    let spritebuf = await ctx.source.getFileById(cacheMajors.sprites, actualid);
    let img = expandSprite(parseSprite(spritebuf)[0]);
    let pngfile = await pixelsToDataUrl(img);
    imgcss = `url('${pngfile}')`;
  }
  return { imgcss, spriteid };
}
var RsInterfaceComponent = class {
  constructor(ctx, interfacedata, compid) {
    this.parent = null;
    this.children = [];
    this.clientChildren = [];
    this.modelrenderer = null;
    this.spriteChild = null;
    this.textChild = null;
    this.loadingSprite = -1;
    this.element = null;
    this.ctx = ctx;
    this.data = interfacedata;
    this.compid = compid;
    this.api = new CS2Api(this);
  }
  isCompType(type) {
    if (type == "container" && !this.data.containerdata) {
      return false;
    }
    if (type == "model" && !this.data.modeldata) {
      return false;
    }
    if (type == "sprite" && !this.data.spritedata) {
      return false;
    }
    if (type == "text" && !this.data.textdata) {
      return false;
    }
    if (type == "figure" && !this.data.figuredata) {
      return false;
    }
    return true;
  }
  async toHtml(ctx) {
    let { style, title } = this.getStyle();
    let childhtml = "";
    for (let child of this.children) {
      childhtml += await child.toHtml(ctx);
    }
    if (this.data.textdata) {
      childhtml += rsmarkupToSafeHtml(this.data.textdata.text);
    }
    if (this.data.modeldata) {
      let isplaceholder = this.data.modeldata.modelid == 32767 || this.data.modeldata.modelid == 65535;
      style += "background:rgba(0,255,0,0.5);outline:blue;";
      childhtml += isplaceholder ? "placeholder" : this.data.modeldata.modelid;
    }
    if (this.data.spritedata) {
      let spritecss = spriteCss(this.data.spritedata);
      let sprite = await spritePromise(ctx, this.data.spritedata.spriteid);
      spritecss += `background-image:${sprite.imgcss};`;
      childhtml += `<div class="rs-image${!this.data.spritedata.tiling ? " rs-image--cover" : ""}" style="${escapeHTML(spritecss)}"></div>`;
    }
    let html = "";
    html += `<div class="rs-component" data-compid=${this.compid} style="${escapeHTML(style)}" onclick="mod.click(event)" title="${escapeHTML(title)}">
`;
    html += childhtml;
    html += "</div>\n";
    return html;
  }
  dispose() {
    this.ctx.comps.delete(this.compid);
    this.modelrenderer?.dispose();
    this.element?.remove();
    this.children.forEach((q) => q.dispose());
    this.clientChildren.forEach((q) => q.dispose());
  }
  initDom() {
    this.element ??= document.createElement("div");
    this.updateDom();
    this.children.forEach((child) => {
      this.element.appendChild(child.initDom());
    });
    this.clientChildren.forEach((child) => {
      this.element.appendChild(child.initDom());
    });
    this.element.classList.add("rs-component");
    this.element.ui = this.data;
    this.element.compid = this.compid;
    return this.element;
  }
  updateDom() {
    if (!this.element) {
      throw new Error("element not set");
    }
    let { style, title } = this.getStyle();
    if (this.data.modeldata) {
      let isplaceholder = this.data.modeldata.modelid == 32767 || this.data.modeldata.modelid == 65535;
      if (!isplaceholder && this.ctx.renderer && this.ctx.sceneCache) {
        this.modelrenderer ??= uiModelRenderer(this.ctx.renderer, this.ctx.sceneCache, this.data.modeldata.positiondata);
        this.modelrenderer.setmodel(this.data.modeldata.modelid);
        this.modelrenderer.setanim(this.data.modeldata.animid);
        this.element.appendChild(this.modelrenderer.canvas);
      } else if (this.modelrenderer) {
        this.modelrenderer.dispose();
        this.modelrenderer = null;
        style += "background:rgba(0,255,0,0.5);outline:blue;";
        this.element.innerText = isplaceholder ? "placeholder" : "";
      }
    }
    if (this.data.textdata) {
      if (!this.textChild) {
        this.textChild = document.createElement("span");
        this.element.appendChild(this.textChild);
      }
      this.textChild.innerHTML = rsmarkupToSafeHtml(this.data.textdata.text);
    } else if (this.textChild) {
      this.textChild.remove();
      this.textChild = null;
    }
    if (this.data.spritedata) {
      if (this.loadingSprite != this.data.spritedata.spriteid) {
        if (!this.spriteChild) {
          this.spriteChild = document.createElement("div");
          this.element.appendChild(this.spriteChild);
          this.spriteChild.classList.add("rs-image");
        }
        this.spriteChild.style.cssText = spriteCss(this.data.spritedata);
        this.spriteChild.classList.toggle("rs-image--cover", !this.data.spritedata.tiling);
        spritePromise(this.ctx, this.data.spritedata.spriteid).then(({ imgcss, spriteid }) => {
          if (this.spriteChild && spriteid == this.data.spritedata?.spriteid) {
            this.spriteChild.style.backgroundImage = imgcss;
          }
        });
        this.loadingSprite = this.data.spritedata.spriteid;
      }
    } else if (this.spriteChild) {
      this.spriteChild.remove();
      this.spriteChild = null;
    }
    this.element.style.cssText = style;
    this.element.title = title;
  }
  getStyle() {
    let style = "";
    let childhtml = "";
    style += cssPosition(this.data);
    style += cssSize(this.data);
    let clickable = false;
    if (this.data.figuredata) {
      if (this.data.figuredata.filled) {
        style += `background:${cssColor(this.data.figuredata.color)};`;
        clickable = true;
      } else {
        style += `border:1px solid ${cssColor(this.data.figuredata.color)};`;
      }
    } else if (this.data.textdata) {
      clickable = true;
      style += "display:flex;";
      style += `color:${cssColor(this.data.textdata.color)};`;
      if (this.data.textdata.alignhor == 1) {
        style += `justify-content:center;`;
        style += `text-align:center;`;
      } else if (this.data.textdata.alignhor) {
        style += `justify-content:right;`;
        style += `text-align:right;`;
      }
      if (this.data.textdata.alignver == 1) {
        style += `align-items:center;`;
      } else if (this.data.textdata.alignver) {
        style += `align-items:bottom;`;
      }
      clickable = true;
    } else if (this.data.containerdata) {
    } else if (this.data.spritedata) {
    } else if (this.data.modeldata) {
      clickable = true;
    } else {
      style += "background:rgba(0,128,128,0.5);outline:red;";
      clickable = true;
    }
    if (clickable) {
      style += "pointer-events:initial;";
    }
    let title = this.data.rightclickopts.filter((q) => q).join("\n");
    return { title, style };
  }
};
var CS2Api = class _CS2Api {
  constructor(comp) {
    this.data = comp?.data ?? null;
    this.comp = comp;
  }
  changed() {
    this.comp?.ctx.touchedComps.add(this.comp);
  }
  findChild(ccid) {
    if (ccid == MAGIC_CONST_IF_AS_CC) {
      return this;
    }
    return this.comp?.clientChildren.find((q) => q.compid == ccid)?.api;
  }
  getNextChildId() {
    if (!this.comp) {
      return 0;
    }
    let max = this.comp.clientChildren.reduce((a, v) => Math.max(a, v.compid), -1);
    return max + 1;
  }
  createChild(ccid, type) {
    let data = {
      type,
      aspectxtype: 0,
      aspectytype: 0,
      aspectwidthtype: 0,
      aspectheighttype: 0,
      basewidth: 0,
      baseheight: 0,
      baseposx: 0,
      baseposy: 0,
      bit4data: 0,
      containerdata: null,
      spritedata: null,
      modeldata: null,
      figuredata: null,
      textdata: null,
      linedata: null,
      contenttype: -1,
      cursor: -1,
      hidden: 0,
      menucounts: 0,
      name: null,
      name2: "",
      optmask: 0,
      optmask1data_bit40: null,
      parentid: this.comp?.compid ?? -1,
      rightclickcursors: [],
      rightclickopts: [],
      scripts: {},
      unkdata: null,
      unk10data: null,
      unk11data: null,
      unk12data: null,
      unk15data: null,
      unk16data: null,
      unk2: 0,
      unk3: [],
      unk4: 0,
      unk5: 0,
      unk6: 0,
      unkdatadata: null,
      unkffff: null,
      unkpre3: null,
      unkprepre3: null,
      unkstring1: null,
      unkstuff123: "",
      version: 7
    };
    if (type == 0) {
      data.containerdata = {
        layerwidth: 0,
        layerheight: 0,
        disablehover: null,
        layerheightextra: null,
        v6unk1: null,
        v6unk2: null
      };
    } else if (type == 3) {
      data.figuredata = {
        color: 0,
        filled: 0,
        trans: 0
      };
    } else if (type == 4) {
      data.textdata = {
        alignhor: 0,
        alignver: 0,
        color: 0,
        fontid: 0,
        multiline: null,
        shadow: false,
        text: "",
        trans: 0,
        unk1: 0,
        unk2: 0
      };
    } else if (type == 5) {
      data.spritedata = {
        spriteid: -1,
        aspectheightdata: 0,
        aspectwidthdata: 0,
        borderthickness: 0,
        clickmask: null,
        color: 16777215,
        tiling: 0,
        hflip: false,
        vflip: false,
        transparency: 0,
        rotation: 0,
        unk2: 0,
        v6unk: 0
      };
    } else if (type == 6) {
      data.modeldata = {
        modelid: -1,
        animid: -1,
        aspectheightdata: 0,
        aspectwidthdata: 0,
        mode: 0,
        positiondata: {
          rotate_x: 0,
          rotate_y: 0,
          rotate_z: 0,
          translate_x: 0,
          translate_y: 0,
          unkextra: null,
          zoom: 0
        },
        unkdata: null
      };
    } else {
      console.log(`creating unknown cc type, type=${type}, id=${ccid}`);
    }
    let api;
    if (this.comp) {
      let child = new RsInterfaceComponent(this.comp.ctx, data, ccid);
      this.comp.clientChildren.push(child);
      this.changed();
      child.api.changed();
      if (this.comp?.element) {
        this.comp.initDom();
      }
      api = child.api;
    } else {
      api = new _CS2Api(null);
    }
    return api;
  }
  setSize(w, h, modew, modeh) {
    if (this.data) {
      this.data.basewidth = w;
      this.data.baseheight = h;
      this.data.aspectwidthtype = modew;
      this.data.aspectheighttype = modeh;
    }
    this.changed();
  }
  setPosition(x, y, modex, modey) {
    if (this.data) {
      this.data.baseposx = x;
      this.data.baseposy = y;
      this.data.aspectxtype = modex;
      this.data.aspectytype = modey;
    }
    this.changed();
  }
  setHide(hide) {
    this.data && (this.data.hidden = hide);
  }
  setWidth(w) {
    this.data && (this.data.basewidth = w);
  }
  setHeight(h) {
    this.data && (this.data.basewidth = h);
  }
  setX(x) {
    this.data && (this.data.baseposx = x);
  }
  setY(y) {
    this.data && (this.data.baseposy = y);
  }
  getHide() {
    return this.data?.hidden ?? 0;
  }
  getWidth() {
    return this.data?.basewidth ?? 0;
  }
  getHeight() {
    return this.data?.baseheight ?? 0;
  }
  getX() {
    return this.data?.baseposx ?? 0;
  }
  getY() {
    return this.data?.baseposy ?? 0;
  }
  setOp(index, text) {
    console.log(`setop ${this.comp?.compid ?? -1} ${index} ${text}`);
  }
  //TODO
  getOp(index) {
    return this.data?.rightclickopts[index] ?? "";
  }
  //text
  setText(text) {
    if (this.data?.textdata) {
      this.data.textdata.text = text;
    }
  }
  getText() {
    return this.data?.textdata?.text ?? "";
  }
  setTextAlign(a, b, c) {
    this.data?.textdata && (this.data.textdata.alignhor = c, this.data.textdata.alignver = b, this.data.textdata.multiline = a | 0);
  }
  getTextAlign() {
    return [this.data?.textdata?.alignhor ?? 0, this.data?.textdata?.alignver ?? 0, this.data?.textdata?.multiline ?? 0];
  }
  //sprite
  getGraphic() {
    return this.data?.spritedata?.spriteid ?? -1;
  }
  getHFlip() {
    return this.data?.spritedata?.hflip ?? false;
  }
  getVFlip() {
    return this.data?.spritedata?.vflip ?? false;
  }
  getTiling() {
    return this.data?.spritedata?.tiling ?? 0;
  }
  getRotation() {
    return this.data?.spritedata?.rotation ?? 0;
  }
  setGraphic(sprite) {
    this.data?.spritedata && (this.data.spritedata.spriteid = sprite);
    this.changed();
  }
  setHFlip(flip) {
    this.data?.spritedata && (this.data.spritedata.hflip = flip);
    this.changed();
  }
  setVFlip(flip) {
    this.data?.spritedata && (this.data.spritedata.vflip = flip);
    this.changed();
  }
  setTiling(tiling) {
    this.data?.spritedata && (this.data.spritedata.tiling = tiling);
    this.changed();
  }
  setRotation(rot) {
    this.data?.spritedata && (this.data.spritedata.rotation = rot);
    this.changed();
  }
  //model
  setModel(id) {
    this.data?.modeldata && (this.data.modeldata.modelid = id);
    this.changed();
  }
  getModel() {
    return this.data?.modeldata?.modelid ?? -1;
  }
  //figure
  getTrans() {
    return this.data?.figuredata?.trans ?? 0;
  }
  setTrans(trans) {
    this.data?.figuredata && (this.data.figuredata.trans = trans);
    this.changed();
  }
  getFilled() {
    return this.data?.figuredata?.filled ?? 0;
  }
  setFilled(filled) {
    this.data?.figuredata && (this.data.figuredata.filled = filled);
    this.changed();
  }
  getColor() {
    return this.data?.figuredata?.color ?? 0;
  }
  setColor(col) {
    this.data?.figuredata && (this.data.figuredata.color = col);
    this.changed();
  }
};

// rsmv/src/scripts/filetypes.ts
async function filerange(source, startindex, endindex) {
  if (startindex.major != endindex.major) {
    throw new Error("range must span one major");
  }
  let files = [];
  if (source.getBuildNr() <= lastLegacyBuildnr) {
    let itercount = 0;
    for (let minor = startindex.minor; minor <= endindex.minor; minor++) {
      if (itercount++ > 1e3) {
        break;
      }
      try {
        let group = [];
        group = await source.getArchiveById(startindex.major, minor);
        let groupindex = {
          major: startindex.major,
          minor,
          crc: 0,
          name: null,
          subindexcount: group.length,
          subindices: group.map((q) => q.fileid),
          subnames: group.map((q) => q.fileid),
          version: 0
        };
        for (let sub of group) {
          if (sub.fileid >= startindex.subid && sub.fileid <= endindex.subid) {
            files.push({
              index: groupindex,
              subindex: sub.fileid
            });
          }
        }
      } catch {
      }
    }
  } else {
    let indexfile = await source.getCacheIndex(startindex.major);
    for (let index of indexfile) {
      if (!index) {
        continue;
      }
      if (index.minor >= startindex.minor && index.minor <= endindex.minor) {
        for (let fileindex = 0; fileindex < index.subindices.length; fileindex++) {
          let subfileid = index.subindices[fileindex];
          if (index.minor == startindex.minor && subfileid < startindex.subid) {
            continue;
          }
          if (index.minor == endindex.minor && subfileid > endindex.subid) {
            continue;
          }
          files.push({ index, subindex: fileindex });
        }
      }
    }
  }
  return files;
}
var throwOnNonSimple = {
  prepareDump() {
  },
  prepareWrite() {
  },
  write(b) {
    throw new Error("write not supported");
  },
  combineSubs(b) {
    throw new Error("not supported");
  }
};
function oldWorldmapIndex(key) {
  return {
    major: cacheMajors.mapsquares,
    minor: void 0,
    logicalDimensions: 2,
    usesArchieves: false,
    fileToLogical(source, major, minor, subfile) {
      return [255, minor];
    },
    logicalToFile(source, id) {
      throw new Error("not implemented");
    },
    async logicalRangeToFiles(source, start, end) {
      let index = await source.getCacheIndex(cacheMajors.mapsquares);
      let res = [];
      for (let x = start[0]; x <= Math.min(end[0], 100); x++) {
        for (let z = start[1]; z <= Math.min(end[1], 200); z++) {
          let namehash = cacheFilenameHash(`${key}${x}_${z}`, source.getBuildNr() <= lastLegacyBuildnr);
          let file = index.find((q) => q.name == namehash);
          if (file) {
            res.push({ index: file, subindex: 0 });
          }
        }
      }
      return res;
    }
  };
}
function worldmapIndex(subfile) {
  const major = cacheMajors.mapsquares;
  const worldStride2 = 128;
  return {
    major,
    minor: void 0,
    logicalDimensions: 2,
    usesArchieves: true,
    fileToLogical(source, major2, minor, subfile2) {
      return [minor % worldStride2, Math.floor(minor / worldStride2)];
    },
    logicalToFile(source, id) {
      return { major, minor: id[0] + id[1] * worldStride2, subid: subfile };
    },
    async logicalRangeToFiles(source, start, end) {
      let indexfile = await source.getCacheIndex(major);
      let files = [];
      for (let index of indexfile) {
        if (!index) {
          continue;
        }
        let x = index.minor % worldStride2;
        let z = Math.floor(index.minor / worldStride2);
        if (x >= start[0] && x <= end[0] && z >= start[1] && z <= end[1]) {
          for (let fileindex = 0; fileindex < index.subindices.length; fileindex++) {
            let subfileid = index.subindices[fileindex];
            if (subfileid == subfile) {
              files.push({ index, subindex: fileindex });
            }
          }
        }
      }
      return files;
    }
  };
}
function singleMinorIndex(major, minor) {
  return {
    major,
    minor,
    logicalDimensions: 1,
    usesArchieves: true,
    fileToLogical(source, major2, minor2, subfile) {
      return [subfile];
    },
    logicalToFile(source, id) {
      return { major, minor, subid: id[0] };
    },
    async logicalRangeToFiles(source, start, end) {
      return filerange(source, { major, minor, subid: start[0] }, { major, minor, subid: end[0] });
    }
  };
}
function chunkedIndex(major) {
  return {
    major,
    minor: void 0,
    logicalDimensions: 1,
    usesArchieves: true,
    fileToLogical(source, major2, minor, subfile) {
      return [archiveToFileId(major2, minor, subfile)];
    },
    logicalToFile(source, id) {
      return fileIdToArchiveminor(major, id[0], source.getBuildNr());
    },
    async logicalRangeToFiles(source, start, end) {
      let startindex = fileIdToArchiveminor(major, start[0], source.getBuildNr());
      let endindex = fileIdToArchiveminor(major, end[0], source.getBuildNr());
      return filerange(source, startindex, endindex);
    }
  };
}
function anyFileIndex() {
  return {
    major: void 0,
    minor: void 0,
    logicalDimensions: 3,
    usesArchieves: true,
    fileToLogical(source, major, minor, subfile) {
      return [major, minor, subfile];
    },
    logicalToFile(source, id) {
      return { major: id[0], minor: id[1], subid: id[2] };
    },
    async logicalRangeToFiles(source, start, end) {
      if (start[0] != end[0]) {
        throw new Error("can only do one major at a time");
      }
      let major = start[0];
      return filerange(source, { major, minor: start[1], subid: start[2] }, { major, minor: end[1], subid: end[2] });
    }
  };
}
function noArchiveIndex(major) {
  return {
    major,
    minor: void 0,
    logicalDimensions: 1,
    usesArchieves: false,
    fileToLogical(source, major2, minor, subfile) {
      if (subfile != 0) {
        throw new Error("nonzero subfile in noarch index");
      }
      return [minor];
    },
    logicalToFile(source, id) {
      return { major, minor: id[0], subid: 0 };
    },
    async logicalRangeToFiles(source, start, end) {
      return filerange(source, { major, minor: start[0], subid: 0 }, { major, minor: end[0], subid: 0 });
    }
  };
}
function standardIndex(major) {
  return {
    major,
    minor: void 0,
    logicalDimensions: 2,
    usesArchieves: true,
    fileToLogical(source, major2, minor, subfile) {
      return [minor, subfile];
    },
    logicalToFile(source, id) {
      return { major, minor: id[0], subid: id[1] };
    },
    async logicalRangeToFiles(source, start, end) {
      return filerange(source, { major, minor: start[0], subid: start[1] }, { major, minor: end[0], subid: end[1] });
    }
  };
}
function blacklistIndex(parent, blacklist) {
  return {
    ...parent,
    async logicalRangeToFiles(source, start, end) {
      let res = await parent.logicalRangeToFiles(source, start, end);
      return res.filter((q) => !blacklist.some((w) => w.major == q.index.major && w.minor == q.index.minor));
    }
  };
}
function indexfileIndex() {
  return {
    major: cacheMajors.index,
    minor: void 0,
    logicalDimensions: 1,
    usesArchieves: false,
    fileToLogical(source, major, minor, subfile) {
      return [minor];
    },
    logicalToFile(source, id) {
      return { major: cacheMajors.index, minor: id[0], subid: 0 };
    },
    async logicalRangeToFiles(source, start, end) {
      let indices = await source.getCacheIndex(cacheMajors.index);
      return indices.filter((index) => index && index.minor >= start[0] && index.minor <= end[0]).map((index) => ({ index, subindex: 0 }));
    }
  };
}
function rootindexfileIndex() {
  return {
    major: cacheMajors.index,
    minor: 255,
    logicalDimensions: 0,
    usesArchieves: false,
    fileToLogical(source, major, minor, subfile) {
      return [];
    },
    logicalToFile(source, id) {
      return { major: cacheMajors.index, minor: 255, subid: 0 };
    },
    async logicalRangeToFiles(source, start, end) {
      return [
        { index: { major: 255, minor: 255, crc: 0, size: 0, version: 0, name: null, subindexcount: 1, subindices: [0], subnames: null }, subindex: 0 }
      ];
    }
  };
}
function standardFile(parser, lookup, prepareDump, prepareParser) {
  let constr = (args) => {
    let singleschemaurl = "";
    let batchschemaurl = "";
    return {
      ...lookup,
      ext: "json",
      parser,
      async prepareDump(output, source) {
        await prepareParser?.(source);
        await prepareDump?.(source);
        let name = Object.entries(cacheFileDecodeModes).find((q) => q[1] == constr);
        if (!name) {
          throw new Error();
        }
        let schema = parser.parser.getJsonSchema();
        if (args.batched == "true") {
          let batchschema = {
            type: "object",
            properties: {
              files: { type: "array", items: schema }
            }
          };
          let relurl = `.schema-${name[0]}_batch.json`;
          output.writeFile(relurl, prettyJson2(batchschema));
          batchschemaurl = relurl;
        } else {
          let relurl = `.schema-${name[0]}.json`;
          output.writeFile(relurl, prettyJson2(schema));
          singleschemaurl = relurl;
        }
      },
      prepareWrite(source) {
        return prepareParser?.(source);
      },
      read(b, id, source) {
        let obj = parser.read(b, source, { keepbuffers: args.keepbuffers });
        if (args.batched) {
          obj.$fileid = id.length == 1 ? id[0] : id;
        } else {
          obj.$schema = singleschemaurl;
        }
        return prettyJson2(obj);
      },
      write(b, id, source) {
        return parser.write(JSON.parse(b.toString("utf8")), source.getDecodeArgs());
      },
      combineSubs(b) {
        return `{"$schema":"${batchschemaurl}","files":[

${b.join("\n,\n\n")}]}`;
      },
      description: "View the JSON representation of a file",
      flagtemplate: {
        keepbuffers: { text: "Keep binary buffers (can be very large)", type: "boolean" }
      }
    };
  };
  return constr;
}
var decodeBinary = () => {
  return {
    ...anyFileIndex(),
    ext: "bin",
    prepareDump() {
    },
    prepareWrite() {
    },
    read(b) {
      return b;
    },
    write(b) {
      return b;
    },
    combineSubs(b) {
      return Buffer.concat(b);
    },
    description: "Outputs the raw files as they are in the cache"
  };
};
var decodeMusic = () => {
  return {
    ext: "ogg",
    major: cacheMajors.music,
    minor: void 0,
    logicalDimensions: 1,
    usesArchieves: false,
    fileToLogical(source, major, minor, subfile) {
      return [minor];
    },
    logicalToFile(source, id) {
      return { major: cacheMajors.music, minor: id[0], subid: 0 };
    },
    async logicalRangeToFiles(source, start, end) {
      let enumfile = await source.getFileById(cacheMajors.enums, 1351);
      let enumdata = parse.enums.read(enumfile, source);
      let indexfile = await source.getCacheIndex(cacheMajors.music);
      return enumdata.intArrayValue2.values.filter((q) => q[1] >= start[0] && q[1] <= end[0]).sort((a, b) => a[1] - b[1]).filter((q, i, arr) => i == 0 || arr[i - 1][1] != q[1]).map((q) => ({ index: indexfile[q[1]], subindex: 0 }));
    },
    ...throwOnNonSimple,
    read(buf, fileid, source) {
      return parseMusic(source, cacheMajors.music, fileid[0], buf, true);
    },
    description: "Stitches child music fragments onto header fragments, only a small number of music fragments are header fragments, ids that lead to child fragments are ignored."
  };
};
var decodeSound = (major, allowdownload) => () => {
  return {
    ext: "ogg",
    ...noArchiveIndex(major),
    ...throwOnNonSimple,
    read(buf, fileid, source) {
      return parseMusic(source, major, fileid[0], buf, allowdownload);
    },
    description: "Extracts sound files from cache"
  };
};
var decodeCutscene = () => {
  return {
    ext: "html",
    ...noArchiveIndex(cacheMajors.cutscenes),
    ...throwOnNonSimple,
    async read(buf, fileid, source) {
      let res = await renderCutscene(source, buf);
      return res.doc;
    },
    description: "Decodes and assembles 2d vector cutscenes (first added in 2023). These cutscenes are saved in cache without image compression so take a while to decode. Sounds effects might be missing if you use a local game cache since the game normally only downloads them on demand."
  };
};
var decodeInterface = () => {
  return {
    ext: "html",
    major: cacheMajors.interfaces,
    minor: void 0,
    logicalDimensions: 1,
    usesArchieves: true,
    fileToLogical(source, major, minor, subfile) {
      if (subfile != 0) {
        throw new Error("subfile 0 expected");
      }
      return [minor];
    },
    logicalToFile(source, id) {
      return { major: cacheMajors.interfaces, minor: id[0], subid: 0 };
    },
    async logicalRangeToFiles(source, start, end) {
      let indexfile = await source.getCacheIndex(cacheMajors.interfaces);
      return indexfile.filter((q) => q && q.minor >= start[0] && q.minor <= end[0]).map((q) => ({ index: q, subindex: 0 }));
    },
    ...throwOnNonSimple,
    async read(buf, fileid, source) {
      let res = await renderRsInterfaceHTML(new UiRenderContext2(source), fileid[0]);
      return res;
    },
    description: "Extracts an interface and converts the template to a html file. Model and scripts will be missing and therefore the result might be incomplete."
  };
};
var decodeInterface2 = () => {
  return {
    ext: "ui.json",
    major: cacheMajors.interfaces,
    minor: void 0,
    logicalDimensions: 1,
    usesArchieves: true,
    fileToLogical(source, major, minor, subfile) {
      if (subfile != 0) {
        throw new Error("subfile 0 expected");
      }
      return [minor];
    },
    logicalToFile(source, id) {
      return { major: cacheMajors.interfaces, minor: id[0], subid: 0 };
    },
    async logicalRangeToFiles(source, start, end) {
      let indexfile = await source.getCacheIndex(cacheMajors.interfaces);
      return indexfile.filter((q) => q && q.minor >= start[0] && q.minor <= end[0]).map((q) => ({ index: q, subindex: 0 }));
    },
    ...throwOnNonSimple,
    async read(buf, fileid, source) {
      return JSON.stringify({ id: fileid[0] });
    },
    description: "Doesn't extract anything but invokes the built-in RSMV interface viewer."
  };
};
var decodeClientScript = (ops) => {
  return {
    ext: "ts",
    ...noArchiveIndex(cacheMajors.clientscript),
    ...throwOnNonSimple,
    async prepareDump(out, source) {
      let calli = await prepareClientScript(source);
      out.writeFile("tsconfig.json", JSON.stringify({ "compilerOptions": { "lib": [], "target": "ESNext" } }, void 0, "	"));
      out.writeFile("opcodes.d.ts", writeOpcodeFile(calli));
      out.writeFile("clientvars.d.ts", writeClientVarFile(calli));
    },
    read(buf, fileid, source) {
      return renderClientScript(source, buf, fileid[0], ops.cs2relativecomps == "true", ops.cs2notypes == "true", ops.cs2intcasts == "true");
    },
    async write(file, fileid, source) {
      let obj = await compileClientScript(source, file.toString("utf8"));
      let res = parse.clientscript.write(obj, source.getDecodeArgs());
      return res;
    },
    description: "Extracts clientscript VM code (cs2) and converts it to something that is typescript-compatible.",
    flagtemplate: {
      cs2relativecomps: { text: "Hide subcomponent ids (can't be compiled, but offers stable diffing)", type: "boolean" },
      cs2notypes: { text: "Don't output TS types (can't be compiled)", type: "boolean" },
      cs2intcasts: { text: "Explicit JS int32 casts during math (can't be compiled)", type: "boolean" }
    }
  };
};
var decodeClientScriptViewer = () => {
  return {
    ext: "cs2.json",
    ...noArchiveIndex(cacheMajors.clientscript),
    ...throwOnNonSimple,
    async prepareDump(fs7, source) {
      await prepareClientScript(source);
    },
    read(buf, fileid, source) {
      return JSON.stringify(parse.clientscript.read(buf, source));
    },
    description: "Basic implementation of the clientscript VM (cs2). Can be used to debug programs and step through code."
  };
};
var decodeOldProcTexture = () => {
  return {
    ext: "png",
    ...singleMinorIndex(cacheMajors.texturesOldPng, 0),
    ...throwOnNonSimple,
    async read(b, id, source) {
      let obj = parse.oldproctexture.read(b, source);
      let spritefile = await source.getFileById(cacheMajors.sprites, obj.spriteid);
      let sprites = parseSprite(spritefile);
      if (sprites.length != 1) {
        throw new Error("exactly one subsprite expected");
      }
      return pixelsToImageFile(sprites[0].img, "png", 1);
    },
    description: "Procedural textures are highly compressed textures used in early rshd."
  };
};
var decodeLegacySprite = (minor) => () => {
  return {
    ext: "png",
    ...singleMinorIndex(legacyMajors.data, minor),
    ...throwOnNonSimple,
    async read(b, id, source) {
      let metafile = await source.findSubfileByName(legacyMajors.data, minor, "INDEX.DAT");
      let img = parseLegacySprite(metafile.buffer, b);
      return pixelsToImageFile(img.img, "png", 1);
    },
    description: "Textures from the 'legacy' era, very early rs2"
  };
};
var decodeSprite = (major) => () => {
  return {
    ext: "png",
    ...noArchiveIndex(major),
    ...throwOnNonSimple,
    read(b, id) {
      return pixelsToImageFile(parseSprite(b)[0].img, "png", 1);
    },
    description: "Sprites are all images that are used in ui. The client stores sprites are uncompressed bitmaps. Currently only the first frame for multi-frame sprites is extracted."
  };
};
var decodeTexture = (major) => () => {
  return {
    ext: "png",
    ...noArchiveIndex(major),
    prepareDump() {
    },
    prepareWrite() {
    },
    read(b, id) {
      let p = new ParsedTexture(b, false, true);
      return p.toImageData().then((q) => pixelsToImageFile(q, "png", 1));
    },
    write(b) {
      throw new Error("write not supported");
    },
    combineSubs(b) {
      if (b.length != 1) {
        throw new Error("not supported");
      }
      return b[0];
    },
    description: "Textures are images that are wrapped around models to display colors are fine details."
  };
};
var decodeSpriteHash = () => {
  return {
    ext: "json",
    ...noArchiveIndex(cacheMajors.sprites),
    ...throwOnNonSimple,
    async read(b, id) {
      let images = parseSprite(b);
      let str = "";
      for (let [sub, img] of images.entries()) {
        const data = img.img.data;
        for (let i = 0; i < data.length; i += 4) {
          if (data[i + 2] == 0) {
            data[i + 2] = 1;
          }
        }
        let hash = crc32(img.img.data);
        str += (str == "" ? "" : ",") + `{"id":${id[0]},"sub":${sub},"hash":${hash}}`;
      }
      return str;
    },
    combineSubs(b) {
      return "[" + b.join(",\n") + "]";
    },
    description: "Used to efficiently compare images."
  };
};
var decodeMeshHash = () => {
  return {
    ext: "json",
    ...noArchiveIndex(cacheMajors.models),
    ...throwOnNonSimple,
    read(b, id, source) {
      let model = parse.models.read(b, source);
      let meshhashes = getModelHashes(model, id[0]);
      return JSON.stringify(meshhashes);
    },
    combineSubs(b) {
      return "[" + b.filter((q) => q).join(",\n") + "]";
    },
    description: "Used to efficiently compare models."
  };
};
var cacheFileJsonModes = constrainedMap()({
  framemaps: { parser: parse.framemaps, lookup: chunkedIndex(cacheMajors.framemaps) },
  items: { parser: parse.item, lookup: chunkedIndex(cacheMajors.items) },
  enums: { parser: parse.enums, lookup: chunkedIndex(cacheMajors.enums) },
  npcs: { parser: parse.npc, lookup: chunkedIndex(cacheMajors.npcs) },
  soundjson: { parser: parse.audio, lookup: blacklistIndex(standardIndex(cacheMajors.sounds), [{ major: cacheMajors.sounds, minor: 0 }]) },
  musicjson: { parser: parse.audio, lookup: blacklistIndex(standardIndex(cacheMajors.music), [{ major: cacheMajors.music, minor: 0 }]) },
  objects: { parser: parse.object, lookup: chunkedIndex(cacheMajors.objects) },
  achievements: { parser: parse.achievement, lookup: chunkedIndex(cacheMajors.achievements) },
  structs: { parser: parse.structs, lookup: chunkedIndex(cacheMajors.structs) },
  sequences: { parser: parse.sequences, lookup: chunkedIndex(cacheMajors.sequences) },
  spotanims: { parser: parse.spotAnims, lookup: chunkedIndex(cacheMajors.spotanims) },
  materials: { parser: parse.materials, lookup: chunkedIndex(cacheMajors.materials) },
  oldmaterials: { parser: parse.oldmaterials, lookup: singleMinorIndex(cacheMajors.materials, 0) },
  quickchatcats: { parser: parse.quickchatCategories, lookup: singleMinorIndex(cacheMajors.quickchat, 0) },
  quickchatlines: { parser: parse.quickchatLines, lookup: singleMinorIndex(cacheMajors.quickchat, 1) },
  dbtables: { parser: parse.dbtables, lookup: singleMinorIndex(cacheMajors.config, cacheConfigPages.dbtables) },
  dbrows: { parser: parse.dbrows, lookup: singleMinorIndex(cacheMajors.config, cacheConfigPages.dbrows) },
  overlays: { parser: parse.mapsquareOverlays, lookup: singleMinorIndex(cacheMajors.config, cacheConfigPages.mapoverlays) },
  identitykit: { parser: parse.identitykit, lookup: singleMinorIndex(cacheMajors.config, cacheConfigPages.identityKit) },
  params: { parser: parse.params, lookup: singleMinorIndex(cacheMajors.config, cacheConfigPages.params) },
  underlays: { parser: parse.mapsquareUnderlays, lookup: singleMinorIndex(cacheMajors.config, cacheConfigPages.mapunderlays) },
  mapscenes: { parser: parse.mapscenes, lookup: singleMinorIndex(cacheMajors.config, cacheConfigPages.mapscenes) },
  environments: { parser: parse.environments, lookup: singleMinorIndex(cacheMajors.config, cacheConfigPages.environments) },
  animgroupconfigs: { parser: parse.animgroupConfigs, lookup: singleMinorIndex(cacheMajors.config, cacheConfigPages.animgroups) },
  maplabels: { parser: parse.maplabels, lookup: singleMinorIndex(cacheMajors.config, cacheConfigPages.maplabels) },
  mapzones: { parser: parse.mapZones, lookup: singleMinorIndex(cacheMajors.worldmap, 0) },
  cutscenes: { parser: parse.cutscenes, lookup: noArchiveIndex(cacheMajors.cutscenes) },
  particles0: { parser: parse.particles_0, lookup: singleMinorIndex(cacheMajors.particles, 0) },
  particles1: { parser: parse.particles_1, lookup: singleMinorIndex(cacheMajors.particles, 1) },
  maptiles: { parser: parse.mapsquareTiles, lookup: worldmapIndex(cacheMapFiles.squares) },
  maptiles_nxt: { parser: parse.mapsquareTilesNxt, lookup: worldmapIndex(cacheMapFiles.square_nxt) },
  maplocations: { parser: parse.mapsquareLocations, lookup: worldmapIndex(cacheMapFiles.locations) },
  mapenvs: { parser: parse.mapsquareEnvironment, lookup: worldmapIndex(cacheMapFiles.env) },
  maptiles_old: { parser: parse.mapsquareTiles, lookup: oldWorldmapIndex("m") },
  maplocations_old: { parser: parse.mapsquareLocations, lookup: oldWorldmapIndex("l") },
  frames: { parser: parse.frames, lookup: standardIndex(cacheMajors.frames) },
  models: { parser: parse.models, lookup: noArchiveIndex(cacheMajors.models) },
  oldmodels: { parser: parse.oldmodels, lookup: noArchiveIndex(cacheMajors.oldmodels) },
  skeletons: { parser: parse.skeletalAnim, lookup: noArchiveIndex(cacheMajors.skeletalAnims) },
  proctextures: { parser: parse.proctexture, lookup: noArchiveIndex(cacheMajors.texturesOldPng) },
  oldproctextures: { parser: parse.oldproctexture, lookup: singleMinorIndex(cacheMajors.texturesOldPng, 0) },
  interfaces: { parser: parse.interfaces, lookup: standardIndex(cacheMajors.interfaces) },
  classicmodels: { parser: parse.classicmodels, lookup: singleMinorIndex(0, classicGroups.models) },
  indices: { parser: parse.cacheIndex, lookup: indexfileIndex() },
  rootindex: { parser: parse.rootCacheIndex, lookup: rootindexfileIndex() },
  test: { parser: FileParser.fromJson(`["struct",
  
]`), lookup: anyFileIndex() },
  clientscriptops: { parser: parse.clientscript, lookup: noArchiveIndex(cacheMajors.clientscript), prepareParser: (source) => prepareClientScript(source).then(() => void 0) }
});
var npcmodels = function() {
  return {
    ...chunkedIndex(cacheMajors.npcs),
    ext: "json",
    prepareDump(output) {
    },
    prepareWrite() {
    },
    read(b, id, source) {
      let obj = parse.npc.read(b, source);
      return prettyJson2({
        id: id[0],
        size: obj.boundSize ?? 1,
        name: obj.name ?? "",
        models: obj.models ?? []
      });
    },
    write(files) {
      throw new Error("");
    },
    combineSubs(b) {
      return `[${b.join(",\n")}]`;
    },
    description: "Extract model metadata from npc configs."
  };
};
var cacheFileDecodersImage = constrainedMap()({
  sprites: decodeSprite(cacheMajors.sprites),
  textures_dds: decodeTexture(cacheMajors.texturesDds),
  textures_png: decodeTexture(cacheMajors.texturesPng),
  textures_bmp: decodeTexture(cacheMajors.texturesBmp),
  textures_ktx: decodeTexture(cacheMajors.texturesKtx)
});
var cacheFileDecodersLegacyImage = constrainedMap()({
  legacy_sprites: decodeLegacySprite(legacyGroups.sprites),
  legacy_textures: decodeLegacySprite(legacyGroups.textures),
  textures_proc: decodeOldProcTexture,
  textures_oldpng: decodeTexture(cacheMajors.texturesOldPng),
  textures_2015png: decodeTexture(cacheMajors.textures2015Png),
  textures_2015dds: decodeTexture(cacheMajors.textures2015Dds),
  textures_2015pngmips: decodeTexture(cacheMajors.textures2015PngMips),
  textures_2015compoundpng: decodeTexture(cacheMajors.textures2015CompoundPng),
  textures_2015compounddds: decodeTexture(cacheMajors.textures2015CompoundDds),
  textures_2015compoundpngmips: decodeTexture(cacheMajors.textures2015CompoundPngMips)
});
var cacheFileDecodersSound = constrainedMap()({
  sounds: decodeSound(cacheMajors.sounds, true),
  musicfragments: decodeSound(cacheMajors.music, false),
  music: decodeMusic
});
var cacheFileDecodersInteractive = constrainedMap()({
  cutscenehtml: decodeCutscene,
  interfacehtml: decodeInterface,
  interfaceviewer: decodeInterface2,
  clientscript: decodeClientScript,
  clientscriptviewer: decodeClientScriptViewer
});
var cacheFileDecodersOther = constrainedMap()({
  bin: decodeBinary,
  spritehash: decodeSpriteHash,
  modelhash: decodeMeshHash,
  npcmodels
});
var cacheFileDecodersJson = Object.fromEntries(Object.entries(cacheFileJsonModes).map(([k, v]) => [k, standardFile(v.parser, v.lookup, v.prepareDump, v.prepareParser)]));
var cacheFileDecodeGroups = {
  image: cacheFileDecodersImage,
  legacyImage: cacheFileDecodersLegacyImage,
  interactive: cacheFileDecodersInteractive,
  sound: cacheFileDecodersSound,
  other: cacheFileDecodersOther,
  json: cacheFileDecodersJson
};
var cacheFileDecodeModes = Object.fromEntries(Object.values(cacheFileDecodeGroups).flatMap((q) => Object.entries(q)));

// rsmv/src/3d/rt2model.ts
import { BufferAttribute as BufferAttribute3, Vector3 as Vector34 } from "three";
function parseRT2Model(modelfile, source) {
  let parsed = parse.classicmodels.read(modelfile, source);
  const posscale = 4;
  let matusecount = /* @__PURE__ */ new Map();
  let allocmat = (colorid, nverts) => {
    if (colorid == 32767) {
      return;
    }
    if (nverts < 3) {
      return;
    }
    let matid = colorid & 32768 ? -1 : colorid + 1;
    let count = matusecount.get(matid);
    if (!count) {
      count = { tris: 0, verts: 0 };
      matusecount.set(matid, count);
    }
    count.verts += nverts;
    count.tris += nverts - 2;
  };
  for (let face of parsed.faces) {
    allocmat(face.color, face.verts.length);
    allocmat(face.backcolor, face.verts.length);
  }
  let matmeshes = /* @__PURE__ */ new Map();
  for (let [matid, count] of matusecount.entries()) {
    matmeshes.set(matid, {
      pos: new BufferAttribute3(new Float32Array(count.verts * 3), 3),
      normals: new BufferAttribute3(new Float32Array(count.verts * 3), 3),
      color: new BufferAttribute3(new Uint8Array(count.verts * 3), 3, true),
      texuvs: new BufferAttribute3(new Float32Array(count.verts * 2), 2),
      index: new Uint16Array(count.tris * 3),
      currentface: 0,
      currentindex: 0,
      matid
    });
  }
  let addvert = (group, verts, polyindex, color) => {
    let posindex = verts[polyindex];
    if (group.matid == -1) {
      group.color.setXYZ(
        group.currentface,
        (~color >> 10 & 31) / 31,
        (~color >> 5 & 31) / 31,
        (~color >> 0 & 31) / 31
      );
    } else {
      group.color.setXYZ(group.currentface, 1, 1, 1);
    }
    group.pos.setXYZ(
      group.currentface,
      parsed.xpos[posindex] * posscale,
      -parsed.ypos[posindex] * posscale,
      parsed.zpos[posindex] * posscale
    );
    group.normals.setXYZ(
      group.currentface,
      currentNormal.x,
      currentNormal.y,
      currentNormal.z
    );
    group.texuvs.setXY(
      group.currentface,
      polyindex == 0 || polyindex == 3 ? 0 : 1,
      polyindex == 0 || polyindex == 1 ? 0 : 1
    );
    return group.currentface++;
  };
  let currentNormal = new Vector34();
  let v0 = new Vector34();
  let v1 = new Vector34();
  let v2 = new Vector34();
  for (let face of parsed.faces) {
    if (face.verts.length < 3) {
      continue;
    }
    if (face.color != 32767) {
      let i0 = face.verts.at(-1);
      let i1 = face.verts.at(-2);
      let i2 = face.verts.at(-3);
      v0.set(parsed.xpos[i0], -parsed.ypos[i0], parsed.zpos[i0]);
      v1.set(parsed.xpos[i1], -parsed.ypos[i1], parsed.zpos[i1]);
      v2.set(parsed.xpos[i2], -parsed.ypos[i2], parsed.zpos[i2]);
      v1.sub(v0);
      v2.sub(v0);
      currentNormal.copy(v1).cross(v2).normalize();
      let group = matmeshes.get(face.color & 32768 ? -1 : face.color + 1);
      let firstvert = addvert(group, face.verts, face.verts.length - 1, face.color);
      let lastvert = addvert(group, face.verts, face.verts.length - 2, face.color);
      for (let i = face.verts.length - 3; i >= 0; i--) {
        let newvert = addvert(group, face.verts, i, face.color);
        group.index[group.currentindex++] = firstvert;
        group.index[group.currentindex++] = lastvert;
        group.index[group.currentindex++] = newvert;
        lastvert = newvert;
      }
    }
    if (face.backcolor != 32767) {
      let i0 = face.verts[0];
      let i1 = face.verts[1];
      let i2 = face.verts[2];
      v0.set(parsed.xpos[i0], -parsed.ypos[i0], parsed.zpos[i0]);
      v1.set(parsed.xpos[i1], -parsed.ypos[i1], parsed.zpos[i1]);
      v2.set(parsed.xpos[i2], -parsed.ypos[i2], parsed.zpos[i2]);
      v1.sub(v0);
      v2.sub(v0);
      currentNormal.copy(v1).cross(v2).normalize();
      let group = matmeshes.get(face.backcolor & 32768 ? -1 : face.backcolor + 1);
      let firstvert = addvert(group, face.verts, 0, face.backcolor);
      let lastvert = addvert(group, face.verts, 1, face.backcolor);
      for (let i = 2; i < face.verts.length; i++) {
        let newvert = addvert(group, face.verts, i, face.backcolor);
        group.index[group.currentindex++] = firstvert;
        group.index[group.currentindex++] = lastvert;
        group.index[group.currentindex++] = newvert;
        lastvert = newvert;
      }
    }
  }
  let maxy = 0;
  let miny = 0;
  let r = {
    bonecount: 0,
    miny,
    maxy,
    skincount: 0,
    meshes: [...matmeshes.values()].map((q) => {
      let indices = new BufferAttribute3(q.index, 1);
      return {
        indices,
        vertexstart: 0,
        vertexend: q.pos.count,
        attributes: {
          pos: q.pos,
          color: q.color,
          texuvs: q.texuvs,
          normals: q.normals
        },
        hasVertexAlpha: false,
        indexLODs: [indices],
        materialId: q.matid,
        needsNormalBlending: true
      };
    })
  };
  return r;
}

// rsmv/src/3d/modelutils.ts
import { BufferAttribute as BufferAttribute4, InterleavedBufferAttribute, Vector3 as Vector35 } from "three";
var white = [255, 255, 255];
var red = [255, 0, 0];
var tile = 512;
var halftile = 256;
var wall = tile * 192 / 128;
var rooftop = wall + tile / 2;
var roofoverhang = halftile + tile / 5;
var roofhang = wall;
var roofcorner = rooftop - (rooftop - roofhang) / (halftile + roofoverhang) * tile;
function getnormal(v0, v1, v2) {
  let normx = (v2[1] - v0[1]) * (v1[2] - v0[2]) - (v1[1] - v0[1]) * (v2[2] - v0[2]);
  let normy = (v2[2] - v0[2]) * (v1[0] - v0[0]) - (v1[2] - v0[2]) * (v2[0] - v0[0]);
  let normz = (v2[0] - v0[0]) * (v1[1] - v0[1]) - (v1[0] - v0[0]) * (v2[1] - v0[1]);
  let invlen = 1 / Math.hypot(normx, normy, normz);
  return [normx * invlen, normy * invlen, normz * invlen];
}
var MeshBuilder = class {
  constructor(parent) {
    this.pos = [];
    this.color = [];
    this.uvs = [];
    this.index = [];
    this.normals = [];
    this.vertindex = 0;
    this.parent = parent;
  }
  addParallelogram(col, v0, v1, v2) {
    let v3 = [
      v0[0] + v2[0] - v1[0],
      v0[1] + v2[1] - v1[1],
      v0[2] + v2[2] - v1[2]
    ];
    let norm = getnormal(v0, v1, v2);
    this.pos.push(...v0, ...v1, ...v2, ...v3);
    this.color.push(...col, ...col, ...col, ...col);
    this.normals.push(...norm, ...norm, ...norm, ...norm);
    this.uvs.push(0, 0, 1, 0, 1, 1, 0, 1);
    this.index.push(
      this.vertindex + 0,
      this.vertindex + 2,
      this.vertindex + 1,
      this.vertindex + 0,
      this.vertindex + 3,
      this.vertindex + 2
    );
    this.vertindex += 4;
    return this;
  }
  addTriangle(col, v0, v1, v2) {
    let norm = getnormal(v0, v2, v1);
    this.color.push(...col, ...col, ...col);
    this.pos.push(...v0, ...v1, ...v2);
    this.uvs.push(0, 0, 0, 1, 1, 1);
    this.normals.push(...norm, ...norm, ...norm);
    this.index.push(this.vertindex + 0, this.vertindex + 1, this.vertindex + 2);
    this.vertindex += 3;
    return this;
  }
  addCube(col, [centerx, centery, centerz], [sizex, sizey, sizez]) {
    let x0 = centerx - sizex / 2;
    let y0 = centery - sizey / 2;
    let z0 = centerz - sizez / 2;
    let x1 = x0 + sizex;
    let y1 = y0 + sizey;
    let z1 = z0 + sizez;
    this.addParallelogram(col, [x0, y0, z0], [x1, y0, z0], [x1, y1, z0]);
    this.addParallelogram(col, [x1, y0, z0], [x1, y0, z1], [x1, y1, z1]);
    this.addParallelogram(col, [x1, y0, z1], [x0, y0, z1], [x0, y1, z1]);
    this.addParallelogram(col, [x0, y0, z1], [x0, y0, z0], [x0, y1, z0]);
    this.addParallelogram(col, [x0, y0, z1], [x1, y0, z1], [x1, y0, z0]);
    this.addParallelogram(col, [x0, y1, z0], [x1, y1, z0], [x1, y1, z1]);
    return this;
  }
  addExtrusion(color, vector, points) {
    let prevpoint = points[points.length - 1];
    if (Math.hypot(...vector) != 0) {
      for (let a = 0; a < points.length; a++) {
        let point = points[a];
        this.addParallelogram(color, prevpoint, point, [point[0] + vector[0], point[1] + vector[1], point[2] + vector[2]]);
        prevpoint = point;
      }
    }
    if (points.length > 2) {
      let dx1 = points[2][0] - points[1][0], dy1 = points[2][1] - points[1][1], dz1 = points[2][2] - points[1][2];
      let dx2 = points[0][0] - points[1][0], dy2 = points[0][1] - points[1][1], dz2 = points[0][2] - points[1][2];
      let normx = dy2 * dz1 - dy1 * dz2;
      let normy = dz2 * dx1 - dz1 * dx2;
      let normz = dx2 * dy1 - dx1 * dy2;
      let len = Math.hypot(normx, normy, normz);
      normx /= len;
      normy /= len;
      normz /= len;
      let startindex = this.index.length;
      let zeroindex = -1;
      let previndex = -1;
      for (let a = 0; a < points.length; a++) {
        let point = points[a];
        this.pos.push(...point);
        this.color.push(...color);
        this.uvs.push(0, 0);
        this.normals.push(normx, normy, normz);
        let index = this.vertindex++;
        if (zeroindex == -1) {
          zeroindex = index;
        } else if (previndex == -1) {
          previndex = index;
        } else {
          this.index.push(zeroindex, previndex, index);
          previndex = index;
        }
      }
      zeroindex = -1;
      previndex = -1;
      for (let a = points.length; a > 0; a--) {
        let point = points[a % points.length];
        this.pos.push(...point);
        this.color.push(...color);
        this.uvs.push(0, 0);
        this.normals.push(-normx, -normy, -normz);
        let index = this.vertindex++;
        if (zeroindex == -1) {
          zeroindex = index;
        } else if (previndex == -1) {
          previndex = index;
        } else {
          this.index.push(zeroindex, previndex, index);
          previndex = index;
        }
      }
    }
    return this;
  }
  convertSubmesh(matid) {
    let indices = new BufferAttribute4(new Uint16Array(this.index), 1);
    return {
      indices,
      vertexstart: 0,
      vertexend: this.pos.length / 3 | 0,
      attributes: {
        pos: new BufferAttribute4(new Float32Array(this.pos), 3),
        color: new BufferAttribute4(new Uint8Array(this.color), 3, true),
        texuvs: new BufferAttribute4(new Float32Array(this.uvs), 2),
        normals: new BufferAttribute4(new Float32Array(this.normals), 3)
      },
      indexLODs: [indices],
      hasVertexAlpha: false,
      materialId: matid,
      needsNormalBlending: false
    };
  }
  mat(mat) {
    return this.parent.mat(mat);
  }
  convert() {
    return this.parent.convert();
  }
};
function getAttributeBackingStore(attr) {
  if (attr instanceof InterleavedBufferAttribute) {
    let data = attr.data.array;
    if (!ArrayBuffer.isView(data)) {
      throw new Error("typed array backing store expected");
    }
    return [data, attr.offset, attr.data.stride];
  } else {
    let data = attr.array;
    if (!ArrayBuffer.isView(data)) {
      throw new Error("typed array backing store expected");
    }
    return [data, 0, attr.itemSize];
  }
}
function computePartialNormals(index, positionAttribute, normalAttribute, indexstart, indexend) {
  const a = new Vector35();
  const b = new Vector35();
  const c = new Vector35();
  const d = new Vector35();
  for (let i = indexstart; i < indexend; i += 3) {
    const vA = index.getX(i + 0);
    const vB = index.getX(i + 1);
    const vC = index.getX(i + 2);
    a.fromBufferAttribute(positionAttribute, vA);
    b.fromBufferAttribute(positionAttribute, vB);
    c.fromBufferAttribute(positionAttribute, vC);
    c.sub(b);
    a.sub(b);
    d.crossVectors(c, a);
    a.fromBufferAttribute(normalAttribute, vA);
    b.fromBufferAttribute(normalAttribute, vB);
    c.fromBufferAttribute(normalAttribute, vC);
    a.add(d);
    b.add(d);
    c.add(d);
    normalAttribute.setXYZ(vA, a.x, a.y, a.z);
    normalAttribute.setXYZ(vB, b.x, b.y, b.z);
    normalAttribute.setXYZ(vC, c.x, c.y, c.z);
  }
  for (let i = indexstart; i < indexend; i++) {
    d.fromBufferAttribute(normalAttribute, i);
    d.normalize();
    normalAttribute.setXYZ(i, d.x, d.y, d.z);
  }
}
function meshBuildersToModel(builders) {
  let miny = 0;
  let maxy = 0;
  let meshes = [];
  builders.forEach((builder, mat) => {
    let mesh = builder.convertSubmesh(mat);
    meshes.push(mesh);
    let posattr = mesh.attributes.pos;
    for (let i = 0; i < posattr.count; i++) {
      let y = posattr.getY(i);
      miny = Math.min(miny, y);
      maxy = Math.max(maxy, y);
    }
  });
  return {
    miny,
    maxy,
    bonecount: 0,
    skincount: 0,
    meshes
  };
}
var ModelBuilder = class {
  constructor() {
    this.meshes = /* @__PURE__ */ new Map();
  }
  mat(mat) {
    let mesh = this.meshes.get(mat);
    if (!mesh) {
      mesh = new MeshBuilder(this);
      this.meshes.set(mat, mesh);
    }
    return mesh;
  }
  convert() {
    return meshBuildersToModel(this.meshes);
  }
};
var materialPreviewCube = new ModelBuilder().mat(0).addCube(white, [0, 300, 0], [600, 600, 600]).convert();
var classicWall = new ModelBuilder().mat(0).addParallelogram(white, [-halftile, 0, halftile], [-halftile, tile, halftile], [-halftile, tile, -halftile]).mat(1).addParallelogram(red, [-halftile, 0, -halftile], [-halftile, tile, -halftile], [-halftile, tile, halftile]).convert();
var classicWallDiag = new ModelBuilder().mat(0).addParallelogram(white, [halftile, 0, halftile], [halftile, tile, halftile], [-halftile, tile, -halftile]).mat(1).addParallelogram(white, [-halftile, 0, -halftile], [-halftile, tile, -halftile], [halftile, tile, halftile]).convert();
var classicRoof10 = new ModelBuilder().mat(0).addParallelogram(white, [-roofoverhang, roofcorner, -roofoverhang], [roofoverhang, roofcorner, -roofoverhang], [roofoverhang, roofcorner, roofoverhang]).convert();
var classicRoof12 = new ModelBuilder().mat(0).addParallelogram(white, [-halftile, rooftop, halftile], [-halftile, rooftop, -halftile], [roofoverhang, roofhang, -halftile]).convert();
var classicRoof13 = new ModelBuilder().mat(0).addTriangle(white, [roofoverhang, roofhang, halftile], [-halftile, roofhang, -roofoverhang], [-halftile, rooftop, halftile]).convert();
var classicRoof14 = new ModelBuilder().mat(0).addTriangle(white, [-halftile, rooftop, -halftile], [-halftile, rooftop, halftile], [halftile, rooftop, halftile]).mat(0).addTriangle(white, [-halftile, rooftop, -halftile], [halftile, rooftop, halftile], [halftile, roofcorner, -halftile]).convert();
var classicRoof15 = new ModelBuilder().mat(0).addTriangle(white, [halftile, rooftop, halftile], [-halftile, rooftop, -halftile], [-halftile, roofcorner, halftile]).mat(0).addTriangle(white, [-halftile, rooftop, -halftile], [halftile, rooftop, halftile], [halftile, roofcorner, -halftile]).convert();
var classicRoof16 = new ModelBuilder().mat(0).addTriangle(white, [roofoverhang, roofhang, -roofoverhang], [-halftile, roofhang, -roofoverhang], [-halftile, rooftop, halftile]).mat(0).addTriangle(white, [roofoverhang, roofhang, halftile], [roofoverhang, roofhang, -roofoverhang], [-halftile, rooftop, halftile]).convert();
var classicRoof17 = new ModelBuilder().mat(0).addParallelogram(white, [-halftile, rooftop, -halftile], [halftile, rooftop, -halftile], [halftile, rooftop, halftile]).convert();
var topdown2dWallModels = generateTopdown2dWallModels();
function generateTopdown2dWallModels() {
  const edge = halftile;
  const offset = halftile - tile / 8;
  const height = 0;
  const wallvec = [0, height, 0];
  return {
    wall: new ModelBuilder().mat(-1).addExtrusion(white, wallvec, [
      [-edge, 0, -edge],
      [-edge, 0, edge],
      [-offset, 0, edge],
      [-offset, 0, -edge]
    ]).convert(),
    shortcorner: new ModelBuilder().mat(-1).addExtrusion(white, wallvec, [
      [-edge, 0, edge],
      [-offset, 0, edge],
      [-offset, 0, offset],
      [-edge, 0, offset]
    ]).convert(),
    longcorner: new ModelBuilder().mat(-1).addExtrusion(white, wallvec, [
      [-offset, 0, offset],
      [-offset, 0, -edge],
      [-edge, 0, -edge],
      [-edge, 0, edge],
      [edge, 0, edge],
      [edge, 0, offset]
    ]).convert(),
    pillar: new ModelBuilder().mat(-1).addExtrusion(white, wallvec, [
      //same as shortcorner
      [-edge, 0, edge],
      [-offset, 0, edge],
      [-offset, 0, offset],
      [-edge, 0, offset]
    ]).convert(),
    diagonal: new ModelBuilder().mat(-1).addExtrusion(white, wallvec, [
      [-edge, 0, -edge],
      [-edge, 0, -offset],
      [offset, 0, edge],
      [edge, 0, edge],
      [edge, 0, offset],
      [-offset, 0, -edge]
    ]).convert()
  };
}

// rsmv/src/3d/classicmap.ts
var chunkSize = 48;
var chunkTileCount = chunkSize * chunkSize;
var classicLocIdWall = 1e6;
var classicLocIdRoof = 2e6;
function indexToPos(i) {
  const last = chunkSize - 1;
  let x = last - (i / chunkSize | 0);
  let z = last - i % chunkSize;
  return { rs2index: x * chunkSize + z, x, z };
}
function posToIndex(x, z) {
  return (chunkSize - 1 - x) * chunkSize + (chunkSize - 1 - z);
}
async function getClassicMapData(engine, rs2x, rs2z) {
  let isunderground = rs2z >= 100;
  let mapfilehash = 0;
  const config = engine.classicData;
  let chunkx = 100 - rs2x;
  let chunkz = 100 - (isunderground ? rs2z - 100 : rs2z);
  let chunknum = `${chunkx.toString().padStart(2, "0")}${chunkz.toString().padStart(2, "0")}`;
  let leveldatas = [];
  let nlevels = isunderground ? 1 : 3;
  for (let level = 0; level < nlevels; level++) {
    let sourcelevel = isunderground ? 3 : level;
    let heifile = engine.getBuildNr() <= 115 ? void 0 : await engine.findSubfileByName(0, classicGroups.land, `m${sourcelevel}${chunknum}.hei`);
    let jmfile = await engine.findSubfileByName(0, classicGroups.maps, `m${sourcelevel}${chunknum}.jm`);
    if (!heifile && !jmfile && level == 0) {
      return null;
    }
    leveldatas.push({ sourcelevel, hei: heifile?.buffer, jm: jmfile?.buffer, loc: void 0, dat: void 0 });
  }
  let grid = new ClassicMapBuilder(config, nlevels);
  for (let level = 0; level < nlevels; level++) {
    let leveldata = leveldatas[level];
    if (!leveldata.jm) {
      let datfile = await engine.findSubfileByName(0, classicGroups.maps, `M${leveldata.sourcelevel}${chunknum}.DAT`);
      let locfile = await engine.findSubfileByName(0, classicGroups.maps, `M${leveldata.sourcelevel}${chunknum}.LOC`);
      leveldata.dat = datfile?.buffer;
      leveldata.loc = locfile?.buffer;
    }
  }
  for (let level = 0; level < nlevels; level++) {
    let leveldata = leveldatas[level];
    if (leveldata.jm) {
      grid.loadJmFile(leveldata.jm, level);
      mapfilehash = crc32(leveldata.jm, mapfilehash);
    } else if (leveldata.hei) {
      grid.loadHeiFile(leveldata.hei, level);
      mapfilehash = crc32(leveldata.hei, mapfilehash);
    }
  }
  for (let level = 0; level < nlevels; level++) {
    let leveldata = leveldatas[level];
    if (!leveldata.jm) {
      if (leveldata.dat) {
        grid.loadDatfile(leveldata.dat, level);
        mapfilehash = crc32(leveldata.dat, mapfilehash);
      }
      if (leveldata.loc) {
        grid.loadLocFile(leveldata.loc, level);
        mapfilehash = crc32(leveldata.loc, mapfilehash);
      } else {
        let locs = loadLocJsonBuffer(config, chunkx, chunkz, leveldata.sourcelevel);
        mapfilehash = crc32(Buffer.from(locs.buffer), mapfilehash);
        grid.addLocBuffer(locs, level);
      }
    }
  }
  let rect = { x: rs2x * chunkSize, z: rs2z * chunkSize, xsize: chunkSize, zsize: chunkSize };
  return {
    rect,
    mapfilehash,
    tiles: grid.convertTiles(),
    locs: grid.locs,
    levels: nlevels
  };
}
var ClassicMapBuilder = class {
  constructor(config, maxlevels) {
    this.locs = [];
    this.config = config;
    this.levels = maxlevels;
    this.tiles = new Array(chunkTileCount * maxlevels).fill(null).map((q, i) => ({
      height: i > chunkTileCount ? 96 : 0,
      //based on wall height 192/128*tilesize=768
      hasbridge: false,
      // loc: 0,
      // wall: " ",
      // roof: 0,
      overlayobj: null,
      overlay: 0,
      underlay: 0,
      locrotation: 0
    }));
  }
  getTile(level, x, z) {
    if (x < 0 || z < 0 || x >= chunkSize || z >= chunkSize) {
      return void 0;
    }
    if (level < 0 || level >= this.levels) {
      return void 0;
    }
    return this.tiles[level * chunkTileCount + x * chunkSize + z];
  }
  getTileClassic(level, index) {
    const last = chunkSize - 1;
    let x = last - (index / chunkSize | 0);
    let z = last - index % chunkSize;
    return this.getTile(level, x, z);
  }
  placeLoc(id, type, rotation, level, x, z, extra = null) {
    let above = this.getTile(level + 1, x, z);
    if (above?.overlayobj?.type.bridge) {
      level++;
    } else if (type == 0) {
      let neighbour = rotation == 2 ? this.getTile(level + 1, x + 1, z) : this.getTile(level + 1, x, z + 1);
      if (neighbour?.overlayobj?.type.bridge) {
        level++;
      }
    }
    this.locs.push({
      id,
      uses: [{ x, y: z, plane: level, rotation, type, extra }]
    });
  }
  convertTiles() {
    return this.tiles.map((tile2, i) => {
      let level = Math.floor(i / chunkTileCount);
      let below = this.tiles[i - chunkTileCount];
      return {
        height: tile2.hasbridge ? level == 1 && below.hasbridge ? below.height / 4 : 0 : tile2.height / 4,
        flags: 0,
        settings: level == 1 && tile2.hasbridge ? 2 : 0,
        overlay: tile2.overlay,
        underlay: tile2.underlay,
        shape: tile2.overlay ? 0 : null
      };
    });
  }
  loadJmFile(jmfile, level) {
    let jm = new Stream(jmfile);
    let lastTerrain = 0;
    let terrainHeight = Buffer.alloc(chunkTileCount);
    for (let tile2 = 0; tile2 < chunkTileCount; tile2++) {
      lastTerrain += jm.readUByte();
      terrainHeight[tile2] = lastTerrain & 255;
    }
    let lastColor = 0;
    let terrainColor = Buffer.alloc(chunkTileCount);
    for (let tile2 = 0; tile2 < chunkTileCount; tile2++) {
      lastColor += jm.readUByte();
      terrainColor[tile2] = lastColor & 255;
    }
    let horwalls = jm.readBuffer(chunkTileCount);
    let verwalls = jm.readBuffer(chunkTileCount);
    let diag1walls = Buffer.alloc(chunkTileCount);
    let diag2walls = Buffer.alloc(chunkTileCount);
    let locbuffer = new Uint32Array(chunkTileCount);
    for (let tile2 = 0; tile2 < chunkTileCount; tile2++) {
      let locint = jm.readUShort(true);
      if (locint != 0) {
        let type = locint / 12e3 | 0;
        let objid = locint % 12e3;
        let pos = indexToPos(tile2);
        if (type == 0) {
          diag1walls[tile2] = objid;
        } else if (type == 1) {
          diag2walls[tile2] = objid;
        } else if (type == 2) {
        } else if (type == 3) {
        } else if (type == 4) {
          locbuffer[tile2] = objid;
        } else {
          console.log(pos.x, pos.z, tile2, " type" + (locint / 12e3 | 0), locint % 12e3);
        }
      }
    }
    let roofs = jm.readBuffer(chunkTileCount);
    let overlays = jm.readBuffer(chunkTileCount);
    let locdirections = jm.readBuffer(chunkTileCount);
    if (!jm.eof()) {
      throw new Error("didn't end reading map.jm at end of file");
    }
    if (level == 0) {
      this.addFloorBuffers(terrainHeight, terrainColor, level, false);
    }
    this.addWallBuffers(horwalls, verwalls, diag1walls, diag2walls, roofs, overlays, locdirections, level);
    this.addLocBuffer(locbuffer, level);
  }
  loadHeiFile(heifile, level) {
    let hei = new Stream(heifile);
    let lastVal = 0;
    let terrainHeight = Buffer.alloc(chunkTileCount);
    let terrainColor = Buffer.alloc(chunkTileCount);
    for (let tile2 = 0; tile2 < chunkTileCount; ) {
      let val = hei.readUByte();
      if (val < 128) {
        terrainHeight[tile2++] = val & 255;
        lastVal = val;
      }
      if (val >= 128) {
        for (let i = 0; i < val - 128; i++) {
          terrainHeight[tile2++] = lastVal & 255;
        }
      }
    }
    for (let tile2 = 0; tile2 < chunkTileCount; ) {
      let val = hei.readUByte();
      if (val < 128) {
        terrainColor[tile2++] = val & 255;
        lastVal = val;
      }
      if (val >= 128) {
        for (let i = 0; i < val - 128; i++) {
          terrainColor[tile2++] = lastVal & 255;
        }
      }
    }
    if (!hei.eof()) {
      throw new Error("unexpected height file length");
    }
    this.addFloorBuffers(terrainHeight, terrainColor, level, true);
  }
  loadDatfile(datfile, level) {
    let dat = new Stream(datfile);
    let horbuffer = dat.readBuffer(chunkTileCount);
    let verbuffer = dat.readBuffer(chunkTileCount);
    let diag1buffer = dat.readBuffer(chunkTileCount);
    let diag2buffer = dat.readBuffer(chunkTileCount);
    let roofids = Buffer.alloc(chunkTileCount);
    for (let tile2 = 0; tile2 < chunkTileCount; ) {
      let val = dat.readUByte();
      if (val < 128) {
        roofids[tile2] = val;
        tile2++;
      } else {
        tile2 += val - 128;
      }
    }
    let overlaybuffer = Buffer.alloc(chunkTileCount);
    let lastVal = 0;
    for (let tileindex = 0; tileindex < chunkTileCount; ) {
      let val = dat.readUByte();
      let iter = 1;
      if (val < 128) {
        lastVal = val;
      } else {
        iter = val - 128;
      }
      for (let i = 0; i < iter; i++) {
        overlaybuffer[tileindex] = lastVal;
        tileindex++;
      }
    }
    let rotatebuffer = Buffer.alloc(chunkTileCount);
    for (let tileindex = 0; tileindex < chunkTileCount; ) {
      let val = dat.readUByte();
      if (val < 128) {
        rotatebuffer[tileindex] = val;
        tileindex++;
      } else {
        tileindex += val - 128;
      }
    }
    if (!dat.eof()) {
      throw new Error("didn't end reading map.dat at end of file");
    }
    this.addWallBuffers(horbuffer, verbuffer, diag1buffer, diag2buffer, roofids, overlaybuffer, rotatebuffer, level);
  }
  addFloorBuffers(terrainHeight, terrainColor, level, doblendything) {
    let lastHeight = 64;
    let lastColor = 35;
    for (let classicY = 0; classicY < chunkSize; classicY++) {
      for (let classicX = 0; classicX < chunkSize; classicX++) {
        let index = classicX * chunkSize + classicY;
        let height = terrainHeight[index];
        let color = terrainColor[index];
        if (doblendything) {
          lastHeight = height + (lastHeight & 127);
          height = lastHeight * 2 & 255;
          lastColor = terrainColor[index] + lastColor & 127;
          color = lastColor * 2 & 255;
        }
        let tile2 = this.getTileClassic(level, index);
        if (!tile2) {
          continue;
        }
        tile2.height = height;
        tile2.underlay = color + 1;
      }
    }
  }
  addWallBuffers(horbuffer, verbuffer, diag1buffer, diag2buffer, roofids, overlaybuffer, rotatebuffer, level) {
    let bridgefytile = (level2, x, z) => {
      let tile00 = this.getTile(level2, x, z);
      let tile01 = this.getTile(level2, x - 1, z);
      let tile10 = this.getTile(level2, x, z - 1);
      let tile11 = this.getTile(level2, x - 1, z - 1);
      if (tile00) {
        tile00.hasbridge = true;
      }
      if (tile01) {
        tile01.hasbridge = true;
      }
      if (tile10) {
        tile10.hasbridge = true;
      }
      if (tile11) {
        tile11.hasbridge = true;
      }
    };
    let tryExtendBridge = (level2, x, z, bridgeid, waterid) => {
      let tile2 = this.getTile(level2, x, z);
      if (tile2 && tile2.overlay != waterid && tile2.overlay != bridgeid) {
        let above = this.getTile(level2 + 1, x, z);
        if (above) {
          above.overlay = bridgeid;
          above.overlayobj = this.config.tiles[bridgeid - 1];
        }
        bridgefytile(level2 + 1, x, z);
      }
    };
    for (let tileindex = 0; tileindex < chunkTileCount; tileindex++) {
      let overlay = overlaybuffer[tileindex];
      let tile2 = this.getTileClassic(level, tileindex);
      if (tile2 && overlay != 0) {
        let overlayobj = this.config.tiles[overlay - 1];
        tile2.overlay = overlay;
        tile2.overlayobj = overlayobj;
      }
    }
    for (let tileindex = 0; tileindex < chunkTileCount; tileindex++) {
      let tile2 = this.getTileClassic(0, tileindex);
      if (tile2?.overlayobj?.type.bridge) {
        let waterid = tile2.overlay == 12 ? 11 : 2;
        let pos = indexToPos(tileindex);
        let tileabove = this.getTile(level + 1, pos.x, pos.z);
        tile2.hasbridge = true;
        bridgefytile(level, pos.x, pos.z);
        bridgefytile(level + 1, pos.x, pos.z);
        tryExtendBridge(level, pos.x + 1, pos.z, tile2.overlay, waterid);
        tryExtendBridge(level, pos.x - 1, pos.z, tile2.overlay, waterid);
        tryExtendBridge(level, pos.x, pos.z + 1, tile2.overlay, waterid);
        tryExtendBridge(level, pos.x, pos.z - 1, tile2.overlay, waterid);
        if (tileabove) {
          tileabove.height = tile2.height;
          tileabove.overlay = tile2.overlay;
          tileabove.overlayobj = tile2.overlayobj;
        }
        let watertype = this.config.tiles[waterid - 1];
        tile2.overlay = waterid;
        tile2.overlayobj = watertype;
      }
    }
    let wallscale = (wallnr) => {
      let wall2 = this.config.wallobjects[wallnr - 1];
      return { flags: 0, rotation: null, scale: null, scaleX: null, scaleY: wall2.height, scaleZ: null, translateX: null, translateY: null, translateZ: null };
    };
    for (let i = 0; i < chunkTileCount; i++) {
      let hor = horbuffer[i];
      let ver = verbuffer[i];
      let diag1 = diag1buffer[i];
      let diag2 = diag2buffer[i];
      let pos = indexToPos(i);
      if (hor) {
        this.placeLoc(classicLocIdWall + (hor - 1), 0, 2, level, pos.x, pos.z, wallscale(hor));
      }
      if (ver) {
        this.placeLoc(classicLocIdWall + (ver - 1), 0, 1, level, pos.x, pos.z, wallscale(ver));
      }
      if (diag1) {
        this.placeLoc(classicLocIdWall + (diag1 - 1), 9, 0, level, pos.x, pos.z, wallscale(diag1));
      }
      if (diag2) {
        this.placeLoc(classicLocIdWall + (diag2 - 1), 9, 1, level, pos.x, pos.z, wallscale(diag2));
      }
    }
    let rooftype = (x, z) => {
      if (x < 0 || x >= chunkSize || z < 0 || z >= chunkSize) {
        return "none";
      }
      let index = posToIndex(x, z);
      if (roofids[index] == 0) {
        return "none";
      }
      if (diag1buffer[index] != 0 || diag2buffer[index] != 0) {
        return "diagedge";
      }
      return "full";
    };
    let findrooftype = (x, z) => {
      let neighbours = [
        rooftype(x + 1, z),
        //e
        rooftype(x + 1, z - 1),
        //se
        rooftype(x, z - 1),
        //s
        rooftype(x - 1, z - 1),
        //sw
        rooftype(x - 1, z),
        //w
        rooftype(x - 1, z + 1),
        //nw
        rooftype(x, z + 1),
        //north
        rooftype(x + 1, z + 1)
        //ne
      ];
      let selftype = rooftype(x, z);
      if (neighbours.every((q, i) => i % 2 == 0 ? q == "full" : q != "none")) {
        return { type: 17, rot: 0 };
      }
      for (let rot = 0; rot < 4; rot++) {
        let front = neighbours[(rot * 2 + 0) % 8];
        let right = neighbours[(rot * 2 + 2) % 8];
        let back = neighbours[(rot * 2 + 4) % 8];
        let left = neighbours[(rot * 2 + 6) % 8];
        let frontright = neighbours[(rot * 2 + 1) % 8];
        let backright = neighbours[(rot * 2 + 3) % 8];
        let backleft = neighbours[(rot * 2 + 5) % 8];
        let frontleft = neighbours[(rot * 2 + 7) % 8];
        if (front == "none" && right == "none" && left != "none" && back != "none" && backleft != "none") {
          return { type: selftype == "diagedge" ? 13 : 16, rot };
        }
        if (front == "none" && right != "none" && left != "none" && back != "none") {
          if (backright == "none") {
            return { type: 16, rot };
          }
          if (backleft == "none") {
            return { type: 16, rot: (rot + 3) % 4 };
          }
          return { type: 12, rot };
        }
        if (front != "none" && right != "none" && left == "full" && back == "full" && frontright == "none") {
          return { type: 14, rot };
        }
        if (front != "none" && right != "none" && left != "none" && back != "none" && frontright == "none" && backleft == "none") {
          return { type: 15, rot };
        }
      }
      return { type: 10, rot: 0 };
    };
    for (let tile2 = 0; tile2 < roofids.length; tile2++) {
      let id = roofids[tile2];
      if (id != 0) {
        let pos = indexToPos(tile2);
        let type = findrooftype(pos.x, pos.z);
        this.placeLoc(classicLocIdRoof + id - 1, type.type, type.rot, level, pos.x, pos.z);
      }
    }
    for (let tileindex = 0; tileindex < chunkTileCount; tileindex++) {
      let tile2 = this.getTileClassic(level, tileindex);
      if (tile2) {
        tile2.locrotation = rotatebuffer[tileindex];
      }
    }
  }
  loadLocFile(locfile, level) {
    let loc = new Stream(locfile);
    let locids = new Uint32Array(chunkTileCount);
    for (let tile2 = 0; tile2 < chunkTileCount; ) {
      let val = loc.readUByte();
      if (val < 128) {
        locids[tile2++] = val;
      } else {
        tile2 += val - 128;
      }
    }
    if (!loc.eof()) {
      throw new Error("didn't end reading map.loc at end of file");
    }
    this.addLocBuffer(locids, level);
  }
  addLocBuffer(locids, level) {
    for (let tileindex = 0; tileindex < chunkTileCount; tileindex++) {
      let locid = locids[tileindex];
      if (locid) {
        let pos = indexToPos(tileindex);
        let obj = this.config.objects[locid - 1];
        if (!obj) {
          console.warn(`loc for ${locid - 1} is missing`);
          continue;
        }
        let isoverflow = false;
        for (let dx = 0; dx < obj.xsize; dx++) {
          for (let dz = 0; dz < obj.zsize; dz++) {
            if (dx == 0 && dz == 0) {
              continue;
            }
            if (pos.x + dx >= chunkSize || pos.z + dz >= chunkSize) {
              continue;
            }
            let otherindex = posToIndex(pos.x + dx, pos.z + dz);
            if (locids[otherindex] == locid) {
              isoverflow = true;
            }
          }
        }
        if (!isoverflow) {
          let tile2 = this.getTileClassic(level, tileindex);
          if (tile2) {
            let rotation = (4 + tile2.locrotation) % 8;
            let type = rotation % 2 == 0 ? 10 : 11;
            let x = pos.x;
            let z = pos.z;
            if (rotation % 4 != 0) {
              x -= obj.zsize - 1;
              z -= obj.xsize - 1;
            } else {
              x -= obj.xsize - 1;
              z -= obj.zsize - 1;
            }
            this.placeLoc(locid - 1, type, Math.floor(rotation / 2), level, x, z);
          }
        }
      }
    }
  }
};
function classicModifyTileGrid(grid) {
  for (let level = 0; level < grid.levels; level++) {
    for (let z = grid.zsize - 1; z >= 1; z--) {
      for (let x = grid.xsize - 1; x >= 1; x--) {
        let tile2 = grid.getTile(grid.xoffset + x, grid.zoffset + z, level);
        let targettile = grid.getTile(grid.xoffset + x - 1, grid.zoffset + z - 1, level);
        if (!tile2 || !targettile) {
          continue;
        }
        tile2.y = targettile.y;
        tile2.underlayprops = targettile.underlayprops;
        tile2.effectiveLevel = level;
        tile2.effectiveVisualLevel = level;
      }
    }
  }
  let getoverlay = (tile2) => tile2?.debug_raw?.overlay ? grid.engine.classicData.tiles[tile2.debug_raw?.overlay - 1] : void 0;
  for (let level = 0; level < grid.levels; level++) {
    for (let z = grid.zsize - 1; z >= 1; z--) {
      for (let x = grid.xsize - 1; x >= 1; x--) {
        let tile2 = grid.getTile(grid.xoffset + x, grid.zoffset + z, level);
        let overlay = getoverlay(tile2);
        if (tile2 && (overlay?.type.autoconnect || overlay?.type.indoors)) {
          if (overlay.blocked) {
            if (tile2.rawCollision) {
              tile2.rawCollision.walk[0] = true;
            }
            if (tile2.effectiveCollision) {
              tile2.effectiveCollision.walk[0] = true;
            }
          }
          let top = getoverlay(grid.getTile(grid.xoffset + x, grid.zoffset + z + 1, level));
          let left = getoverlay(grid.getTile(grid.xoffset + x - 1, grid.zoffset + z, level));
          let right = getoverlay(grid.getTile(grid.xoffset + x + 1, grid.zoffset + z, level));
          let bot = getoverlay(grid.getTile(grid.xoffset + x, grid.zoffset + z - 1, level));
          let hastop = overlay.type.indoors ? top?.type.indoors : top?.type.autoconnect;
          let hasleft = overlay.type.indoors ? left?.type.indoors : left?.type.autoconnect;
          let hasright = overlay.type.indoors ? right?.type.indoors : right?.type.autoconnect;
          let hasbot = overlay.type.indoors ? bot?.type.indoors : bot?.type.autoconnect;
          if (hastop && hasleft && !hasbot && !hasright) {
            tile2.shape = tileshapes[5];
          }
          if (hastop && !hasleft && !hasbot && hasright) {
            tile2.shape = tileshapes[6];
          }
          if (!hastop && !hasleft && hasbot && hasright) {
            tile2.shape = tileshapes[7];
          }
          if (!hastop && hasleft && hasbot && !hasright) {
            tile2.shape = tileshapes[4];
          }
        }
      }
    }
  }
}
function classicDecodeMaterialInt(int2) {
  let material = 0;
  let invisible = false;
  let color = [255, 255, 255];
  if (int2 > 99999999) {
    int2 = 99999999 - int2;
  }
  if (int2 == 12345678) {
    invisible = true;
  } else if (int2 < 0) {
    let col = -int2 - 1;
    let r = col >> 10 & 31;
    let g = col >> 5 & 31;
    let b = col >> 0 & 31;
    color = [r, g, b];
  } else {
    material = int2 + 1;
  }
  return {
    color,
    colorint: HSL2packHSL(...RGB2HSL(...color)),
    material,
    invisible
  };
}
function getClassicLoc(engine, id) {
  const config = engine.classicData;
  let locdata = {};
  if (id >= classicLocIdRoof) {
    let rawloc = config.roofs[id - classicLocIdRoof];
    locdata = {
      name: `roof_${id - classicLocIdRoof}`,
      // probably_morphFloor: true,
      models: [
        { type: 10, values: [constModelsIds.classicRoof10] },
        { type: 12, values: [constModelsIds.classicRoof12] },
        { type: 13, values: [constModelsIds.classicRoof13] },
        { type: 14, values: [constModelsIds.classicRoof14] },
        { type: 15, values: [constModelsIds.classicRoof15] },
        { type: 16, values: [constModelsIds.classicRoof16] },
        { type: 17, values: [constModelsIds.classicRoof17] }
      ],
      //sets replace_colors/mats and if invisible sets models to null
      ...classicIntsToModelMods(rawloc.texture)
    };
  } else if (id >= classicLocIdWall) {
    let rawloc = config.wallobjects[id - classicLocIdWall];
    locdata = {
      name: rawloc.name,
      probably_morphFloor: true,
      models: [
        { type: 0, values: [constModelsIds.classicWall] },
        { type: 9, values: [constModelsIds.classicWallDiag] }
      ],
      //sets replace_colors/mats and if invisible sets models to null
      ...classicIntsToModelMods(rawloc.frontdecor, rawloc.backdecor)
    };
  } else {
    let loc = config.objects[id];
    if (loc.model.id == void 0) {
      console.warn(`model for ${loc.name} is missing`);
    }
    locdata = {
      name: loc.name,
      width: loc.xsize,
      length: loc.zsize,
      // probably_morphFloor: true,
      models: [
        { type: 10, values: loc.model.id == void 0 ? [] : [loc.model.id] }
      ]
    };
  }
  return locdata;
}
function classicIntsToModelMods(...matints) {
  let r = {
    color_replacements: [],
    material_replacements: []
  };
  for (let [i, matint] of matints.entries()) {
    let mods = classicDecodeMaterialInt(matint);
    r.color_replacements.push([i, mods.colorint]);
    r.material_replacements.push([i, mods.material]);
    if (mods.invisible) {
      r.models = null;
    }
  }
  return r;
}
async function classicOverlays(engine) {
  let config = engine.classicData;
  let texindex = await engine.findSubfileByName(0, classicGroups.textures, "INDEX.DAT");
  let usetga = !texindex;
  return Promise.all(config.tiles.map(async (q) => {
    let mods = classicDecodeMaterialInt(q.decor);
    let color = mods.color;
    if (mods.material) {
      let texmeta = config.textures[mods.material - 1];
      let img = await combineLegacyTexture(engine, texmeta.name, texmeta.subname, usetga);
      let r = 0, g = 0, b = 0;
      for (let i = 0; i < img.img.data.length; i += 4) {
        r += img.img.data[i + 0];
        g += img.img.data[i + 1];
        b += img.img.data[i + 2];
      }
      let npix = img.img.width * img.img.height;
      color = [r / npix | 0, g / npix | 0, b / npix | 0];
    }
    return {
      color: q.type.type == 5 ? [255, 0, 255] : color,
      material: mods.material
    };
  }));
}
function classicUnderlays() {
  let underlays = [];
  for (let i = 0; i < 64; i += 1) {
    const r = 255 - i * 4;
    const g = 255 - (i * 1.75 | 0);
    const b = 255 - i * 4;
    underlays.push({ color: [r, g, b] });
  }
  for (let i = 0; i < 64; i += 1) {
    const r = i * 3;
    const g = 144;
    const b = 0;
    underlays.push({ color: [r, g, b] });
  }
  for (let i = 0; i < 64; i += 1) {
    const r = 192 - (i * 1.5 | 0);
    const g = 144 - (i * 1.5 | 0);
    const b = 0;
    underlays.push({ color: [r, g, b] });
  }
  for (let l = 0; l < 64; l++) {
    const r = 96 - (l * 1.5 | 0);
    const g = 48 + (l * 1.5 | 0);
    const b = 0;
    underlays.push({ color: [r, g, b] });
  }
  underlays.forEach((q) => {
    q.color[0] /= 2;
    q.color[1] /= 2;
    q.color[2] /= 2;
  });
  return underlays;
}
function loadLocJsonBuffer(config, chunkx, chunkz, level) {
  let minx = chunkx * chunkSize, minz = chunkz * chunkSize;
  let maxx = minx + chunkSize, maxz = minz + chunkSize;
  let locids = new Uint32Array(chunkTileCount);
  let locs = config.jsonlocs.filter((q) => q.level == level && q.x >= minx && q.x < maxx && q.z >= minz && q.z < maxz);
  for (let loc of locs) {
    let x = loc.x - minx;
    let z = loc.z - minz;
    locids[x * chunkSize + z] = loc.id + 1;
  }
  return locids;
}

// rsmv/src/3d/proceduraltexture.ts
var import_proctexes = __toESM(require_proctexes());
var TextureGroup = class _TextureGroup {
  constructor(tex) {
    this.textures = [];
    this.sprites = [];
    this.filesize = 0;
    this.parent = tex;
  }
  getTexture(id) {
    let index = this.parent.textureIds.indexOf(id);
    if (index != -1 && this.textures[index]) {
      return this.textures[index];
    }
    throw new Error("texture not loaded");
  }
  getSprite(id) {
    let index = this.parent.spriteIds.indexOf(id);
    if (index != -1 && this.sprites[index]) {
      return this.sprites[index];
    }
    throw new Error("sprite not loaded");
  }
  static async create(engine, tex) {
    let group = new _TextureGroup(tex);
    for (let texid of tex.textureIds) {
      let subtex = await loadProcTexture(engine, texid, void 0, true);
      group.textures.push(subtex.img);
      group.filesize += subtex.filesize;
    }
    for (let spriteid of tex.spriteIds) {
      let spritefile = await engine.getFileById(cacheMajors.sprites, spriteid);
      let sprite = parseSprite(spritefile);
      group.sprites.push(sprite[0].img);
      group.filesize += spritefile.byteLength;
    }
    return group;
  }
};
async function loadProcTexture(engine, id, size = 256, raw = false) {
  let buf = await engine.getFileById(cacheMajors.texturesOldPng, id);
  let filesize = buf.byteLength;
  let javabuf = new import_proctexes.Buffer([...buf]);
  let tex = new import_proctexes.Texture(javabuf);
  let deps = await TextureGroup.create(engine, tex);
  filesize += deps.filesize;
  let img = renderProcTexture(tex, deps, size, raw);
  return { img, filesize, tex, deps };
}
function renderProcTexture(tex, group, size, raw = false) {
  let pixels = tex.getPixels(size, size, group, raw ? 1 : 1 / 2.2, false, !raw);
  let img = new ImageData(size, size);
  for (let i = 0; i < pixels.length; i++) {
    img.data[i * 4 + 0] = pixels[i] >> 16 & 255;
    img.data[i * 4 + 1] = pixels[i] >> 8 & 255;
    img.data[i * 4 + 2] = pixels[i] >> 0 & 255;
    img.data[i * 4 + 3] = 255;
  }
  return img;
}

// rsmv/src/rs3shaders/index.ts
import { SRGBColorSpace, ShaderMaterial } from "three";
var inputreplace = {
  //camera matrices, slightly different
  uModelMatrix: "#define uModelMatrix modelMatrix",
  uViewProjMatrix: "#define uViewProjMatrix (projectionMatrix*viewMatrix)",
  uViewMatrix: "#define uViewMatrix viewMatrix",
  //used for shadow stuff
  uProjectionMatrix: "#define uProjectionMatrix projectionMatrix",
  uCameraPosition: "#define uCameraPosition cameraPosition",
  aWaterPosition_Depth: "#define aWaterPosition_Depth vec4(position,10.0)",
  aVertexPosition: "#define aVertexPosition position",
  aVertexPosition_BoneLabel: "#define aVertexPosition_BoneLabel vec4(position,0.0)",
  aTextureUV: "#define aTextureUV uv",
  aVertexColour: "#define aVertexColour vec4(color.rgb,1.0)",
  aTextureWeight: [
    "attribute vec3 color_1;",
    "#define aTextureWeight vec4(color_1,1.0)"
    // "#define aTextureWeight vec4(1.0,0.0,0.0,1.0)"
  ],
  aMaterialProperties: [
    "attribute vec3 color_2;",
    "#define aMaterialProperties vec4(256.0-color_2*256.0,0.0)"
    // "#define aMaterialProperties vec4(256.0,256.0,256.0,0.0)"
  ],
  aVertexNormal_FogProportion: "#define aVertexNormal_FogProportion vec4(normal,0.0)",
  gl_FragColor: ""
};
var definereplace = {
  UNIFORM_BUFFER_BEGIN: "#define UNIFORM_BUFFER_BEGIN(name)",
  UNIFORM_BUFFER_END: "#define UNIFORM_BUFFER_END",
  TEXTURE_GRAD: "",
  gl_FragColor: ""
};
var definereplaceloc = {
  UNIFORM_BUFFER_BEGIN: "#define UNIFORM_BUFFER_BEGIN(name)",
  UNIFORM_BUFFER_END: "#define UNIFORM_BUFFER_END",
  TEXTURE_GRAD: "",
  gl_FragColor: ""
  // SRGB_TEXTURES: ""
};
function minimapLocMaterial(texture, alphamode, alphathreshold) {
  let mat = new ShaderMaterial();
  mat.uniforms = {
    uAlphaTestThreshold: { value: [-1] },
    uAmbientColour: { value: [0.6059895753860474, 0.5648590922355652, 0.5127604007720947] },
    uAtlasMeta: { value: [512, 16, 1220703125e-13, 4] },
    uCameraPosition: { value: [1638400, 17248, 1671168] },
    uDummy: { value: [1] },
    uFade: { value: [0] },
    uFullScreenLookupScale: { value: [0, 5960465188081798e-23, 1, 0] },
    uInscatteringAmount: { value: [1, 0, 0] },
    uInvSunDirection: { value: [-0.5391638875007629, 0.6469966173171997, -0.5391638875007629] },
    uModelMatrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1630208, 0, 1654784, 1] },
    uOutscatteringAmount: { value: [1638400, 17248, 1671168] },
    uProjectionMatrix: { value: [152587890625e-16, 0, 0, 0, 0, -152587890625e-16, 0, 0, 0, 0, -6200397183420137e-20, 0, 0, 0, -1.0317461490631104, 1] },
    uScatteringParameters: { value: [0, -1, 5960465188081798e-23, 0] },
    uScatteringTintColour: { value: [0, 5960465188081798e-23, 1] },
    uSunColour: { value: [0.8666666746139526, 0.8078431487083435, 0.7333333492279053] },
    uTextureAnimationTime: { value: [459.7019958496094] },
    uTextureAtlas: { value: [5] },
    uTextureAtlasSettings: { value: [6] },
    uTint: { value: [0, 0, 0, 0] },
    uVertexScale: { value: [1] },
    uViewMatrix: { value: [1, 0, 0, 0, 0, 5960465188081798e-23, 1, 0, 0, -1, 5960465188081798e-23, 0, -1638400, 1671168, -17248.099609375, 1] },
    uViewProjMatrix: { value: [152587890625e-16, 0, 0, 0, 0, -9094948101931455e-28, -6200397183420137e-20, 0, 0, 152587890625e-16, -3695725149521767e-27, 0, -25, -25.5, 0.03770458698272705, 1] },
    uViewportLookupScale: { value: [1638400, 17248, 1671168, 0] },
    uViewportOffsetScale: { value: [1, 0, 0, 0] },
    uZBufferParams: { value: [16777248, 32256, -32768, -512.0009765625] }
  };
  mat.vertexColors = true;
  let vert = require_minimap_loc_vert_glsl();
  vert = fixShader(vert);
  vert = replaceUniforms(vert, inputreplace);
  vert = replaceDefines(vert, definereplaceloc);
  let frag = require_minimap_loc_frag_glsl();
  frag = fixShader(frag);
  frag = replaceUniforms(frag, inputreplace);
  frag = replaceDefines(frag, definereplaceloc);
  frag = frag.replace(/#undef gl_FragColor/, "// $&");
  frag = frag.replace(
    /void getTextureSettings\(/,
    "void getTextureSettings(vec2 s, out TextureSettings settings){\nsettings.textureMeta1 = vec3(0.0,0.0,8196.0);\nsettings.textureMeta2 = vec3(0.0,0.0,8196.0);\nsettings.uvAnim = vec2(0.0,0.0);\nsettings.wrapping = 0.0;\nsettings.specular = 0.0;\nsettings.normalScale = 0.0;\n}\nvoid getTextureSettingsOld("
  );
  frag = frag.replace(/(?<!void )getTexel\(\w+,/gm, () => `getTexel(vTextureUV,`);
  frag = wrapMain(frag, `
        void main(){
            super();
            //pre-multiply alpha
            // gl_FragColor.rgb *= gl_FragColor.a;
            // gl_FragColor.rgb = vec3( gl_FragColor.a);
            gl_FragColor.a=1.0;
            
        }
    `);
  mat.vertexShader = vert;
  mat.fragmentShader = frag;
  mat.uniforms.uTextureAtlas = { value: texture };
  mat.uniforms.uInvSunDirection.value[2] *= -1;
  mat.uniforms.uAlphaTestThreshold = { value: [alphathreshold] };
  mat.uniformsNeedUpdate = true;
  if (alphamode == "blend") {
    mat.transparent = true;
  }
  if (texture) {
    texture.colorSpace = SRGBColorSpace;
  }
  return mat;
}
function minimapFloorMaterial(texture) {
  let mat = new ShaderMaterial();
  mat.uniforms = {
    uAmbientColour: { value: [0.6059895753860474, 0.5648590922355652, 0.5127604007720947] },
    uAtlasMeta: { value: [512, 16, 1220703125e-13, 4] },
    uCameraPosition: { value: [1638400, 17632, 1769472] },
    uDummy: { value: [1] },
    uFade: { value: [0] },
    uFullScreenLookupScale: { value: [0, 5960465188081798e-23, 1, 0] },
    uGridSize: { value: [512] },
    uInscatteringAmount: { value: [1, 0, 0] },
    uInvSunDirection: { value: [-0.5391638875007629, 0.6469966173171997, -0.5391638875007629] },
    uModelMatrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1622015, 100, 1753087, 1] },
    uOutscatteringAmount: { value: [1638400, 17632, 1769472] },
    uProjectionMatrix: { value: [152587890625e-16, 0, 0, 0, 0, -152587890625e-16, 0, 0, 0, 0, -6200397183420137e-20, 0, 0, 0, -1.0317461490631104, 1] },
    uScatteringParameters: { value: [0, -1, 5960465188081798e-23, 0] },
    uScatteringTintColour: { value: [0, 5960465188081798e-23, 1] },
    uSunColour: { value: [0.8666666746139526, 0.8078431487083435, 0.7333333492279053] },
    uTextureAtlas: { value: [5] },
    uTextureAtlasSettings: { value: [6] },
    uViewMatrix: { value: [1, 0, 0, 0, 0, 5960465188081798e-23, 1, 0, 0, -1, 5960465188081798e-23, 0, -1638400, 1769472, -17632.10546875, 1] },
    uViewProjMatrix: { value: [152587890625e-16, 0, 0, 0, 0, -9094948101931455e-28, -6200397183420137e-20, 0, 0, 152587890625e-16, -3695725149521767e-27, 0, -25, -27, 0.06151437759399414, 1] },
    uViewportLookupScale: { value: [1638400, 17632, 1769472, 0] },
    uViewportOffsetScale: { value: [1, 0, 0, 0] },
    uZBufferParams: { value: [16777248, 32256, -32768, -512.0009765625] }
  };
  mat.vertexColors = true;
  let vert = require_minimap_floor_vert_glsl();
  vert = fixShader(vert);
  vert = replaceUniforms(vert, inputreplace);
  vert = replaceDefines(vert, definereplace);
  let frag = require_minimap_floor_frag_glsl();
  frag = fixShader(frag);
  frag = replaceUniforms(frag, inputreplace);
  frag = replaceDefines(frag, definereplace);
  frag = frag.replace(/#undef gl_FragColor/, "// $&");
  frag = frag.replace(
    /void getTextureSettings\(/,
    "void getTextureSettings(vec2 s, out TextureSettings settings){\nsettings.textureMeta1 = vec3(0.0,0.0,8196.0);\nsettings.textureMeta2 = vec3(0.0,0.0,8196.0);\nsettings.uvAnim = vec2(0.0,0.0);\nsettings.wrapping = 0.0;\nsettings.specular = 0.0;\nsettings.normalScale = 0.0;\n}\nvoid getTextureSettingsOld("
  );
  let gettexelcount = 0;
  frag = injectheader(frag, "in highp vec2 v_texcoord_0;\nin highp vec2 v_texcoord_1;\nin highp vec2 v_texcoord_2;");
  vert = injectheader(vert, "in highp vec2 texcoord_0;\nin highp vec2 texcoord_1;\nin highp vec2 texcoord_2;");
  vert = injectheader(vert, "out highp vec2 v_texcoord_0;\nout highp vec2 v_texcoord_1;\nout highp vec2 v_texcoord_2;");
  vert = injectmain(vert, "v_texcoord_0=texcoord_0;\nv_texcoord_1=texcoord_1;\nv_texcoord_2=texcoord_2;\n");
  frag = frag.replace(/(?<!void )getTexel\(\w+,/gm, () => `getTexel(v_texcoord_${gettexelcount++ % 3},`);
  mat.vertexShader = vert;
  mat.fragmentShader = frag;
  mat.uniforms.uTextureAtlas = { value: texture };
  mat.uniforms.uInvSunDirection.value[2] *= -1;
  mat.uniformsNeedUpdate = true;
  return mat;
}
function minimapWaterMaterial(texture) {
  let mat = new ShaderMaterial();
  mat.customProgramCacheKey = () => "water";
  mat.uniforms = {
    uAmbientColour: { value: [1, 0, 0] },
    uCameraPosition: { value: [1671168, 17344, 1638400] },
    uDummy: { value: [0] },
    uFullScreenLookupScale: { value: [0, 5960465188081798e-23, 1, 0] },
    uInvSunDirection: { value: [1671168, 17344, 1638400] },
    uModelMatrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1654783, 100, 1622015, 1] },
    uProjectionMatrix: { value: [152587890625e-16, 0, 0, 0, 0, -152587890625e-16, 0, 0, 0, 0, -6200397183420137e-20, 0, 0, 0, -1.0317461490631104, 1] },
    uSunColour: { value: [0, 5960465188081798e-23, 1] },
    uViewMatrix: { value: [1, 0, 0, 0, 0, 5960465188081798e-23, 1, 0, 0, -1, 5960465188081798e-23, 0, -1671168, 1638400, -17344.09765625, 1] },
    uViewProjMatrix: { value: [152587890625e-16, 0, 0, 0, 0, -9094948101931455e-28, -6200397183420137e-20, 0, 0, 152587890625e-16, -3695725149521767e-27, 0, -25.5, -25, 0.04365682601928711, 1] },
    uViewportLookupScale: { value: [1671168, 17344, 1638400, 10947093356943706e11] },
    uViewportOffsetScale: { value: [1, 0, 0, 0] },
    uZBufferParams: { value: [16777248, 32256, -32768, -512.0009765625] }
  };
  mat.vertexColors = true;
  let vert = require_minimap_water_vert_glsl();
  vert = fixShader(vert);
  vert = replaceUniforms(vert, inputreplace);
  vert = replaceDefines(vert, definereplace);
  let frag = require_minimap_water_frag_glsl();
  frag = fixShader(frag);
  frag = replaceUniforms(frag, inputreplace);
  frag = replaceDefines(frag, definereplace);
  frag = frag.replace(/#undef gl_FragColor/, "// $&");
  frag = frag.replace(
    /void getTextureSettings\(/,
    "void getTextureSettings(vec2 s, out TextureSettings settings){\nsettings.textureMeta1 = vec3(0.0,0.0,8196.0);\nsettings.textureMeta2 = vec3(0.0,0.0,8196.0);\nsettings.uvAnim = vec2(0.0,0.0);\nsettings.wrapping = 0.0;\nsettings.specular = 0.0;\nsettings.normalScale = 0.0;\n}\nvoid getTextureSettingsOld("
  );
  let gettexelcount = 0;
  frag = injectheader(frag, "in highp vec2 v_texcoord_0;\nin highp vec2 v_texcoord_1;\nin highp vec2 v_texcoord_2;");
  vert = injectheader(vert, "in highp vec2 texcoord_0;\nin highp vec2 texcoord_1;\nin highp vec2 texcoord_2;");
  vert = injectheader(vert, "out highp vec2 v_texcoord_0;\nout highp vec2 v_texcoord_1;\nout highp vec2 v_texcoord_2;");
  vert = injectmain(vert, "v_texcoord_0=texcoord_0;\nv_texcoord_1=texcoord_1;\nv_texcoord_2=texcoord_2;\n");
  frag = frag.replace(/(?<!void )getTexel\(\w+,/gm, () => `getTexel(v_texcoord_${gettexelcount++ % 3},`);
  mat.vertexShader = vert;
  mat.fragmentShader = frag;
  mat.uniforms.uTextureAtlas = { value: texture };
  mat.uniforms.uInvSunDirection.value[2] *= -1;
  mat.uniformsNeedUpdate = true;
  return mat;
}
function injectmain(source, injected) {
  return source.replace(/void main\(\)[\s\r\n]*\{/, "$&\n" + injected);
}
function injectheader(source, injected) {
  return injected + "\n" + source;
}
function replaceUniforms(source, unis) {
  return source.replace(/^((flat) )*(in|out|uniform|attribute|varying) ((highp|mediump|lowp) )*(float|vec\d|mat\d) ((\w|,\s*)+);$/mg, (m, mods, mod, vartype, precs, prec, datatype, varnames) => {
    return varnames.split(/,\s*/g).map((varname) => {
      let repl = unis[varname];
      if (repl != void 0) {
        let value = typeof repl == "function" ? repl() : repl;
        value = Array.isArray(value) ? value.join("\n") : value + "\n";
        return m.split("\n").map((q) => `// ${q}`).join("\n") + "\n" + value;
      }
      return `${mods ?? ""}${vartype} ${precs ?? ""}${datatype ?? ""} ${varname};`;
    }).join("\n");
  });
}
function replaceDefines(source, defs) {
  return source.replace(/^#define (\w+)(\(.*?\))?($| (\\\r?\n|.)*$)/mg, (m, defname) => {
    let repl = defs[defname];
    if (repl != void 0) {
      let value = typeof repl == "function" ? repl() : repl;
      value = Array.isArray(value) ? value.join("\n") : value + "\n";
      return m.split("\n").map((q) => `// ${q}`).join("\n") + "\n" + value;
    }
    return m;
  });
}
function wrapMain(source, newmain) {
  source = source.replace(/\bvoid main\(/, "void originalMain(");
  source = source + "\n" + newmain.replace(/super\(/, "originalMain(");
  return source;
}
function fixShader(source) {
  let header = [
    // `#version 300 es`,//highest version we can choose in webgl2
    `precision highp float;`,
    `precision mediump sampler3D;`,
    `#define fma(a,b,c) ((a)*(b)+(c))`
    //fma doesn't exist
  ].join("\n") + "\n\n";
  return header + source.replace(/^#version ([\w ]+)$/m, "//original version $1").replace(/\bprecise\b/g, "highp");
}

// rsmv/src/scripts/dependencies.ts
var depids = arrayEnum(["material", "model", "item", "loc", "mapsquare", "sequence", "skeleton", "frameset", "animgroup", "npc", "framebase", "texture", "enum", "overlay", "underlay"]);
var depidmap = Object.fromEntries(depids.map((q, i) => [q, i]));
function chunkDeps(data, addDep, addHash) {
  let squareindex = data.mapsquarex + data.mapsquarez * worldStride;
  addHash("mapsquare", squareindex, data.chunkfilehash, data.chunkfileversion);
  for (let loc of data.rawlocs) {
    addDep("loc", loc.id, "mapsquare", squareindex);
  }
  let overlays = /* @__PURE__ */ new Set();
  let underlays = /* @__PURE__ */ new Set();
  for (let tile2 of data.tiles) {
    if (tile2.overlay != null) {
      overlays.add(tile2.overlay);
    }
    if (tile2.underlay != null) {
      underlays.add(tile2.underlay);
    }
  }
  overlays.forEach((id) => addDep("overlay", id, "mapsquare", squareindex));
  underlays.forEach((id) => addDep("underlay", id, "mapsquare", squareindex));
}
var mapsquareDeps2 = async (cache, addDep, addHash, args) => {
  await trickleTasksTwoStep(20, function* () {
    let rect = args?.area ?? { x: 0, z: 0, xsize: 100, zsize: 200 };
    for (let z = rect.z; z < rect.z + rect.zsize; z++) {
      for (let x = rect.x; x < rect.x + rect.xsize; x++) {
        yield getMapsquareData(cache, x, z);
        ;
      }
    }
  }, (data) => {
    if (!data) {
      return;
    }
    chunkDeps(data, addDep, addHash);
  });
};
function coltoint(col) {
  if (!col) {
    return 16711935;
  }
  return col[0] << 16 | col[1] << 8 | col[2];
}
function hashFloorType(lay, hash) {
  hash = crc32addInt(+!!lay.bleedToUnderlay, hash);
  hash = crc32addInt(lay.bleedpriority ?? -1, hash);
  hash = crc32addInt(lay.materialbyte ?? lay.material ?? -1, hash);
  hash = crc32addInt(coltoint(lay.color), hash);
  hash = crc32addInt(coltoint(lay.secondary_colour), hash);
  hash = crc32addInt(coltoint(lay.tertiary_colour), hash);
  hash = crc32addInt(lay.material_tiling ?? -1, hash);
  return hash;
}
var mapUnderlayDeps = async (cache, addDep, addHash) => {
  for (let [id, underlay] of cache.mapUnderlays.entries()) {
    if (!underlay) {
      continue;
    }
    let crc = hashFloorType(underlay, 0);
    addHash("underlay", id, crc, 0);
    if (underlay.material) {
      addDep("material", underlay.material, "underlay", id);
    }
  }
};
var mapOverlayDeps = async (cache, addDep, addHash) => {
  for (let [id, overlay] of cache.mapOverlays.entries()) {
    if (!overlay) {
      continue;
    }
    let crc = hashFloorType(overlay, 0);
    if (overlay.material) {
      addDep("material", overlay.material, "overlay", id);
    }
    addHash("overlay", id, crc, 0);
  }
};
var locationDeps = async (cache, addDep, addHash) => {
  if (cache.classicData) {
    for (let [id, loc] of cache.classicData.objects.entries()) {
      let hash = crc32(Buffer.from(JSON.stringify(loc)));
      addHash("loc", id, hash, 0);
      if (loc.model.id != void 0) {
        addDep("model", loc.model.id, "loc", id);
      }
    }
  } else {
    for await (let { id, file } of iterateConfigFiles(cache, cacheMajors.objects)) {
      addHash("loc", id, crc32(file), 0);
      let loc = parse.object.read(file, cache);
      if (loc.probably_animation) {
        addDep("sequence", loc.probably_animation, "loc", id);
      }
      if (loc.models) {
        for (let group of loc.models) {
          for (let model of group.values) {
            addDep("model", model, "loc", id);
          }
        }
      }
      if (loc.models_05) {
        for (let group of loc.models_05.models) {
          for (let model of group.values) {
            addDep("model", model, "loc", id);
          }
        }
      }
      if (loc.morphs_1 || loc.morphs_2) {
        let morphid = defaultMorphId(loc);
        if (morphid != -1) {
          addDep("loc", morphid, "loc", id);
        }
      }
    }
  }
};
var itemDeps = async (cache, addDep, addHash) => {
  if (cache.classicData) {
    for (let [id, item] of cache.classicData.items.entries()) {
      let hash = crc32(Buffer.from(JSON.stringify(item)));
      addHash("item", id, hash, 0);
    }
  } else {
    for await (let { id, file } of iterateConfigFiles(cache, cacheMajors.items)) {
      addHash("item", id, crc32(file), 0);
      let item = parse.item.read(file, cache);
      let models = [].concat(
        item.baseModel,
        item.maleModels_0?.id,
        item.maleModels_1,
        item.maleModels_2,
        item.femaleModels_0?.id,
        item.femaleModels_1,
        item.femaleModels_2,
        item.maleHeads_0,
        item.maleHeads_1,
        item.femaleHeads_0,
        item.femaleHeads_1
      ).filter((q) => typeof q == "number");
      for (let model of models) {
        addDep("model", model, "item", id);
      }
      if (item.noteTemplate) {
        addDep("item", item.noteTemplate, "item", id);
      }
    }
  }
};
var animgroupDeps = async (cache, addDep, addHash) => {
  if (cache.getBuildNr() < 526) {
    return;
  }
  let animgroupfiles = await cache.getArchiveById(cacheMajors.config, cacheConfigPages.animgroups);
  for (let file of animgroupfiles) {
    addHash("animgroup", file.fileid, crc32(file.buffer), 0);
    let animgroup = parse.animgroupConfigs.read(file.buffer, cache);
    let anim = animgroup.unknown_26 ?? animgroup.baseAnims?.idle;
    if (anim) {
      addDep("sequence", anim, "animgroup", file.fileid);
    }
  }
};
var materialDeps2 = async (cache, addDep, addHash) => {
  if (cache.getBuildNr() <= lastLegacyBuildnr) {
    let mats = await cache.getArchiveById(legacyMajors.data, legacyGroups.textures);
    for (let id of mats.map((q) => q.fileid)) {
      addHash("material", id, 0, 0);
      addDep("texture", id, "material", id);
    }
  } else if (cache.getBuildNr() <= 471) {
    let arch = await cache.getArchiveById(cacheMajors.texturesOldPng, 0);
    for (let mat of arch) {
      addHash("material", mat.fileid, crc32(mat.buffer), 0);
      let matdata = parse.oldproctexture.read(mat.buffer, cache);
      addDep("texture", matdata.spriteid, "material", mat.fileid);
    }
  } else if (cache.getBuildNr() < 759) {
  } else {
    let arch = await cache.getArchiveById(cacheMajors.materials, 0);
    for (let file of arch) {
      addHash("material", file.fileid, crc32(file.buffer), 0);
      let mat = convertMaterial(file.buffer, file.fileid, cache);
      for (let tex of Object.values(mat.textures)) {
        if (typeof tex == "number") {
          addDep("texture", tex, "material", file.fileid);
        }
      }
    }
  }
};
var npcDeps = async (cache, addDep, addHash) => {
  if (cache.classicData) {
    for (let [id, npc] of cache.classicData.npcs.entries()) {
      let hash = crc32(Buffer.from(JSON.stringify(npc)));
      addHash("npc", id, hash, 0);
    }
  } else {
    for await (let { id, file } of iterateConfigFiles(cache, cacheMajors.npcs)) {
      addHash("npc", id, crc32(file), 0);
      let npc = parse.npc.read(file, cache);
      if (npc.animation_group) {
        addDep("animgroup", npc.animation_group, "npc", id);
      }
      if (npc.models) {
        for (let model of npc.models) {
          addDep("model", model, "npc", id);
        }
      }
      if (npc.headModels) {
        for (let model of npc.headModels) {
          addDep("model", model, "npc", id);
        }
      }
    }
  }
};
async function getDependencies(cache, args) {
  let dependentsMap = /* @__PURE__ */ new Map();
  let dependencyMap = /* @__PURE__ */ new Map();
  let hashes = /* @__PURE__ */ new Map();
  let addDep = (holdertype, holderId, deptType, depId) => {
    let holder = `${holdertype}-${holderId}`;
    let newdep = `${deptType}-${depId}`;
    let dependencies = dependencyMap.get(newdep);
    if (!dependencies) {
      dependencies = [];
      dependencyMap.set(newdep, dependencies);
    }
    if (dependencies.indexOf(holder) == -1) {
      dependencies.push(holder);
    }
    let deps = dependentsMap.get(holder);
    if (!deps) {
      deps = [];
      dependentsMap.set(holder, deps);
    }
    if (deps.indexOf(newdep) == -1) {
      deps.push(newdep);
    }
  };
  let addHash = (deptType, depId, hash, version) => {
    let depname = `${deptType}-${depId}`;
    hashes.set(depname, hash);
  };
  let runDependencyGroup = async (run2, args2) => {
    try {
      console.log(`starting ${run2.name}`);
      let t = Date.now();
      await run2(cache, addDep, addHash, args2);
      console.log(`finished ${run2.name}, duration ${((Date.now() - t) / 1e3).toFixed(1)}`);
    } catch (e) {
      debugger;
      throw e;
    }
  };
  let runs = [
    // mapsquareDeps2,
    locationDeps,
    itemDeps,
    animgroupDeps,
    materialDeps2,
    npcDeps,
    mapOverlayDeps,
    mapUnderlayDeps
    // modelDeps,
    // sequenceDeps,
    // skeletonDeps,
    // framesetDeps,
  ];
  for (let run2 of runs) {
    await runDependencyGroup(run2, args);
  }
  let preloadChunkDependencies = (args2) => {
    return runDependencyGroup(mapsquareDeps2, args2);
  };
  let makeDeptName = (deptType, id) => {
    return `${deptType}-${id}`;
  };
  let cascadeDependencies = (depname, list = []) => {
    let hash = hashes.get(depname) ?? 0;
    let hashtext = `${depname}-${hash}`;
    if (!list.includes(hashtext)) {
      list.push(hashtext);
      let deps = dependencyMap.get(depname);
      if (deps) {
        for (let dep of deps) {
          cascadeDependencies(dep, list);
        }
      }
    }
    return list;
  };
  let hashDependencies = (depname, previouscrc = 0) => {
    let hash = hashes.get(depname) ?? 0;
    let [type, id] = depname.split("-");
    let crc = previouscrc;
    crc = crc32addInt(depidmap[type], crc);
    crc = crc32addInt(+id, crc);
    crc = crc32addInt(+hash, crc);
    let deps = dependencyMap.get(depname);
    if (deps) {
      for (let dep of deps) {
        crc = hashDependencies(dep, crc);
      }
    }
    return crc;
  };
  let hasEntry = (deptType, depId) => {
    return hashes.has(makeDeptName(deptType, depId));
  };
  let insertMapChunk = (data) => {
    chunkDeps(data, addDep, addHash);
    let squareindex = data.mapsquarex + data.mapsquarez * worldStride;
    return makeDeptName("mapsquare", squareindex);
  };
  return { dependencyMap, dependentsMap, cascadeDependencies, makeDeptName, hashDependencies, hasEntry, insertMapChunk, preloadChunkDependencies };
}

// rsmv/src/3d/modeltothree.ts
var constModelOffset = 1e6;
var constModelsIds = {
  materialCube: constModelOffset + 1,
  classicWall: constModelOffset + 2,
  classicWallDiag: constModelOffset + 3,
  classicRoof10: constModelOffset + 10,
  classicRoof12: constModelOffset + 12,
  classicRoof13: constModelOffset + 13,
  classicRoof14: constModelOffset + 14,
  classicRoof15: constModelOffset + 15,
  classicRoof16: constModelOffset + 16,
  classicRoof17: constModelOffset + 17
};
var constModels = /* @__PURE__ */ new Map([
  [constModelsIds.materialCube, Promise.resolve(materialPreviewCube)],
  [constModelsIds.classicWall, Promise.resolve(classicWall)],
  [constModelsIds.classicWallDiag, Promise.resolve(classicWallDiag)],
  [constModelsIds.classicRoof10, Promise.resolve(classicRoof10)],
  [constModelsIds.classicRoof12, Promise.resolve(classicRoof12)],
  [constModelsIds.classicRoof13, Promise.resolve(classicRoof13)],
  [constModelsIds.classicRoof14, Promise.resolve(classicRoof14)],
  [constModelsIds.classicRoof15, Promise.resolve(classicRoof15)],
  [constModelsIds.classicRoof16, Promise.resolve(classicRoof16)],
  [constModelsIds.classicRoof17, Promise.resolve(classicRoof17)]
]);
function augmentZOffsetMaterial(mat, zoffset) {
  mat.customProgramCacheKey = () => "zoffset" + zoffset;
  mat.onBeforeCompile = (shader) => {
    shader.vertexShader = shader.vertexShader.replace(/#include <(\w+)>/g, (m, n) => `// == ${n} ==
${m}`);
    shader.vertexShader = shader.vertexShader.replace("#include <project_vertex>", `
			#include <project_vertex>
			mvPosition.xyz -= normalize(mvPosition.xyz) * ${zoffset.toExponential()};
			gl_Position = projectionMatrix * mvPosition;
		`);
  };
}
function augmentThreeJsFloorMaterial(mat, isminimap) {
  mat.customProgramCacheKey = () => isminimap ? "minimaptex" : "floortex";
  mat.onBeforeCompile = (shader, renderer) => {
    shader.vertexShader = `#ifdef USE_MAP
attribute vec2 texcoord_0;
attribute vec2 texcoord_1;
attribute vec2 texcoord_2;
attribute vec3 color_1;
attribute vec3 color_2;
varying vec2 v_ra_floortex_0;
varying vec2 v_ra_floortex_1;
varying vec2 v_ra_floortex_2;
varying vec3 v_ra_floortex_weights;
varying vec3 v_ra_floortex_usescolor;
#endif
` + shader.vertexShader.replace(
      "#include <uv_vertex>",
      `#ifdef USE_MAP
v_ra_floortex_0 = texcoord_0;
v_ra_floortex_1 = texcoord_1;
v_ra_floortex_2 = texcoord_2;
v_ra_floortex_weights = color_1;
v_ra_floortex_usescolor = color_2;
#endif
#include <uv_vertex>`
    );
    shader.fragmentShader = `#ifdef USE_MAP
varying vec2 v_ra_floortex_0;
varying vec2 v_ra_floortex_1;
varying vec2 v_ra_floortex_2;
varying vec3 v_ra_floortex_weights;
varying vec3 v_ra_floortex_usescolor;
#endif

highp vec3 runeapps_srgb_to_linear(highp vec3 color,float gamma){
	return pow(color.rgb,vec3(1.0/gamma));
}
highp vec3 runeapps_linear_to_srgb(highp vec3 color,float gamma){
	return pow(color.rgb,vec3(gamma));
}
` + shader.fragmentShader.replace("#include <color_fragment>", "").replace(
      "#include <map_fragment>",
      `#include <color_fragment>
#ifdef USE_MAP
vec4 texelColor = 
` + (isminimap ? `   v_ra_floortex_weights.r * mix(texture2D( map, v_ra_floortex_0 ), diffuseColor * 0.5, v_ra_floortex_usescolor.r)
 + v_ra_floortex_weights.g * mix(texture2D( map, v_ra_floortex_1 ), diffuseColor * 0.5, v_ra_floortex_usescolor.g)
 + v_ra_floortex_weights.b * mix(texture2D( map, v_ra_floortex_2 ), diffuseColor * 0.5, v_ra_floortex_usescolor.b);
` : `   texture2D( map, v_ra_floortex_0 ) * v_ra_floortex_weights.r * mix(vec4(1.0), diffuseColor, v_ra_floortex_usescolor.r)
 + texture2D( map, v_ra_floortex_1 ) * v_ra_floortex_weights.g * mix(vec4(1.0), diffuseColor, v_ra_floortex_usescolor.g)
 + texture2D( map, v_ra_floortex_2 ) * v_ra_floortex_weights.b * mix(vec4(1.0), diffuseColor, v_ra_floortex_usescolor.b);
`) + `texelColor = mix( diffuseColor,texelColor,dot(vec3(1.0),v_ra_floortex_weights));
#endif
diffuseColor = texelColor;
`
    );
    if (isminimap) {
      shader.fragmentShader = shader.fragmentShader.replace(
        "#include <colorspace_fragment>",
        "const float outgamma=2.3;\ngl_FragColor.rgb = runeapps_srgb_to_linear(gl_FragColor.rgb,outgamma);\n"
        //don't blame me for this, this is literally how the minimap is rendered
      ).replace(
        "#include <lights_fragment_begin>",
        `#include <lights_fragment_begin>
irradiance =  runeapps_linear_to_srgb(0.5*getAmbientLightIrradiance( ambientLightColor ),2.4);
irradiance += runeapps_linear_to_srgb(0.5*getLightProbeIrradiance( lightProbe, geometry.normal ),2.4);
`
        // + `irradiance *= 0.5;\n`
      );
    }
  };
}
var EngineCache4 = class _EngineCache extends CachingFileSource {
  constructor(source) {
    super(source);
    this.hasOldModels = false;
    this.hasNewModels = false;
    this.materialArchive = /* @__PURE__ */ new Map();
    this.materialCache = /* @__PURE__ */ new Map();
    this.mapUnderlays = [];
    this.mapOverlays = [];
    this.mapMapscenes = [];
    this.mapMaplabels = [];
    this.legacyData = null;
    this.classicData = null;
    this.jsonSearchCache = /* @__PURE__ */ new Map();
    this.dependencyGraph = null;
  }
  static create(source) {
    return new _EngineCache(source).preload();
  }
  async preload() {
    if (this.getBuildNr() > lastLegacyBuildnr) {
      for (let subfile of await this.getArchiveById(cacheMajors.config, cacheConfigPages.mapunderlays)) {
        this.mapUnderlays[subfile.fileid] = parse.mapsquareUnderlays.read(subfile.buffer, this.rawsource);
      }
      for (let subfile of await this.getArchiveById(cacheMajors.config, cacheConfigPages.mapoverlays)) {
        this.mapOverlays[subfile.fileid] = parse.mapsquareOverlays.read(subfile.buffer, this.rawsource);
      }
      if (this.getBuildNr() >= 527) {
        for (let subfile of await this.getArchiveById(cacheMajors.config, cacheConfigPages.mapscenes)) {
          this.mapMapscenes[subfile.fileid] = parse.mapscenes.read(subfile.buffer, this.rawsource);
        }
      }
      if (this.getBuildNr() >= 548) {
        for (let subfile of await this.getArchiveById(cacheMajors.config, cacheConfigPages.maplabels)) {
          this.mapMaplabels[subfile.fileid] = parse.maplabels.read(subfile.buffer, this.rawsource);
        }
      }
      if (this.getBuildNr() <= 471) {
        for (let file of await this.getArchiveById(cacheMajors.texturesOldPng, 0)) {
          this.materialArchive.set(file.fileid, file.buffer);
        }
      } else if (this.getBuildNr() <= 498) {
      } else if (this.getBuildNr() <= 753) {
        let file = await this.getFile(cacheMajors.materials, 0);
        this.materialArchive.set(0, file);
      } else {
        for (let file of await this.getArchiveById(cacheMajors.materials, 0)) {
          this.materialArchive.set(file.fileid, file.buffer);
        }
      }
      let rootindex = await this.getCacheIndex(cacheMajors.index);
      this.hasNewModels = !!rootindex[cacheMajors.models];
      this.hasOldModels = !!rootindex[cacheMajors.oldmodels];
    } else if (this.getBuildNr() > lastClassicBuildnr) {
      this.legacyData = await legacyPreload(this);
      let floors = this.legacyData.overlays.map((q) => parse.mapsquareOverlays.read(q, this));
      this.mapOverlays = floors;
      this.mapUnderlays = floors;
      this.hasNewModels = false;
      this.hasOldModels = true;
    } else {
      if (!(this.rawsource instanceof ClassicFileSource)) {
        throw new Error("can only load classic caches from a classic source");
      }
      this.classicData = await classicConfig(this.rawsource, this.getBuildNr());
      this.mapUnderlays = classicUnderlays();
      this.mapOverlays = await classicOverlays(this);
      this.hasNewModels = false;
      this.hasOldModels = true;
    }
    return this;
  }
  async getDependencyGraph() {
    this.dependencyGraph ??= getDependencies(this, { lazyMapChunks: true });
    return this.dependencyGraph;
  }
  async getGameFile(type, id) {
    if (this.legacyData) {
      return this.legacyData[type][id];
    } else {
      return this.getFileById(cacheMajors[type], id);
    }
  }
  getMaterialData(id) {
    let cached = this.materialCache.get(id);
    if (!cached) {
      if (id == -1) {
        cached = defaultMaterial();
      } else {
        if (this.getBuildNr() <= lastLegacyBuildnr) {
          cached = defaultMaterial();
          cached.textures.diffuse = id;
          cached.baseColorFraction = 1;
          cached.texmodes = "mirror";
          cached.texmodet = "mirror";
        } else if (this.getBuildNr() <= 471) {
          let file = this.materialArchive.get(id);
          if (!file) {
            throw new Error("material " + id + " not found");
          }
          let matprops = parse.oldproctexture.read(file, this);
          cached = defaultMaterial();
          cached.textures.diffuse = matprops.spriteid;
          cached.baseColorFraction = 1;
        } else if (this.getBuildNr() <= 753) {
          cached = defaultMaterial();
          if (this.getBuildNr() >= 500) {
            let matlist = parse.oldmaterials.read(this.materialArchive.get(0), this);
            let matdata = matlist.mats[id];
            if (matdata.basecolorfraction != null && matdata.basecolor != null) {
              cached.baseColorFraction = matdata.basecolorfraction / 255;
              cached.baseColor = HSL2RGBfloat(packedHSL2HSL(matdata.basecolor));
            }
            cached.textures.diffuse = matdata.id;
          }
        } else {
          let file = this.materialArchive.get(id);
          if (!file) {
            throw new Error("material " + id + " not found");
          }
          cached = convertMaterial(file, id, this.rawsource);
        }
      }
      this.materialCache.set(id, cached);
    }
    return cached;
  }
  /**
   * very aggressive caching, do not use for objects which take a lot of memory
   */
  getJsonSearchData(modename) {
    let cached = this.jsonSearchCache.get(modename);
    if (!cached) {
      let mode = cacheFileJsonModes[modename];
      if (!mode) {
        throw new Error("unknown decode mode " + modename);
      }
      let files = (async () => {
        await mode.prepareDump?.(this);
        let allfiles = await mode.lookup.logicalRangeToFiles(this, [0, 0], [Infinity, Infinity]);
        let lastarchive = null;
        let files2 = [];
        for (let fileid of allfiles) {
          let arch;
          if (lastarchive && lastarchive.index == fileid.index) {
            arch = lastarchive.subfiles;
          } else {
            arch = await this.getFileArchive(fileid.index);
            lastarchive = { index: fileid.index, subfiles: arch };
          }
          let file = arch[fileid.subindex];
          let logicalid = mode.lookup.fileToLogical(this, fileid.index.major, fileid.index.minor, file.fileid);
          let res = mode.parser.read(file.buffer, this.rawsource);
          res.$fileid = logicalid.length == 1 ? logicalid[0] : logicalid;
          files2.push(res);
        }
        return files2;
      })();
      cached = { files, schema: mode.parser.parser.getJsonSchema() };
      this.jsonSearchCache.set(modename, cached);
    }
    return cached;
  }
};
async function* iterateConfigFiles(cache, major) {
  if (cache.legacyData) {
    let files = null;
    if (major == cacheMajors.items) {
      files = cache.legacyData.items;
    } else if (major == cacheMajors.npcs) {
      files = cache.legacyData.npcs;
    } else if (major == cacheMajors.objects) {
      files = cache.legacyData.objects;
    } else if (major == cacheMajors.spotanims) {
      files = cache.legacyData.spotanims;
    }
    if (!files) {
      throw new Error(`cache major ${major} can not be iterated`);
    }
    yield* files.map((file, id) => ({ id, file }));
  } else if (cache.getBuildNr() <= 488) {
    let arch = await cache.getArchiveById(cacheMajors.config, oldConfigMaps[major]);
    yield* arch.map((q) => ({ id: q.fileid, file: q.buffer }));
  } else {
    let locindices = await cache.getCacheIndex(major);
    let stride = mappedFileIds[major];
    for (let index of locindices) {
      if (!index) {
        continue;
      }
      let arch = await cache.getFileArchive(index);
      yield* arch.map((q) => ({ id: index.minor * stride + q.fileid, file: q.buffer }));
    }
  }
}
async function detectTextureMode(source) {
  let detectmajor = async (major) => {
    let lastfile = -1;
    try {
      let indexfile = await source.getCacheIndex(major);
      let last = indexfile[indexfile.length - 1];
      await source.getFile(last.major, last.minor, last.crc);
      lastfile = last.minor;
    } catch (e) {
    }
    return lastfile;
  };
  let textureMode = "none";
  if (source.getBuildNr() <= lastClassicBuildnr) {
    let texindex = await source.findSubfileByName(0, classicGroups.textures, "INDEX.DAT");
    textureMode = texindex ? "legacy" : "legacytga";
  } else if (source.getBuildNr() <= lastLegacyBuildnr) {
    textureMode = "legacy";
  } else if (source.getBuildNr() <= 471) {
    textureMode = "oldproc";
  } else if (source.getBuildNr() <= 736) {
    textureMode = "fullproc";
  } else {
    let numbmp = await detectmajor(cacheMajors.texturesBmp);
    let numdds = await detectmajor(cacheMajors.texturesDds);
    if (numbmp > 0 || numdds > 0) {
      textureMode = numbmp > numdds ? "bmp" : "dds";
    } else {
      let numpng2014 = await detectmajor(cacheMajors.textures2015Png);
      let numdds2014 = await detectmajor(cacheMajors.textures2015Dds);
      if (numpng2014 > 0 || numdds2014 >= 0) {
        textureMode = numdds2014 > numpng2014 ? "dds2014" : "png2014";
      } else if (await detectmajor(cacheMajors.texturesOldPng) > 0) {
        textureMode = "oldpng";
      } else {
        textureMode = "none";
      }
    }
  }
  console.log(`detectedtexture mode. ${textureMode}`);
  return textureMode;
}
async function convertMaterialToThree(source, material, hasVertexAlpha, minimapVariant) {
  let mat = new THREE4.MeshStandardMaterial();
  mat.alphaTest = material.alphamode == "cutoff" ? 0.5 : 0.1;
  mat.transparent = hasVertexAlpha || material.alphamode == "blend";
  const wraptypes = material.texmodes == "clamp" ? THREE4.ClampToEdgeWrapping : material.texmodes == "repeat" ? THREE4.RepeatWrapping : THREE4.MirroredRepeatWrapping;
  const wraptypet = material.texmodet == "clamp" ? THREE4.ClampToEdgeWrapping : material.texmodet == "repeat" ? THREE4.RepeatWrapping : THREE4.MirroredRepeatWrapping;
  if (typeof material.textures.diffuse != "undefined" && source.textureType != "none") {
    let diffuse = await (await source.getTextureFile("diffuse", material.textures.diffuse, material.stripDiffuseAlpha)).toImageData();
    let difftex = new THREE4.DataTexture(diffuse.data, diffuse.width, diffuse.height, THREE4.RGBAFormat);
    difftex.needsUpdate = true;
    difftex.wrapS = wraptypes;
    difftex.wrapT = wraptypet;
    difftex.colorSpace = THREE4.SRGBColorSpace;
    difftex.magFilter = THREE4.LinearFilter;
    difftex.minFilter = THREE4.NearestMipMapNearestFilter;
    difftex.generateMipmaps = true;
    mat.map = difftex;
    if (material.textures.normal) {
      let parsed = await source.getTextureFile("normal", material.textures.normal, false);
      let raw = await parsed.toImageData();
      let normals = makeImageData(null, raw.width, raw.height);
      let emisive = makeImageData(null, raw.width, raw.height);
      const data = raw.data;
      for (let i = 0; i < data.length; i += 4) {
        let dx = data[i + 1] / 127.5 - 1;
        let dy = data[i + 3] / 127.5 - 1;
        normals.data[i + 0] = data[i + 1];
        normals.data[i + 1] = data[i + 3];
        normals.data[i + 2] = (Math.sqrt(Math.max(1 - dx * dx - dy * dy, 0)) + 1) * 127.5;
        normals.data[i + 3] = 255;
        const emissive = data[i + 0] / 255;
        emisive.data[i + 0] = diffuse.data[i + 0] * emissive;
        emisive.data[i + 1] = diffuse.data[i + 1] * emissive;
        emisive.data[i + 2] = diffuse.data[i + 2] * emissive;
        emisive.data[i + 3] = 255;
      }
      mat.normalMap = new THREE4.DataTexture(normals.data, normals.width, normals.height, THREE4.RGBAFormat);
      mat.normalMap.needsUpdate = true;
      mat.normalMap.wrapS = wraptypes;
      mat.normalMap.wrapT = wraptypet;
      mat.normalMap.magFilter = THREE4.LinearFilter;
      mat.emissiveMap = new THREE4.DataTexture(emisive.data, emisive.width, emisive.height, THREE4.RGBAFormat);
      mat.emissiveMap.needsUpdate = true;
      mat.emissiveMap.wrapS = wraptypes;
      mat.emissiveMap.wrapT = wraptypet;
      mat.emissiveMap.magFilter = THREE4.LinearFilter;
      mat.emissive.setRGB(1, 1, 1);
    }
    if (material.textures.compound) {
      let compound = await (await source.getTextureFile("compound", material.textures.compound, false)).toImageData();
      let compoundmapped = makeImageData(null, compound.width, compound.height);
      for (let i = 0; i < compound.data.length; i += 4) {
        compoundmapped.data[i + 1] = compound.data[i + 1];
        compoundmapped.data[i + 2] = compound.data[i + 0];
        compoundmapped.data[i + 3] = 255;
      }
      let tex = new THREE4.DataTexture(compoundmapped.data, compoundmapped.width, compoundmapped.height, THREE4.RGBAFormat);
      tex.needsUpdate = true;
      tex.wrapS = wraptypes;
      tex.wrapT = wraptypet;
      tex.colorSpace = THREE4.SRGBColorSpace;
      tex.magFilter = THREE4.LinearFilter;
      mat.metalnessMap = tex;
      mat.roughnessMap = tex;
      mat.metalness = 1;
    }
  }
  mat.vertexColors = material.baseColorFraction != 1 || !material.textures.diffuse || hasVertexAlpha;
  mat.userData = material;
  if (material.uvAnim) {
    (mat.userData.gltfExtensions ??= {}).RA_materials_uvanim = {
      uvAnim: [material.uvAnim.u, material.uvAnim.v]
    };
  }
  if (minimapVariant) {
    mat = minimapLocMaterial(mat.map, material.alphamode, material.alphacutoff);
  }
  return { mat, matmeta: material };
}
var ThreejsSceneCache2 = class _ThreejsSceneCache {
  constructor(scenecache, modeltype) {
    this.modelCache = /* @__PURE__ */ new Map();
    this.threejsTextureCache = /* @__PURE__ */ new Map();
    this.threejsMaterialCache = /* @__PURE__ */ new Map();
    this.textureType = "dds";
    this.modelType = "nxt";
    this.engine = scenecache;
    if (modeltype != "auto") {
      this.modelType = modeltype;
    } else if (scenecache.getBuildNr() <= lastClassicBuildnr) {
      this.modelType = "classic";
    } else if (scenecache.hasOldModels && !scenecache.hasNewModels) {
      this.modelType = "old";
    } else {
      this.modelType = "nxt";
    }
  }
  static {
    this.textureIndices = {
      diffuse: {
        png: cacheMajors.texturesPng,
        dds: cacheMajors.texturesDds,
        bmp: cacheMajors.texturesBmp,
        ktx: cacheMajors.texturesKtx,
        png2014: cacheMajors.textures2015Png,
        dds2014: cacheMajors.textures2015Dds,
        oldpng: cacheMajors.texturesOldPng,
        oldproc: cacheMajors.sprites,
        fullproc: cacheMajors.texturesOldPng,
        legacy: legacyMajors.data,
        legacytga: 0
      },
      normal: {
        png: cacheMajors.texturesPng,
        dds: cacheMajors.texturesDds,
        bmp: cacheMajors.texturesBmp,
        ktx: cacheMajors.texturesKtx,
        //TODO are these normals or compounds?
        png2014: cacheMajors.textures2015CompoundPng,
        dds2014: cacheMajors.textures2015CompoundDds,
        oldpng: cacheMajors.texturesOldCompoundPng,
        oldproc: 0,
        fullproc: 0,
        legacy: 0,
        legacytga: 0
      },
      compound: {
        png: cacheMajors.texturesPng,
        dds: cacheMajors.texturesDds,
        bmp: cacheMajors.texturesBmp,
        ktx: cacheMajors.texturesKtx,
        //TODO are these normals or compounds?
        png2014: cacheMajors.textures2015CompoundPng,
        dds2014: cacheMajors.textures2015CompoundDds,
        oldpng: cacheMajors.texturesOldCompoundPng,
        oldproc: 0,
        fullproc: 0,
        legacy: 0,
        legacytga: 0
      }
    };
  }
  static async create(engine, texturemode = "auto", modelmode = "auto") {
    let scene = new _ThreejsSceneCache(engine, modelmode);
    scene.textureType = texturemode == "auto" ? await detectTextureMode(engine.rawsource) : texturemode;
    return scene;
  }
  getTextureFile(type, texid, stripAlpha) {
    let cacheindex = _ThreejsSceneCache.textureIndices[type][this.textureType];
    let cachekey = (cacheindex | 255) << 23 | texid;
    let texmode = this.textureType;
    return this.engine.fetchCachedObject(this.threejsTextureCache, cachekey, async () => {
      if (texmode == "fullproc") {
        let tex = await loadProcTexture(this.engine, texid);
        let parsed = new ParsedTexture(tex.img, false, false);
        parsed.filesize = tex.filesize;
        return parsed;
      } else if (texmode == "legacytga" || texmode == "legacy") {
        let img;
        if (this.engine.classicData) {
          let texmeta = this.engine.classicData.textures[texid - 1];
          img = await combineLegacyTexture(this.engine, texmeta.name, texmeta.subname, texmode == "legacytga");
        } else {
          let imgfile = await this.engine.getArchiveById(legacyMajors.data, legacyGroups.textures);
          img = await parseLegacyImageFile(this.engine, imgfile[texid].buffer);
        }
        return new ParsedTexture(img.img, stripAlpha, false);
      } else {
        let file = await this.engine.getFileById(cacheindex, texid);
        if (texmode == "oldproc") {
          let sprite = parseSprite(file);
          return new ParsedTexture(sprite[0].img, stripAlpha, false);
        } else {
          return new ParsedTexture(file, stripAlpha, true);
        }
      }
    }, (obj) => obj.filesize * 2);
  }
  getModelData(id) {
    if (id >= constModelOffset) {
      let res = constModels.get(id);
      if (!res) {
        throw new Error(`constmodel ${id} does not exist`);
      }
      return res;
    }
    return this.engine.fetchCachedObject(this.modelCache, id, async () => {
      if (this.modelType == "nxt") {
        let file = await this.engine.getFileById(cacheMajors.models, id);
        return parseOb3Model(file, this.engine);
      } else if (this.modelType == "old") {
        let major = this.engine.legacyData ? legacyMajors.oldmodels : cacheMajors.oldmodels;
        let file = await this.engine.getFileById(major, id);
        return parseRT5Model(file, this.engine.rawsource);
      } else if (this.modelType == "classic") {
        let arch = await this.engine.getArchiveById(0, classicGroups.models);
        return parseRT2Model(arch[id].buffer, this.engine);
      } else {
        throw new Error("unexpected");
      }
    }, (obj) => obj.meshes.reduce((a, m) => m.indices.count, 0) * 30);
  }
  getMaterial(matid, hasVertexAlpha, minimapVariant) {
    let matcacheid = materialCacheKey(matid, hasVertexAlpha, minimapVariant);
    return this.engine.fetchCachedObject(this.threejsMaterialCache, matcacheid, async () => {
      let material = this.engine.getMaterialData(matid);
      return convertMaterialToThree(this, material, hasVertexAlpha, minimapVariant);
    }, (mat) => 256 * 256 * 4 * 2);
  }
};
function clamp2(num) {
  return num > 255 ? 255 : num < 0 ? 0 : num;
}
function applyMaterial(mesh, parsedmat, minimapVariant, inplace = false) {
  let oldcol = mesh.geometry.getAttribute("color");
  let hasVertexAlpha = !!oldcol && oldcol.itemSize == 4;
  mesh.material = parsedmat.mat;
  let basecolor = minimapVariant && parsedmat.matmeta.baseColorFraction == 1 ? [0.5, 0.5, 0.5] : parsedmat.matmeta.baseColor;
  let nonwhiteverts = parsedmat.matmeta.baseColorFraction != 1 || basecolor.some((q) => q != 1) || minimapVariant;
  let needsvertexcolors = nonwhiteverts || !parsedmat.matmeta.textures.diffuse || hasVertexAlpha;
  if (needsvertexcolors) {
    if (parsedmat.matmeta.baseColorFraction != 0) {
      let vertcount = mesh.geometry.getAttribute("position").count;
      let oldcol2 = mesh.geometry.getAttribute("color");
      let oldfrac = 1 - parsedmat.matmeta.baseColorFraction;
      let newrcomp = parsedmat.matmeta.baseColorFraction * basecolor[0] * 255;
      let newgcomp = parsedmat.matmeta.baseColorFraction * basecolor[1] * 255;
      let newbcomp = parsedmat.matmeta.baseColorFraction * basecolor[2] * 255;
      let itemsize = hasVertexAlpha ? 4 : 3;
      let newcol = inplace && oldcol2 ? oldcol2 : new BufferAttribute5(new Uint8Array(itemsize * vertcount), itemsize, true);
      if (hasVertexAlpha && !oldcol2) {
        throw new Error("material has vertex alpha, but mesh doesn't have vertex colors");
      }
      let [oldbuf, oldoffset, oldstride] = getAttributeBackingStore(oldcol2);
      let [newbuf, newoffset, newstride] = getAttributeBackingStore(newcol);
      let hasoldcol = !!oldcol2;
      for (let i = 0; i < vertcount; i++) {
        let ii = newoffset + newstride * i;
        let jj = oldoffset + oldstride * i;
        let oldr = hasoldcol ? oldbuf[jj + 0] : 255;
        let oldg = hasoldcol ? oldbuf[jj + 1] : 255;
        let oldb = hasoldcol ? oldbuf[jj + 2] : 255;
        newbuf[ii + 0] = clamp2(oldr * oldfrac + newrcomp);
        newbuf[ii + 1] = clamp2(oldg * oldfrac + newgcomp);
        newbuf[ii + 2] = clamp2(oldb * oldfrac + newbcomp);
        if (hasVertexAlpha) {
          newbuf[ii + 3] = hasoldcol ? oldbuf[jj + 3] : 255;
        }
      }
      mesh.geometry.setAttribute("color", newcol);
    }
  } else if (mesh.geometry.getAttribute("color")) {
    mesh.geometry.deleteAttribute("color");
  }
}
function mergeBoneids(model) {
  let totalverts = model.meshes.reduce((a, v) => a + v.vertexend - v.vertexstart, 0);
  let order = new Uint32Array(totalverts);
  let orderindex = 0;
  for (let meshindex = 0; meshindex < model.meshes.length; meshindex++) {
    let mesh = model.meshes[meshindex];
    for (let i = mesh.vertexstart; i < mesh.vertexend; i++) {
      order[orderindex++] = meshindex << 23 | i;
    }
  }
  function compareVertkeys(model2, a, b) {
    const mesha = model2.meshes[a >> 23];
    const meshb = model2.meshes[b >> 23];
    const ia = a & 8388607;
    const ib = b & 8388607;
    const posa = mesha.attributes.pos;
    const posb = meshb.attributes.pos;
    return posa.getX(ia) - posb.getX(ib) || posa.getY(ia) - posb.getY(ib) || posa.getZ(ia) - posb.getZ(ib);
  }
  let tmp1 = new THREE4.Vector3();
  let normsum = new THREE4.Vector3();
  let mergecount = 0;
  order.sort((a, b) => compareVertkeys(model, a, b));
  for (let i = 0; i < order.length; ) {
    let start = i;
    while (i < order.length && compareVertkeys(model, order[start], order[++i]) == 0) ;
    if (i > start + 1) {
      const mesh1 = model.meshes[order[start] >> 23];
      const i1 = order[start] & 8388607;
      normsum.set(0, 0, 0);
      for (let j = start; j < i; j++) {
        const mesh2 = model.meshes[order[j] >> 23];
        const i2 = order[j] & 8388607;
        if (mesh2.needsNormalBlending && mesh2.attributes.normals) {
          tmp1.fromBufferAttribute(mesh2.attributes.normals, i2);
          normsum.add(tmp1);
        }
      }
      normsum.normalize();
      for (let j = start; j < i; j++) {
        const mesh2 = model.meshes[order[j] >> 23];
        const i2 = order[j] & 8388607;
        if (j != start && mesh1.attributes.boneids && mesh1.attributes.boneweights && mesh2.attributes.boneids && mesh2.attributes.boneweights) {
          if (mesh1.attributes.boneids.getX(i1) != mesh2.attributes.boneids.getX(i2)) {
            mergecount++;
          }
          mesh2.attributes.boneids.copyAt(i2, mesh1.attributes.boneids, i1);
          mesh2.attributes.boneweights.copyAt(i2, mesh1.attributes.boneweights, i1);
        }
        if (mesh2.needsNormalBlending && mesh2.attributes.normals) {
          if (normsum.lengthSq() > 1e-3) {
            mesh2.attributes.normals.setXYZ(i2, normsum.x, normsum.y, normsum.z);
          }
        }
      }
    }
  }
  console.log("merged bones:", mergecount);
}
function mergeModelDatas(models) {
  let r = {
    bonecount: Math.max(...models.map((q) => q.bonecount)),
    skincount: Math.max(...models.map((q) => q.skincount)),
    maxy: Math.max(...models.map((q) => q.maxy)),
    miny: Math.max(...models.map((q) => q.miny)),
    meshes: models.flatMap((q) => q.meshes),
    debugmeshes: models.flatMap((q) => q.debugmeshes ?? [])
  };
  return r;
}
async function ob3ModelToThree(scene, model) {
  let rootnode = new Object3D4();
  let nullskeleton = null;
  if (model.bonecount != 0 || model.skincount != 0) {
    let nullbones = [];
    let maxbones = Math.max(model.bonecount, model.skincount);
    let rootbone = new Bone3();
    rootnode.add(rootbone);
    for (let i = 0; i < maxbones; i++) {
      nullbones.push(rootbone);
    }
    nullskeleton = new Skeleton4(nullbones);
  }
  for (let meshdata of model.meshes) {
    let attrs = meshdata.attributes;
    let geo = new THREE4.BufferGeometry();
    geo.setAttribute("position", attrs.pos);
    if (attrs.color) {
      geo.setAttribute("color", attrs.color);
    }
    if (attrs.normals) {
      geo.setAttribute("normal", attrs.normals);
    }
    if (attrs.texuvs) {
      geo.setAttribute("uv", attrs.texuvs);
    }
    if (attrs.skinids) {
      geo.setAttribute("RA_skinIndex_skin", attrs.skinids);
    }
    if (attrs.skinweights) {
      geo.setAttribute("RA_skinWeight_skin", attrs.skinweights);
    }
    if (attrs.boneids) {
      geo.setAttribute("RA_skinIndex_bone", attrs.boneids);
    }
    if (attrs.boneweights) {
      geo.setAttribute("RA_skinWeight_bone", attrs.boneweights);
    }
    geo.index = meshdata.indices;
    let mesh;
    if (attrs.skinids || attrs.boneids) {
      mesh = new THREE4.SkinnedMesh(geo);
      let oldbones = !!geo.attributes.RA_skinIndex_bone;
      if (!geo.attributes.skinIndex) {
        geo.attributes.skinIndex = oldbones ? geo.attributes.RA_skinIndex_bone : geo.attributes.RA_skinIndex_skin;
        geo.attributes.skinWeight = oldbones ? geo.attributes.RA_skinWeight_bone : geo.attributes.RA_skinWeight_skin;
      }
      mesh.bind(nullskeleton);
    } else {
      mesh = new THREE4.Mesh(geo);
    }
    applyMaterial(mesh, await scene.getMaterial(meshdata.materialId, meshdata.hasVertexAlpha, false), false);
    rootnode.add(mesh);
  }
  if (model.debugmeshes && model.debugmeshes.length != 0) {
    rootnode.add(...model.debugmeshes);
  }
  return rootnode;
}
function getModelHashes(model, id) {
  let meshhashes = [];
  const matchvertices = 20;
  const maxfullvertices = 1e3;
  const bufsize = matchvertices * 2 * 2;
  const normalssize = matchvertices * 3;
  const possize = matchvertices * 3 * 2;
  if (!model.meshes) {
    throw new Error("model hash not supported for new model format");
  }
  for (let [sub, mesh] of model.meshes.entries()) {
    let uvshead = 0;
    let uvsfull = 0;
    let normalshead = 0;
    let normalsfull = 0;
    let poshead = 0;
    let posfull = 0;
    if (mesh.uvBuffer && mesh.uvBuffer.length >= bufsize) {
      let hasnonnull = false;
      for (let i = 0; i < bufsize; i++) {
        if (mesh.uvBuffer[i] != 0) {
          hasnonnull = true;
          break;
        }
      }
      if (hasnonnull) {
        uvshead = crc32(Buffer.from(mesh.uvBuffer.buffer, mesh.uvBuffer.byteOffset, bufsize));
        uvsfull = crc32(Buffer.from(mesh.uvBuffer.buffer, mesh.uvBuffer.byteOffset, Math.min(maxfullvertices * 2 * 2, mesh.uvBuffer.byteLength)));
      }
    }
    if (mesh.normalBuffer && mesh.normalBuffer.length >= normalssize) {
      normalshead = crc32(Buffer.from(mesh.normalBuffer.buffer, mesh.normalBuffer.byteOffset, normalssize));
      normalsfull = crc32(Buffer.from(mesh.normalBuffer.buffer, mesh.normalBuffer.byteOffset, Math.min(maxfullvertices * 3, mesh.normalBuffer.byteLength)));
    }
    if (mesh.positionBuffer && mesh.positionBuffer.length >= possize) {
      poshead = crc32(Buffer.from(mesh.positionBuffer.buffer, mesh.positionBuffer.byteOffset, possize));
      posfull = crc32(Buffer.from(mesh.positionBuffer.buffer, mesh.positionBuffer.byteOffset, Math.min(maxfullvertices * 3 * 2, mesh.positionBuffer.byteLength)));
    }
    let indexedposcrcs = [];
    if (mesh.positionBuffer) {
      for (let indices of mesh.indexBuffers) {
        let primcount = indices.length / 3 | 0;
        if (primcount >= matchvertices) {
          let crc = new CrcBuilder();
          let head = 0;
          for (let i = 0; i < primcount; i++) {
            for (let j = 0; j < 3; j++) {
              let index = indices[i * 3 + j];
              crc.addUint16(mesh.positionBuffer[index * 3 + 0]);
              crc.addUint16(mesh.positionBuffer[index * 3 + 1]);
              crc.addUint16(mesh.positionBuffer[index * 3 + 2]);
            }
            if (i == matchvertices - 1) {
              head = crc.get();
            }
          }
          indexedposcrcs.push({
            id,
            head,
            full: crc.get(),
            count: primcount
          });
        }
      }
    }
    if (uvshead || poshead || normalshead || indexedposcrcs.length != 0) {
      meshhashes.push({
        id,
        sub,
        uvshead,
        uvsfull,
        normalshead,
        normalsfull,
        poshead,
        posfull,
        verts: mesh.vertexCount,
        indexpos: indexedposcrcs
      });
    }
  }
}

// rsmv/src/3d/mapsquare.ts
import { BufferAttribute as BufferAttribute7, Object3D as Object3D5, Quaternion as Quaternion3, Vector3 as Vector38 } from "three";
import * as THREE5 from "three";

// rsmv/src/map/chunksummary.ts
import { Box2, BufferAttribute as BufferAttribute6, Group as Group2, Matrix4 as Matrix45, Vector2 as Vector23, Vector3 as Vector37 } from "three";
var pointAttribute = new BufferAttribute6(new Float32Array(3), 3);
function mapsquareFloorDependencies(grid, deps, chunk) {
  let groups = [];
  const groupsize = 2;
  for (let x = 0; x < chunk.tilerect.xsize; x += groupsize) {
    for (let z = 0; z < chunk.tilerect.zsize; z += groupsize) {
      let tilehashes = new Array(grid.levels).fill(0);
      let maxy = 0;
      let overlays = [];
      let underlays = [];
      for (let level = 0; level < grid.levels; level++) {
        let minlevel = level;
        for (let dx = 0; dx < groupsize; dx++) {
          for (let dz = 0; dz < groupsize; dz++) {
            let tilehash = 0;
            let tile2 = grid.getTile(chunk.tilerect.x + x + dx, chunk.tilerect.z + z + dz, level);
            if (!tile2 || !tile2.underlayVisible && !tile2.overlayVisible) {
              continue;
            }
            minlevel = Math.min(minlevel, tile2.effectiveVisualLevel);
            let rawtile = tile2.debug_raw;
            if (!rawtile) {
              throw new Error("can't calculate chunkhash since rawtile isn't set");
            }
            tilehash = crc32addInt(rawtile.height ?? -1, tilehash);
            tilehash = crc32addInt(rawtile.overlay ?? -1, tilehash);
            tilehash = crc32addInt(rawtile.settings ?? -1, tilehash);
            tilehash = crc32addInt(rawtile.shape ?? -1, tilehash);
            tilehash = crc32addInt(rawtile.underlay ?? -1, tilehash);
            tilehash = crc32addInt(tile2.effectiveVisualLevel, tilehash);
            if (rawtile.overlay != null && overlays.indexOf(rawtile.overlay) == -1) {
              overlays.push(rawtile.overlay);
            }
            if (rawtile.underlay != null && underlays.indexOf(rawtile.underlay) == -1) {
              underlays.push(rawtile.underlay);
            }
            maxy = Math.max(maxy, tile2.y, tile2.y01, tile2.y10, tile2.y11);
            for (let i = tile2.effectiveVisualLevel; i < grid.levels; i++) {
              tilehashes[i] = crc32addInt(tilehash, tilehashes[i]);
            }
          }
        }
      }
      let dephash = 0;
      overlays.forEach((id) => dephash = deps.hashDependencies(deps.makeDeptName("overlay", id), dephash));
      underlays.forEach((id) => dephash = deps.hashDependencies(deps.makeDeptName("underlay", id), dephash));
      groups.push({
        x,
        z,
        xzsize: groupsize,
        maxy,
        dephash,
        tilehashes
      });
    }
  }
  return groups;
}
function compareChunkLoc(a, b) {
  return a.plane - b.plane || a.x - b.x || a.z - b.z || a.rotation - b.rotation || a.type - b.type;
}
function mapsquareLocDependencies(grid, deps, locs, chunkx, chunkz) {
  const boxAttribute = new BufferAttribute6(new Float32Array(3 * 8), 3);
  const v0 = new Vector37();
  const v1 = new Vector37();
  const v2 = new Vector37();
  let locgroups = /* @__PURE__ */ new Map();
  for (let loc of locs.keys()) {
    let group = getOrInsert(locgroups, loc.locid, () => []);
    group.push(loc);
  }
  let outlocgroups = [];
  for (let [locid, group] of locgroups) {
    let lochash = deps.hashDependencies(deps.makeDeptName("loc", locid));
    let outgroup = {
      id: locid,
      dependencyhash: lochash,
      instances: []
    };
    outlocgroups.push(outgroup);
    for (let loc of group) {
      let models = locs.get(loc);
      v0.set(0, 0, 0);
      v1.set(0, 0, 0);
      for (let mesh of models) {
        let posattr = mesh.model.attributes.pos;
        for (let i = 0; i < posattr.count; i++) {
          v2.set(posattr.getX(i), posattr.getY(i), posattr.getZ(i));
          v0.min(v2);
          v1.max(v2);
        }
      }
      boxAttribute.setXYZ(0, v0.x, v0.y, v0.z);
      boxAttribute.setXYZ(1, v0.x, v0.y, v1.z);
      boxAttribute.setXYZ(2, v0.x, v1.y, v0.z);
      boxAttribute.setXYZ(3, v0.x, v1.y, v1.z);
      boxAttribute.setXYZ(4, v1.x, v0.y, v0.z);
      boxAttribute.setXYZ(5, v1.x, v0.y, v1.z);
      boxAttribute.setXYZ(6, v1.x, v1.y, v0.z);
      boxAttribute.setXYZ(7, v1.x, v1.y, v1.z);
      let first = models[0];
      let trans = transformVertexPositions(boxAttribute, first.morph, grid, first.maxy, chunkx * rs2ChunkSize * tiledimensions2, chunkz * rs2ChunkSize * tiledimensions2);
      let bounds = [...trans.array].map((v) => v | 0);
      outgroup.instances.push({
        plane: loc.plane,
        x: loc.x,
        z: loc.z,
        rotation: loc.rotation,
        type: loc.type,
        visualLevel: loc.visualLevel,
        placementhash: modelPlacementHash(loc),
        bounds
      });
    }
    outgroup.instances.sort(compareChunkLoc);
  }
  outlocgroups.sort((a, b) => a.id - b.id);
  return outlocgroups;
}
function tileSetVertices(tile2) {
  let x0 = tile2.x * tiledimensions2;
  let x1 = x0 + tile2.xzsize * tiledimensions2;
  let z0 = tile2.z * tiledimensions2;
  let z1 = z0 + tile2.xzsize * tiledimensions2;
  let y0 = 0;
  let y1 = tile2.maxy;
  return [
    x0,
    y0,
    z0,
    x0,
    y0,
    z1,
    x0,
    y1,
    z0,
    x0,
    y1,
    z1,
    x1,
    y0,
    z0,
    x1,
    y0,
    z1,
    x1,
    y1,
    z0,
    x1,
    y1,
    z1
  ];
}
function compareFloorDependencies(tilesa, tilesb, levela, levelb) {
  let vertsets = [];
  for (let i = 0; i < tilesa.length; i++) {
    let tilea = tilesa[i];
    let tileb = tilesb[i];
    let maxfloor = Math.max(levela, levelb);
    let mismatch = false;
    if (tilea.dephash != tileb.dephash) {
      mismatch = true;
    } else if (tilea.tilehashes.length <= maxfloor || tileb.tilehashes.length <= maxfloor) {
      mismatch = true;
    } else if (tilea.tilehashes[levela] != tileb.tilehashes[levelb]) {
      mismatch = true;
    }
    if (mismatch) {
      vertsets.push(tileSetVertices(tilea));
      vertsets.push(tileSetVertices(tileb));
    }
  }
  return vertsets;
}
function compareLocDependencies(chunka, chunkb, levela, levelb) {
  let vertsets = [];
  let iloca = 0, ilocb = 0;
  while (true) {
    let loca = iloca < chunka.length ? chunka[iloca] : void 0;
    let locb = ilocb < chunkb.length ? chunkb[ilocb] : void 0;
    if (!loca && !locb) {
      break;
    } else if (loca && locb && loca.id == locb.id) {
      if (loca.dependencyhash == locb.dependencyhash) {
        for (let ia = 0, ib = 0; ; ) {
          let insta = loca.instances.at(ia);
          let instb = locb.instances.at(ib);
          if (insta && insta.visualLevel > levela) {
            insta = void 0;
          }
          if (instb && instb.visualLevel > levelb) {
            instb = void 0;
          }
          if (!insta && !instb) {
            if (ia >= loca.instances.length && ib >= locb.instances.length) {
              break;
            } else {
              ia++;
              ib++;
              continue;
            }
          }
          let cmp = !insta ? -1 : !instb ? 1 : compareChunkLoc(insta, instb);
          if (cmp == 0) {
            if (insta.placementhash != instb.placementhash) {
              vertsets.push(insta.bounds);
              vertsets.push(instb.bounds);
            }
            ia++;
            ib++;
          } else if (cmp < 0) {
            vertsets.push(instb.bounds);
            ib++;
          } else {
            vertsets.push(insta.bounds);
            ia++;
          }
        }
      } else {
        vertsets.push(...loca.instances.map((q) => q.bounds));
        vertsets.push(...locb.instances.map((q) => q.bounds));
      }
      iloca++;
      ilocb++;
    } else if (!loca || locb && locb.id < loca.id) {
      vertsets.push(...locb.instances.map((q) => q.bounds));
      ilocb++;
    } else if (!locb || loca && loca.id < locb.id) {
      vertsets.push(...loca.instances.map((q) => q.bounds));
      iloca++;
    }
  }
  return vertsets;
}
async function mapdiffmesh(scene, points, col = [255, 0, 0]) {
  let tri = (model, verts, a, b, c) => model.mat(-1).addTriangle(
    col,
    verts.slice(a * 3, a * 3 + 3),
    verts.slice(b * 3, b * 3 + 3),
    verts.slice(c * 3, c * 3 + 3)
  );
  let models = new Group2();
  models.matrixAutoUpdate = false;
  models.updateMatrix();
  for (let group of points) {
    let model = new ModelBuilder();
    tri(model, group, 0, 4, 1);
    tri(model, group, 0, 1, 4);
    tri(model, group, 4, 5, 1);
    tri(model, group, 4, 1, 5);
    tri(model, group, 1, 5, 3);
    tri(model, group, 1, 3, 5);
    tri(model, group, 5, 7, 3);
    tri(model, group, 5, 3, 7);
    tri(model, group, 3, 7, 2);
    tri(model, group, 3, 2, 7);
    tri(model, group, 7, 6, 2);
    tri(model, group, 7, 2, 6);
    tri(model, group, 2, 6, 0);
    tri(model, group, 2, 0, 6);
    tri(model, group, 6, 4, 0);
    tri(model, group, 6, 0, 4);
    tri(model, group, 0, 1, 2);
    tri(model, group, 0, 2, 1);
    tri(model, group, 1, 3, 2);
    tri(model, group, 1, 2, 3);
    tri(model, group, 4, 6, 7);
    tri(model, group, 4, 7, 6);
    tri(model, group, 4, 7, 5);
    tri(model, group, 4, 5, 7);
    models.add(await ob3ModelToThree(scene, model.convert()));
  }
  return models;
}
async function generateLocationHashBoxes(scene, locs, grid, chunkx, chunkz, level) {
  let deps = await scene.engine.getDependencyGraph();
  await deps.preloadChunkDependencies({ area: { x: chunkx, z: chunkz, xsize: 1, zsize: 1 } });
  let locdeps = mapsquareLocDependencies(grid, deps, locs, chunkx, chunkz);
  let group = new Group2();
  for (let loc of locdeps) {
    for (let inst of loc.instances) {
      if (inst.visualLevel != level) {
        continue;
      }
      let totalhash = loc.dependencyhash ^ inst.placementhash;
      let color = [totalhash >> 16 & 255, totalhash >> 8 & 255, totalhash >> 0 & 255];
      group.add(await mapdiffmesh(scene, [inst.bounds], color));
    }
  }
  group.userData = {
    modeltype: "overlay",
    isclickable: false,
    modelgroup: "hashbox_objects" + level,
    level
  };
  return group;
}
async function generateFloorHashBoxes(scene, grid, chunk, level) {
  let deps = await scene.engine.getDependencyGraph();
  await deps.preloadChunkDependencies({ area: { x: chunk.mapsquarex, z: chunk.mapsquarez, xsize: 1, zsize: 1 } });
  let floordeps = mapsquareFloorDependencies(grid, deps, chunk);
  let group = new Group2();
  for (let dep of floordeps) {
    let totalhash = 0;
    totalhash = crc32addInt(dep.dephash, totalhash);
    totalhash = crc32addInt(dep.tilehashes[level], totalhash);
    let color = [totalhash >> 16 & 255, totalhash >> 8 & 255, totalhash >> 0 & 255];
    let verts = tileSetVertices(dep);
    group.add(await mapdiffmesh(scene, [verts], color));
  }
  group.userData = {
    modeltype: "overlay",
    isclickable: false,
    modelgroup: "hashbox_floor" + level,
    level
  };
  return group;
}
function pointsIntersectProjection(projection, points) {
  const min = new Vector37();
  const max = new Vector37();
  const tmp = new Vector37();
  for (let group of points) {
    for (let i = 0; i < group.length; i += 3) {
      tmp.set(group[i + 0], group[i + 1], group[i + 2]);
      tmp.applyMatrix4(projection);
      if (i == 0) {
        min.copy(tmp);
        max.copy(tmp);
      } else {
        min.min(tmp);
        max.max(tmp);
      }
    }
    if (min.x < 1 && max.x > -1 && min.y < 1 && max.y > -1) {
      return true;
    }
  }
  return false;
}
globalThis.test = async (chunka, levela, levelb = 0, chunkb = chunka) => {
  let depsa = await chunka.cache.engine.getDependencyGraph();
  let depsb = await chunkb.cache.engine.getDependencyGraph();
  await depsa.preloadChunkDependencies({ area: { x: chunka.chunkx, z: chunka.chunkz, xsize: 1, zsize: 1 } });
  await depsb.preloadChunkDependencies({ area: { x: chunkb.chunkx, z: chunkb.chunkz, xsize: 1, zsize: 1 } });
  await chunka.chunkdata;
  await chunkb.chunkdata;
  if (!chunka.loaded || !chunkb.loaded) {
    return;
  }
  let locsa = mapsquareLocDependencies(chunka.loaded.grid, depsa, chunka.loaded.modeldata, chunka.chunkx, chunka.chunkz);
  let locsb = mapsquareLocDependencies(chunkb.loaded.grid, depsb, chunkb.loaded.modeldata, chunkb.chunkx, chunkb.chunkz);
  let cmplocs = compareLocDependencies(locsa, locsb, levela, levelb);
  let cmplocsmesh = await mapdiffmesh(chunka.cache, cmplocs);
  chunka.rootnode.children[0].add(cmplocsmesh);
  cmplocsmesh.userData = { modeltype: "overlay", isclickable: false, modelgroup: `cmplocs_${levela}_${levelb}`, level: levela };
  let floora = mapsquareFloorDependencies(chunka.loaded.grid, depsa, chunka.loaded.chunk);
  let floorb = mapsquareFloorDependencies(chunkb.loaded.grid, depsb, chunkb.loaded.chunk);
  let cmpfloor = compareFloorDependencies(floora, floorb, levela, levelb);
  let cmpfloormesh = await mapdiffmesh(chunka.cache, cmpfloor);
  chunka.rootnode.children[0].add(cmpfloormesh);
  cmpfloormesh.userData = { modeltype: "overlay", isclickable: false, modelgroup: `cmpfloor_${levela}_${levelb}`, level: levela };
  chunka.emit("changed", void 0);
  return () => {
    let render = globalThis.render;
    let cam = render.getCurrent2dCamera();
    if (!cam) {
      return;
    }
    chunka.rootnode.updateWorldMatrix(true, false);
    let modelmatrix = new Matrix45().makeTranslation(
      chunka.chunkx * tiledimensions2 * chunka.loaded.chunkSize,
      0,
      chunka.chunkz * tiledimensions2 * chunka.loaded.chunkSize
    ).premultiply(chunka.rootnode.matrixWorld);
    let proj = cam.projectionMatrix.clone().multiply(cam.matrixWorldInverse).multiply(modelmatrix);
    let locschanged = pointsIntersectProjection(proj, cmplocs);
    let floorchanged = pointsIntersectProjection(proj, cmpfloor);
    let anychanged = locschanged || floorchanged;
    return { locschanged, floorchanged, anychanged };
  };
};
function modelPlacementHash(loc) {
  let hash = 0;
  hash = crc32addInt(loc.resolvedlocid, hash);
  hash = crc32addInt(loc.rotation, hash);
  hash = crc32addInt(loc.type, hash);
  if (loc.placement) {
    if (loc.placement.rotation) {
      hash = crc32addInt(loc.placement.rotation[0], hash);
      hash = crc32addInt(loc.placement.rotation[1], hash);
      hash = crc32addInt(loc.placement.rotation[2], hash);
      hash = crc32addInt(loc.placement.rotation[3], hash);
    }
    hash = crc32addInt(loc.placement.translateX ?? 0, hash);
    hash = crc32addInt(loc.placement.translateY ?? 0, hash);
    hash = crc32addInt(loc.placement.translateZ ?? 0, hash);
    hash = crc32addInt(loc.placement.scale ?? 0, hash);
    hash = crc32addInt(loc.placement.scaleX ?? 0, hash);
    hash = crc32addInt(loc.placement.scaleY ?? 0, hash);
    hash = crc32addInt(loc.placement.scaleZ ?? 0, hash);
  }
  return hash;
}

// rsmv/src/3d/mapsquare.ts
var tiledimensions2 = 512;
var rs2ChunkSize = 64;
var classicChunkSize = 48;
var squareLevels = 4;
var worldStride = 128;
var heightScale = 1 / 16;
var upvector = new THREE5.Vector3(0, 1, 0);
var defaultVertexProp = { material: -1, materialTiling: 128, materialBleedpriority: -1, color: [255, 0, 255] };
var { tileshapes, defaulttileshape, defaulttileshapeflipped } = generateTileShapes();
function mapRectsIntersect(a, b) {
  if (a.x >= b.x + b.xsize || a.x + a.xsize <= b.x) {
    return false;
  }
  if (a.z >= b.z + b.zsize || a.z + a.zsize <= b.z) {
    return false;
  }
  return true;
}
function mapRectContains(rect, x, z) {
  if (x < rect.x || x >= rect.x + rect.xsize) {
    return false;
  }
  if (z < rect.z || z >= rect.z + rect.zsize) {
    return false;
  }
  return true;
}
var scratchbuffers = /* @__PURE__ */ new Map();
var scratchbuffersinuse = /* @__PURE__ */ new Set();
function borrowScratchbuffer(size, key = "default") {
  if (scratchbuffersinuse.has(key)) {
    console.error("scratchbuffer hasn't been returned since last use, leaking memory by creating new buffer.");
    scratchbuffersinuse.delete(key);
    scratchbuffers.delete(key);
  }
  let buf = scratchbuffers.get(key);
  if (!buf || buf && buf.byteLength < size) {
    buf = new ArrayBuffer(size);
    scratchbuffers.set(key, buf);
    console.log("allocating new scratchbuf mb:", (size / 1e6).toFixed(2));
  }
  scratchbuffersinuse.add(key);
  let exit = (copysize) => {
    scratchbuffersinuse.delete(key);
    if (copysize > size) {
      throw new Error("larger slice of scratchbuffer requested than was reserved");
    }
    return buf.slice(0, copysize);
  };
  return [buf, exit];
}
var TileProps3 = class {
  constructor(height, tilesettings, tilex, tilez, level, docollision) {
    this.debug_nxttile = null;
    this.debug_raw = null;
    this.rawOverlay = void 0;
    this.rawUnderlay = void 0;
    //1=blocking,2=bridge/flag2,4=roofed,8=forcedraw,16=roofoverhang,128=nxtwater
    this.next01 = void 0;
    this.next10 = void 0;
    this.next11 = void 0;
    this.shape = defaulttileshape;
    this.underlayVisible = false;
    this.overlayVisible = false;
    //these should probably be merged
    this.normalX = 0;
    this.normalZ = 0;
    this.bleedsOverlayMaterial = false;
    this.originalUnderlayColor = defaultVertexProp.color;
    this.rawCollision = void 0;
    this.effectiveCollision = void 0;
    this.waterProps = null;
    let y = height * tiledimensions2 * heightScale;
    this.settings = tilesettings;
    this.x = tilex;
    this.y = y;
    this.z = tilez;
    this.y01 = y;
    this.y10 = y;
    this.y11 = y;
    this.playery00 = y, this.playery01 = y;
    this.playery10 = y;
    this.playery11 = y;
    this.effectiveLevel = level;
    this.effectiveVisualLevel = 0;
    let underlayprop = { ...defaultVertexProp };
    this.vertexprops = [underlayprop, underlayprop, underlayprop, underlayprop];
    this.underlayprops = underlayprop;
    this.overlayprops = underlayprop;
    let collision = void 0;
    if (docollision) {
      let blocked = ((tilesettings ?? 0) & 1) != 0;
      collision = {
        settings: tilesettings ?? 0,
        walk: [blocked, false, false, false, false, false, false, false, false],
        sight: [false, false, false, false, false, false, false, false, false]
      };
    }
    this.rawCollision = collision;
    this.effectiveCollision = collision;
  }
  addUnderlay(engine, tileunderlay) {
    let underlay = tileunderlay != void 0 ? engine.mapUnderlays[tileunderlay - 1] : void 0;
    if (underlay) {
      if (underlay.color && (underlay.color[0] != 255 || underlay.color[1] != 0 || underlay.color[2] != 255)) {
        this.underlayVisible = true;
      }
      this.underlayprops = {
        material: underlay.material ?? -1,
        materialTiling: underlay.material_tiling ?? 128,
        materialBleedpriority: -1,
        color: underlay.color ?? [255, 0, 255]
      };
      this.rawUnderlay = underlay;
      this.originalUnderlayColor = this.underlayprops.color;
      this.vertexprops.fill(this.underlayprops);
    }
  }
  addOverlay(engine, tileoverlay, shape) {
    let overlay = tileoverlay != void 0 ? engine.mapOverlays[tileoverlay - 1] : void 0;
    if (overlay) {
      if (overlay.color && (overlay.color[0] != 255 || overlay.color[1] != 0 || overlay.color[2] != 255)) {
        this.overlayVisible = true;
      }
      this.overlayprops = {
        material: overlay.materialbyte ?? overlay.material ?? -1,
        materialTiling: overlay.material_tiling ?? 128,
        materialBleedpriority: overlay.bleedpriority ?? 0,
        color: overlay.color ?? (overlay.materialbyte != null ? [255, 255, 255] : [255, 0, 255])
      };
      this.bleedsOverlayMaterial = !!overlay.bleedToUnderlay;
      this.rawOverlay = overlay;
    }
    if (shape != null) {
      this.shape = tileshapes[shape];
    }
  }
  addUnderWater(engine, height, tileoverlay, tileunderlay) {
    this.waterProps = {
      y00: this.y,
      y01: this.y,
      y10: this.y,
      y11: this.y,
      props: this.overlayprops,
      shape: this.shape.overlay,
      isoriginal: this.shape == defaulttileshape || this.shape == defaulttileshapeflipped,
      rawOverlay: this.rawOverlay
    };
    let oldunderlay = this.underlayprops;
    this.underlayVisible = false;
    this.overlayVisible = false;
    this.bleedsOverlayMaterial = false;
    this.rawOverlay = void 0;
    this.addUnderlay(engine, tileunderlay);
    this.addOverlay(engine, tileoverlay, null);
    if (!this.overlayVisible) {
      this.overlayVisible = true;
      this.overlayprops = oldunderlay;
      this.bleedsOverlayMaterial = true;
    }
    this.y = this.y01 = this.y10 = this.y11 = this.y - height * tiledimensions2 * heightScale;
  }
};
function generateTileShapes() {
  let nodes = [
    { subvertex: 0, nextx: false, nextz: true, subx: 0, subz: 1 },
    { subvertex: 1, nextx: false, nextz: true, subx: 0.5, subz: 1 },
    { subvertex: 0, nextx: true, nextz: true, subx: 1, subz: 1 },
    { subvertex: 2, nextx: true, nextz: false, subx: 1, subz: 0.5 },
    { subvertex: 0, nextx: true, nextz: false, subx: 1, subz: 0 },
    { subvertex: 1, nextx: false, nextz: false, subx: 0.5, subz: 0 },
    { subvertex: 0, nextx: false, nextz: false, subx: 0, subz: 0 },
    { subvertex: 2, nextx: false, nextz: false, subx: 0, subz: 0.5 },
    { subvertex: 3, nextx: false, nextz: false, subx: 0.5, subz: 0.5 }
  ];
  function getvertex(index, rotate) {
    if (index == 8) {
      return nodes[8];
    }
    index = (index + rotate * 2) % 8;
    return nodes[index];
  }
  let tileshapes3 = [];
  for (let i = 0; i < 48; i++) {
    let overlay = [];
    let underlay = [];
    let rotation = i % 4;
    let shape = i - rotation;
    if (shape == 0) {
      overlay.push(0, 2, 4, 6);
    } else if (shape == 4 || shape == 36 || shape == 40) {
      overlay.push(0, 4, 6);
      underlay.push(0, 2, 4);
      if (shape == 36) {
        rotation += 1;
      }
      if (shape == 40) {
        rotation += 3;
      }
    } else if (shape == 8) {
      overlay.push(0, 1, 6);
      underlay.push(1, 2, 4, 6);
    } else if (shape == 12) {
      overlay.push(1, 2, 4);
      underlay.push(0, 1, 4, 6);
    } else if (shape == 16) {
      overlay.push(1, 2, 4, 6);
      underlay.push(0, 1, 6);
    } else if (shape == 20) {
      overlay.push(0, 1, 4, 6);
      underlay.push(1, 2, 4);
    } else if (shape == 24) {
      overlay.push(0, 1, 5, 6);
      underlay.push(1, 2, 4, 5);
    } else if (shape == 28) {
      overlay.push(5, 6, 7);
      underlay.push(2, 4, 5, 7, 0);
    } else if (shape == 32) {
      overlay.push(2, 4, 5, 7, 0);
      underlay.push(5, 6, 7);
    } else if (shape == 44) {
      overlay.push(4, 6, 8);
      underlay.push(8, 6, 0, 2, 4);
    } else {
      throw new Error("shouldnt happen");
    }
    tileshapes3[i] = {
      overlay: overlay.map((q) => getvertex(q, rotation)),
      underlay: underlay.map((q) => getvertex(q, rotation))
    };
  }
  let defaulttileshape2 = {
    overlay: [],
    underlay: [0, 2, 4, 6].map((q) => getvertex(q, 0))
  };
  let defaulttileshapeflipped2 = {
    overlay: [],
    underlay: [2, 4, 6, 0].map((q) => getvertex(q, 0))
  };
  return { tileshapes: tileshapes3, defaulttileshape: defaulttileshape2, defaulttileshapeflipped: defaulttileshapeflipped2 };
}
function invertTileShape(shape) {
  let rotation = shape % 4;
  let mirrorrotation = (rotation + 2) % 4;
  let base = shape - rotation;
  if (base == 0) {
    return 0 + mirrorrotation;
  } else if (base == 4) {
    return 4 + mirrorrotation;
  } else if (base == 8) {
    return 16 + rotation;
  } else if (base == 12) {
    return 20 + rotation;
  } else if (base == 16) {
    return 8 + rotation;
  } else if (base == 20) {
    return 12 + rotation;
  } else if (base == 24) {
    return 24 + mirrorrotation;
  } else if (base == 28) {
    return 32 + rotation;
  } else if (base == 36) {
    return 40 + rotation;
  } else if (base == 40) {
    return 36 + rotation;
  } else if (base == 32) {
    return 28 + rotation;
  } else if (base == 44) {
    console.log("unknown inverse shape");
    return 0;
  }
  throw new Error("unexpected");
}
function modifyMesh(mesh, mods) {
  let newmat = mods.replaceMaterials?.find((q) => q[0] == mesh.materialId)?.[1];
  let newmesh = { ...mesh };
  if (newmat != void 0) {
    newmesh.materialId = newmat == (1 << 16) - 1 ? -1 : newmat;
  }
  if (typeof mods.lodLevel == "number" && mods.lodLevel != -1) {
    newmesh.indices = mesh.indexLODs[Math.min(mods.lodLevel, mesh.indexLODs.length - 1)];
  }
  let clonedcolors = void 0;
  if (mods.replaceColors && mods.replaceColors.length != 0 && mesh.attributes.color) {
    let colors = mesh.attributes.color;
    let map = [];
    for (let repl of mods.replaceColors) {
      let oldcol = HSL2RGB(packedHSL2HSL(repl[0]));
      let newcol = HSL2RGB(packedHSL2HSL(repl[1]));
      map.push([oldcol[0] << 16 | oldcol[1] << 8 | oldcol[2], newcol]);
    }
    for (let i = 0; i < colors.count; i++) {
      let key = colors.getX(i) * 255 << 16 | colors.getY(i) * 255 << 8 | colors.getZ(i) * 255;
      for (let repl of map) {
        if (key == repl[0]) {
          if (!clonedcolors) {
            clonedcolors = colors.clone();
          }
          clonedcolors.setXYZ(i, repl[1][0] / 255, repl[1][1] / 255, repl[1][2] / 255);
          break;
        }
      }
    }
  }
  if (clonedcolors) {
    newmesh.attributes = {
      ...mesh.attributes,
      color: clonedcolors
    };
  }
  return newmesh;
}
function getMorphMatrix(morph, gridoffsetx, gridoffsetz) {
  let matrix = new THREE5.Matrix4().makeTranslation(morph.translate.x - gridoffsetx, morph.translate.y, morph.translate.z - gridoffsetz).multiply(new THREE5.Matrix4().makeRotationFromQuaternion(morph.rotation)).multiply(new THREE5.Matrix4().makeScale(morph.scale.x, morph.scale.y, morph.scale.z));
  return matrix;
}
function transformVertexPositions(pos, morph, grid, modelheight, gridoffsetx, gridoffsetz, newpos, newposindex = 0, inputstart = 0, inputend = pos.count) {
  let matrix = getMorphMatrix(morph, gridoffsetx, gridoffsetz);
  let centery = getTileHeight(grid, morph.originx / tiledimensions2, morph.originz / tiledimensions2, morph.level);
  let vector = new THREE5.Vector3();
  let followfloor = morph.placementMode == "followfloor" || morph.placementMode == "followfloorceiling";
  let followceiling = morph.placementMode == "followfloorceiling";
  let yscale = followceiling && modelheight > 0 ? 1 / modelheight : 1;
  let inputcount = inputend - inputstart;
  newpos ??= new THREE5.BufferAttribute(new Float32Array(inputcount * 3), 3);
  let [oldbuf, oldsuboffset, oldstride] = getAttributeBackingStore(pos);
  let [newbuf, newsuboffset, newstride] = getAttributeBackingStore(newpos);
  let newoffset = newsuboffset + newposindex * newstride;
  let oldoffset = oldsuboffset + inputstart * oldstride;
  for (let i = 0; i < inputcount; i++) {
    let ii = newoffset + newstride * i;
    let jj = oldoffset + oldstride * i;
    vector.x = oldbuf[jj + 0];
    vector.y = oldbuf[jj + 1];
    vector.z = oldbuf[jj + 2];
    let vertexy = vector.y;
    vector.applyMatrix4(matrix);
    if (followfloor) {
      let gridx = (vector.x + gridoffsetx) / tiledimensions2;
      let gridz = (vector.z + gridoffsetz) / tiledimensions2;
      if (followceiling) {
        let wceiling = vertexy * yscale;
        let floory = getTileHeight(grid, gridx, gridz, morph.level);
        let ceily = getTileHeight(grid, gridx, gridz, morph.level + 1) - morph.scaleModelHeightOffset;
        vector.y += -vertexy + ceily * wceiling + floory * (1 - wceiling);
      } else {
        vector.y += getTileHeight(grid, gridx, gridz, morph.level);
      }
    } else {
      vector.y += centery;
    }
    newbuf[ii + 0] = vector.x;
    newbuf[ii + 1] = vector.y;
    newbuf[ii + 2] = vector.z;
  }
  return newpos;
}
var CombinedTileGrid = class {
  constructor(grids) {
    this.grids = grids;
  }
  getTile(x, z, level) {
    for (let grid of this.grids) {
      if (x >= grid.rect.x && x < grid.rect.x + grid.rect.xsize && z >= grid.rect.z && z < grid.rect.z + grid.rect.zsize) {
        return grid.src.getTile(x, z, level);
      }
    }
    return void 0;
  }
};
function getTileHeight(grid, x, z, level) {
  let xfloor = Math.floor(x);
  let zfloor = Math.floor(z);
  let tile2 = grid.getTile(xfloor, zfloor, level);
  if (!tile2) {
    return 0;
  }
  if (tile2.waterProps) {
    return tile2.waterProps.y00;
  }
  let w00 = (1 - (x - xfloor)) * (1 - (z - zfloor));
  let w01 = (x - xfloor) * (1 - (z - zfloor));
  let w10 = (1 - (x - xfloor)) * (z - zfloor);
  let w11 = (x - xfloor) * (z - zfloor);
  return tile2.y * w00 + tile2.y01 * w01 + tile2.y10 * w10 + tile2.y11 * w11;
}
var TileGrid3 = class {
  constructor(engine, area, tilemask) {
    this.levels = 4;
    this.area = area;
    this.tilemask = tilemask?.filter((q) => mapRectsIntersect(q, area));
    this.engine = engine;
    this.xoffset = area.x;
    this.zoffset = area.z;
    this.xsize = area.xsize;
    this.zsize = area.zsize;
    this.xstep = 1;
    this.zstep = this.xstep * area.xsize;
    this.levelstep = this.zstep * area.zsize;
    this.tiles = new Array(this.levelstep * this.levels).fill(void 0);
  }
  getHeightCollisionFile(x, z, level, xsize, zsize) {
    let file = new Uint16Array(xsize * zsize * 2);
    for (let dz = 0; dz < zsize; dz++) {
      for (let dx = 0; dx < xsize; dx++) {
        let tile2 = this.getTile(x + dx, z + dz, level);
        if (tile2) {
          let index = (dx + dz * xsize) * 2;
          let y = (tile2.playery00 + tile2.playery01 + tile2.playery10 + tile2.playery11) / 4;
          file[index + 0] = y / 16;
          let colint = 0;
          let col = tile2.effectiveCollision;
          for (let i = 0; i < 9; i++) {
            let v = col.walk[i] ? col.sight[i] ? 2 : 1 : 0;
            colint += Math.pow(3, i) * v;
          }
          file[index + 1] = colint;
        }
      }
    }
    return file;
  }
  getTile(x, z, level) {
    x -= this.xoffset;
    z -= this.zoffset;
    if (x < 0 || z < 0 || x >= this.xsize || z >= this.zsize) {
      return void 0;
    }
    return this.tiles[this.levelstep * level + z * this.zstep + x * this.xstep];
  }
  blendUnderlays() {
    for (let z = this.zoffset; z < this.zoffset + this.zsize; z++) {
      for (let x = this.xoffset; x < this.xoffset + this.xsize; x++) {
        let effectiveVisualLevel = 0;
        let layer1tile = this.getTile(x, z, 1);
        let flag2 = ((layer1tile?.settings ?? 0) & 2) != 0;
        let leveloffset = flag2 ? -1 : 0;
        for (let level = 0; level < this.levels; level++) {
          let currenttile = this.getTile(x, z, level);
          if (!currenttile) {
            continue;
          }
          if (!currenttile.debug_nxttile) {
            let r = 0, g = 0, b = 0;
            let count = 0;
            for (let dz = -4; dz <= 5; dz++) {
              for (let dx = -4; dx <= 5; dx++) {
                let tile2 = this.getTile(x + dx, z + dz, level);
                if (!tile2 || !tile2.underlayVisible) {
                  continue;
                }
                let col = tile2.originalUnderlayColor;
                r += col[0];
                g += col[1];
                b += col[2];
                count++;
              }
            }
            if (count > 0) {
              currenttile.underlayprops.color = [r / count, g / count, b / count];
            }
          }
          let tile_sw = this.getTile(x - 1, z - 1, level);
          let tile_s = this.getTile(x, z - 1, level);
          let tile_se = this.getTile(x + 1, z - 1, level);
          let tile_e = this.getTile(x + 1, z, level);
          let tile_ne = this.getTile(x + 1, z + 1, level);
          let tile_n = this.getTile(x, z + 1, level);
          let tile_nw = this.getTile(x - 1, z + 1, level);
          let tile_w = this.getTile(x - 1, z, level);
          let dydx = 0;
          let dydz = 0;
          if (tile_w && tile_e) {
            dydx = (tile_e.y - tile_w.y) / (2 * tiledimensions2);
          }
          if (tile_s && tile_n) {
            dydz = (tile_n.y - tile_s.y) / (2 * tiledimensions2);
          }
          let len = Math.hypot(dydx, dydz, 1);
          currenttile.normalZ = -dydx / len;
          currenttile.normalX = -dydz / len;
          currenttile.y01 = tile_e?.y ?? currenttile.y;
          currenttile.y10 = tile_n?.y ?? currenttile.y;
          currenttile.y11 = tile_ne?.y ?? currenttile.y;
          currenttile.playery00 = currenttile.y;
          currenttile.playery01 = tile_e?.y ?? currenttile.y01;
          currenttile.playery10 = tile_n?.y ?? currenttile.y10;
          currenttile.playery11 = tile_ne?.y ?? currenttile.y11;
          if (currenttile.waterProps) {
            currenttile.playery00 = Math.max(currenttile.playery00, currenttile.waterProps.y00);
            currenttile.playery01 = Math.max(currenttile.playery01, currenttile.waterProps.y01);
            currenttile.playery10 = Math.max(currenttile.playery10, currenttile.waterProps.y10);
            currenttile.playery11 = Math.max(currenttile.playery11, currenttile.waterProps.y11);
          }
          currenttile.next01 = tile_e;
          currenttile.next10 = tile_n;
          currenttile.next11 = tile_ne;
          let alwaysshow = ((currenttile.settings ?? 0) & 8) != 0;
          let effectiveLevel = level + leveloffset;
          if (alwaysshow) {
            effectiveVisualLevel = 0;
          }
          let effectiveTile = this.getTile(x, z, effectiveLevel);
          let hasroof = ((effectiveTile?.settings ?? 0) & 4) != 0;
          if (effectiveTile && effectiveLevel != level) {
            effectiveTile.effectiveCollision = currenttile.rawCollision;
            effectiveTile.playery00 = currenttile.playery00;
            effectiveTile.playery01 = currenttile.playery01;
            effectiveTile.playery10 = currenttile.playery10;
            effectiveTile.playery11 = currenttile.playery11;
          }
          currenttile.effectiveLevel = effectiveLevel;
          currenttile.effectiveVisualLevel = Math.max(currenttile.effectiveVisualLevel, effectiveVisualLevel);
          for (let dz = -1; dz <= 1; dz++) {
            for (let dx = -1; dx <= 1; dx++) {
              let tile2 = this.getTile(x + dx, z + dz, level);
              if (tile2 && ((tile2.settings ?? 0) & 8) == 0) {
                tile2.effectiveVisualLevel = Math.max(tile2.effectiveVisualLevel, effectiveVisualLevel);
              }
            }
          }
          if (hasroof) {
            effectiveVisualLevel = effectiveLevel + 1;
          }
          if (!currenttile.waterProps) {
            let northoreast = tile_n?.waterProps?.isoriginal || tile_e?.waterProps?.isoriginal;
            if (tile_ne?.waterProps?.isoriginal && northoreast) {
              currenttile.waterProps = {
                ...tile_ne.waterProps,
                isoriginal: false,
                shape: tileshapes[0].overlay
              };
            } else if (tile_ne?.waterProps?.isoriginal) {
              currenttile.waterProps = {
                ...tile_ne.waterProps,
                isoriginal: false,
                shape: tileshapes[6].overlay
              };
            } else if (tile_nw?.waterProps?.isoriginal && tile_n?.waterProps?.isoriginal) {
              currenttile.waterProps = {
                ...tile_nw.waterProps,
                isoriginal: false,
                shape: tileshapes[5].overlay
              };
            } else if (tile_se?.waterProps?.isoriginal && tile_e?.waterProps?.isoriginal) {
              currenttile.waterProps = {
                ...tile_se.waterProps,
                isoriginal: false,
                shape: tileshapes[7].overlay
              };
            }
          } else if (currenttile.waterProps.shape.length == 0) {
            if (tile_ne?.waterProps || tile_n?.waterProps || tile_e?.waterProps) {
              currenttile.waterProps.shape = tileshapes[0].overlay;
            } else {
              currenttile.waterProps.shape = tileshapes[4].overlay;
            }
          }
          if (currenttile.waterProps) {
            if (tile_e?.waterProps) {
              currenttile.waterProps.y01 = tile_e.waterProps.y00;
            }
            if (tile_n?.waterProps) {
              currenttile.waterProps.y10 = tile_n.waterProps.y00;
            }
            if (tile_ne?.waterProps) {
              currenttile.waterProps.y11 = tile_ne.waterProps.y00;
            } else if (tile_e?.waterProps) {
              currenttile.waterProps.y11 = tile_e.waterProps.y10;
            } else if (tile_n?.waterProps) {
              currenttile.waterProps.y11 = tile_n.waterProps.y01;
            }
          }
        }
      }
    }
    for (let z = this.zoffset; z < this.zoffset + this.zsize; z++) {
      for (let x = this.xoffset; x < this.xoffset + this.xsize; x++) {
        for (let level = 0; level < this.levels; level++) {
          let currenttile = this.getTile(x, z, level);
          if (!currenttile) {
            continue;
          }
          if (currenttile.bleedsOverlayMaterial) {
            for (let vertex of currenttile.shape.overlay) {
              let node = currenttile;
              if (vertex.nextx && vertex.nextz) {
                node = node.next11;
              } else if (vertex.nextx) {
                node = node.next01;
              } else if (vertex.nextz) {
                node = node.next10;
              }
              if (node) {
                if (node.vertexprops[vertex.subvertex].materialBleedpriority < currenttile.overlayprops.materialBleedpriority) {
                  node.vertexprops[vertex.subvertex] = currenttile.overlayprops;
                }
              }
            }
          }
        }
      }
    }
  }
  gatherMaterials(x, z, xsize, zsize) {
    let mats = /* @__PURE__ */ new Map();
    let addmat = (id, tiling) => {
      let repeat = 1;
      const defaultTiling = 128;
      if (tiling < defaultTiling) {
        repeat = defaultTiling / tiling + 1;
      } else if (tiling % defaultTiling != 0) {
        repeat = 1 + defaultTiling / tiling;
      }
      let old = mats.get(id);
      if (!old || old < repeat) {
        mats.set(id, repeat);
      }
    };
    for (let level = 0; level < this.levels; level++) {
      for (let dz = 0; dz < zsize; dz++) {
        for (let dx = 0; dx < xsize; dx++) {
          let tile2 = this.getTile(x + dx, z + dz, level);
          if (!tile2) {
            continue;
          }
          if (tile2.underlayprops.material != -1) {
            addmat(tile2.underlayprops.material, tile2.underlayprops.materialTiling);
          }
          if (tile2.overlayprops.material != -1) {
            addmat(tile2.overlayprops.material, tile2.overlayprops.materialTiling);
          }
          if (tile2.waterProps && tile2.waterProps.props.material != -1) {
            addmat(tile2.waterProps.props.material, tile2.waterProps.props.materialTiling);
          }
        }
      }
    }
    return mats;
  }
  addMapsquare(tiles, nxttiles, chunkrect, levels, docollision = false) {
    if (tiles.length != chunkrect.xsize * chunkrect.zsize * levels) {
      throw new Error();
    }
    let baseoffset = (chunkrect.x - this.xoffset) * this.xstep + (chunkrect.z - this.zoffset) * this.zstep;
    for (let z = 0; z < chunkrect.zsize; z++) {
      for (let x = 0; x < chunkrect.xsize; x++) {
        if (!mapRectContains(this.area, chunkrect.x + x, chunkrect.z + z)) {
          continue;
        }
        if (this.tilemask && !this.tilemask.some((q) => mapRectContains(q, chunkrect.x + x, chunkrect.z + z))) {
          continue;
        }
        let tilex = (chunkrect.x + x) * tiledimensions2;
        let tilez = (chunkrect.z + z) * tiledimensions2;
        let tileindex = z + x * chunkrect.zsize;
        let height = 0;
        for (let level = 0; level < this.levels; level++) {
          let tile2 = level < levels ? tiles[tileindex] : {};
          let nxttile = null;
          let extraheight = tile2.height;
          if (nxttiles) {
            let nxtfloor = [nxttiles.level0, nxttiles.level1, nxttiles.level2, nxttiles.level3][level];
            if (nxtfloor) {
              nxttile = nxtfloor[(x + 1) * 66 + z + 1];
              extraheight = nxttile.flags & 16 ? nxttile.rest?.waterheight : nxttile.height;
            }
          }
          let waterheight = height;
          if (extraheight != void 0 && extraheight != 0) {
            height += extraheight == 1 ? 0 : extraheight;
          } else {
            height += 30;
          }
          let outtile;
          if (nxttile) {
            let nxtset = nxttile.flags;
            let haswater = (nxtset & 16) != 0;
            let newsettings = (nxtset & 2 ? 1 : 0) | (nxtset & 4 ? 2 : 0) | (nxtset & 8 ? 4 : 0) | (nxtset & 32 ? 8 : 0) | (nxtset & 64 ? 16 : 0);
            if (haswater) {
              newsettings |= 128;
            }
            outtile = new TileProps3(height, newsettings, tilex, tilez, level, docollision);
            let overlay = nxttile.rest?.overlay_under ?? nxttile.rest?.overlay;
            let underlay = nxttile.rest?.underlay_under ?? nxttile.rest?.underlay;
            let shape = haswater ? invertTileShape(nxttile.rest?.shape ?? 0) : nxttile.rest?.shape;
            outtile.addUnderlay(this.engine, underlay);
            outtile.addOverlay(this.engine, overlay, shape);
            if (haswater) {
              outtile.addUnderWater(this.engine, nxttile.height, nxttile.rest?.overlay, nxttile.rest?.underlay);
            }
            outtile.debug_raw = tile2;
            outtile.debug_nxttile = nxttile;
            outtile.originalUnderlayColor = HSL2RGB(packedHSL2HSL(nxttile.rest?.underlaycolor ?? 0));
            outtile.underlayprops.color = outtile.originalUnderlayColor;
          } else {
            outtile = new TileProps3(height, tile2.settings ?? 0, tilex, tilez, level, docollision);
            outtile.addUnderlay(this.engine, tile2.underlay);
            outtile.addOverlay(this.engine, tile2.overlay, tile2.shape);
            outtile.debug_raw = tile2;
          }
          let newindex = baseoffset + this.xstep * x + this.zstep * z + this.levelstep * level;
          this.tiles[newindex] = outtile;
          tileindex += chunkrect.xsize * chunkrect.zsize;
        }
      }
    }
  }
};
async function getMapsquareData(engine, chunkx, chunkz) {
  let squareSize = engine.classicData ? classicChunkSize : rs2ChunkSize;
  let squareindex = chunkx + chunkz * worldStride;
  let tiles;
  let nxttiles = null;
  let tilesextra = {};
  let locs = [];
  let tilerect;
  let levelcount = squareLevels;
  let filehash = 0;
  let fileversion = 0;
  if (engine.getBuildNr() > lastClassicBuildnr) {
    let tilefile = null;
    let nxttilefile = null;
    let locsfile = null;
    if (engine.getBuildNr() >= 759) {
      let mapcacheindex = await engine.getCacheIndex(cacheMajors.mapsquares);
      let chunkindex = mapcacheindex[squareindex];
      if (!chunkindex) {
        return null;
      }
      filehash = chunkindex.crc;
      fileversion = chunkindex.version;
      let selfarchive = await engine.getFileArchive(chunkindex);
      let tileindex = chunkindex.subindices.indexOf(cacheMapFiles.squares);
      if (tileindex == -1) {
        return null;
      }
      tilefile = selfarchive[tileindex].buffer;
      let locsindex = chunkindex.subindices.indexOf(cacheMapFiles.locations);
      if (locsindex != -1) {
        locsfile = selfarchive[locsindex].buffer;
      }
      if (engine.getBuildNr() >= 861) {
        let nxttileindex = chunkindex.subindices.indexOf(cacheMapFiles.square_nxt);
        if (nxttileindex != -1) {
          nxttilefile = selfarchive[nxttileindex].buffer;
        }
      }
    } else if (engine.getBuildNr() > lastLegacyBuildnr) {
      try {
        let index = await engine.findFileByName(cacheMajors.mapsquares, `m${chunkx}_${chunkz}`);
        if (!index) {
          return null;
        }
        filehash = index.crc;
        fileversion = index.version;
        tilefile = await engine.getFile(index.major, index.minor, index.crc);
      } catch (e) {
        return null;
      }
      try {
        let index = await engine.findFileByName(cacheMajors.mapsquares, `l${chunkx}_${chunkz}`);
        if (index) {
          filehash = crc32addInt(index.crc, filehash);
          fileversion = Math.max(fileversion, index.version);
          locsfile = await engine.getFile(index.major, index.minor, index.crc);
        }
      } catch (e) {
      }
    } else {
      let index = chunkx * 256 + chunkz;
      let info = engine.legacyData?.mapmeta.get(index);
      if (!info) {
        return null;
      }
      try {
        filehash = info.crc;
        fileversion = info.version;
        tilefile = await engine.getFile(legacyMajors.map, info.map);
        locsfile = await engine.getFile(legacyMajors.map, info.loc);
      } catch {
        console.warn(`map for ${chunkx}_${chunkz} declared but file did not exist`);
      }
    }
    if (!tilefile) {
      return null;
    }
    let tiledata = parse.mapsquareTiles.read(tilefile, engine.rawsource);
    if (nxttilefile) {
      nxttiles = parse.mapsquareTilesNxt.read(nxttilefile, engine.rawsource);
    }
    tiles = tiledata.tiles;
    tilesextra = tiledata.extra;
    if (locsfile) {
      locs = parse.mapsquareLocations.read(locsfile, engine.rawsource).locations;
    }
    tilerect = {
      x: chunkx * squareSize,
      z: chunkz * squareSize,
      xsize: squareSize,
      zsize: squareSize
    };
  } else {
    let mapdata = await getClassicMapData(engine, chunkx, chunkz);
    if (!mapdata) {
      return null;
    }
    tiles = mapdata.tiles;
    tilerect = mapdata.rect;
    levelcount = mapdata.levels;
    locs = mapdata.locs;
    filehash = mapdata.mapfilehash;
  }
  let chunk = {
    tilerect,
    levelcount,
    mapsquarex: chunkx,
    mapsquarez: chunkz,
    chunkfilehash: filehash,
    chunkfileversion: fileversion,
    tiles,
    nxttiles,
    extra: tilesextra,
    rawlocs: locs,
    locs: []
  };
  return chunk;
}
async function parseMapsquare(engine, chunkx, chunkz, opts) {
  let chunkfloorpadding = opts?.padfloor ? 20 : 0;
  let chunkSize2 = engine.classicData ? classicChunkSize : rs2ChunkSize;
  let chunkpadding = Math.ceil(chunkfloorpadding / chunkSize2);
  let grid = new TileGrid3(engine, {
    x: chunkx * chunkSize2 - chunkfloorpadding,
    z: chunkz * chunkSize2 - chunkfloorpadding,
    xsize: chunkSize2 + chunkfloorpadding * 2,
    zsize: chunkSize2 + chunkfloorpadding * 2
  }, opts?.mask);
  let chunk = null;
  for (let z = -chunkpadding; z <= chunkpadding; z++) {
    for (let x = -chunkpadding; x <= chunkpadding; x++) {
      let chunkdata = await getMapsquareData(engine, chunkx + x, chunkz + z);
      if (!chunkdata) {
        continue;
      }
      grid.addMapsquare(chunkdata.tiles, chunkdata.nxttiles, chunkdata.tilerect, chunkdata.levelcount, !!opts?.collision);
      if (chunkdata.mapsquarex == chunkx && chunkdata.mapsquarez == chunkz) {
        chunk = chunkdata;
      }
    }
  }
  if (engine.classicData) {
    classicModifyTileGrid(grid);
  }
  grid.blendUnderlays();
  if (chunk) {
    chunk.locs = await mapsquareObjects(engine, grid, chunk.rawlocs, chunk.tilerect.x, chunk.tilerect.z, !!opts?.collision);
  }
  return { grid, chunk, chunkSize: chunkSize2, chunkx, chunkz };
}
async function mapsquareSkybox(scene, mainchunk) {
  let skybox = new Object3D5();
  let fogColor = [0, 0, 0, 0];
  let skyboxModelid = -1;
  if (mainchunk?.extra.unk00?.unk20) {
    fogColor = mainchunk.extra.unk00.unk20.slice(1);
  }
  if (mainchunk?.extra.unk80) {
    let envarch = await scene.engine.getArchiveById(cacheMajors.config, cacheConfigPages.environments);
    let envfile = envarch.find((q) => q.fileid == mainchunk.extra.unk80.environment);
    let env = parse.environments.read(envfile.buffer, scene.engine.rawsource);
    if (typeof env.model == "number") {
      skyboxModelid = env.model;
      skybox = await ob3ModelToThree(scene, await scene.getModelData(env.model));
    }
  }
  return { skybox, fogColor, skyboxModelid };
}
async function mapsquareFloors(scene, grid, chunk, opts) {
  let floors = [];
  let matids = grid.gatherMaterials(chunk.tilerect.x, chunk.tilerect.z, chunk.tilerect.xsize + 1, chunk.tilerect.zsize + 1);
  let textures = /* @__PURE__ */ new Map();
  let textureproms = [];
  for (let [matid, repeat] of matids.entries()) {
    let mat = scene.engine.getMaterialData(matid);
    if (mat.textures.diffuse && scene.textureType != "none") {
      textureproms.push(
        scene.getTextureFile("diffuse", mat.textures.diffuse, mat.stripDiffuseAlpha).then((tex) => tex.toWebgl()).then((src) => {
          textures.set(mat.textures.diffuse, { tex: src, repeat });
        })
      );
    }
  }
  await Promise.all(textureproms);
  let atlas;
  let sortedtextures = [...textures.entries()].sort((a, b) => b[1].tex.width * b[1].repeat - a[1].tex.width * a[1].repeat);
  let sizelist = [
    [256, 256],
    [512, 512],
    [1024, 512],
    [1024, 1024],
    [1024, 2048],
    [2048, 1024],
    //try both orientations because the layout algo isnt symmetric
    [2048, 2048],
    [2048, 2048 + 1024],
    [2048, 4096],
    [2048 + 1024, 4096],
    [4096, 4096]
  ];
  retrysize: for (let size of sizelist) {
    atlas = new SimpleTexturePacker(size[0], size[1]);
    for (let [id, { tex, repeat }] of sortedtextures) {
      if (!atlas.addTexture(id, tex, repeat)) {
        continue retrysize;
      }
    }
    break;
  }
  for (let level = 0; level < squareLevels; level++) {
    floors.push(mapsquareMesh(grid, chunk, level, atlas, true, "default"));
    floors.push(mapsquareMesh(grid, chunk, level, atlas, true, "default", true));
    if (opts?.map2d) {
      floors.push(mapsquareMesh(grid, chunk, level, atlas, false, "worldmap"));
      floors.push(mapsquareMesh(grid, chunk, level, atlas, false, "worldmap", true));
    }
    if (opts?.invisibleLayers) {
      floors.push(mapsquareMesh(grid, chunk, level, atlas, false, "wireframe"));
      floors.push(mapsquarePathMesh(grid, chunk, level));
    }
    if (opts?.minimap) {
      floors.push(mapsquareMesh(grid, chunk, level, atlas, false, "minimap"));
      floors.push(mapsquareMesh(grid, chunk, level, atlas, false, "minimap", true));
    }
  }
  return floors;
}
async function renderMapSquare(cache, parsedsquare, chunkx, chunkz, opts) {
  let { grid, chunk } = await parsedsquare;
  let modeldata;
  let chunkroot = new THREE5.Group();
  chunkroot.name = `mapsquare ${chunkx}.${chunkz}`;
  let locRenders = /* @__PURE__ */ new Map();
  if (chunk) {
    let floordatas = await mapsquareFloors(cache, grid, chunk, opts);
    let overlays = !opts?.map2d ? [] : await mapsquareOverlays(cache.engine, grid, chunk.locs);
    let locmeshes = await generateLocationMeshgroups(cache, chunk.locs);
    let allmeshes = [...locmeshes.byMaterial, ...overlays];
    if (opts.minimap) {
      let minimeshes = await generateLocationMeshgroups(cache, chunk.locs, true);
      allmeshes.push(...minimeshes.byMaterial);
    }
    let rootx = chunk.tilerect.x * tiledimensions2;
    let rootz = chunk.tilerect.z * tiledimensions2;
    chunkroot.matrixAutoUpdate = false;
    chunkroot.position.set(rootx, 0, rootz);
    chunkroot.updateMatrix();
    if (allmeshes.length != 0) {
      let materials = await Promise.all(allmeshes.map((q) => q.material ?? cache.getMaterial(q.materialId, q.hasVertexAlpha, q.minimapVariant)));
      chunkroot.add(...allmeshes.map((q, i) => meshgroupsToThree(grid, q, rootx, rootz, materials[i], locRenders)));
    }
    let floors = (await Promise.all(floordatas.map((f) => floorToThree(cache, f)))).filter((q) => q);
    if (floors.length != 0) {
      chunkroot.add(...floors);
    }
    for (let level = 0; level < squareLevels; level++) {
      let boxes = mapsquareCollisionToThree(grid, chunk, level);
      if (boxes) {
        chunkroot.add(boxes);
      }
      let rawboxes = mapsquareCollisionToThree(grid, chunk, level, true);
      if (rawboxes) {
        chunkroot.add(rawboxes);
      }
    }
    if (opts.hashboxes) {
      for (let level = 0; level < squareLevels; level++) {
        chunkroot.add(await generateLocationHashBoxes(cache, locmeshes.byLogical, grid, chunk.mapsquarex, chunk.mapsquarez, level));
        chunkroot.add(await generateFloorHashBoxes(cache, grid, chunk, level));
      }
    }
    modeldata = locmeshes.byLogical;
  } else {
    modeldata = /* @__PURE__ */ new Map();
  }
  let sky = chunk && opts?.skybox ? await mapsquareSkybox(cache, chunk) : null;
  let chunkSize2 = cache.engine.classicData ? classicChunkSize : rs2ChunkSize;
  chunkroot?.traverse((node) => {
    if (node instanceof THREE5.Mesh) {
      let parent = node;
      let iswireframe = false;
      while (parent) {
        if (parent.userData.modeltype == "floorhidden") {
          iswireframe = true;
        }
        parent = parent.parent;
      }
      if (iswireframe && node.material instanceof THREE5.MeshPhongMaterial) {
        node.material.wireframe = true;
      }
    }
  });
  return { chunkx, chunkz, grid, chunk, sky, modeldata, chunkroot, chunkSize: chunkSize2, locRenders };
}
var SimpleTexturePacker = class {
  constructor(width, height) {
    this.padsize = 32;
    this.allocs = [];
    this.map = /* @__PURE__ */ new Map();
    this.allocx = 0;
    this.allocy = 0;
    this.allocLineHeight = 0;
    this.result = null;
    this.resultSource = null;
    this.width = width;
    this.height = height;
  }
  addTexture(id, img, repeat) {
    if (this.result != null) {
      this.result = null;
      console.log("adding textures to atlas after creation of texture");
    }
    let repeatWidth = Math.floor(img.width * repeat);
    let repeatHeight = Math.floor(img.height * repeat);
    let sizex = repeatWidth + 2 * this.padsize;
    let sizey = repeatHeight + 2 * this.padsize;
    if (this.allocx + sizex > this.width) {
      this.allocx = 0;
      this.allocy += this.allocLineHeight;
      this.allocLineHeight = 0;
    }
    this.allocLineHeight = Math.max(this.allocLineHeight, sizey);
    if (this.allocy + this.allocLineHeight > this.height) {
      return false;
    }
    let alloc = {
      u: (this.allocx + this.padsize) / this.width,
      v: (this.allocy + this.padsize) / this.height,
      usize: img.width / this.width,
      vsize: img.height / this.height,
      x: this.allocx + this.padsize,
      y: this.allocy + this.padsize,
      repeatWidth,
      repeatHeight,
      totalpixels: (this.padsize + repeatWidth + this.padsize) * (this.padsize + repeatHeight + this.padsize),
      img
    };
    this.allocs.push(alloc);
    this.allocx += sizex;
    this.map.set(id, alloc);
    return true;
  }
  convertToThreeTexture() {
    return this.resultSource ??= (() => {
      let map = new THREE5.CanvasTexture(this.convert());
      map.flipY = false;
      map.magFilter = THREE5.LinearFilter;
      map.minFilter = THREE5.LinearMipMapNearestFilter;
      map.generateMipmaps = true;
      map.colorSpace = THREE5.SRGBColorSpace;
      return map;
    })();
  }
  convert() {
    if (this.result) {
      return this.result;
    }
    let cnv = document.createElement("canvas");
    cnv.width = this.width;
    cnv.height = this.height;
    let ctx = cnv.getContext("2d", { willReadFrequently: true });
    let drawSubimg = (src, destx, desty, srcx = 0, srcy = 0, width = src.width, height = src.height) => {
      ctx.drawImage(src, srcx, srcy, width, height, destx, desty, width, height);
    };
    for (let alloc of this.allocs) {
      let xx1 = -this.padsize;
      let xx2 = alloc.repeatWidth + this.padsize;
      let yy1 = -this.padsize;
      let yy2 = alloc.repeatHeight + this.padsize;
      for (let y = yy1; y < yy2; y = nexty) {
        var nexty = Math.min(yy2, Math.ceil((y + 1) / alloc.img.height) * alloc.img.height);
        for (let x = xx1; x < xx2; x = nextx) {
          var nextx = Math.min(xx2, Math.ceil((x + 1) / alloc.img.width) * alloc.img.width);
          drawSubimg(
            alloc.img,
            alloc.x + x,
            alloc.y + y,
            posmod(x, alloc.img.width),
            posmod(y, alloc.img.height),
            nextx - x,
            nexty - y
          );
        }
      }
    }
    this.result = cnv;
    return cnv;
  }
};
function defaultMorphId(locmeta) {
  let newid = -1;
  if (locmeta.morphs_1) {
    newid = locmeta.morphs_1.unk2[0] ?? locmeta.morphs_1.unk3;
  }
  if (locmeta.morphs_2) {
    newid = locmeta.morphs_2.unk2;
  }
  if (newid == (1 << 15) - 1) {
    newid = -1;
  }
  if (newid == (1 << 16) - 1) {
    newid = -1;
  }
  return newid;
}
async function resolveMorphedObject(source, id) {
  let resolvedid = id;
  if (source.classicData) {
    let locdata = getClassicLoc(source, id);
    return { rawloc: locdata, morphedloc: locdata, resolvedid };
  } else {
    let objectfile = await source.getGameFile("objects", id);
    let rawloc = parse.object.read(objectfile, source);
    let morphedloc = rawloc;
    if (rawloc.morphs_1 || rawloc.morphs_2) {
      let newid = defaultMorphId(rawloc);
      if (newid != -1) {
        let newloc = await source.getGameFile("objects", newid);
        morphedloc = {
          ...rawloc,
          ...parse.object.read(newloc, source)
        };
        resolvedid = newid;
      }
    }
    return { rawloc, morphedloc, resolvedid };
  }
}
async function mapsquareOverlays(engine, grid, locs) {
  let mat = new THREE5.MeshBasicMaterial();
  mat.transparent = true;
  mat.depthTest = false;
  let floorgroup = (level) => {
    let wallgroup = {
      models: [],
      groupid: "walls" + level,
      minimapVariant: false,
      hasVertexAlpha: false,
      materialId: -1,
      material: { mat, matmeta: { ...defaultMaterial() } },
      overlayIndex: 1
    };
    let mapscenes = /* @__PURE__ */ new Map();
    return { wallgroup, mapscenes };
  };
  let floors = [floorgroup(0), floorgroup(1), floorgroup(2), floorgroup(3)];
  let addwall = (model, loc) => {
    let translate = new THREE5.Vector3().set((loc.x + loc.sizex / 2) * tiledimensions2, 0, (loc.z + loc.sizez / 2) * tiledimensions2);
    let rotation = new THREE5.Quaternion().setFromAxisAngle(upvector, loc.rotation / 2 * Math.PI);
    let scale = new THREE5.Vector3(1, 1, 1);
    floors[loc.effectiveLevel].wallgroup.models.push({
      model: model.meshes[0],
      morph: {
        level: loc.plane,
        placementMode: "followfloor",
        translate,
        rotation,
        scale,
        scaleModelHeightOffset: 0,
        originx: translate.x,
        originz: translate.z
      },
      miny: model.miny,
      maxy: model.maxy,
      extras: {
        modeltype: "overlay",
        isclickable: false,
        modelgroup: "walls" + loc.visualLevel,
        level: loc.effectiveLevel
      }
    });
  };
  let addMapscene = async (loc, sceneid) => {
    let group = floors[loc.effectiveLevel].mapscenes.get(sceneid);
    let mapscene = grid.engine.mapMapscenes[sceneid];
    if (mapscene.sprite_id == void 0) {
      return;
    }
    let spritefile = await engine.getFileById(cacheMajors.sprites, mapscene.sprite_id);
    let sprite = parseSprite(spritefile);
    let mat2 = new THREE5.MeshBasicMaterial();
    mat2.map = new THREE5.DataTexture(sprite[0].img.data, sprite[0].img.width, sprite[0].img.height, THREE5.RGBAFormat);
    mat2.depthTest = false;
    mat2.transparent = true;
    mat2.needsUpdate = true;
    group = {
      groupid: "mapscenes" + loc.effectiveLevel,
      hasVertexAlpha: false,
      materialId: -1,
      minimapVariant: false,
      material: { mat: mat2, matmeta: { ...defaultMaterial(), alphamode: "cutoff" } },
      models: [],
      overlayIndex: 2
    };
    floors[loc.effectiveLevel].mapscenes.set(sceneid, group);
    console.warn("using very inefficient code path for 3d mapscenes");
    let tex = mat2.map;
    const spritescale = 128;
    let w = tex.image.width * spritescale;
    let h = tex.image.height * spritescale;
    let mesh = new MeshBuilder(null).addParallelogram([255, 255, 255], [-w / 2, 0, -h / 2], [w, 0, 0], [0, 0, h]).convertSubmesh(0);
    let translate = new THREE5.Vector3((loc.x + loc.sizex / 2) * tiledimensions2, 0, (loc.z + loc.sizez / 2) * tiledimensions2);
    group.models.push({
      model: mesh,
      morph: {
        level: loc.plane,
        placementMode: "simple",
        rotation: new THREE5.Quaternion(),
        scale: new THREE5.Vector3(1, 1, 1),
        translate,
        scaleModelHeightOffset: 0,
        originx: translate.x,
        originz: translate.z
      },
      miny: 0,
      maxy: 0,
      extras: {
        modeltype: "overlay",
        isclickable: false,
        level: loc.visualLevel,
        modelgroup: "mapscenes"
      }
    });
  };
  for (let loc of locs) {
    if (loc.effectiveLevel == -1) {
      continue;
    }
    if (loc.type == 0) {
      addwall(topdown2dWallModels.wall, loc);
    } else if (loc.type == 1) {
      addwall(topdown2dWallModels.shortcorner, loc);
    } else if (loc.type == 2) {
      addwall(topdown2dWallModels.longcorner, loc);
    } else if (loc.type == 3) {
      addwall(topdown2dWallModels.pillar, loc);
    } else if (loc.type == 9) {
      addwall(topdown2dWallModels.diagonal, loc);
    }
    if (loc.location.mapscene != void 0) {
      await addMapscene(loc, loc.location.mapscene);
    }
  }
  return floors.flatMap((f) => [f.wallgroup, ...f.mapscenes.values()]);
}
function mapsquareObjectModels(cache, inst, minimap = false) {
  let locmodels = [];
  let objectmeta = inst.location;
  let isGroundDecor = inst.type == 22 && !objectmeta.unknown_49;
  let modelmods = {
    replaceColors: objectmeta.color_replacements ?? void 0,
    replaceMaterials: objectmeta.material_replacements ?? void 0,
    lodLevel: minimap ? 100 : void 0
  };
  if (cache.getBuildNr() > lastClassicBuildnr && cache.getBuildNr() < 377) {
    modelmods.replaceMaterials = modelmods.replaceColors;
  }
  const translatefactor = 4;
  let translate = new Vector38(
    (objectmeta.translateX ?? 0) * translatefactor,
    -(objectmeta.translateY ?? 0) * translatefactor,
    //minus y!!!
    (objectmeta.translateZ ?? 0) * translatefactor
  );
  const scalefactor = 1 / 128;
  let scale = new Vector38(
    (objectmeta.scaleX ?? 128) * scalefactor,
    (objectmeta.scaleY ?? 128) * scalefactor,
    (objectmeta.scaleZ ?? 128) * scalefactor
  );
  let originx = (inst.x + inst.sizex / 2) * tiledimensions2;
  let originz = (inst.z + inst.sizez / 2) * tiledimensions2;
  let rotation = new THREE5.Quaternion().setFromAxisAngle(upvector, inst.rotation / 2 * Math.PI);
  if (inst.rotation % 2 == 1) {
    let tmp = scale.x;
    scale.x = scale.z;
    scale.z = tmp;
  }
  if (objectmeta.mirror) {
    scale.z *= -1;
  }
  translate.add(new Vector38(originx, 0, originz));
  if (minimap) {
    translate.y -= 0.2 * tiledimensions2;
  }
  if (inst.placement) {
    translate.add(new Vector38().set(
      inst.placement.translateX ?? 0,
      -(inst.placement.translateY ?? 0),
      inst.placement.translateZ ?? 0
    ));
    if (inst.placement.scale) {
      scale.multiplyScalar((inst.placement.scale ?? 128) / 128);
    }
    if (inst.placement.scaleX || inst.placement.scaleY || inst.placement.scaleZ) {
      scale.multiply(new Vector38().set(
        (inst.placement.scaleX ?? 128) / 128,
        (inst.placement.scaleY ?? 128) / 128,
        (inst.placement.scaleZ ?? 128) / 128
      ));
    }
    if (inst.placement.rotation) {
      let scale2 = 1 / (1 << 15);
      let rot = new THREE5.Quaternion(
        -inst.placement.rotation[0] * scale2,
        inst.placement.rotation[1] * scale2,
        -inst.placement.rotation[2] * scale2,
        inst.placement.rotation[3] * scale2
      );
      rotation.premultiply(rot);
    }
  }
  let linkabove = typeof objectmeta.probably_morphCeilingOffset != "undefined";
  let followfloor = linkabove || !!objectmeta.probably_morphFloor;
  let morph = {
    translate,
    rotation,
    scale,
    level: inst.plane,
    placementMode: linkabove ? "followfloorceiling" : followfloor ? "followfloor" : "simple",
    scaleModelHeightOffset: objectmeta.probably_morphCeilingOffset ?? 0,
    originx,
    originz
  };
  let extras = {
    modeltype: "location",
    isclickable: false,
    modelgroup: minimap ? `mini_objects${inst.resolvedlocid == inst.locid && inst.location.probably_animation == void 0 ? inst.visualLevel : 0}` : `objects${inst.visualLevel}`,
    locationid: inst.locid,
    worldx: inst.x,
    worldz: inst.z,
    rotation: inst.rotation,
    mirror: !!objectmeta.mirror,
    isGroundDecor,
    level: inst.visualLevel,
    locationInstance: inst
  };
  let modelcount = 0;
  let addmodel = (type, finalmorph) => {
    if (minimap && isGroundDecor) {
      return;
    }
    if (objectmeta.models) {
      for (let ch of objectmeta.models) {
        if (ch.type != type) {
          continue;
        }
        modelcount++;
        for (let modelid of ch.values) {
          locmodels.push({ model: modelid, morph: finalmorph });
        }
      }
    } else if (objectmeta.models_05) {
      for (let ch of objectmeta.models_05.models) {
        if (ch.type != type) {
          continue;
        }
        modelcount++;
        for (let modelid of ch.values) {
          locmodels.push({ model: modelid, morph: finalmorph });
        }
      }
    }
  };
  if (inst.type == 11) {
    addmodel(10, {
      ...morph,
      rotation: new Quaternion3().setFromAxisAngle(upvector, Math.PI / 4).premultiply(morph.rotation)
    });
  } else if (inst.type == 8 || inst.type == 7 || inst.type == 6) {
    if (inst.type == 6 || inst.type == 8) {
      let dx = tiledimensions2 * 0.6;
      let angle = Math.PI / 4;
      let rotation2 = new THREE5.Quaternion().setFromAxisAngle(upvector, angle).premultiply(morph.rotation);
      addmodel(4, {
        ...morph,
        rotation: rotation2,
        translate: new THREE5.Vector3(dx, 0, 0).applyQuaternion(rotation2).add(morph.translate)
      });
    }
    if (inst.type == 7 || inst.type == 8) {
      let dx = tiledimensions2 * 0.5;
      let angle = Math.PI / 4 * 5;
      let rotation2 = new THREE5.Quaternion().setFromAxisAngle(upvector, angle).premultiply(morph.rotation);
      addmodel(4, {
        ...morph,
        rotation: rotation2,
        translate: new THREE5.Vector3(dx, 0, 0).applyQuaternion(rotation2).add(morph.translate)
      });
    }
  } else if (inst.type == 2) {
    addmodel(2, {
      ...morph,
      scale: new Vector38(1, 1, -1).multiply(morph.scale)
    });
    addmodel(2, {
      ...morph,
      rotation: new Quaternion3().setFromAxisAngle(upvector, Math.PI / 2).premultiply(morph.rotation)
    });
  } else if (inst.type == 5) {
    let dx = tiledimensions2 / 6;
    addmodel(4, {
      ...morph,
      translate: new THREE5.Vector3(dx, 0, 0).applyQuaternion(morph.rotation).add(morph.translate)
    });
  } else {
    addmodel(inst.type, morph);
  }
  return { models: locmodels, mods: modelmods, extras };
}
async function mapsquareObjects(engine, grid, locations, originx, originz, collision = false) {
  let locs = [];
  let locdatas = await Promise.all(locations.map((q) => resolveMorphedObject(engine, q.id)));
  for (let locindex = 0; locindex < locations.length; locindex++) {
    let loc = locations[locindex];
    let { morphedloc, rawloc, resolvedid } = locdatas[locindex];
    if (!morphedloc) {
      continue;
    }
    for (let inst of loc.uses) {
      let callingtile = grid.getTile(inst.x + originx, inst.y + originz, inst.plane);
      if (!callingtile) {
        continue;
      }
      let sizex = morphedloc.width ?? 1;
      let sizez = morphedloc.length ?? 1;
      if (inst.rotation % 2 == 1) {
        [sizex, sizez] = [sizez, sizex];
      }
      let visualLevel = callingtile.effectiveVisualLevel;
      for (let dz = 0; dz < sizez; dz++) {
        for (let dx = 0; dx < sizex; dx++) {
          let tile2 = grid.getTile(inst.x + originx + dx, inst.y + originz + dz, inst.plane);
          if (tile2 && tile2.effectiveVisualLevel > visualLevel) {
            visualLevel = tile2.effectiveVisualLevel;
          }
        }
      }
      locs.push({
        location: morphedloc,
        locid: loc.id,
        resolvedlocid: resolvedid,
        placement: inst.extra,
        sizex,
        sizez,
        x: inst.x + originx,
        z: inst.y + originz,
        type: inst.type,
        rotation: inst.rotation,
        plane: inst.plane,
        visualLevel,
        effectiveLevel: callingtile.effectiveLevel,
        forceVisible: !!(callingtile.settings & 8)
      });
      const fullcollisiontypes = [
        9,
        //is actually diagonal wall
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21
        //roof types, only some are confirmed
      ];
      if (collision && !rawloc.probably_nocollision) {
        for (let dz = 0; dz < sizez; dz++) {
          for (let dx = 0; dx < sizex; dx++) {
            let tile2 = grid.getTile(inst.x + originx + dx, inst.y + originz + dz, callingtile.effectiveLevel);
            if (tile2) {
              let col = tile2.effectiveCollision;
              if (inst.type == 22 && rawloc.maybe_blocks_movement) {
                col.walk[0] = true;
              }
              if (inst.type == 0) {
                col.walk[1 + inst.rotation] = true;
                if (!rawloc.maybe_allows_lineofsight) {
                  col.sight[1 + inst.rotation] = true;
                }
              } else if (inst.type == 2) {
                col.walk[1 + inst.rotation] = true;
                col.walk[1 + (inst.rotation + 1) % 4] = true;
                if (!rawloc.maybe_allows_lineofsight) {
                  col.sight[1 + inst.rotation] = true;
                  col.sight[1 + (inst.rotation + 1) % 4] = true;
                }
              } else if (inst.type == 1 || inst.type == 3) {
                col.walk[5 + inst.rotation] = true;
                if (!rawloc.maybe_allows_lineofsight) {
                  col.sight[5 + inst.rotation] = true;
                }
              } else if (fullcollisiontypes.includes(inst.type)) {
                col.walk[0] = true;
                if (!rawloc.maybe_allows_lineofsight) {
                  col.sight[0] = true;
                }
              }
            }
          }
        }
      }
    }
  }
  return locs;
}
function mapsquareCollisionMesh(grid, tilerect, level, rawmode = false) {
  const maxtriangles = tilerect.xsize * tilerect.zsize * 5 * 6 * 2;
  let posoffset = 0;
  let coloroffset = 12;
  let stride = 16;
  const posstride = stride / 4 | 0;
  const colorstride = stride;
  let [buf, slicebuf] = borrowScratchbuffer(stride * maxtriangles * 3);
  let [indexbufdata, sliceindexbuf] = borrowScratchbuffer(maxtriangles * 3 * 4, "index");
  let indexbuf = new Uint32Array(indexbufdata);
  let posbuffer = new Float32Array(buf);
  let colorbuffer = new Uint8Array(buf);
  let rootx = tilerect.x * tiledimensions2;
  let rootz = tilerect.z * tiledimensions2;
  let vertexindex = 0;
  let indexpointer = 0;
  let writevertex = (tile2, dx, dy, dz, color) => {
    const pospointer = vertexindex * posstride + posoffset;
    const colorpointer = vertexindex * colorstride + coloroffset;
    const y00 = (rawmode ? tile2.y : tile2.playery00) * (1 - dx) * (1 - dz);
    const y01 = (rawmode ? tile2.y01 : tile2.playery01) * dx * (1 - dz);
    const y10 = (rawmode ? tile2.y10 : tile2.playery10) * (1 - dx) * dz;
    const y11 = (rawmode ? tile2.y11 : tile2.playery11) * dx * dz;
    posbuffer[pospointer + 0] = tile2.x + dx * tiledimensions2 - rootx;
    posbuffer[pospointer + 1] = y00 + y01 + y10 + y11 + dy * tiledimensions2;
    posbuffer[pospointer + 2] = tile2.z + dz * tiledimensions2 - rootz;
    colorbuffer[colorpointer + 0] = color[0];
    colorbuffer[colorpointer + 1] = color[1];
    colorbuffer[colorpointer + 2] = color[2];
    colorbuffer[colorpointer + 3] = color[3];
    return vertexindex++;
  };
  let writebox = (tile2, dx, dy, dz, sizex, sizey, sizez, color) => {
    let v000 = writevertex(tile2, dx, dy, dz, color);
    let v001 = writevertex(tile2, dx + sizex, dy, dz, color);
    let v010 = writevertex(tile2, dx, dy + sizey, dz, color);
    let v011 = writevertex(tile2, dx + sizex, dy + sizey, dz, color);
    let v100 = writevertex(tile2, dx, dy, dz + sizez, color);
    let v101 = writevertex(tile2, dx + sizex, dy, dz + sizez, color);
    let v110 = writevertex(tile2, dx, dy + sizey, dz + sizez, color);
    let v111 = writevertex(tile2, dx + sizex, dy + sizey, dz + sizez, color);
    indexbuf[indexpointer++] = v000;
    indexbuf[indexpointer++] = v011;
    indexbuf[indexpointer++] = v001;
    indexbuf[indexpointer++] = v000;
    indexbuf[indexpointer++] = v010;
    indexbuf[indexpointer++] = v011;
    indexbuf[indexpointer++] = v001;
    indexbuf[indexpointer++] = v111;
    indexbuf[indexpointer++] = v101;
    indexbuf[indexpointer++] = v001;
    indexbuf[indexpointer++] = v011;
    indexbuf[indexpointer++] = v111;
    indexbuf[indexpointer++] = v000;
    indexbuf[indexpointer++] = v110;
    indexbuf[indexpointer++] = v010;
    indexbuf[indexpointer++] = v000;
    indexbuf[indexpointer++] = v100;
    indexbuf[indexpointer++] = v110;
    indexbuf[indexpointer++] = v010;
    indexbuf[indexpointer++] = v111;
    indexbuf[indexpointer++] = v011;
    indexbuf[indexpointer++] = v010;
    indexbuf[indexpointer++] = v110;
    indexbuf[indexpointer++] = v111;
    indexbuf[indexpointer++] = v000;
    indexbuf[indexpointer++] = v101;
    indexbuf[indexpointer++] = v100;
    indexbuf[indexpointer++] = v000;
    indexbuf[indexpointer++] = v001;
    indexbuf[indexpointer++] = v101;
    indexbuf[indexpointer++] = v100;
    indexbuf[indexpointer++] = v111;
    indexbuf[indexpointer++] = v110;
    indexbuf[indexpointer++] = v100;
    indexbuf[indexpointer++] = v101;
    indexbuf[indexpointer++] = v111;
  };
  for (let z = tilerect.z; z < tilerect.z + tilerect.zsize; z++) {
    for (let x = tilerect.x; x < tilerect.x + tilerect.xsize; x++) {
      let tile2 = grid.getTile(x, z, level);
      let collision = rawmode ? tile2?.rawCollision : tile2?.effectiveCollision;
      if (tile2 && collision) {
        if (collision.walk[0]) {
          let height = collision.sight[0] ? 1.8 : 0.3;
          writebox(tile2, 0.05, 0, 0.05, 0.9, height, 0.9, [100, 50, 50, 255]);
        }
        if (rawmode && collision.settings & (2 | 4 | 8 | 16)) {
          let r = 0, g = 0, b = 0;
          if (collision.settings & 2) {
            r += 0;
            g += 127;
            b += 127;
          }
          if (collision.settings & 4) {
            r += 0;
            g += 127;
            b += 0;
          }
          if (collision.settings & 8) {
            r += 127;
            g += 0;
            b += 0;
          }
          if (collision.settings & ~(1 | 2 | 4 | 8)) {
            r += 0;
            g += 0;
            b += 127;
          }
          writebox(tile2, -0.05, -0.05, 0, 1.1, 0.25, 1.1, [r, g, b, 255]);
        }
        for (let dir = 0; dir < 4; dir++) {
          if (collision.walk[1 + dir]) {
            let height = collision.sight[1 + dir] ? 2 : 0.5;
            let col = [255, 60, 60, 255];
            if (dir == 0) {
              writebox(tile2, 0, 0, 0, 0.15, height, 1, col);
            }
            if (dir == 1) {
              writebox(tile2, 0, 0, 0.85, 1, height, 0.15, col);
            }
            if (dir == 2) {
              writebox(tile2, 0.85, 0, 0, 0.15, height, 1, col);
            }
            if (dir == 3) {
              writebox(tile2, 0, 0, 0, 1, height, 0.15, col);
            }
          }
          if (collision.walk[5 + dir]) {
            let height = collision.sight[5 + dir] ? 2 : 0.5;
            let col = [255, 60, 60, 255];
            if (dir == 0) {
              writebox(tile2, 0, 0, 0.85, 0.15, height, 0.15, col);
            }
            if (dir == 1) {
              writebox(tile2, 0.85, 0, 0.85, 0.15, height, 0.15, col);
            }
            if (dir == 2) {
              writebox(tile2, 0.85, 0, 0, 0.15, height, 0.15, col);
            }
            if (dir == 3) {
              writebox(tile2, 0, 0, 0, 0.15, height, 0.15, col);
            }
          }
        }
      }
    }
  }
  let extra = {
    modeltype: "overlay",
    isclickable: false,
    modelgroup: (rawmode ? "collision-raw" : "collision") + level,
    level
  };
  let bufslice = slicebuf(vertexindex * stride);
  let indexslice = sliceindexbuf(indexpointer * 4);
  return {
    pos: new Float32Array(bufslice),
    color: new Uint8Array(bufslice),
    indices: new Uint32Array(indexslice),
    posstride,
    colorstride,
    posoffset,
    coloroffset,
    extra
  };
}
function mapsquareCollisionToThree(grid, chunk, level, rawmode = false) {
  let { color, indices, pos, coloroffset, colorstride, posoffset, posstride, extra } = mapsquareCollisionMesh(grid, chunk.tilerect, level, rawmode);
  if (indices.length == 0) {
    return void 0;
  }
  let geo = new THREE5.BufferGeometry();
  geo.setAttribute("position", new THREE5.InterleavedBufferAttribute(new THREE5.InterleavedBuffer(pos, posstride), 3, posoffset, false));
  geo.setAttribute("color", new THREE5.InterleavedBufferAttribute(new THREE5.InterleavedBuffer(color, colorstride), 4, coloroffset, true));
  geo.index = new THREE5.BufferAttribute(indices, 1, false);
  let mat = new THREE5.MeshPhongMaterial({ shininess: 0 });
  mat.flatShading = true;
  augmentZOffsetMaterial(mat, 1);
  mat.vertexColors = true;
  let model = new THREE5.Mesh(geo, mat);
  model.userData = extra;
  model.name = `${rawmode ? "raw " : ""}collision ${chunk.mapsquarex},${chunk.mapsquarez} (${level})`;
  return model;
}
async function generateLocationMeshgroups(scene, locbases, minimap = false) {
  let loadedmodels = /* @__PURE__ */ new Map();
  let matmeshes = /* @__PURE__ */ new Map();
  let byLogical = /* @__PURE__ */ new Map();
  let locs = locbases.map((loc) => mapsquareObjectModels(scene.engine, loc, minimap));
  let loadproms = [];
  let queuedmodels = /* @__PURE__ */ new Set();
  for (let loc of locs) {
    for (let model of loc.models) {
      if (queuedmodels.has(model.model)) {
        continue;
      }
      queuedmodels.add(model.model);
      loadproms.push(scene.getModelData(model.model).catch((e) => {
        console.warn("ignoring missing model", model.model, "in loc", loc.extras.locationInstance.location.name ?? loc.extras.locationid);
        return { bonecount: 0, skincount: 0, miny: 0, maxy: 0, meshes: [] };
      }).then((m) => loadedmodels.set(model.model, m)));
    }
  }
  await Promise.all(loadproms);
  for (let index = 0; index < locs.length; index++) {
    let obj = locs[index];
    let miny = 0;
    let maxy = 0;
    for (let modelinst of obj.models) {
      let model = loadedmodels.get(modelinst.model);
      miny = Math.min(model.miny, miny);
      maxy = Math.max(model.maxy, maxy);
    }
    let meshes = [];
    for (let modelinst of obj.models) {
      let model = loadedmodels.get(modelinst.model);
      for (let rawmesh of model.meshes) {
        let modified = modifyMesh(rawmesh, obj.mods);
        let matkey = materialCacheKey(modified.materialId, modified.hasVertexAlpha, minimap);
        let group = matmeshes.get(obj.extras.modelgroup);
        if (!group) {
          group = /* @__PURE__ */ new Map();
          matmeshes.set(obj.extras.modelgroup, group);
        }
        let matgroup = getOrInsert(group, matkey, () => ({
          materialId: modified.materialId,
          material: null,
          hasVertexAlpha: modified.hasVertexAlpha,
          minimapVariant: minimap,
          models: [],
          groupid: obj.extras.modelgroup,
          overlayIndex: 0
        }));
        let mesh = {
          model: modified,
          morph: modelinst.morph,
          miny,
          maxy,
          extras: obj.extras
        };
        meshes.push(mesh);
        matgroup.models.push(mesh);
      }
    }
    if (meshes.length != 0) {
      byLogical.set(locbases[index], meshes);
    }
  }
  let byMaterial = [];
  for (let group of matmeshes.values()) {
    byMaterial.push(...group.values());
  }
  return { byMaterial, byLogical };
}
var RSBatchMesh = class _RSBatchMesh extends THREE5.Mesh {
  constructor(geo, mat) {
    super(geo, mat);
    this.renderSections = [];
  }
  cloneSection(section) {
    let geo = new THREE5.BufferGeometry();
    for (let attrname in this.geometry.attributes) {
      let attr = this.geometry.attributes[attrname];
      let cloned = new BufferAttribute7(attr.array.slice(section.startvertex * attr.itemSize, section.endvertex * attr.itemSize), attr.itemSize, attr.normalized);
      geo.setAttribute(attrname, cloned);
    }
    let indexarr = this.geometry.index.array.slice(section.startindex, section.endindex);
    for (let i = 0; i < indexarr.length; i++) {
      indexarr[i] -= section.startvertex;
    }
    geo.setIndex(new THREE5.BufferAttribute(indexarr, 1));
    let clone = new _RSBatchMesh(geo, this.material);
    let newsection = {
      mesh: clone,
      startindex: 0,
      endindex: section.endindex - section.startindex,
      startvertex: 0,
      endvertex: section.endvertex - section.startvertex,
      hidden: false
    };
    clone.renderSections.push(newsection);
    return newsection;
  }
  setSectionHide(section, hide) {
    if (section.hidden == hide) {
      return;
    }
    section.hidden = hide;
    let drawend = this.geometry.drawRange.count;
    if (this.geometry.drawRange.start != 0) {
      throw new Error("unexpected");
    }
    if (!this.geometry.index) {
      throw new Error("unexpected");
    }
    if (!isFinite(drawend)) {
      drawend = this.geometry.index.count;
    }
    let len = section.endindex - section.startindex;
    let newoffset = hide ? drawend - len : drawend;
    if (hide) {
      let tmp = this.geometry.index.array.slice(section.startindex, section.endindex);
      this.geometry.index.array.copyWithin(section.startindex, section.endindex, drawend);
      this.geometry.index.array.set(tmp, newoffset);
    } else {
      let tmp = this.geometry.index.array.slice(section.startindex, section.endindex);
      this.geometry.index.array.copyWithin(drawend + len, drawend, section.startindex);
      this.geometry.index.array.set(tmp, newoffset);
    }
    let front = hide ? section.startindex : newoffset;
    let back = hide ? drawend : section.endindex;
    let changediff = hide ? -len : len;
    for (let i = 0; i < this.renderSections.length; i++) {
      let other = this.renderSections[i];
      if (other == section) {
        continue;
      }
      if (other.startindex < front || other.startindex >= back) {
        continue;
      }
      other.startindex += changediff;
      other.endindex += changediff;
    }
    section.startindex = newoffset;
    section.endindex = newoffset + len;
    this.geometry.setDrawRange(0, drawend + changediff);
    this.geometry.index.needsUpdate = true;
  }
};
function meshgroupsToThree(grid, meshgroup, rootx, rootz, material, locrenders) {
  let totalverts = meshgroup.models.reduce((a, v) => a + v.model.vertexend - v.model.vertexstart, 0);
  let totalindices = meshgroup.models.reduce((a, v) => a + v.model.indices.count, 0);
  let vertalphas = meshgroup.models.reduce((a, v) => a + +v.model.hasVertexAlpha, 0);
  if (vertalphas != 0 && vertalphas != meshgroup.models.length) {
    throw new Error("all meshes are expected to have same vertexAlpha setting");
  }
  let hasvertexAlpha = vertalphas != 0;
  let vertindex = 0;
  let indexindex = 0;
  let pos = new BufferAttribute7(new Float32Array(totalverts * 3), 3);
  let uvs = new BufferAttribute7(new Float32Array(totalverts * 2), 2);
  let col = new BufferAttribute7(new Uint8Array(totalverts * (hasvertexAlpha ? 4 : 3)), hasvertexAlpha ? 4 : 3, true);
  let normals = new BufferAttribute7(new Int8Array(totalverts * 3), 3, true);
  let indices = new BufferAttribute7(totalverts > 65535 ? new Uint32Array(totalindices) : new Uint16Array(totalindices), 1);
  let mergedgeo = new THREE5.BufferGeometry();
  mergedgeo.setAttribute("position", pos);
  mergedgeo.setAttribute("normal", normals);
  mergedgeo.setAttribute("color", col);
  mergedgeo.setAttribute("uv", uvs);
  mergedgeo.setIndex(indices);
  let mergedmesh = new RSBatchMesh(mergedgeo);
  let indexcounts = [];
  for (let m of meshgroup.models) {
    let mesh = m.model;
    let matrix = getMorphMatrix(m.morph, rootx, rootz);
    let vertexcount = mesh.vertexend - mesh.vertexstart;
    let indexcount = mesh.indices.count;
    indexcounts.push(indexindex);
    let section = {
      mesh: mergedmesh,
      startindex: indexindex,
      endindex: indexindex + indexcount,
      startvertex: vertindex,
      endvertex: vertindex + vertexcount,
      hidden: false
    };
    mergedmesh.renderSections.push(section);
    if (m.extras.modeltype == "location") {
      let v = getOrInsert(locrenders, m.extras.locationInstance, () => []);
      v.push(section);
    }
    {
      let vertoffset = vertindex - mesh.vertexstart;
      let oldindices = mesh.indices;
      if (matrix.determinant() < 0) {
        for (let i = 0; i < indexcount; i += 3) {
          let ii = indexindex + i;
          indices.setX(ii + 0, vertoffset + oldindices.getX(i + 0));
          indices.setX(ii + 1, vertoffset + oldindices.getX(i + 2));
          indices.setX(ii + 2, vertoffset + oldindices.getX(i + 1));
        }
      } else {
        for (let i = 0; i < indexcount; i += 3) {
          let ii = indexindex + i;
          indices.setX(ii + 0, vertoffset + oldindices.getX(i + 0));
          indices.setX(ii + 1, vertoffset + oldindices.getX(i + 1));
          indices.setX(ii + 2, vertoffset + oldindices.getX(i + 2));
        }
      }
    }
    transformVertexPositions(mesh.attributes.pos, m.morph, grid, m.maxy - m.miny, rootx, rootz, pos, vertindex, mesh.vertexstart, mesh.vertexend);
    {
      let vector = new THREE5.Vector3();
      if (mesh.attributes.normals) {
        let norm = mesh.attributes.normals;
        let [oldbuf, oldsuboffset, oldstride] = getAttributeBackingStore(norm);
        let [newbuf, newsuboffset, newstride] = getAttributeBackingStore(normals);
        let oldoffset = mesh.vertexstart * oldstride + oldsuboffset;
        let newoffset = vertindex * newstride + newsuboffset;
        let rotation = new THREE5.Matrix4().makeRotationFromQuaternion(m.morph.rotation);
        for (let i = 0; i < vertexcount; i++) {
          let ii = newoffset + i * newstride;
          let jj = oldoffset + i * oldstride;
          vector.set(oldbuf[jj + 0], oldbuf[jj + 1], oldbuf[jj + 2]);
          vector.applyMatrix4(rotation);
          newbuf[ii + 0] = Math.round(vector.x);
          newbuf[ii + 1] = Math.round(vector.y);
          newbuf[ii + 2] = Math.round(vector.z);
        }
      } else {
        computePartialNormals(indices, pos, normals, indexindex, indexindex + indexcount);
      }
    }
    {
      let [newbuf, newsuboffset, newstride] = getAttributeBackingStore(col);
      let newoffset = vertindex * newstride + newsuboffset;
      if (mesh.attributes.color) {
        let [oldbuf, oldsuboffset, oldstride] = getAttributeBackingStore(mesh.attributes.color);
        let oldoffset = mesh.vertexstart * oldstride + oldsuboffset;
        if (hasvertexAlpha) {
          for (let i = 0; i < vertexcount; i++) {
            let ii = newoffset + i * newstride;
            let jj = oldoffset + i * oldstride;
            newbuf[ii + 0] = oldbuf[jj + 0];
            newbuf[ii + 1] = oldbuf[jj + 1];
            newbuf[ii + 2] = oldbuf[jj + 2];
            newbuf[ii + 3] = oldbuf[jj + 3];
          }
        } else {
          for (let i = 0; i < vertexcount; i++) {
            let ii = newoffset + i * newstride;
            let jj = oldoffset + i * oldstride;
            newbuf[ii + 0] = oldbuf[jj + 0];
            newbuf[ii + 1] = oldbuf[jj + 1];
            newbuf[ii + 2] = oldbuf[jj + 2];
          }
        }
      } else {
        for (let i = 0; i < vertexcount; i++) {
          let ii = newoffset + i * newstride;
          newbuf[ii + 0] = 1;
          newbuf[ii + 1] = 1;
          newbuf[ii + 2] = 1;
          if (hasvertexAlpha) {
            newbuf[ii + 3] = 1;
          }
        }
      }
    }
    {
      let olduvs = mesh.attributes.texuvs;
      if (olduvs) {
        for (let i = 0; i < vertexcount; i++) {
          uvs.setXY(vertindex + i, olduvs.getX(mesh.vertexstart + i), olduvs.getY(mesh.vertexstart + i));
        }
      } else {
        for (let i = 0; i < vertexcount; i++) {
          uvs.setXY(vertindex + i, 0, 0);
        }
      }
    }
    vertindex += vertexcount;
    indexindex += indexcount;
  }
  applyMaterial(mergedmesh, material, meshgroup.minimapVariant);
  let clickable = {
    modeltype: "locationgroup",
    modelgroup: meshgroup.groupid,
    isclickable: true,
    subranges: indexcounts,
    searchPeers: true,
    subobjects: meshgroup.models.map((q) => q.extras)
  };
  mergedmesh.renderOrder = meshgroup.overlayIndex;
  mergedmesh.userData = clickable;
  mergedmesh.matrixAutoUpdate = false;
  mergedmesh.updateMatrix();
  mergedmesh.name = "merged locs";
  return mergedmesh;
}
function mapsquarePathMesh(grid, chunk, level) {
  const maxtiles = chunk.tilerect.xsize * chunk.tilerect.zsize * grid.levels;
  const maxVerticesPerTile = 6;
  const posoffset = 0;
  const normaloffset = 3;
  const coloroffset = 24;
  const texusescoloroffset = 28;
  const texweightoffset = 32;
  const texuvoffset = 18;
  const vertexstride = 52;
  let [vertexbuffer, slicebuffer] = borrowScratchbuffer(maxtiles * vertexstride * maxVerticesPerTile);
  let [indexbufferdata, sliceindexbuffer] = borrowScratchbuffer(maxtiles * maxVerticesPerTile * 4, "index");
  let indexbuffer = new Uint32Array(indexbufferdata);
  let posbuffer = new Float32Array(vertexbuffer);
  let normalbuffer = new Float32Array(vertexbuffer);
  let colorbuffer = new Uint8Array(vertexbuffer);
  let texusescolorbuffer = new Uint8Array(vertexbuffer);
  let texweightbuffer = new Uint8Array(vertexbuffer);
  let texuvbuffer = new Uint16Array(vertexbuffer);
  const posstride = vertexstride / 4 | 0;
  const normalstride = vertexstride / 4 | 0;
  const colorstride = vertexstride | 0;
  const texusescolorstride = vertexstride | 0;
  const texweightstride = vertexstride | 0;
  const texuvstride = vertexstride / 2 | 0;
  let vertexindex = 0;
  let indexpointer = 0;
  const modelx = chunk.tilerect.x * tiledimensions2;
  const modelz = chunk.tilerect.z * tiledimensions2;
  let tileinfos = [];
  let tileindices = [];
  let minx = Infinity, miny = Infinity, minz = Infinity;
  let maxx = -Infinity, maxy = -Infinity, maxz = -Infinity;
  const writeVertex = (tile2, subx, subz, polyprops, currentmat) => {
    const pospointer = vertexindex * posstride + posoffset;
    const normalpointer = vertexindex * normalstride + normaloffset;
    const colpointer = vertexindex * colorstride + coloroffset;
    const texweightpointer = vertexindex * texweightstride + texweightoffset;
    const texusescolorpointer = vertexindex * texusescolorstride + texusescoloroffset;
    const texuvpointer = vertexindex * texuvstride + texuvoffset;
    const w00 = (1 - subx) * (1 - subz);
    const w01 = subx * (1 - subz);
    const w10 = (1 - subx) * subz;
    const w11 = subx * subz;
    const x = tile2.x + subx * tiledimensions2 - modelx;
    const z = tile2.z + subz * tiledimensions2 - modelz;
    const y = tile2.playery00 * w00 + tile2.playery01 * w01 + tile2.playery10 * w10 + tile2.playery11 * w11;
    minx = Math.min(minx, x);
    miny = Math.min(miny, y);
    minz = Math.min(minz, z);
    maxx = Math.max(maxx, x);
    maxy = Math.max(maxy, y);
    maxz = Math.max(maxz, z);
    posbuffer[pospointer + 0] = x;
    posbuffer[pospointer + 1] = y;
    posbuffer[pospointer + 2] = z;
    let r = polyprops[currentmat].color[0];
    let g = polyprops[currentmat].color[1];
    let b = polyprops[currentmat].color[2];
    colorbuffer[colpointer + 0] = r;
    colorbuffer[colpointer + 1] = g;
    colorbuffer[colpointer + 2] = b;
    colorbuffer[colpointer + 3] = 255;
    return vertexindex++;
  };
  let polypropswalkable = [{
    material: -1,
    materialTiling: 128,
    materialBleedpriority: 0,
    color: [0, 0, 0]
  }];
  let polypropsblocked = [{
    material: -1,
    materialTiling: 128,
    materialBleedpriority: 0,
    color: [255, 0, 255]
  }];
  for (let blockedpass of [true, false]) {
    for (let z = 0; z < chunk.tilerect.zsize; z++) {
      for (let x = 0; x < chunk.tilerect.xsize; x++) {
        let tile2 = grid.getTile(chunk.tilerect.x + x, chunk.tilerect.z + z, level);
        let effectivetile = tile2;
        for (let tilelevel = level + 1; tilelevel < chunk.levelcount; tilelevel++) {
          let leveltile = grid.getTile(chunk.tilerect.x + x, chunk.tilerect.z + z, tilelevel);
          if (leveltile && leveltile.effectiveLevel == level) {
            effectivetile = leveltile;
          }
        }
        if (!tile2 || !effectivetile) {
          continue;
        }
        let isblocked = !!tile2.effectiveCollision?.walk[0];
        let polyprops = isblocked ? polypropsblocked : polypropswalkable;
        if (isblocked != blockedpass) {
          continue;
        }
        indexbuffer[indexpointer++] = writeVertex(tile2, 0, 0, polyprops, 0);
        indexbuffer[indexpointer++] = writeVertex(tile2, 0, 1, polyprops, 0);
        indexbuffer[indexpointer++] = writeVertex(tile2, 1, 1, polyprops, 0);
        indexbuffer[indexpointer++] = writeVertex(tile2, 0, 0, polyprops, 0);
        indexbuffer[indexpointer++] = writeVertex(tile2, 1, 1, polyprops, 0);
        indexbuffer[indexpointer++] = writeVertex(tile2, 1, 0, polyprops, 0);
      }
    }
  }
  let extra = {
    modelgroup: "walkmesh" + level,
    modeltype: "floorhidden",
    mapsquarex: chunk.mapsquarex,
    mapsquarez: chunk.mapsquarez,
    level,
    isclickable: true,
    searchPeers: false,
    subobjects: tileinfos,
    subranges: tileindices
  };
  let vertexslice = slicebuffer(vertexindex * vertexstride);
  let indexslice = sliceindexbuffer(indexpointer * 4);
  let vertexfloat = new Float32Array(vertexslice);
  let vertexubyte = new Uint8Array(vertexslice);
  let vertexushort = new Uint16Array(vertexslice);
  return {
    chunk,
    level,
    tileinfos,
    mode: "walkmesh",
    iswater: false,
    vertexstride,
    //TODO i'm not actually using these, can get rid of it again
    indices: new Uint32Array(indexslice),
    nvertices: vertexindex,
    atlas: null,
    pos: { src: vertexfloat, offset: posoffset, vecsize: 3, normalized: false },
    normal: { src: vertexfloat, offset: normaloffset, vecsize: 3, normalized: false },
    color: { src: vertexubyte, offset: coloroffset, vecsize: 4, normalized: true },
    _RA_FLOORTEX_UV0: { src: vertexushort, offset: texuvoffset + 0, vecsize: 2, normalized: true },
    _RA_FLOORTEX_UV1: { src: vertexushort, offset: texuvoffset + 2, vecsize: 2, normalized: true },
    _RA_FLOORTEX_UV2: { src: vertexushort, offset: texuvoffset + 4, vecsize: 2, normalized: true },
    _RA_FLOORTEX_WEIGHTS: { src: vertexubyte, offset: texweightoffset, vecsize: 3, normalized: true },
    _RA_FLOORTEX_USESCOLOR: { src: vertexubyte, offset: texusescoloroffset, vecsize: 3, normalized: true },
    posmax: [maxx, maxy, maxz],
    posmin: [minx, miny, minz],
    extra
  };
}
function mapsquareMesh(grid, chunk, level, atlas, keeptileinfo = false, mode = "default", drawWater = false) {
  const showhidden = mode == "wireframe";
  const worldmap = mode == "worldmap";
  const isMinimap = mode == "minimap";
  const maxtiles = chunk.tilerect.xsize * chunk.tilerect.zsize * grid.levels;
  const maxVerticesPerTile = 8;
  const posoffset = 0;
  const normaloffset = 3;
  const coloroffset = 24;
  const texusescoloroffset = 28;
  const texweightoffset = 32;
  const texuvoffset = 18;
  const vertexstride = 52;
  let [vertexbuffer, slicebuffer] = borrowScratchbuffer(maxtiles * vertexstride * maxVerticesPerTile);
  let [indexbufferdata, sliceindexbuffer] = borrowScratchbuffer(maxtiles * maxVerticesPerTile * 4, "index");
  let indexbuffer = new Uint32Array(indexbufferdata);
  let posbuffer = new Float32Array(vertexbuffer);
  let normalbuffer = new Float32Array(vertexbuffer);
  let colorbuffer = new Uint8Array(vertexbuffer);
  let texusescolorbuffer = new Uint8Array(vertexbuffer);
  let texweightbuffer = new Uint8Array(vertexbuffer);
  let texuvbuffer = new Uint16Array(vertexbuffer);
  const posstride = vertexstride / 4 | 0;
  const normalstride = vertexstride / 4 | 0;
  const colorstride = vertexstride | 0;
  const texusescolorstride = vertexstride | 0;
  const texweightstride = vertexstride | 0;
  const texuvstride = vertexstride / 2 | 0;
  let vertexindex = 0;
  let indexpointer = 0;
  const modelx = chunk.tilerect.x * tiledimensions2;
  const modelz = chunk.tilerect.z * tiledimensions2;
  let tileinfos = [];
  let tileindices = [];
  let minx = Infinity, miny = Infinity, minz = Infinity;
  let maxx = -Infinity, maxy = -Infinity, maxz = -Infinity;
  const writeVertex = (tile2, subx, subz, polyprops, currentmat) => {
    const pospointer = vertexindex * posstride + posoffset;
    const normalpointer = vertexindex * normalstride + normaloffset;
    const colpointer = vertexindex * colorstride + coloroffset;
    const texweightpointer = vertexindex * texweightstride + texweightoffset;
    const texusescolorpointer = vertexindex * texusescolorstride + texusescoloroffset;
    const texuvpointer = vertexindex * texuvstride + texuvoffset;
    const w00 = (1 - subx) * (1 - subz);
    const w01 = subx * (1 - subz);
    const w10 = (1 - subx) * subz;
    const w11 = subx * subz;
    const x = tile2.x + subx * tiledimensions2 - modelx;
    const z = tile2.z + subz * tiledimensions2 - modelz;
    const y = drawWater ? tile2.waterProps.y00 * w00 + tile2.waterProps.y01 * w01 + tile2.waterProps.y10 * w10 + tile2.waterProps.y11 * w11 : tile2.y * w00 + tile2.y01 * w01 + tile2.y10 * w10 + tile2.y11 * w11;
    const normalx = drawWater ? 0 : tile2.normalX * w00 + (tile2.next01 ?? tile2).normalX * w01 + (tile2.next10 ?? tile2).normalX * w10 + (tile2.next11 ?? tile2).normalX * w11;
    const normalz = drawWater ? 0 : tile2.normalZ * w00 + (tile2.next01 ?? tile2).normalZ * w01 + (tile2.next10 ?? tile2).normalZ * w10 + (tile2.next11 ?? tile2).normalZ * w11;
    minx = Math.min(minx, x);
    miny = Math.min(miny, y);
    minz = Math.min(minz, z);
    maxx = Math.max(maxx, x);
    maxy = Math.max(maxy, y);
    maxz = Math.max(maxz, z);
    posbuffer[pospointer + 0] = x;
    posbuffer[pospointer + 1] = y;
    posbuffer[pospointer + 2] = z;
    normalbuffer[normalpointer + 0] = normalx;
    normalbuffer[normalpointer + 1] = Math.sqrt(1 - normalx * normalx - normalz * normalz);
    normalbuffer[normalpointer + 2] = normalz;
    let r = polyprops[currentmat].color[0];
    let g = polyprops[currentmat].color[1];
    let b = polyprops[currentmat].color[2];
    if (isMinimap) {
      r = 20 + 0.656 * r;
      g = 28 + 0.577 * g;
      b = 23 + 0.604 * b;
      if (drawWater) {
        r = Math.pow(r / 255, 2.2) * 255;
        g = Math.pow(g / 255, 2.2) * 255;
        b = Math.pow(b / 255, 2.2) * 255;
      }
    }
    colorbuffer[colpointer + 0] = r;
    colorbuffer[colpointer + 1] = g;
    colorbuffer[colpointer + 2] = b;
    colorbuffer[colpointer + 3] = 255;
    for (let i = 0; i < 3; i++) {
      texuvbuffer[texuvpointer + 2 * i + 0] = 0;
      texuvbuffer[texuvpointer + 2 * i + 1] = 0;
      texweightbuffer[texweightpointer + i] = 0;
      texusescolorbuffer[texusescolorpointer + i] = 0;
      if (i < polyprops.length) {
        const subprop = polyprops[i];
        let texdata = void 0;
        let whitemix = 0;
        if (subprop && subprop.material != -1) {
          let mat = grid.engine.getMaterialData(subprop.material);
          whitemix = mat.baseColorFraction;
          if (mat.textures.diffuse) {
            texdata = atlas.map.get(mat.textures.diffuse);
          }
        }
        if (texdata) {
          let gridsize = subprop.materialTiling / 128;
          let ubase = tile2.x / tiledimensions2 % gridsize;
          let vbase = tile2.z / tiledimensions2 % gridsize;
          const maxuv = 65536;
          texuvbuffer[texuvpointer + 2 * i + 0] = (texdata.u + texdata.usize * (ubase + subx) / gridsize) * maxuv;
          texuvbuffer[texuvpointer + 2 * i + 1] = (texdata.v + texdata.vsize * (vbase + subz) / gridsize) * maxuv;
          texweightbuffer[texweightpointer + i] = i == currentmat ? 255 : 0;
          texusescolorbuffer[texusescolorpointer + i] = 255 - whitemix * 255;
        }
      }
    }
    return vertexindex++;
  };
  for (let tilelevel = level; tilelevel < chunk.levelcount; tilelevel++) {
    if (showhidden && tilelevel != level) {
      continue;
    }
    for (let z = 0; z < chunk.tilerect.zsize; z++) {
      for (let x = 0; x < chunk.tilerect.xsize; x++) {
        let tile2 = grid.getTile(chunk.tilerect.x + x, chunk.tilerect.z + z, tilelevel);
        if (!tile2) {
          continue;
        }
        if (!showhidden && tile2.effectiveVisualLevel != level) {
          continue;
        }
        let shape = tile2.shape;
        let hasneighbours = tile2.next01 && tile2.next10 && tile2.next11;
        if (shape == defaulttileshape && hasneighbours) {
          let dcpos = Math.abs(tile2.underlayprops.color[0] - tile2.next11.underlayprops.color[0]) + Math.abs(tile2.underlayprops.color[1] - tile2.next11.underlayprops.color[1]) + Math.abs(tile2.underlayprops.color[2] - tile2.next11.underlayprops.color[2]);
          let dcinv = Math.abs(tile2.next01.underlayprops.color[0] - tile2.next10.underlayprops.color[0]) + Math.abs(tile2.next01.underlayprops.color[1] - tile2.next10.underlayprops.color[1]) + Math.abs(tile2.next01.underlayprops.color[2] - tile2.next10.underlayprops.color[2]);
          if (dcpos < dcinv) {
            shape = defaulttileshapeflipped;
          }
        }
        if (keeptileinfo) {
          tileinfos.push({ tile: tile2.debug_raw, x, z, level: tilelevel, tilenxt: tile2.debug_nxttile, underlaycolor: tile2.originalUnderlayColor });
          tileindices.push(indexpointer);
        }
        if (drawWater) {
          if (tile2.waterProps) {
            let props = tile2.waterProps.props;
            let polyprops = [props, props, props];
            let shape2 = tile2.waterProps.shape;
            for (let i = 2; i < shape2.length; i++) {
              let v0 = shape2[0];
              let v1 = shape2[i - 1];
              let v2 = shape2[i];
              if (!v0 || !v1 || !v2) {
                continue;
              }
              indexbuffer[indexpointer++] = writeVertex(tile2, v0.subx, v0.subz, polyprops, 0);
              indexbuffer[indexpointer++] = writeVertex(tile2, v1.subx, v1.subz, polyprops, 1);
              indexbuffer[indexpointer++] = writeVertex(tile2, v2.subx, v2.subz, polyprops, 2);
            }
          }
        } else {
          if (hasneighbours && shape.overlay.length != 0) {
            let overlaytype = tile2.rawOverlay;
            let color = overlaytype?.color ?? (overlaytype && typeof overlaytype.materialbyte != "undefined" ? [255, 255, 255] : [255, 0, 255]);
            let isvisible = tile2.overlayVisible;
            if (worldmap && !isvisible && overlaytype?.secondary_colour) {
              color = overlaytype.secondary_colour;
              isvisible = true;
            }
            if (isvisible || showhidden) {
              let props;
              if (!worldmap) {
                props = shape.overlay.map((vertex) => {
                  if (!tile2.bleedsOverlayMaterial) {
                    return tile2.overlayprops;
                  } else {
                    let node = tile2;
                    if (vertex.nextx && vertex.nextz) {
                      node = tile2.next11;
                    } else if (vertex.nextx) {
                      node = tile2.next01;
                    } else if (vertex.nextz) {
                      node = tile2.next10;
                    }
                    if (node) {
                      return node.vertexprops[vertex.subvertex];
                    }
                  }
                  return defaultVertexProp;
                });
              } else {
                let vert = {
                  material: 0,
                  materialTiling: 128,
                  materialBleedpriority: 0,
                  color
                };
                props = Array(shape.overlay.length).fill(vert);
              }
              for (let i = 2; i < shape.overlay.length; i++) {
                let v0 = shape.overlay[0];
                let v1 = shape.overlay[i - 1];
                let v2 = shape.overlay[i];
                if (!v0 || !v1 || !v2) {
                  continue;
                }
                let polyprops = [props[0], props[i - 1], props[i]];
                indexbuffer[indexpointer++] = writeVertex(tile2, v0.subx, v0.subz, polyprops, 0);
                indexbuffer[indexpointer++] = writeVertex(tile2, v1.subx, v1.subz, polyprops, 1);
                indexbuffer[indexpointer++] = writeVertex(tile2, v2.subx, v2.subz, polyprops, 2);
              }
            }
          }
          if (hasneighbours && shape.underlay.length != 0 && (tile2.underlayVisible || showhidden)) {
            let props;
            if (!worldmap) {
              props = shape.underlay.map((vertex) => {
                let node = tile2;
                if (vertex.nextx && vertex.nextz) {
                  node = tile2.next11;
                } else if (vertex.nextx) {
                  node = tile2.next01;
                } else if (vertex.nextz) {
                  node = tile2.next10;
                }
                if (node) {
                  let prop = node.vertexprops[vertex.subvertex];
                  if (prop.material == -1) {
                    return { ...prop, material: tile2.underlayprops.material };
                  } else {
                    return prop;
                  }
                }
                return defaultVertexProp;
              });
            } else {
              let prop = {
                material: 0,
                materialTiling: 128,
                materialBleedpriority: -1,
                color: tile2.underlayprops.color
              };
              props = Array(shape.underlay.length).fill(prop);
            }
            for (let i = 2; i < shape.underlay.length; i++) {
              let v0 = shape.underlay[0];
              let v1 = shape.underlay[i - 1];
              let v2 = shape.underlay[i];
              if (!v0 || !v1 || !v2) {
                continue;
              }
              let polyprops = [props[0], props[i - 1], props[i]];
              indexbuffer[indexpointer++] = writeVertex(tile2, v0.subx, v0.subz, polyprops, 0);
              indexbuffer[indexpointer++] = writeVertex(tile2, v1.subx, v1.subz, polyprops, 1);
              indexbuffer[indexpointer++] = writeVertex(tile2, v2.subx, v2.subz, polyprops, 2);
            }
          }
        }
      }
    }
  }
  let extra = {
    modelgroup: (mode == "wireframe" ? "floorhidden" : mode == "worldmap" ? "map" : mode == "minimap" ? "mini_floor" : "floor") + level,
    modeltype: showhidden ? "floorhidden" : "floor",
    mapsquarex: chunk.mapsquarex,
    mapsquarez: chunk.mapsquarez,
    level,
    isclickable: true,
    searchPeers: false,
    subobjects: tileinfos,
    subranges: tileindices
  };
  let vertexslice = slicebuffer(vertexindex * vertexstride);
  let indexslice = sliceindexbuffer(indexpointer * 4);
  let vertexfloat = new Float32Array(vertexslice);
  let vertexubyte = new Uint8Array(vertexslice);
  let vertexushort = new Uint16Array(vertexslice);
  return {
    chunk,
    level,
    tileinfos,
    mode,
    iswater: drawWater,
    vertexstride,
    //TODO i'm not actually using these, can get rid of it again
    indices: new Uint32Array(indexslice),
    nvertices: vertexindex,
    atlas: mode != "worldmap" ? atlas : null,
    pos: { src: vertexfloat, offset: posoffset, vecsize: 3, normalized: false },
    normal: { src: vertexfloat, offset: normaloffset, vecsize: 3, normalized: false },
    color: { src: vertexubyte, offset: coloroffset, vecsize: 4, normalized: true },
    _RA_FLOORTEX_UV0: { src: vertexushort, offset: texuvoffset + 0, vecsize: 2, normalized: true },
    _RA_FLOORTEX_UV1: { src: vertexushort, offset: texuvoffset + 2, vecsize: 2, normalized: true },
    _RA_FLOORTEX_UV2: { src: vertexushort, offset: texuvoffset + 4, vecsize: 2, normalized: true },
    _RA_FLOORTEX_WEIGHTS: { src: vertexubyte, offset: texweightoffset, vecsize: 3, normalized: true },
    _RA_FLOORTEX_USESCOLOR: { src: vertexubyte, offset: texusescoloroffset, vecsize: 3, normalized: true },
    posmax: [maxx, maxy, maxz],
    posmin: [minx, miny, minz],
    extra
  };
}
function floorToThree(scene, floor) {
  if (floor.nvertices == 0) {
    return void 0;
  }
  let makeAttribute = (attr) => {
    let buf = new THREE5.InterleavedBuffer(attr.src, floor.vertexstride / attr.src.BYTES_PER_ELEMENT);
    return new THREE5.InterleavedBufferAttribute(buf, attr.vecsize, attr.offset, attr.normalized);
  };
  let geo = new THREE5.BufferGeometry();
  geo.setAttribute("position", makeAttribute(floor.pos));
  geo.setAttribute("color", makeAttribute(floor.color));
  geo.setAttribute("normal", makeAttribute(floor.normal));
  geo.setAttribute("texcoord_0", makeAttribute(floor._RA_FLOORTEX_UV0));
  geo.setAttribute("texcoord_1", makeAttribute(floor._RA_FLOORTEX_UV1));
  geo.setAttribute("texcoord_2", makeAttribute(floor._RA_FLOORTEX_UV2));
  geo.setAttribute("color_1", makeAttribute(floor._RA_FLOORTEX_WEIGHTS));
  geo.setAttribute("color_2", makeAttribute(floor._RA_FLOORTEX_USESCOLOR));
  let mat = floor.mode != "worldmap" ? new THREE5.MeshPhongMaterial({ shininess: 0 }) : new THREE5.MeshBasicMaterial();
  mat.vertexColors = true;
  if (floor.mode == "walkmesh") {
    augmentZOffsetMaterial(mat, 1);
  }
  if (floor.mode == "wireframe") {
    mat.wireframe = true;
  }
  if (floor.atlas) {
    let map = floor.atlas.convertToThreeTexture();
    if (floor.mode == "minimap") {
      if (floor.iswater) {
        mat = minimapWaterMaterial(map);
      } else {
        mat = minimapFloorMaterial(map);
      }
    } else {
      augmentThreeJsFloorMaterial(mat, false);
      mat.map = map;
    }
  }
  let model = new THREE5.Mesh(geo, mat);
  model.userData = floor.extra;
  model.name = `floor ${floor.chunk.mapsquarex},${floor.chunk.mapsquarez} (${floor.level})`;
  return model;
}

// rsmv/src/map/index.ts
import prettyJson3 from "json-stringify-pretty-compact";
import * as zlib from "zlib";
import { Camera as Camera2, Matrix4 as Matrix48, Object3D as Object3D6, OrthographicCamera as OrthographicCamera2, Vector3 as Vector310 } from "three";

// rsmv/src/map/progressui.ts
var ProgressUI = class _ProgressUI {
  constructor() {
    this.tiles = /* @__PURE__ */ new Map();
    this.props = {};
    this.updateDebounce = 0;
    this.queuedUpdates = [];
    this.areas = [];
    this.grid = document.createElement("div");
    this.grid.style.display = "grid";
    this.proproot = document.createElement("div");
    let root = document.createElement("div");
    root.style.display = "grid";
    root.style.grid = "'a b'/auto 1fr";
    root.appendChild(this.grid);
    root.appendChild(this.proproot);
    this.root = root;
  }
  static {
    this.renderBackgrounds = {
      loaded: "lime",
      loading: "red",
      unloaded: "green"
    };
  }
  static {
    this.backgrounds = {
      queued: "black",
      imaging: "orange",
      saving: "yellow",
      done: "green",
      skipped: "darkgreen"
    };
  }
  setAreas(areas) {
    this.areas = areas;
    this.grid.replaceChildren();
    let minx = Infinity, minz = Infinity;
    let maxx = -Infinity, maxz = -Infinity;
    for (let area of areas) {
      minx = Math.min(minx, area.x);
      minz = Math.min(minz, area.z);
      maxx = Math.max(maxx, area.x + area.xsize - 1);
      maxz = Math.max(maxz, area.z + area.zsize - 1);
      for (let dz = 0; dz < area.zsize; dz++) {
        for (let dx = 0; dx < area.xsize; dx++) {
          let id = `${area.x + dx}-${area.z + dz}`;
          if (!this.tiles.has(id)) {
            let el = document.createElement("div");
            this.tiles.set(id, { x: area.x + dx, z: area.z + dz, el, progress: "queued", loadstate: "unloaded" });
          }
        }
      }
    }
    const maxheight = 930;
    const maxwidth = 700;
    let scale = Math.min(maxwidth / (maxx - minx + 1), maxheight / (maxz - minz + 1));
    this.grid.style.width = `${(maxx - minx + 1) * scale}px`;
    this.grid.style.height = `${(maxz - minz + 1) * scale}px`;
    this.grid.style.gridTemplateColumns = `repeat(${maxx - minx + 1},1fr)`;
    this.grid.style.gridTemplateRows = `repeat(${maxz - minz + 1},1fr)`;
    this.proproot.style.left = `${(maxx - minx + 1) * scale}px`;
    for (let tile2 of this.tiles.values()) {
      tile2.el.style.gridColumn = tile2.x - minx + 1 + "";
      tile2.el.style.gridRow = maxz - minz - (tile2.z - minz) + 1 + "";
      tile2.el.style.background = _ProgressUI.backgrounds.queued;
      this.grid.appendChild(tile2.el);
    }
  }
  update(x, z, state, tilestate = "") {
    this.queuedUpdates.push({ x, z, state, tilestate });
    if (!this.updateDebounce) {
      this.updateDebounce = +setTimeout(() => {
        this.queuedUpdates.forEach((q) => this.doupdate(q.x, q.z, q.state, q.tilestate));
        this.queuedUpdates = [];
        this.updateDebounce = 0;
      }, 400);
    }
  }
  doupdate(x, z, state, tilestate = "") {
    let id = `${x}-${z}`;
    let tile2 = this.tiles.get(id);
    if (!tile2) {
      return;
    }
    if (state) {
      tile2.progress = state;
    }
    if (tilestate) {
      tile2.loadstate = tilestate;
    }
    if (tile2.progress == "imaging" || tile2.progress == "saving") {
      tile2.el.style.background = _ProgressUI.backgrounds[tile2.progress];
    } else if (tile2.loadstate != "unloaded") {
      tile2.el.style.background = _ProgressUI.renderBackgrounds[tile2.loadstate];
    } else {
      tile2.el.style.background = _ProgressUI.backgrounds[tile2.progress];
    }
  }
  updateProp(propname, value) {
    let prop = this.props[propname];
    if (!value && prop) {
      this.proproot.removeChild(prop.el);
      delete this.props[propname];
      return;
    }
    if (value && !prop) {
      let titleel = document.createElement("b");
      let contentel = document.createElement("span");
      let el = document.createElement("div");
      el.append(titleel, contentel);
      titleel.innerText = propname + ": ";
      prop = { el, contentel, text: "" };
      this.props[propname] = prop;
      this.proproot.appendChild(prop.el);
    }
    prop.text = value;
    prop.contentel.innerText = value;
  }
};

// rsmv/src/map/index.ts
var SkewOrthographicCamera = class extends OrthographicCamera2 {
  constructor(ntiles, dxdy, dzdy) {
    super(-ntiles / 2, ntiles / 2, ntiles / 2, -ntiles / 2, -500, 500);
    this.skewMatrix = new Matrix48();
    this.setSkew(dxdy, dzdy);
  }
  pointDown() {
    this.quaternion.setFromUnitVectors(new Vector310(0, 0, 1), new Vector310(0, 1, 0));
  }
  setSkew(dxdz, dydz) {
    this.skewMatrix.set(
      1,
      0,
      dxdz,
      0,
      0,
      1,
      dydz,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    if (this.skewMatrix) {
      super.updateProjectionMatrix();
      this.projectionMatrix.multiply(this.skewMatrix);
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
  }
};

// rsmv/src/viewer/scenenodes.tsx
import { boundMethod as boundMethod5 } from "autobind-decorator";
import { Euler as Euler3, Quaternion as Quaternion5, Vector3 as Vector311 } from "three";
import * as React7 from "react";
import classNames3 from "classnames";

// rsmv/src/scripts/cachediff.ts
import prettyJson4 from "json-stringify-pretty-compact";
function chunkedIndexName(major, minor, subfile) {
  let name = majormap[major]?.name ?? `${major}`;
  return `${name}-${archiveToFileId(major, minor, subfile)}`;
}
function standardName(major, minor, subfile) {
  let name = majormap[major]?.name ?? `${major}`;
  return `${name}-${major}_${minor}${subfile != -1 ? `_${subfile}` : ""}`;
}
function worldmapFilename(major, minor, subfile) {
  const worldStride2 = 128;
  return `mapsquare-${minor % worldStride2}_${Math.floor(minor / worldStride2)}`;
}
function subfileFilename(major, minor, subfile) {
  return subfile + "";
}
var configmap = {
  [cacheConfigPages.mapoverlays]: { name: "overlays", comparesubfiles: true, parser: parse.mapsquareOverlays, outputType: "json", getFileName: subfileFilename },
  [cacheConfigPages.mapunderlays]: { name: "underlays", comparesubfiles: true, parser: parse.mapsquareUnderlays, outputType: "json", getFileName: subfileFilename },
  [cacheConfigPages.mapscenes]: { name: "mapsscenes", comparesubfiles: true, parser: parse.mapscenes, outputType: "json", getFileName: subfileFilename }
};
var majormap = {
  [cacheMajors.objects]: { name: "loc", comparesubfiles: true, parser: parse.object, outputType: "json", getFileName: chunkedIndexName },
  [cacheMajors.items]: { name: "item", comparesubfiles: true, parser: parse.item, outputType: "json", getFileName: chunkedIndexName },
  [cacheMajors.npcs]: { name: "npc", comparesubfiles: true, parser: parse.npc, outputType: "json", getFileName: chunkedIndexName },
  [cacheMajors.models]: { name: "model", comparesubfiles: false, parser: parse.models, outputType: "json", getFileName: standardName },
  [cacheMajors.oldmodels]: { name: "oldmodel", comparesubfiles: false, parser: parse.oldmodels, outputType: "json", getFileName: standardName },
  [cacheMajors.mapsquares]: { name: "mapsquare", comparesubfiles: false, parser: null, outputType: "bin", getFileName: worldmapFilename },
  [cacheMajors.enums]: { name: "enum", comparesubfiles: true, parser: parse.enums, outputType: "json", getFileName: chunkedIndexName },
  [cacheMajors.sequences]: { name: "sequence", comparesubfiles: true, parser: parse.sequences, outputType: "json", getFileName: chunkedIndexName },
  [cacheMajors.spotanims]: { name: "spotanim", comparesubfiles: true, parser: parse.spotAnims, outputType: "json", getFileName: chunkedIndexName },
  [cacheMajors.achievements]: { name: "achievements", comparesubfiles: true, parser: parse.achievement, outputType: "json", getFileName: chunkedIndexName },
  [cacheMajors.materials]: { name: "material", comparesubfiles: true, parser: parse.materials, outputType: "json", getFileName: chunkedIndexName },
  [cacheMajors.texturesBmp]: { name: "texturesBmp", comparesubfiles: false, parser: null, outputType: "png", getFileName: standardName },
  [cacheMajors.texturesDds]: { name: "texturesDds", comparesubfiles: false, parser: null, outputType: "png", getFileName: standardName },
  [cacheMajors.texturesPng]: { name: "texturesPng", comparesubfiles: false, parser: null, outputType: "png", getFileName: standardName },
  [cacheMajors.texturesKtx]: { name: "texturesKtx", comparesubfiles: false, parser: null, outputType: "png", getFileName: standardName },
  [cacheMajors.sprites]: { name: "sprites", comparesubfiles: false, parser: null, outputType: "png", getFileName: standardName },
  [cacheMajors.cutscenes]: { name: "cutscenes", comparesubfiles: false, parser: parse.cutscenes, outputType: "json", getFileName: standardName },
  [cacheMajors.interfaces]: { name: "interfaces", comparesubfiles: false, parser: null, outputType: "html", getFileName: standardName },
  //need to first run deob first before this works
  // [cacheMajors.clientscript]: { name: "clientscript", comparesubfiles: false, parser: parse.clientscript, outputType: "json", getFileName: standardName },
  [cacheMajors.config]: (major, minor) => configmap[minor]
};

// rsmv/src/viewer/scriptsui.tsx
import { useEffect as useEffect2 } from "react";
import * as React3 from "react";

// rsmv/src/viewer/commoncontrols.tsx
import * as React2 from "react";
import { boundMethod as boundMethod3 } from "autobind-decorator";
import prettyJson5 from "json-stringify-pretty-compact";
import classNames from "classnames";

// rsmv/src/viewer/jsonsearch.tsx
import * as React from "react";
import * as ReactDOM from "react-dom/client";
function ModalFrame(p) {
  return /* @__PURE__ */ React.createElement("div", { className: "mv-modal-container" }, /* @__PURE__ */ React.createElement("div", { className: "mv-modal", style: { maxWidth: p.maxWidth } }, /* @__PURE__ */ React.createElement("div", { className: "mv-modal-head" }, /* @__PURE__ */ React.createElement("span", null, p.title), /* @__PURE__ */ React.createElement("span", { onClick: p.onClose }, "X")), /* @__PURE__ */ React.createElement("div", { className: "mv-modal-body" }, p.children)));
}
function selectEntity(ctx, mode, callback, initialFilters = []) {
  let onselect = (id, obj) => {
    modal.close();
    callback(id);
  };
  let modal = showModal({ title: "Select item" }, /* @__PURE__ */ React.createElement(JsonSearchPreview, { cache: ctx.sceneCache.engine, mode, onSelect: onselect, initialFilters }));
}
function showModal(config, children) {
  let rootel = document.createElement("div");
  rootel.classList.add("mv-style");
  document.body.appendChild(rootel);
  let root = ReactDOM.createRoot(rootel);
  let close = () => {
    if (root) {
      root.unmount();
      rootel.remove();
      root = null;
    }
  };
  root.render(/* @__PURE__ */ React.createElement(ModalFrame, { onClose: close, title: config.title, maxWidth: config.maxWidth ?? "" }, children));
  return { close };
}
function JsonSearchPreview(p) {
  let [selid, setSelid] = React.useState(-1);
  let [selobj, setSelobj] = React.useState(null);
  const onchange = (id, obj) => {
    setSelid(id);
    setSelobj(obj);
  };
  return /* @__PURE__ */ React.createElement("div", { style: { display: "grid", gridTemplateColumns: "40% 60%", height: "100%" } }, /* @__PURE__ */ React.createElement("div", { style: { display: "flex", flexDirection: "column", overflow: "hidden" } }, /* @__PURE__ */ React.createElement(JsonSearch, { cache: p.cache, mode: p.mode, onSelect: onchange, initialFilters: p.initialFilters })), /* @__PURE__ */ React.createElement("div", { style: { display: "flex", flexDirection: "column", overflow: "hidden" } }, selobj && /* @__PURE__ */ React.createElement("input", { type: "button", className: "sub-btn", value: "Select", onClick: (e) => p.onSelect(selid, selobj) }), /* @__PURE__ */ React.createElement(JsonDisplay, { obj: selobj })));
}
function JsonSearch(p) {
  let initfilters = p.initialFilters;
  const [filters, setFilters] = React.useState(initfilters);
  const { filtered, getprop, actualfilters, loaded } = useJsonCacheSearch(p.cache, p.mode, filters);
  const editFilters = (index, cb) => {
    let newfilters = filters.map((q) => ({ path: q.path.slice(), search: q.search }));
    if (!cb) {
      newfilters.splice(index, 1);
    } else {
      let filter = newfilters[index];
      if (!filter) {
        filter = { path: [], search: "" };
        newfilters[index] = filter;
      }
      cb(filter);
    }
    setFilters(newfilters);
  };
  return /* @__PURE__ */ React.createElement(React.Fragment, null, actualfilters.map((q, i) => /* @__PURE__ */ React.createElement(JsonFilterUI, { key: i, index: i, filter: q.filter, editFilters, optsthree: q.optsthree, searchtype: q.searchtype })), /* @__PURE__ */ React.createElement("input", { type: "button", className: "sub-btn", value: "extra filter", onClick: (e) => editFilters(actualfilters.length, () => {
  }) }), /* @__PURE__ */ React.createElement("div", null, loaded ? `${filtered.length} Matches` : "Loading..."), /* @__PURE__ */ React.createElement("div", { style: { flex: "1", overflowY: "auto" } }, filtered.slice(0, 500).map((q, i) => /* @__PURE__ */ React.createElement("div", { key: q.$fileid, onClick: (e) => p.onSelect(q.$fileid, q) }, q.$fileid, " - ", filters.map((f) => getprop(q, f.path, 0).next().value + "").join(", ")))));
}
function useJsonCacheSearch(cache, mode, filters, dryrun = false) {
  const searchmeta = dryrun ? null : cache.getJsonSearchData(mode);
  const [files, setFiles] = React.useState(null);
  React.useEffect(() => {
    !files && searchmeta?.files.then(setFiles);
  }, [searchmeta?.files]);
  const hasprop = (o, p) => o && Object.prototype.hasOwnProperty.call(o, p);
  const getprop = function* (prop, path7, depth) {
    if (Array.isArray(prop)) {
      for (let sub of prop) {
        yield* getprop(sub, path7, depth);
      }
      return false;
    } else if (depth < path7.length) {
      let part = path7[depth];
      if (typeof prop != "object" || !hasprop(prop, part)) {
        return false;
      }
      yield* getprop(prop[part], path7, depth + 1);
    } else {
      yield prop;
    }
  };
  let filtered = files ?? [];
  let actualfilters = [];
  if (!dryrun) {
    for (let filter of filters) {
      let optsthree = [];
      let def = searchmeta.schema;
      let searchtype = "any";
      let partindex = 0;
      let lastdef = null;
      while (lastdef != def) {
        let part = filter.path[partindex];
        lastdef = def;
        if (typeof def != "object") {
          break;
        }
        if (def.oneOf) {
          if (def.oneOf.length == 2 && typeof def.oneOf[1] == "object" && def.oneOf[1].type == "null") {
            def = def.oneOf[part == "null" ? 1 : 0];
          }
        } else if (def.type == "object") {
          if (def.properties) {
            optsthree.push(Object.keys(def.properties));
            if (part) {
              def = def.properties[part];
              partindex++;
            }
          }
        } else if (def.type == "array") {
          if (def.items) {
            if (typeof def.items != "object") {
              throw new Error("only standard array props supported");
            }
            if (Array.isArray(def.items)) {
              optsthree.push(Object.keys(def.items));
              if (part) {
                def = def.items[part];
                partindex++;
              }
            } else {
              def = def.items;
            }
          }
        } else if (typeof def.type == "string") {
          searchtype = def.type;
        } else {
          console.log("unknown jsonschema type");
        }
      }
      actualfilters.push({ filter, optsthree, searchtype });
      const searchstring = filter.search.toLowerCase();
      const searchnum = +filter.search;
      const searchbool = filter.search == "true";
      filtered = filtered.filter((file) => {
        for (let prop of getprop(file, filter.path, 0)) {
          let match = false;
          if (searchtype == "string" && typeof prop == "string" && prop.toLowerCase().indexOf(searchstring) != -1) {
            match = true;
          }
          if ((searchtype == "integer" || searchtype == "number") && typeof prop == "number" && prop == searchnum) {
            match = true;
          }
          if (searchtype == "boolean" && typeof prop == "boolean" && prop == searchbool) {
            match = true;
          }
          if (match) {
            return true;
          }
        }
        return false;
      });
    }
  }
  return { filtered, getprop, actualfilters, loaded: !!files };
}
function JsonFilterUI(p) {
  return /* @__PURE__ */ React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(5,auto)" } }, p.optsthree.map((opts, i) => /* @__PURE__ */ React.createElement("select", { key: i, value: p.filter.path[i], onChange: (e) => p.editFilters(p.index, (f) => f.path.splice(i, 100, e.currentTarget.value)) }, opts.map((opt, j) => /* @__PURE__ */ React.createElement("option", { key: opt, value: opt }, opt)))), p.searchtype == "string" && /* @__PURE__ */ React.createElement("input", { value: p.filter.search, onChange: (e) => p.editFilters(p.index, (f) => f.search = e.currentTarget.value), type: "text" }), (p.searchtype == "number" || p.searchtype == "integer") && /* @__PURE__ */ React.createElement("input", { value: p.filter.search, onChange: (e) => p.editFilters(p.index, (f) => f.search = e.currentTarget.value), type: "number" }), p.searchtype == "boolean" && /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement("input", { checked: p.filter.search == "true", onChange: (e) => p.editFilters(p.index, (f) => f.search = e.currentTarget.checked + ""), type: "checkbox" }), "True"), /* @__PURE__ */ React.createElement("input", { type: "button", className: "sub-btn", value: "x", onClick: (e) => p.editFilters(p.index) }));
}

// rsmv/src/viewer/commoncontrols.tsx
function TabStrip(p) {
  const templatecols = `repeat(${Math.min(4, Object.keys(p.tabs).length)},minmax(0,1fr))`;
  return /* @__PURE__ */ React2.createElement("div", { className: "mv-tab-strip mv-inset", style: { gridTemplateColumns: templatecols } }, Object.entries(p.tabs).map(([k, v]) => /* @__PURE__ */ React2.createElement("div", { key: k, className: classNames("mv-icon-button", { active: p.value == k }), onClick: () => p.onChange(k) }, v)));
}
function JsonDisplay(p) {
  return /* @__PURE__ */ React2.createElement("pre", { className: "mv-json-block" }, prettyJson5(p.obj, { maxLength: 32 }));
}
function StringInput2({ initialid, onChange }) {
  let [idstate, setId] = React2.useState(initialid ?? "");
  let stale = React2.useRef(false);
  let id = stale.current || typeof initialid == "undefined" ? idstate : initialid;
  let submit = (e) => {
    onChange(id);
    e.preventDefault();
    stale.current = false;
  };
  return /* @__PURE__ */ React2.createElement("form", { className: "mv-searchbar", onSubmit: submit }, /* @__PURE__ */ React2.createElement("input", { type: "text", className: "mv-searchbar-input", spellCheck: "false", value: id, onChange: (e) => {
    setId(e.currentTarget.value);
    stale.current = true;
  } }), /* @__PURE__ */ React2.createElement("input", { type: "submit", style: { width: "25px", height: "25px" }, value: "", className: "sub-btn sub-btn-search" }));
}
function CopyButton(p) {
  let [didcopy, setdidcopy] = React2.useState(false);
  let copy = async () => {
    await navigator.clipboard.writeText("text" in p ? p.text : p.getText());
    setdidcopy(true);
    setTimeout(() => setdidcopy(false), 2e3);
  };
  return /* @__PURE__ */ React2.createElement("input", { type: "button", className: "sub-btn", onClick: copy, value: didcopy ? "copied!" : "copy" });
}
function PasteButton(p) {
  let [didcopy, setdidcopy] = React2.useState(false);
  let paste = async () => {
    let v = await navigator.clipboard.readText();
    setdidcopy(true);
    setTimeout(() => setdidcopy(false), 2e3);
    p.onPaste(v);
  };
  return /* @__PURE__ */ React2.createElement("input", { type: "button", className: "sub-btn", onClick: paste, value: didcopy ? "pasted!" : "paste" });
}
var InputCommitted2 = class extends React2.Component {
  constructor() {
    super(...arguments);
    this.el = null;
    this.stale = false;
  }
  onInput() {
    this.stale = true;
  }
  onChange(e) {
    this.props.onChange?.(e);
    this.stale = false;
  }
  ref(el) {
    if (this.el) {
      this.el.removeEventListener("change", this.onChange);
      this.el.removeEventListener("input", this.onInput);
    }
    if (el) {
      el.addEventListener("change", this.onChange);
      el.addEventListener("input", this.onInput);
      this.el = el;
    }
  }
  render() {
    if (!this.stale && this.el && this.props.value) {
      this.el.value = this.props.value;
    }
    let newp = { ...this.props, onChange: void 0, value: void 0, defaultValue: this.props.value };
    return /* @__PURE__ */ React2.createElement("input", { ref: this.ref, ...newp });
  }
};
__decorateClass([
  boundMethod3
], InputCommitted2.prototype, "onInput", 1);
__decorateClass([
  boundMethod3
], InputCommitted2.prototype, "onChange", 1);
__decorateClass([
  boundMethod3
], InputCommitted2.prototype, "ref", 1);

// rsmv/src/scriptrunner.ts
import path2 from "path";
import fs3 from "fs";
var CLIScriptFS = class {
  constructor(dir) {
    this.copyOnSymlink = true;
    this.dir = path2.resolve(dir);
    if (dir) {
      fs3.mkdirSync(dir, { recursive: true });
    }
  }
  convertPath(sub) {
    let target = path2.resolve(this.dir, sub.replace(/^\//g, ""));
    let rel = path2.relative(this.dir, target);
    if (target != this.dir && (rel.startsWith("..") || path2.isAbsolute(rel))) {
      throw new Error("Error while converting CLIScriptFS path");
    }
    return target;
  }
  mkDir(name) {
    return fs3.promises.mkdir(this.convertPath(name), { recursive: true });
  }
  writeFile(name, data) {
    return fs3.promises.writeFile(this.convertPath(name), data);
  }
  readFileBuffer(name) {
    return fs3.promises.readFile(this.convertPath(name));
  }
  readFileText(name) {
    return fs3.promises.readFile(this.convertPath(name), "utf-8");
  }
  async readDir(name) {
    let files = await fs3.promises.readdir(this.convertPath(name), { withFileTypes: true });
    return files.map((q) => ({ name: q.name, kind: q.isDirectory() ? "directory" : "file" }));
  }
  unlink(name) {
    return fs3.promises.unlink(this.convertPath(name));
  }
  copyFile(from, to, symlink) {
    if (!symlink || this.copyOnSymlink) {
      return fs3.promises.copyFile(this.convertPath(from), this.convertPath(to));
    } else {
      return fs3.promises.symlink(this.convertPath(to), this.convertPath(from));
    }
  }
};

// rsmv/src/viewer/scriptsui.tsx
import path3 from "path";
var electron = (() => {
  try {
    let electron3 = __require("electron/renderer");
    if (electron3?.ipcRenderer) {
      return electron3;
    }
  } catch (e) {
  }
  return null;
})();
var WebFsScriptFS = class {
  constructor(handle) {
    this.dirhandles = /* @__PURE__ */ new Map();
    this.roothandle = handle;
    this.dirhandles.set("", handle);
  }
  async getDir(dir, create) {
    let parts = dir.split("/");
    let cdir = this.roothandle;
    let cpath = "";
    for (let p of parts) {
      if (p == "..") {
        throw new Error("unexpected");
      }
      if (p == "." || p == "") {
        continue;
      }
      cpath += p + "/";
      let subdir = this.dirhandles.get(cpath);
      if (!subdir) {
        subdir = await cdir.getDirectoryHandle(p, { create });
        this.dirhandles.set(cpath, subdir);
      }
      cdir = subdir;
    }
    return cdir;
  }
  async getFile(name, create) {
    let parts = name.split("/");
    let filename = parts.pop();
    let dir = await this.getDir(parts.join("/"), false);
    return dir.getFileHandle(filename, { create });
  }
  async mkDir(dir) {
    await this.getDir(dir, true);
  }
  async readDir(dirname2) {
    let dir = await this.getDir(dirname2, false);
    let files = [];
    for await (let [name, v] of dir.entries()) {
      files.push({ name, kind: v.kind });
    }
    return files;
  }
  async writeFile(name, data) {
    let file = await this.getFile(name, true);
    let str = await file.createWritable({ keepExistingData: false });
    await str.write(data);
    await str.close();
  }
  async unlink(name) {
    throw new Error("not implemented");
  }
  async copyFile(from, to, symlink) {
    await this.writeFile(to, await this.readFileBuffer(from));
  }
  async readFileBuffer(name) {
    let file = await this.getFile(name, false);
    return Buffer.from(await (await file.getFile()).arrayBuffer());
  }
  async readFileText(name) {
    let file = await this.getFile(name, false);
    return (await file.getFile()).text();
  }
};

// rsmv/src/viewer/maincomponents.tsx
import * as React6 from "react";
import { boundMethod as boundMethod4 } from "autobind-decorator";

// rsmv/src/cache/sqlitewasm.ts
var WasmGameCacheLoader = class extends CacheFileSource {
  constructor() {
    super();
    this.indices = /* @__PURE__ */ new Map();
    this.dbfiles = {};
    this.msgidcounter = 1;
    this.callbacks = /* @__PURE__ */ new Map();
    this.timestamp = /* @__PURE__ */ new Date();
    this.worker = new Worker(new URL("./sqlitewasmworker.ts", import.meta.url));
    this.worker.onmessage = (e) => {
      let handler = this.callbacks.get(e.data.id);
      if (e.data.error) {
        if (handler) {
          let err = e.data.error;
          if (handler.reqpacket.type == "getfile") {
            err += `
 in getfile ${handler.reqpacket.major}.${handler.reqpacket.minor}`;
          } else if (handler.reqpacket.type == "getindex") {
            err += `
 in getindex ${handler.reqpacket.major}`;
          } else {
            err += `
 in other ${handler.reqpacket.type}`;
          }
          handler.reject(new Error(err));
        }
      } else {
        handler?.resolve(e.data.packet);
      }
      this.callbacks.delete(e.data.id);
    };
  }
  getCacheMeta() {
    return {
      name: `sqlitewasm`,
      descr: "Direclty loads NXT cache files from the disk, in browser compatible environment.",
      timestamp: this.timestamp
    };
  }
  async generateRootIndex() {
    console.log("using generated cache index file meta, crc size and version missing");
    let majors = [];
    for (let file of Object.keys(this.dbfiles)) {
      let m = file.match(/js5-(\d+)\.jcache$/);
      if (m) {
        majors[m[1]] = {
          major: cacheMajors.index,
          minor: +m[1],
          crc: 0,
          size: 0,
          subindexcount: 1,
          subindices: [0],
          version: 0,
          uncompressed_crc: 0,
          uncompressed_size: 0
        };
      }
    }
    return majors;
  }
  sendWorker(packet) {
    let id = this.msgidcounter++;
    this.worker.postMessage({ id, packet });
    return new Promise((resolve3, reject) => this.callbacks.set(id, { resolve: resolve3, reject, reqpacket: packet }));
  }
  giveBlobs(blobs) {
    Object.assign(this.dbfiles, blobs);
    this.sendWorker({ type: "blobs", blobs });
  }
  async giveFsDirectory(dir) {
    let files = {};
    if (await dir.queryPermission() != "granted") {
      console.log("tried to open cache without permission");
      return null;
    }
    for await (let file of dir.values()) {
      if (file.kind == "file") {
        files[file.name] = await file.getFile();
      }
    }
    this.giveBlobs(files);
  }
  async getFile(major, minor, crc) {
    if (major == cacheMajors.index) {
      return this.getIndexFile(minor);
    }
    let data = await this.sendWorker({ type: "getfile", major, minor, crc });
    return Buffer.from(data.buffer, data.byteOffset, data.byteLength);
  }
  async getFileArchive(index) {
    let arch = await this.getFile(index.major, index.minor, index.crc);
    return unpackSqliteBufferArchive(arch, index.subindices, index.subnames);
  }
  async getCacheIndex(major) {
    if (major == cacheMajors.index) {
      return this.generateRootIndex();
    }
    let index = this.indices.get(major);
    if (!index) {
      index = this.getIndexFile(major).then((file) => indexBufferToObject(major, file, this));
      this.indices.set(major, index);
    }
    return index;
  }
  async getIndexFile(major) {
    let data = await this.sendWorker({ type: "getindex", major });
    return Buffer.from(data.buffer, data.byteOffset, data.byteLength);
  }
  close() {
    this.worker.terminate();
  }
};

// rsmv/src/viewer/maincomponents.tsx
import * as datastore2 from "idb-keyval";
import prettyJson6 from "json-stringify-pretty-compact";

// rsmv/src/cache/downloader.ts
var import_node_fetch3 = __toESM(require_lib3());
import * as net from "net";
var maxblocksize = 102400;
var handshake1 = new FileParser([
  "struct",
  ["type", "ubyte"],
  ["length", "ubyte"],
  ["version1", "uint"],
  ["version2", "uint"],
  ["key", "string"],
  ["lang", "ubyte"]
]);
var handshake2 = new FileParser([
  "struct",
  ["op", "ubyte"],
  ["tribyte", "unsigned tribyte"],
  ["short1", "ushort"],
  ["version", "ushort"],
  ["short2", "ushort"]
]);
var filereq1 = new FileParser([
  "struct",
  ["mode", "ubyte"],
  ["major", "ubyte"],
  ["minor", "uint"],
  ["version", "ushort"],
  ["short2", "ushort"]
]);
function parseClientConfig(cnf) {
  var key = Object.values(cnf.param).find((param) => param.length == 32);
  if (!key) {
    throw new Error("client cache key not found in config");
  }
  let serverVersionMajor = parseInt(cnf.server_version);
  if (!serverVersionMajor) {
    throw new Error("client cache doesn't have a server_version");
  }
  let serverVersionMinor = 1;
  const port = 43594;
  const endpoint2 = "content.runescape.com";
  const unknownshort1 = 0;
  const unknownshort2 = 0;
  return { key, serverVersionMajor, serverVersionMinor, endpoint: endpoint2, port, unknownshort1, unknownshort2 };
}
async function downloadServerConfig() {
  let body = await (0, import_node_fetch3.default)("http://world3.runescape.com/jav_config.ws?binaryType=2").then((r) => r.text());
  let chunks = body.split(/(?:\r\n|\r|\n)/g);
  var config = {};
  for (var i = 0; i < chunks.length; ++i) {
    let line = chunks[i].split(/(?:=)/g);
    if (line.length == 2) {
      config[line[0]] = line[1];
    } else if (line.length == 3) {
      config[line[0]] = config[line[0]] || {};
      config[line[0]][line[1]] = line[2];
    }
  }
  if (typeof config.server_version != "string") {
    throw new Error("server version not found in config");
  }
  return config;
}
var downloadedBytes2 = 0;
function trackDataUsage(len) {
  if (Math.floor(downloadedBytes2 / 1e8) != Math.floor((downloadedBytes2 + len) / 1e8)) {
    console.info(`loaded ${(downloadedBytes2 + len) / 1e6 | 0} mb from jagex server`);
  }
  downloadedBytes2 += len;
}
var DownloadSocket = class {
  constructor(config) {
    this.pending = [];
    this.ready = new CallbackPromise();
    this.packetPending = [];
    this.packetPendingError = null;
    this.packetCallback = null;
    this.config = config;
    this.socket = new net.Socket();
    this.socket.on("connect", () => {
      console.log("downloader connected " + this.socket.remoteAddress);
    });
    this.socket.on("data", (data) => {
      this.packetPending.push(data);
      this.packetCallback?.();
      trackDataUsage(data.byteLength);
    });
    this.socket.on("close", () => {
      console.log("closed");
      this.packetPendingError = new Error("connection closed");
      this.packetCallback?.();
    });
    this.socket.on("error", (err) => {
      this.packetPendingError = err;
      this.packetCallback?.();
    });
  }
  async connect() {
    this.socket.connect(this.config.port, this.config.endpoint);
    this.socket.write(handshake1.write({
      type: 15,
      length: 42,
      version1: this.config.serverVersionMajor,
      version2: this.config.serverVersionMinor,
      key: this.config.key,
      lang: 0
      //en
    }));
    let res1 = await this.getChunk(1);
    if (res1.readUint8(0) != 0) {
      throw new Error("unexpected handshake response");
    }
    let tribyte = 5;
    this.socket.write(handshake2.write({ op: 6, tribyte, short1: this.config.unknownshort1, short2: this.config.unknownshort2, version: this.config.serverVersionMajor }));
    this.socket.write(handshake2.write({ op: 3, tribyte, short1: this.config.unknownshort1, short2: this.config.unknownshort2, version: this.config.serverVersionMajor }));
  }
  async run() {
    await this.connect();
    this.ready.done();
    while (true) {
      let bytesread = 0;
      try {
        var chunk = await this.getChunk(1 + 4);
      } catch (e) {
        return;
      }
      bytesread += 1 + 4;
      let major = chunk.readUint8(0);
      let minor = chunk.readUint32BE(1) & 2147483647;
      let req = this.pending.find((q) => q.major == major && q.minor == minor);
      if (!req) {
        throw new Error("Received file which wasn't requested");
      }
      if (req.totalBytes == -1) {
        let header = await this.getChunk(1 + 4);
        bytesread += 1 + 4;
        let compression = header.readUint8(0);
        let compressedSize = header.readUint32BE(1);
        req.totalBytes = header.byteLength + (compression == 0 ? 0 : 4) + compressedSize;
        req.result.push(header);
        req.currentBytes += header.byteLength;
      }
      let bytesleft = req.totalBytes - req.currentBytes;
      let payloadsize = Math.min(maxblocksize - bytesread, bytesleft);
      let datachunk = await this.getChunk(payloadsize);
      req.result.push(datachunk);
      req.currentBytes += datachunk.byteLength;
      if (req.currentBytes == req.totalBytes) {
        this.pending.splice(this.pending.indexOf(req), 1);
        req.done(Buffer.concat(req.result));
      }
    }
  }
  writeRequest(major, minor) {
    return new Promise((done, err) => {
      this.socket.write(filereq1.write({
        mode: major == 255 && minor == 255 ? 33 : 1,
        version: this.config.serverVersionMajor,
        major,
        minor,
        short2: this.config.unknownshort2
      }));
      this.pending.push({
        major,
        minor,
        totalBytes: -1,
        pendingsocket: this.socket,
        result: [],
        currentBytes: 0,
        done,
        err
      });
    });
  }
  async getChunk(bytes) {
    let res = Buffer.alloc(bytes);
    let index = 0;
    while (index < bytes) {
      if (this.packetPending.length == 0 && !this.packetPendingError) {
        await new Promise((done) => this.packetCallback = done);
      }
      if (this.packetPending.length == 0 && this.packetPendingError) {
        for (let pend of this.pending) {
          pend.err(this.packetPendingError);
        }
        throw this.packetPendingError;
      }
      let chunk = this.packetPending[0];
      let len = Math.min(chunk.byteLength, bytes - index);
      chunk.copy(res, index, 0, len);
      index += len;
      if (len == chunk.byteLength) {
        this.packetPending.shift();
      } else {
        this.packetPending[0] = chunk.slice(len);
      }
    }
    return res;
  }
};
var CacheDownloader = class extends DirectCacheFileSource {
  constructor() {
    super(true);
    this.socket = null;
    this.socketPromise = null;
    this.timestamp = /* @__PURE__ */ new Date();
    this.configPromise = downloadServerConfig().then(parseClientConfig);
  }
  getCacheMeta() {
    return { name: "live", descr: "Download live data from jagex server", timestamp: this.timestamp };
  }
  async getSocket() {
    if (!this.socketPromise) {
      this.socketPromise = (async () => {
        let config = await this.configPromise;
        let sock = new DownloadSocket(config);
        sock.run().catch().finally(() => {
          this.socket = null;
          this.socketPromise = null;
        });
        await sock.ready;
        this.socket = sock;
        return this.socket;
      })();
    }
    return this.socketPromise;
  }
  async getFile(major, minor, crc) {
    if (major == cacheMajors.music) {
      let config = await this.configPromise;
      let indexfiles = await this.getCacheIndex(major);
      let index = indexfiles.find((q) => q && q.major == major && q.minor == minor);
      if (!index) {
        throw new Error("requested file not found");
      }
      let res = await (0, import_node_fetch3.default)(`https://${config.endpoint}/ms?m=0&a=${major}&k=${config.serverVersionMajor}&g=${minor}&c=${index.crc >> 0}&v=${index.version}`);
      if (!res.ok) {
        throw new Error(`http cache request failed with code ${res.status}`);
      }
      let data = await res.arrayBuffer();
      trackDataUsage(data.byteLength);
      return decompress(Buffer.from(data));
    }
    let socket = this.socket ?? await this.getSocket();
    for (let attempt = 0; attempt < 10; attempt++) {
      try {
        var file = await socket.writeRequest(major, minor);
      } catch (e) {
        if (attempt >= 5) {
          await delay(500);
        }
        continue;
      }
      if (typeof crc == "number" && (major != 255 || minor != 255)) {
        let filecrc = crc32(file);
        if (filecrc != crc) {
          console.log(`crc fail expected ${crc}, got ${filecrc}`);
          if (attempt >= 5) {
            await delay(500);
          }
          continue;
        }
      }
      return decompress(file);
    }
    throw new Error("Failed to download matching crc after 10 attemps");
  }
  close() {
    this.socket?.socket.end();
  }
};

// rsmv/src/viewer/maincomponents.tsx
import * as path5 from "path";
import classNames2 from "classnames";

// rsmv/src/cache/sqlite.ts
import * as path4 from "path";
import * as fs4 from "fs";
var GameCacheLoader = class extends CacheFileSource {
  constructor(cachedir, writable) {
    super();
    this.opentables = /* @__PURE__ */ new Map();
    this.timestamp = /* @__PURE__ */ new Date();
    this.cachedir = cachedir || path4.resolve(process.env.ProgramData, "jagex/runescape");
    this.writable = !!writable;
  }
  getCacheMeta() {
    return {
      name: `sqlite:${this.cachedir}`,
      descr: "Directly reads NXT cache files.",
      timestamp: this.timestamp
    };
  }
  async generateRootIndex() {
    let files = fs4.readdirSync(path4.resolve(this.cachedir));
    console.log("using generated cache index file meta, crc size and version missing");
    let majors = [];
    for (let file of files) {
      let m = file.match(/js5-(\d+)\.jcache$/);
      if (m) {
        majors[m[1]] = {
          major: cacheMajors.index,
          minor: +m[1],
          crc: 0,
          size: 0,
          subindexcount: 1,
          subindices: [0],
          version: 0,
          uncompressed_crc: 0,
          uncompressed_size: 0
        };
      }
    }
    return majors;
  }
  openTable(major) {
    let sqlite = __non_webpack_require__("sqlite3");
    if (!this.opentables.get(major)) {
      let db = null;
      let indices;
      let readFile2;
      let updateFile;
      let readIndexFile;
      let updateIndexFile;
      if (major == cacheMajors.index) {
        indices = this.generateRootIndex();
        readFile2 = (minor) => this.openTable(minor).readIndexFile();
        readIndexFile = () => {
          throw new Error("root index file not accesible for sqlite cache");
        };
        updateFile = (minor, data) => {
          let table = this.openTable(minor);
          return table.updateIndexFile(data);
        };
        updateIndexFile = (data) => {
          throw new Error("cannot write root index");
        };
      } else {
        let dbfile = path4.resolve(this.cachedir, `js5-${major}.jcache`);
        if (!fs4.existsSync(dbfile)) {
          throw new Error(`cache index ${major} doesn't exist`);
        }
        db = new sqlite.Database(dbfile, this.writable ? sqlite.OPEN_READWRITE : sqlite.OPEN_READONLY);
        let ready = new Promise((done) => db.once("open", done));
        let dbget = async (query, args) => {
          await ready;
          return new Promise((resolve3, reject) => {
            db.get(query, args, (err, row) => {
              if (err) {
                reject(err);
              } else {
                resolve3(row);
              }
            });
          });
        };
        let dbrun = async (query, args) => {
          await ready;
          return new Promise((resolve3, reject) => {
            db.run(query, args, (err, res) => {
              if (err) {
                reject(err);
              } else {
                resolve3(res);
              }
            });
          });
        };
        readFile2 = (minor) => dbget(`SELECT DATA,CRC FROM cache WHERE KEY=?`, [minor]);
        readIndexFile = () => dbget(`SELECT DATA FROM cache_index`, []);
        updateFile = (minor, data) => dbrun(`UPDATE cache SET DATA=? WHERE KEY=?`, [data, minor]);
        updateIndexFile = (data) => dbrun(`UPDATE cache_index SET DATA=?`, [data]);
        indices = readIndexFile().then(async (row) => {
          let file = decompress(Buffer.from(row.DATA.buffer, row.DATA.byteOffset, row.DATA.byteLength));
          return indexBufferToObject(major, file, this);
        });
      }
      this.opentables.set(major, { db, readFile: readFile2, updateFile, readIndexFile, updateIndexFile, indices });
    }
    return this.opentables.get(major);
  }
  async getFile(major, minor, crc) {
    if (major == cacheMajors.index) {
      return this.getIndexFile(minor);
    }
    let { readFile: getFile } = this.openTable(major);
    let row = await getFile(minor);
    if (typeof crc == "number" && row.CRC != crc) {
    }
    let file = Buffer.from(row.DATA.buffer, row.DATA.byteOffset, row.DATA.byteLength);
    let res = decompress(file);
    return res;
  }
  async getFileArchive(index) {
    let arch = await this.getFile(index.major, index.minor, index.crc);
    let res = unpackSqliteBufferArchive(arch, index.subindices, index.subnames);
    return res;
  }
  writeFile(major, minor, file) {
    let table = this.openTable(major);
    let compressed = compressSqlite(file, "zlib");
    return table.updateFile(minor, compressed);
  }
  writeFileArchive(major, minor, files) {
    let arch = packSqliteBufferArchive(files);
    return this.writeFile(major, minor, arch);
  }
  async getCacheIndex(major) {
    return this.openTable(major).indices;
  }
  async getIndexFile(major) {
    let row = await this.openTable(major).readIndexFile();
    let file = Buffer.from(row.DATA.buffer, row.DATA.byteOffset, row.DATA.byteLength);
    return decompress(file);
  }
  close() {
    for (let table of this.opentables.values()) {
      table.db?.close();
    }
  }
};

// rsmv/src/cache/autocache.ts
async function selectFsCache(fs7, opts) {
  let files = await fs7.readDir(".");
  let jcachecount = 0;
  let datcount = 0;
  let dat2count = 0;
  let jagcount = 0;
  for (let file of files) {
    let ext = file.name.match(/\.(\w+)$/);
    if (ext?.[1] == "jcache") {
      jcachecount++;
    }
    if (ext?.[1] == "dat2") {
      dat2count++;
    }
    if (ext?.[1] == "dat") {
      datcount++;
    }
    if (ext?.[1] == "jag") {
      jagcount++;
    }
  }
  let maxcount = Math.max(jcachecount, datcount, dat2count, jagcount);
  if (maxcount == 0) {
    throw new Error("no cache files found in selected directory");
  }
  if (maxcount == jcachecount) {
    if (fs7 instanceof CLIScriptFS) {
      return new GameCacheLoader(fs7.dir, !!opts?.writable);
    } else if (fs7 instanceof WebFsScriptFS) {
      if (!fs7.roothandle) {
        throw new Error("need fs with hard disk backing");
      }
      let cache = new WasmGameCacheLoader();
      await cache.giveFsDirectory(fs7.roothandle);
      return cache;
    }
  }
  if (maxcount == datcount) {
  }
  if (maxcount == dat2count) {
  }
  if (maxcount == jagcount) {
    return await ClassicFileSource.create(fs7);
  }
  throw new Error("couldn't detect cache type");
}

// rsmv/src/viewer/rsuiviewer.tsx
import * as React4 from "react";

// rsmv/src/viewer/cs2viewer.tsx
import * as React5 from "react";

// rsmv/src/viewer/maincomponents.tsx
var electron2 = (() => {
  try {
    let electron3 = __require("electron/renderer");
    if (electron3?.ipcRenderer) {
      return electron3;
    }
  } catch (e) {
  }
  return null;
})();
function OpenRs2IdSelector(p) {
  let [relevantcaches, setrelevantcaches] = React6.useState(null);
  let [loading, setLoading] = React6.useState(false);
  let [relevantonly, setrelevantonly] = React6.useState(true);
  let [gameFilter, setGameFilter] = React6.useState("runescape");
  let [yearFilter, setYearfilter] = React6.useState("");
  let [langFilter, setLangfilter] = React6.useState("en");
  let openselector = React6.useCallback(async () => {
    setLoading(true);
    setrelevantcaches(await validOpenrs2Caches());
  }, []);
  let games = [];
  let years = [];
  let langs = [];
  for (let cache of relevantcaches ?? []) {
    if (cache.timestamp) {
      let year = "" + new Date(cache.timestamp ?? 0).getUTCFullYear();
      if (years.indexOf(year) == -1) {
        years.push(year);
      }
    }
    if (games.indexOf(cache.game) == -1) {
      games.push(cache.game);
    }
    if (langs.indexOf(cache.language) == -1) {
      langs.push(cache.language);
    }
  }
  years.sort((a, b) => +b - +a);
  let showncaches = (relevantcaches ?? []).filter((cache) => {
    if (gameFilter && cache.game != gameFilter) {
      return false;
    }
    if (langFilter && cache.language != langFilter) {
      return false;
    }
    if (yearFilter && new Date(cache.timestamp ?? 0).getUTCFullYear() != +yearFilter) {
      return false;
    }
    return true;
  });
  showncaches.sort((a, b) => +new Date(b.timestamp ?? 0) - +new Date(a.timestamp ?? 0));
  let enterCacheId = async (idstring) => {
    let id = +idstring;
    if (id <= 0) {
      id = (await Openrs2CacheSource.getRecentCache(-id)).id;
    }
    p.onSelect(id);
  };
  return /* @__PURE__ */ React6.createElement(React6.Fragment, null, /* @__PURE__ */ React6.createElement(StringInput2, { initialid: p.initialid + "", onChange: enterCacheId }), !loading && !relevantcaches && /* @__PURE__ */ React6.createElement("input", { type: "button", className: "sub-btn", onClick: openselector, value: "More options..." }), relevantcaches && /* @__PURE__ */ React6.createElement(React6.Fragment, null, /* @__PURE__ */ React6.createElement("div", { style: { overflowY: "auto" } }, /* @__PURE__ */ React6.createElement("table", null, /* @__PURE__ */ React6.createElement("thead", null, /* @__PURE__ */ React6.createElement("tr", null, /* @__PURE__ */ React6.createElement("td", null), /* @__PURE__ */ React6.createElement("td", null, /* @__PURE__ */ React6.createElement("select", { value: yearFilter, onChange: (e) => setYearfilter(e.currentTarget.value) }, /* @__PURE__ */ React6.createElement("option", { value: "" }, "Date"), years.map((year) => /* @__PURE__ */ React6.createElement("option", { key: year, value: year }, year)))), /* @__PURE__ */ React6.createElement("td", null, "Build"))), /* @__PURE__ */ React6.createElement("tbody", null, showncaches.map((cache) => /* @__PURE__ */ React6.createElement("tr", { key: cache.language + cache.id }, /* @__PURE__ */ React6.createElement("td", null, /* @__PURE__ */ React6.createElement("input", { type: "button", value: cache.id, className: "sub-btn", onClick: p.onSelect.bind(null, cache.id) })), /* @__PURE__ */ React6.createElement("td", null, cache.timestamp ? new Date(cache.timestamp).toDateString() : ""), /* @__PURE__ */ React6.createElement("td", null, cache.builds.map((q) => q.major + (q.minor ? "." + q.minor : "")).join(",")))))))));
}
var CacheSelector = class extends React6.Component {
  constructor(p) {
    super(p);
    this.state = {
      lastFolderOpen: null
    };
    if (!this.props.noReopen) {
      datastore2.get("lastfolderopen").then((f) => {
        if (f) {
          this.setState({ lastFolderOpen: f });
        }
      });
    }
  }
  componentDidMount() {
    document.body.addEventListener("dragover", this.onDragOver);
    document.body.addEventListener("drop", this.onFileDrop);
  }
  componentWillUnmount() {
    document.body.removeEventListener("dragover", this.onDragOver);
    document.body.removeEventListener("drop", this.onFileDrop);
  }
  onDragOver(e) {
    e.preventDefault();
  }
  async clickOpen() {
    let dir = await showDirectoryPicker();
    this.props.onOpen({ type: "autohandle", handle: dir });
  }
  async clickOpenNative() {
    if (!electron2) {
      return;
    }
    let dir = await electron2.ipcRenderer.invoke("openfolder", path5.resolve(process.env.ProgramData, "jagex/runescape"));
    if (!dir.canceled) {
      this.props.onOpen({ type: "autofs", location: dir.filePaths[0], writable: !!globalThis.writecache });
    }
  }
  async clickOpenLive() {
    this.props.onOpen({ type: "live" });
  }
  async clickReopen() {
    if (!this.state.lastFolderOpen) {
      return;
    }
    if (await this.state.lastFolderOpen.requestPermission() == "granted") {
      this.props.onOpen({ type: "autohandle", handle: this.state.lastFolderOpen });
    }
  }
  async onFileDrop(e) {
    e.preventDefault();
    if (e.dataTransfer) {
      let files = {};
      let items = [];
      let folderhandles = [];
      let filehandles = [];
      for (let i = 0; i < e.dataTransfer.items.length; i++) {
        items.push(e.dataTransfer.items[i]);
      }
      await Promise.all(items.map(async (item) => {
        if (item.getAsFileSystemHandle) {
          let filehandle = await item.getAsFileSystemHandle();
          if (filehandle.kind == "file") {
            let file = filehandle;
            filehandles.push(file);
            files[filehandle.name] = await file.getFile();
          } else {
            let dir = filehandle;
            folderhandles.push(dir);
            for await (let handle of dir.values()) {
              if (handle.kind == "file") {
                files[handle.name] = await handle.getFile();
              }
            }
          }
        } else if (item.kind == "file") {
          let file = item.getAsFile();
          files[file.name] = file;
        }
      }));
      if (folderhandles.length == 1 && filehandles.length == 0) {
        console.log("stored folder " + folderhandles[0].name);
        datastore2.set("lastfolderopen", folderhandles[0]);
        this.props.onOpen({ type: "autohandle", handle: folderhandles[0] });
      } else {
        console.log(`added ${Object.keys(files).length} files`);
        this.props.onOpen({ type: "sqliteblobs", blobs: files });
      }
    }
  }
  openOpenrs2Cache(cachename) {
    this.props.onOpen({ type: "openrs2", cachename: cachename + "" });
  }
  render() {
    return /* @__PURE__ */ React6.createElement(React6.Fragment, null, electron2 && /* @__PURE__ */ React6.createElement(React6.Fragment, null, /* @__PURE__ */ React6.createElement("h2", null, "Native local RS3 cache"), /* @__PURE__ */ React6.createElement("p", null, "Only works when running in electron"), /* @__PURE__ */ React6.createElement("input", { type: "button", className: "sub-btn", onClick: this.clickOpenNative, value: "Open native cache" })), electron2 && /* @__PURE__ */ React6.createElement(React6.Fragment, null, /* @__PURE__ */ React6.createElement("h2", null, "Jagex Servers"), /* @__PURE__ */ React6.createElement("p", null, "Download directly from content servers. Only works when running in electron"), /* @__PURE__ */ React6.createElement("input", { type: "button", className: "sub-btn", onClick: this.clickOpenLive, value: "Stream from Jagex" })), /* @__PURE__ */ React6.createElement("h2", null, "Local Cache"), /* @__PURE__ */ React6.createElement(CacheDragNDropHelp, null), !this.props.noReopen && this.state.lastFolderOpen && /* @__PURE__ */ React6.createElement("input", { type: "button", className: "sub-btn", onClick: this.clickReopen, value: `Reopen ${this.state.lastFolderOpen.name}` }), /* @__PURE__ */ React6.createElement("h2", null, "Historical caches"), /* @__PURE__ */ React6.createElement("p", null, "Enter any valid cache id from ", /* @__PURE__ */ React6.createElement("a", { target: "_blank", href: "https://archive.openrs2.org/" }, "OpenRS2"), ". Entering 0 will load the latest RS3 cache, negative values will load previous caches."), /* @__PURE__ */ React6.createElement(OpenRs2IdSelector, { initialid: 0, onSelect: this.openOpenrs2Cache }));
  }
};
__decorateClass([
  boundMethod4
], CacheSelector.prototype, "onDragOver", 1);
__decorateClass([
  boundMethod4
], CacheSelector.prototype, "clickOpen", 1);
__decorateClass([
  boundMethod4
], CacheSelector.prototype, "clickOpenNative", 1);
__decorateClass([
  boundMethod4
], CacheSelector.prototype, "clickOpenLive", 1);
__decorateClass([
  boundMethod4
], CacheSelector.prototype, "clickReopen", 1);
__decorateClass([
  boundMethod4
], CacheSelector.prototype, "onFileDrop", 1);
__decorateClass([
  boundMethod4
], CacheSelector.prototype, "openOpenrs2Cache", 1);
function CacheDragNDropHelp() {
  const canfsapi = typeof FileSystemHandle != "undefined";
  let [open, setOpen] = React6.useState(false);
  let [mode, setmode] = React6.useState(canfsapi ? "fsapi" : "blob");
  return /* @__PURE__ */ React6.createElement(React6.Fragment, null, /* @__PURE__ */ React6.createElement("p", null, canfsapi && "Drag a folder containing the RS3 cache files here in order to view it.", !canfsapi && "Drag the RS3 cache files you wish to view", /* @__PURE__ */ React6.createElement("a", { style: { float: "right" }, onClick: (e) => setOpen(!open) }, !open ? "More info" : "Close")), open && /* @__PURE__ */ React6.createElement("div", { style: { display: "flex", flexDirection: "column" } }, /* @__PURE__ */ React6.createElement(TabStrip, { value: mode, tabs: { fsapi: "Full folder", blob: "Files" }, onChange: setmode }), mode == "fsapi" && /* @__PURE__ */ React6.createElement(React6.Fragment, null, !canfsapi && /* @__PURE__ */ React6.createElement("p", { className: "mv-errortext" }, "You browser does not support full folder loading!"), /* @__PURE__ */ React6.createElement("p", null, "Drop the RuneScape folder into this window."), /* @__PURE__ */ React6.createElement("input", { type: "text", onFocus: (e) => e.target.select(), readOnly: true, value: "C:\\ProgramData\\Jagex" }), /* @__PURE__ */ React6.createElement("video", { src: new URL("../assets/dragndrop.mp4", import.meta.url).href, autoPlay: true, loop: true, style: { aspectRatio: "352/292" } })), mode == "blob" && /* @__PURE__ */ React6.createElement(React6.Fragment, null, /* @__PURE__ */ React6.createElement("p", null, "Drop and drop the cache files into this window."), /* @__PURE__ */ React6.createElement("input", { type: "text", onFocus: (e) => e.target.select(), readOnly: true, value: "C:\\ProgramData\\Jagex" }), /* @__PURE__ */ React6.createElement("video", { src: new URL("../assets/dragndropblob.mp4", import.meta.url).href, autoPlay: true, loop: true, style: { aspectRatio: "458/380" } }))));
}
var UIContext = class extends TypedEmitter {
  constructor(rootelement, useServiceWorker) {
    super();
    this.source = null;
    this.sceneCache = null;
    this.renderer = null;
    this.openedfile = null;
    this.rootElement = rootelement;
    this.useServiceWorker = useServiceWorker;
    if (useServiceWorker) {
      navigator.serviceWorker?.register(new URL("../assets/contextholder.js", import.meta.url).href, { scope: "./" });
    }
  }
  setCacheSource(source) {
    this.source = source;
    this.emit("statechange", void 0);
  }
  setSceneCache(sceneCache) {
    this.sceneCache = sceneCache;
    this.emit("statechange", void 0);
  }
  setRenderer(renderer) {
    this.renderer = renderer;
    this.emit("statechange", void 0);
  }
  canRender() {
    return !!this.source && !!this.sceneCache && !!this.renderer;
  }
  openFile(file) {
    this.openedfile = file;
    this.emit("openfile", file);
  }
};
__decorateClass([
  boundMethod4
], UIContext.prototype, "openFile", 1);
async function openSavedCache(source, remember) {
  let cache = null;
  if (source.type == "sqliteblobs" || source.type == "autohandle") {
    if (source.type == "autohandle") {
      let perm = await source.handle.queryPermission({ mode: "read" });
      if (perm == "granted") {
        let wasmcache = new WasmGameCacheLoader();
        await wasmcache.giveFsDirectory(source.handle);
        navigator.serviceWorker?.ready.then((q) => q.active?.postMessage({ type: "sethandle", handle: source.handle }));
        cache = wasmcache;
      }
    } else {
      let wasmcache = new WasmGameCacheLoader();
      wasmcache.giveBlobs(source.blobs);
      cache = wasmcache;
    }
  }
  if (source.type == "openrs2") {
    cache = await Openrs2CacheSource.fromId(+source.cachename);
  }
  if (electron2 && source.type == "autofs") {
    let fs7 = new CLIScriptFS(source.location);
    cache = await selectFsCache(fs7, { writable: source.writable });
  }
  if (source.type == "live") {
    cache = new CacheDownloader();
  }
  if (remember) {
    datastore2.set("openedcache", source);
    localStorage.rsmv_openedcache = JSON.stringify(source);
  }
  return cache;
}

// rsmv/src/viewer/scenenodes.tsx
var import_node_fetch5 = __toESM(require_lib3());

// rsmv/src/jsonschemas.ts
import { validate, mustBeValid } from "json-schema";
function assertSchema(v, schema) {
  mustBeValid(validate(v, schema));
}
function parseJsonOrDefault(str, schema, defaultvalue) {
  try {
    if (typeof str != "string") {
      throw new Error("json string expected");
    }
    let v = JSON.parse(str);
    assertSchema(v, schema);
    return v;
  } catch {
    return typeof defaultvalue == "function" ? defaultvalue() : defaultvalue;
  }
}
var int = { type: "integer" };
var number = { type: "number" };
var string = { type: "string" };
var boolean = { type: "boolean" };
var mapRectSchema = {
  properties: {
    x: int,
    z: int,
    xsize: int,
    zsize: int
  },
  required: ["x", "z", "xsize", "zsize"]
};
var modelModsSchema = {
  properties: {
    replaceMaterials: { type: "array", minLength: 2, maxLength: 2, items: int },
    replaceColors: { type: "array", minLength: 2, maxLength: 2, items: int }
  }
};
var simpleModelDefSchema = {
  type: "array",
  items: {
    properties: {
      modelid: int,
      mods: modelModsSchema
    },
    required: ["modelid", "mods"]
  }
};
var customModelDefSchema = {
  properties: {
    type: { const: "custom" },
    modelkey: string,
    name: string,
    simpleModel: simpleModelDefSchema,
    globalMods: modelModsSchema,
    basecomp: string
  },
  required: ["type", "modelkey", "name", "simplemodel", "globalMods", "basecomp"]
};
var scenarioModelSchema = {
  oneOf: [
    {
      properties: {
        type: { const: "simple" },
        modelkey: string,
        name: string,
        simpleModel: simpleModelDefSchema
      },
      required: ["type", "modelkey", "name", "simplemodel"]
    },
    {
      properties: {
        type: { const: "map" },
        modelkey: string,
        name: string,
        mapRect: mapRectSchema
      },
      required: ["type", "modelkey", "name", "mapRect"]
    },
    customModelDefSchema
  ]
};
var scenarioActionSchema = {
  oneOf: [
    {
      properties: {
        type: { const: "location" },
        target: int,
        x: number,
        z: number,
        level: int,
        dy: number,
        rotation: number
      },
      required: ["type", "target", "x", "z", "level", "dy"]
    },
    {
      properties: {
        type: { const: "transform" },
        target: int,
        flip: boolean,
        scalex: number,
        scaley: number,
        scalez: number
      },
      required: ["type", "target", "flip", "scalex", "scaley", "scalez"]
    },
    {
      properties: {
        type: { const: "anim" },
        target: int,
        animid: int
      },
      required: ["type", "target", "animid"]
    },
    {
      properties: {
        type: { const: "animset" },
        target: int,
        animid: int,
        anims: {
          type: "object",
          additionalProperties: int
        }
      },
      required: ["type", "target", "animid", "anims"]
    },
    {
      properties: {
        type: { const: "delay" },
        target: { const: -1 },
        duration: number
      },
      required: ["type", "target", "duration"]
    },
    {
      properties: {
        type: { const: "visibility" },
        target: int,
        visibility: boolean
      },
      required: ["type", "target", "visibility"]
    },
    {
      properties: {
        type: { const: "scale" },
        target: int,
        scalex: number,
        scaley: number,
        scalez: number
      },
      required: ["type", "target", "scalex", "scaley", "scalez"]
    }
  ]
};
var scenarioStateSchema = {
  properties: {
    components: {
      type: "object",
      additionalProperties: scenarioModelSchema
    },
    actions: {
      type: "array",
      items: scenarioActionSchema
    }
  }
};
var maprenderConfigSchema = {
  properties: {
    tileimgsize: number,
    mapsizex: number,
    mapsizez: number,
    area: {
      default: "full",
      description: "A string representing the the map area to render. Either one of the named presets (main, full, test ...), or one or more chunk ranges. eg: 50.50,20.20-70.70",
      anyOf: [
        { type: "string", pattern: /^\d+\.\d+(-\d+\.\d+)?(,\d+\.\d+(-\d+\.\d+)?)*$/.source },
        { type: "string", enum: ["main", "full", "test"] },
        { type: "string", pattern: /^\w+$/.source }
      ]
    },
    layers: {
      items: {
        properties: {
          mode: string,
          pxpersquare: number,
          name: string,
          level: number,
          usegzip: boolean,
          subtractlayers: { items: string },
          format: { type: "string", enum: ["png", "webp"] },
          mipmode: { enum: ["default", "avg"] }
        },
        required: ["mode", "name", "pxpersquare", "level"],
        oneOf: [{
          properties: {
            mode: { enum: ["3d", "minimap", "interactions"] },
            dxdy: number,
            dzdy: number,
            hidelocs: boolean,
            overlaywalls: boolean,
            overlayicons: boolean
          },
          required: ["mode", "dxdy", "dzdy"]
        }, {
          properties: {
            mode: { const: "map" },
            wallsonly: boolean,
            mapicons: boolean,
            thicklines: boolean
          },
          required: ["mode"]
        }, {
          properties: {
            mode: { enum: ["height", "collision", "locs", "maplabels", "rendermeta"] }
          },
          required: ["mode"]
        }]
      }
    }
  },
  required: ["layers", "tileimgsize", "mapsizex", "mapsizez", "area"]
};

// rsmv/src/map/backends.ts
import * as commentjson from "comment-json";

// rsmv/src/cliparser.ts
import * as cmdts from "cmd-ts";

// rsmv/src/cache/rawfiles.ts
import * as path6 from "path";
import * as fs5 from "fs";
var RawFileLoader = class extends CacheFileSource {
  constructor(cachedir, virtualMajor = 0) {
    super();
    this.files = /* @__PURE__ */ new Map();
    this.cachedir = cachedir;
    this.virtualMajor = virtualMajor;
    let dir = fs5.readdirSync(cachedir);
    this.index = dir.map((name, index) => {
      this.files.set(index, name);
      return {
        major: virtualMajor,
        minor: index,
        crc: 0,
        subindexcount: 1,
        subindices: [0],
        subnames: null,
        version: 0,
        size: 0,
        name: null,
        uncompressed_crc: 0,
        uncompressed_size: 0
      };
    });
  }
  getCacheMeta() {
    return {
      name: `files:${this.cachedir}`,
      descr: `Only index ${this.virtualMajor}, loaded from unpacked cache files in ${this.cachedir}.`,
      timestamp: /* @__PURE__ */ new Date(0)
    };
  }
  getFile(major, minor, crc) {
    let name = this.files.get(minor);
    if (!name) {
      throw new Error(`virtual minor ${minor} does not have a corresponding file`);
    }
    return fs5.promises.readFile(path6.join(this.cachedir, name));
  }
  async getFileArchive(index) {
    let file = await this.getFile(index.major, index.minor, index.crc);
    return [{ fileid: 0, offset: 0, size: file.byteLength, buffer: file, namehash: null }];
  }
  async getCacheIndex(major) {
    return this.index;
  }
};

// rsmv/src/cliparser.ts
function cacheSourceFromString(str) {
  let [mode, ...argparts] = str.split(":");
  let arg = argparts.join(":");
  return async (opts) => {
    switch (mode) {
      case "live":
        return new CacheDownloader();
      case "auto":
        let fs7 = new CLIScriptFS(arg);
        return selectFsCache(fs7, opts);
      case "nxt":
      case "cache":
        return new GameCacheLoader(arg, opts?.writable ?? false);
      case "cache-write":
        return new GameCacheLoader(arg, true);
      case "openrs":
      case "openrs2":
        return Openrs2CacheSource.fromId(+arg);
      case "openrslast":
      case "openrs2last":
        let target = await Openrs2CacheSource.getRecentCache(+(arg ?? "0"));
        if (!target) {
          throw new Error(`cache index ${arg} not found`);
        }
        console.log(`opening openrs2:${target.id}`);
        return new Openrs2CacheSource(target);
      case "extracted":
        return new RawFileLoader(arg, 0);
      case "global":
        let fn = globalThis[arg];
        if (typeof fn != "function") {
          throw new Error("the 'global' cache source requires a callback function with name <arg> to be exposed on the global scope");
        }
        return new CallbackCacheLoader(fn, false);
      default:
        throw new Error("unknown cache mode");
    }
  };
}
var ReadCacheSource = {
  async from(str) {
    return cacheSourceFromString(str);
  },
  defaultValue: () => cacheSourceFromString("cache"),
  description: "Where to get game files from, can be 'live', 'cache[:rscachedir]', openrs2[:ors2cacheid] or openrs2last[:skipcount]"
};
var FileRange2 = {
  async from(str) {
    return stringToFileRange(str);
  },
  description: "A file range with possible multiple components. '10', '10-20', '10,12' or '5.10-5.20' etc"
};
var MapRectangle = {
  async from(str) {
    let rect = stringToMapArea(str);
    if (!rect) {
      throw new Error("expected maprect format: x,y,xsize,zsize");
    }
    return rect;
  },
  description: "A square of map coordinates as 'x,y', 'x,y,size' or 'x,y,w,h'"
};
function literal(args) {
  return args;
}
var filesource = literal({
  source: cmdts.option({ long: "source", short: "o", type: ReadCacheSource })
});
var filerange2 = literal({
  files: cmdts.option({ long: "ids", short: "i", type: FileRange2, defaultValue: () => [{ start: [0, 0, 0], end: [Infinity, Infinity, Infinity] }] })
});
var mapareasource = literal({
  area: cmdts.option({ long: "area", short: "a", type: MapRectangle })
});
var mapareasourceoptional = literal({
  area: cmdts.option({ long: "area", short: "a", defaultValue: () => null, type: MapRectangle })
});

// rsmv/src/clicommands.ts
import { command, option as option2, flag } from "cmd-ts";
import * as cmdts2 from "cmd-ts";

// rsmv/src/scripts/indexoverview.ts
import prettyJson7 from "json-stringify-pretty-compact";

// rsmv/src/scripts/quickchatlookup.ts
import prettyJson8 from "json-stringify-pretty-compact";

// rsmv/src/scripts/scrapeavatars.ts
var import_node_fetch4 = __toESM(require_lib3());
import prettyJson9 from "json-stringify-pretty-compact";

// rsmv/src/scripts/groupskeletons.ts
import prettyJson10 from "json-stringify-pretty-compact";

// rsmv/src/clicommands.ts
import fs6 from "fs/promises";

// rsmv/src/clientscript/extractmodule.ts
var implementations;
((implementations2) => {
  var paramtable = /* @__PURE__ */ new Map();
  var structatble = /* @__PURE__ */ new Map();
  var enumtable = /* @__PURE__ */ new Map();
  function struct_getparam(structid, paramid) {
    let param = paramtable.get(paramid);
    if (!param) {
      throw new Error(`unknown param id ${paramid}`);
    }
    let struct = structatble.get(structid);
    let res = struct?.get(paramid) ?? param.defaultValue;
    return res;
  }
  implementations2.struct_getparam = struct_getparam;
  function enum_getvalue(fromtype, totype, enumid, key) {
    let enumdata = enumtable.get(enumid);
    if (!enumdata) {
      throw new Error(`unknown enum id ${enumid}`);
    }
    let index = enumdata.from.indexOf(key);
    return index == -1 ? enumdata.defaultTo : enumdata.to[index];
  }
  implementations2.enum_getvalue = enum_getvalue;
  function ENUM_GETOUTPUTCOUNT(enumid) {
    let enumdata = enumtable.get(enumid);
    if (!enumdata) {
      throw new Error(`unknown enum id ${enumid}`);
    }
    return enumdata.from.length;
  }
  implementations2.ENUM_GETOUTPUTCOUNT = ENUM_GETOUTPUTCOUNT;
})(implementations || (implementations = {}));
var IsolatedCS2Module = class _IsolatedCS2Module {
  constructor(deob) {
    this.scripts = /* @__PURE__ */ new Map();
    this.enums = /* @__PURE__ */ new Map();
    this.params = /* @__PURE__ */ new Map();
    this.structs = /* @__PURE__ */ new Map();
    this.mockscripts = /* @__PURE__ */ new Set();
    this.entrypoints = [];
    this.source = deob.source;
    this.deob = deob;
  }
  static async fromSource(source) {
    let deob = await prepareClientScript(source);
    return new _IsolatedCS2Module(deob);
  }
  async run(entryscripts) {
    this.entrypoints = entryscripts;
    let queue = entryscripts.slice();
    while (queue.length != 0) {
      let id = queue.pop();
      let fn = await this.addscript(id);
      if (this.scripts.size % 100 == 0) {
        console.log(`script count: ${this.scripts.size}, queue: ${queue.length}`);
      }
      if (fn) {
        queue.push(...[...fn.scripts].filter((q) => !this.scripts.has(q)));
      }
    }
    let res = "";
    res += writeOpcodeFile(this.deob);
    res += this.writeVars();
    res += await this.writeStructsParamsEnums();
    res += implementations.enum_getvalue + "\n";
    res += implementations.struct_getparam + "\n";
    res += implementations.ENUM_GETOUTPUTCOUNT + "\n";
    res += this.writeScripts();
    return res;
  }
  async addscript(id) {
    if (this.scripts.has(id)) {
      return null;
    }
    if (this.mockscripts.has(id)) {
      return null;
    }
    let filebuf = await this.source.getFileById(cacheMajors.clientscript, id);
    let script = parse.clientscript.read(filebuf, this.source);
    let { rootfunc, sections, typectx } = parseClientScriptIm2(this.deob, script, id);
    let fn = {
      func: rootfunc,
      ctx: typectx,
      sections,
      enums: /* @__PURE__ */ new Set(),
      params: /* @__PURE__ */ new Set(),
      structs: /* @__PURE__ */ new Set(),
      scripts: /* @__PURE__ */ new Set(),
      vars: /* @__PURE__ */ new Set(),
      varbits: /* @__PURE__ */ new Set()
    };
    scriptdeps(this, fn);
    this.scripts.set(id, fn);
    return fn;
  }
  writeScripts() {
    let res = "";
    for (let mockid of [...this.mockscripts]) {
      res += `var script${mockid} = function(...args[]){};
`;
    }
    res += "\n";
    let funcs = [...this.scripts].sort((a, b) => a[0] - b[0]).map((q) => q[1]);
    for (let fn of funcs) {
      let writer = new TsWriterContext(this.deob, fn.ctx);
      let code = writer.getCode(fn.func);
      res += code + "\n\n";
    }
    return res;
  }
  async writeStructsParamsEnums() {
    let res = "";
    let allstructs = /* @__PURE__ */ new Set();
    let allparams = /* @__PURE__ */ new Set();
    let allenums = /* @__PURE__ */ new Set();
    for (let fn of this.scripts.values()) {
      fn.structs.forEach((q) => allstructs.add(q));
      fn.params.forEach((q) => allparams.add(q));
      fn.enums.forEach((q) => allenums.add(q));
    }
    res += `type Param = { defaultValue: number | string | bigint };
`;
    res += `type Struct = Map<number, string | number | bigint>;
`;
    res += `type Enum = { defaultFrom: number, defaultTo: string | number, from: number[] | string[], to: number[] | string[] };
`;
    res += "\n";
    res += `var paramtable = new Map<number, Param>();
`;
    for (let paramid of allparams) {
      let param = this.deob.parammeta.get(paramid);
      res += `paramtable.set(${paramid},${JSON.stringify({ defaultValue: param?.type?.defaultint ?? param?.type?.defaultstring })});
`;
    }
    res += "\n";
    res += `var structatble = new Map<number, Struct>();
`;
    for (let structid of allstructs) {
      let struct = await loadStruct(this.source, structid);
      res += `structtable.set(${structid}, new Map([
`;
      for (let val of struct.extra ?? []) {
        res += `	[${val.prop}, ${val.intvalue ?? `"${(val.stringvalue ?? "").replace(/\\/g, "\\\\").replace(/"/, '\\"')}"`}],
`;
      }
      res += `]))
`;
    }
    res += "\n";
    res += `var enumtable = new Map<number, Enum>();
`;
    for (let enumsid of allenums) {
      let enumdata = await loadEnum(this.source, enumsid);
      let intarr = enumdata.intArrayValue1 ?? enumdata.intArrayValue2?.values;
      let stringarr = enumdata.stringArrayValue1 ?? enumdata.stringArrayValue2?.values;
      let arr = intarr ?? stringarr;
      let from = arr?.map((q) => q[0]) ?? [];
      let to = arr?.map((q) => q[1]) ?? [];
      let defaultFrom = -1;
      let defaultTo = stringarr ? "" : -1;
      res += `enumtable.set(${enumsid}, ${JSON.stringify({ defaultFrom, defaultTo, from, to })})
`;
    }
    res += "\n";
    return res;
  }
  writeVars() {
    let res = "";
    let allvars = /* @__PURE__ */ new Set();
    let allvarbits = /* @__PURE__ */ new Set();
    for (let fn of this.scripts.values()) {
      fn.vars.forEach((q) => allvars.add(q));
      fn.varbits.forEach((q) => allvarbits.add(q));
    }
    for (let varid of [...allvars].sort((a, b) => a - b)) {
      let varmeta = this.deob.getClientVarMeta(varid);
      let varname = varmeta ? `var${varmeta.name}_${varmeta.varid}` : `varunk_${varid}`;
      res += `var ${varname}`;
      res += `: ${varmeta ? subtypeToTs(varmeta.fulltype) : "any"}`;
      res += `
`;
    }
    res += "\n";
    for (let varid of [...allvarbits].sort((a, b) => a - b)) {
      let id = varid >> 8;
      let optarget = varid & 255;
      let varbitmeta = this.deob.varbitmeta.get(id);
      let varname = "";
      let comment = "unknown";
      if (typeof varbitmeta?.varid != "number") {
        varname = `varbitunk_${varid}`;
      } else {
        let groupmeta = this.deob.varmeta.get(varbitmeta.varid >> 16);
        varname = `varbit${groupmeta?.name ?? "unk"}_${id}${optarget == 0 ? "" : `[${optarget}]`}`;
        comment = `${varbitmeta.bits[1] - varbitmeta.bits[0] + 1}`;
      }
      res += `var ${varname}`;
      res += `: int`;
      res += `; //${comment}
`;
    }
    res += "\n";
    return res;
  }
};
globalThis.IsolatedCS2Module = IsolatedCS2Module;
function analyzeCallGraph(mod) {
  let nodedepths = /* @__PURE__ */ new Map();
  let getdepth = (node) => {
    let d = 0;
    for (; node; node = node.parent) ;
    return d;
  };
  let iter = (parent, scriptid) => {
    let fn = mod.scripts.get(scriptid);
    if (!fn) {
      return;
    }
    let node = nodedepths.get(scriptid);
    let runchildren = false;
    if (!node) {
      node = { id: scriptid, parent, children: /* @__PURE__ */ new Set() };
      parent.children.add(scriptid);
      nodedepths.set(scriptid, node);
      runchildren = true;
    } else if (getdepth(node) > getdepth(parent) + 1) {
      node.parent?.children.delete(scriptid);
      node.parent = parent;
      runchildren = true;
    }
    if (runchildren) {
      for (let id of fn.scripts) {
        iter(node, id);
      }
    }
  };
  let rootnode = { id: -1, parent: null, children: /* @__PURE__ */ new Set() };
  for (let entry of mod.entrypoints) {
    iter(rootnode, entry);
  }
  let res = "from,to\n";
  for (let [id, node] of nodedepths) {
    for (let child of node.children) {
      res += `${node.id},${child}
`;
    }
  }
  return res;
}
globalThis.analizeCallGraph = analyzeCallGraph;
function alanyzeFull(mod) {
  let res = "from,to\n";
  for (let [id, node] of mod.scripts) {
    for (let child of node.scripts) {
      res += `${id},${child}
`;
    }
  }
  return res;
}
globalThis.alanyzeFull = alanyzeFull;
function scriptdeps(mod, fn) {
  let consts = new StackConstants();
  let hasunknown = false;
  let cursor = new RewriteCursor(fn.func);
  for (let node = cursor.goToStart(); node; node = cursor.next()) {
    if (isNamedOp(node, namedClientScriptOps.enum_getvalue)) {
      let enumid = consts?.values.at(-2);
      if (typeof enumid == "number") {
        fn.enums.add(enumid);
      }
    }
    if (isNamedOp(node, namedClientScriptOps.struct_getparam)) {
      let param = consts?.values.at(-1);
      let struct = consts?.values.at(-2);
      if (typeof param == "number") {
        fn.params.add(param);
      }
      if (typeof struct == "number") {
        fn.structs.add(struct);
      }
    }
    if (isNamedOp(node, namedClientScriptOps.enum_getreverseindex)) {
      let enumid = consts?.values.at(-3);
      if (typeof enumid == "number") {
        fn.enums.add(enumid);
      }
    }
    if (isNamedOp(node, namedClientScriptOps.gosub)) {
      fn.scripts.add(node.op.imm);
    }
    if (isNamedOp(node, namedClientScriptOps.popvarbit) || isNamedOp(node, namedClientScriptOps.pushvarbit)) {
      fn.varbits.add(node.op.imm);
    }
    if (isNamedOp(node, namedClientScriptOps.popvar) || isNamedOp(node, namedClientScriptOps.pushvar)) {
      fn.vars.add(node.op.imm);
    }
    if (node instanceof FunctionBindNode) {
      let scriptid = node.children[0]?.knownStackDiff?.constout ?? -1;
      if (typeof scriptid == "number" && scriptid != -1) {
      }
    }
    let stackinout = node.knownStackDiff;
    if (node instanceof RawOpcodeNode) {
      stackinout ??= node.opinfo.stackinfo;
      hasunknown ||= node.unknownstack;
    }
    if (consts) {
      if (node.knownStackDiff?.constout != null) {
        consts.pushOne(node.knownStackDiff.constout);
      } else if (stackinout?.initializedthrough) {
        consts.applyInOut(stackinout);
      } else {
        consts = null;
      }
    }
  }
}

// rsmv/src/viewer/scenenodes.tsx
import * as cmdts3 from "cmd-ts";
function ScenarioActionControl(p) {
  const action = p.action;
  let targetname = p.comp?.name ?? "??";
  let remove = /* @__PURE__ */ React7.createElement("input", { type: "button", className: "sub-btn", value: "x", onClick: () => p.onChange(null) });
  let gridstyle = (nparts) => ({
    display: "grid",
    gridTemplateColumns: nparts <= 0 ? "1fr min-content" : `${nparts}fr repeat(${nparts},1fr) min-content`,
    alignItems: "baseline"
  });
  let spanstyle = { minWidth: "0", overflow: "hidden", whiteSpace: "nowrap" };
  switch (action.type) {
    case "anim": {
      return /* @__PURE__ */ React7.createElement("div", { style: gridstyle(1) }, /* @__PURE__ */ React7.createElement("span", { style: spanstyle }, p.action.type, " ", targetname), /* @__PURE__ */ React7.createElement(InputCommitted2, { type: "number", value: action.animid, onChange: (e) => p.onChange({ ...action, animid: +e.currentTarget.value }) }), remove);
    }
    case "animset": {
      return /* @__PURE__ */ React7.createElement("div", { style: gridstyle(1) }, /* @__PURE__ */ React7.createElement("span", { style: spanstyle }, p.action.type, " ", targetname), /* @__PURE__ */ React7.createElement("select", { value: action.animid, onChange: (e) => p.onChange({ ...action, animid: +e.currentTarget.value }) }, Object.entries(action.anims).map(([k, v]) => /* @__PURE__ */ React7.createElement("option", { key: k, value: v }, k))), remove);
    }
    case "delay": {
      return /* @__PURE__ */ React7.createElement("div", { style: gridstyle(1) }, /* @__PURE__ */ React7.createElement("span", { style: spanstyle }, p.action.type, " (ms)"), /* @__PURE__ */ React7.createElement(InputCommitted2, { type: "number", value: action.duration, onChange: (e) => p.onChange({ ...action, duration: +e.currentTarget.value }) }), remove);
    }
    case "location": {
      return /* @__PURE__ */ React7.createElement(React7.Fragment, null, /* @__PURE__ */ React7.createElement("div", { style: gridstyle(0) }, /* @__PURE__ */ React7.createElement("span", { style: spanstyle }, p.action.type, " ", targetname), remove), /* @__PURE__ */ React7.createElement("div", { style: { ...gridstyle(0), gridTemplateColumns: "1em 2fr repeat(2,minmax(0,1fr))" } }, /* @__PURE__ */ React7.createElement("span", { style: { gridColumn: "2" } }, "Floor+offset"), /* @__PURE__ */ React7.createElement(InputCommitted2, { type: "number", value: action.level, step: 1, onChange: (e) => p.onChange({ ...action, level: +e.currentTarget.value }) }), /* @__PURE__ */ React7.createElement(InputCommitted2, { type: "number", value: action.dy, onChange: (e) => p.onChange({ ...action, dy: +e.currentTarget.value }) }), /* @__PURE__ */ React7.createElement("span", { style: { gridColumn: "2" } }, "Position x,z"), /* @__PURE__ */ React7.createElement(InputCommitted2, { type: "number", value: action.x, onChange: (e) => p.onChange({ ...action, x: +e.currentTarget.value }) }), /* @__PURE__ */ React7.createElement(InputCommitted2, { type: "number", value: action.z, onChange: (e) => p.onChange({ ...action, z: +e.currentTarget.value }) }), /* @__PURE__ */ React7.createElement("span", { style: { gridColumn: "2" } }, "Rotation"), /* @__PURE__ */ React7.createElement(InputCommitted2, { type: "number", style: { gridColumn: "span 2" }, value: action.rotation, onChange: (e) => p.onChange({ ...action, rotation: +e.currentTarget.value }) })));
    }
    case "scale": {
      return /* @__PURE__ */ React7.createElement("div", { style: gridstyle(3) }, /* @__PURE__ */ React7.createElement("span", { style: spanstyle }, p.action.type, " ", targetname), /* @__PURE__ */ React7.createElement(InputCommitted2, { type: "number", value: action.scalex, onChange: (e) => p.onChange({ ...action, scalex: +e.currentTarget.value }) }), /* @__PURE__ */ React7.createElement(InputCommitted2, { type: "number", value: action.scalez, onChange: (e) => p.onChange({ ...action, scalez: +e.currentTarget.value }) }), /* @__PURE__ */ React7.createElement(InputCommitted2, { type: "number", value: action.scaley, onChange: (e) => p.onChange({ ...action, scaley: +e.currentTarget.value }) }), remove);
    }
    case "visibility": {
      return /* @__PURE__ */ React7.createElement("div", { style: gridstyle(1) }, /* @__PURE__ */ React7.createElement("span", { style: spanstyle }, p.action.type, " ", targetname), /* @__PURE__ */ React7.createElement("label", null, /* @__PURE__ */ React7.createElement("input", { type: "checkbox", checked: action.visible, onChange: (e) => p.onChange({ ...action, visible: e.currentTarget.checked }) })), remove);
    }
  }
}
function convertScenarioComponent(comp) {
  let mods = { replaceColors: [], replaceMaterials: [], lodLevel: -1 };
  if (comp.simpleModel.length != 0) {
    let firstmodel = comp.simpleModel[0];
    for (let col of firstmodel.mods.replaceColors ?? []) {
      if (comp.simpleModel.every((q) => q.mods.replaceColors?.some((q2) => q2[0] == col[0] && q2[1] == col[1]))) {
        mods.replaceColors.push(col);
      }
    }
    for (let mat of firstmodel.mods.replaceMaterials ?? []) {
      if (comp.simpleModel.every((q) => q.mods.replaceMaterials?.some((q2) => q2[0] == mat[0] && q2[1] == mat[1]))) {
        mods.replaceMaterials.push(mat);
      }
    }
  }
  let models = comp.simpleModel.map((model) => ({
    ...model,
    mods: {
      replaceColors: model.mods.replaceColors?.filter((q) => !mods.replaceColors.some((col) => col[0] == q[0] && col[1] == q[1])) ?? [],
      replaceMaterials: model.mods.replaceMaterials?.filter((q) => !mods.replaceMaterials.some((mat) => mat[0] == q[0] && mat[1] == q[1])) ?? []
    }
  }));
  let json = customModelJson(models, mods);
  return {
    type: "custom",
    modelkey: json,
    name: comp.name + "*",
    simpleModel: models,
    globalMods: mods,
    basecomp: comp.modelkey
  };
}
function RecolorList(p) {
  let [addid, setAddid] = React7.useState(0);
  let editcolor = (icol, v) => {
    let newcols = p.cols.slice() ?? [];
    if (v == null) {
      newcols.splice(icol, 1);
    } else {
      newcols[icol] = [newcols[icol][0], v];
    }
    p.onChange(newcols);
  };
  if (!p.showAdd && p.cols.length == 0) {
    return null;
  }
  return /* @__PURE__ */ React7.createElement("div", { className: "mv-overridegroup" }, /* @__PURE__ */ React7.createElement("div", { style: { gridColumn: "1/-1", textAlign: "center" } }, "Color overrides"), p.cols.flatMap((col, i) => {
    return [
      /* @__PURE__ */ React7.createElement("div", { key: `${i}a` }, col[0]),
      /* @__PURE__ */ React7.createElement(InputCommitted2, { key: `${i}b`, type: "color", value: hsl2hex(col[1]), onChange: (e) => editcolor(i, hex2hsl(e.currentTarget.value)) }),
      /* @__PURE__ */ React7.createElement("input", { key: `${i}c`, type: "button", className: "sub-btn", value: "x", onClick: (e) => editcolor(i, null) })
    ];
  }), /* @__PURE__ */ React7.createElement("input", { type: "number", value: addid, onChange: (e) => setAddid(+e.currentTarget.value) }), /* @__PURE__ */ React7.createElement("input", { type: "button", value: "add color", className: "sub-btn", onClick: (e) => p.onChange(p.cols.concat([[addid, 0]])) }));
}
function RematerialList(p) {
  let [addid, setAddid] = React7.useState(0);
  let editmaterial = (icol, v) => {
    let newcols = p.mats.slice() ?? [];
    if (v == null) {
      newcols.splice(icol, 1);
    } else {
      newcols[icol] = [newcols[icol][0], v];
    }
    p.onChange(newcols);
  };
  if (!p.showAdd && p.mats.length == 0) {
    return null;
  }
  return /* @__PURE__ */ React7.createElement("div", { className: "mv-overridegroup" }, /* @__PURE__ */ React7.createElement("div", { style: { gridColumn: "1/-1", textAlign: "center" } }, "Material overrides"), p.mats.flatMap((col, i) => {
    return [
      /* @__PURE__ */ React7.createElement("div", { key: `${i}a` }, col[0]),
      /* @__PURE__ */ React7.createElement(InputCommitted2, { key: `${i}b`, type: "number", value: col[1], onChange: (e) => editmaterial(i, +e.currentTarget.value) }),
      /* @__PURE__ */ React7.createElement("input", { key: `${i}c`, type: "button", className: "sub-btn", value: "x", onClick: (e) => editmaterial(i, null) })
    ];
  }), /* @__PURE__ */ React7.createElement("input", { type: "number", value: addid, onChange: (e) => setAddid(+e.currentTarget.value) }), /* @__PURE__ */ React7.createElement("input", { type: "button", value: "add material", className: "sub-btn", onClick: (e) => p.onChange(p.mats.concat([[addid, 0]])) }));
}
function ScenarionComponentModelSettings(p) {
  let [showopts, setShowopts] = React7.useState(false);
  let editcolor = (v) => {
    p.onChange(p.index, { ...p.comp, mods: { ...p.comp.mods, replaceColors: v } });
  };
  let editmats = (v) => {
    p.onChange(p.index, { ...p.comp, mods: { ...p.comp.mods, replaceMaterials: v } });
  };
  let totaloverrides = (p.comp.mods.replaceColors?.length ?? 0) + (p.comp.mods.replaceMaterials?.length ?? 0);
  return /* @__PURE__ */ React7.createElement(React7.Fragment, null, /* @__PURE__ */ React7.createElement("div", { style: { clear: "both", overflow: "hidden" } }, "modelid: ", p.comp.modelid, /* @__PURE__ */ React7.createElement("input", { type: "button", className: "sub-btn", value: "x", onClick: (e) => p.onChange(p.index, null), style: { float: "right" } }), /* @__PURE__ */ React7.createElement("input", { type: "button", className: "sub-btn", value: showopts ? "collapse" : `overrides (${totaloverrides})`, onClick: (e) => setShowopts(!showopts), style: { float: "right" } })), showopts && /* @__PURE__ */ React7.createElement("div", { className: "mv-overridegroup__border" }, /* @__PURE__ */ React7.createElement(RecolorList, { cols: p.comp.mods.replaceColors ?? [], onChange: editcolor, showAdd: showopts }), /* @__PURE__ */ React7.createElement(RematerialList, { mats: p.comp.mods.replaceMaterials ?? [], onChange: editmats, showAdd: showopts })));
}
function ScenarionComponentSettings(p) {
  let [addid, setAddid] = React7.useState(0);
  let addmodel = () => {
    let m = p.comp.simpleModel.concat({ modelid: addid, mods: {} });
    p.onChange({
      ...p.comp,
      modelkey: customModelJson(m, p.comp.globalMods),
      simpleModel: m
    });
  };
  let change = (i, def) => {
    let m = p.comp.simpleModel.slice();
    if (def) {
      m[i] = def;
    } else {
      m.splice(i, 1);
    }
    p.onChange({
      ...p.comp,
      modelkey: customModelJson(m, p.comp.globalMods),
      simpleModel: m
    });
  };
  let changeColors = (v) => {
    let mods = { ...p.comp.globalMods, replaceColors: v };
    p.onChange({
      ...p.comp,
      modelkey: customModelJson(p.comp.simpleModel, mods),
      globalMods: mods
    });
  };
  let changeMats = (v) => {
    let mods = { ...p.comp.globalMods, replaceMaterials: v };
    p.onChange({
      ...p.comp,
      modelkey: customModelJson(p.comp.simpleModel, mods),
      globalMods: mods
    });
  };
  return /* @__PURE__ */ React7.createElement(React7.Fragment, null, p.comp.simpleModel.map((q, i) => /* @__PURE__ */ React7.createElement(ScenarionComponentModelSettings, { index: i, key: i, comp: q, onChange: change })), /* @__PURE__ */ React7.createElement("div", { className: "mv-overridegroup" }, /* @__PURE__ */ React7.createElement("input", { type: "number", value: addid, onChange: (e) => setAddid(+e.currentTarget.value) }), /* @__PURE__ */ React7.createElement("input", { type: "button", value: "add model", className: "sub-btn", onClick: addmodel })), p.showOpts && /* @__PURE__ */ React7.createElement("div", { className: "mv-overridegroup__border" }, /* @__PURE__ */ React7.createElement(RecolorList, { cols: p.comp.globalMods.replaceColors ?? [], onChange: changeColors, showAdd: true }), /* @__PURE__ */ React7.createElement(RematerialList, { mats: p.comp.globalMods.replaceMaterials ?? [], onChange: changeMats, showAdd: true })));
}
function ScenarioComponentControl(p) {
  let [showOpts, setShowOpts] = React7.useState(false);
  let edit = () => {
    if (p.comp.type == "simple") {
      p.onChange(convertScenarioComponent(p.comp));
      setShowOpts(true);
    }
  };
  let revert = async () => {
    if (p.comp.type != "custom" || !p.ctx) {
      return;
    }
    let def = await modelInitToModel(p.ctx.sceneCache, p.comp.basecomp);
    p.onChange({
      type: "simple",
      modelkey: p.comp.basecomp,
      name: p.comp.name.replace(/\*$/, ""),
      simpleModel: def.models
    });
  };
  return /* @__PURE__ */ React7.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr min-content min-content min-content", alignItems: "baseline" } }, /* @__PURE__ */ React7.createElement("div", { style: { maxWidth: "100%", overflow: "hidden" } }, p.comp.name), p.comp.type == "custom" && /* @__PURE__ */ React7.createElement("input", { type: "button", className: "sub-btn", value: showOpts ? "-" : "+", onClick: (e) => setShowOpts(!showOpts) }), p.comp.type == "simple" && /* @__PURE__ */ React7.createElement("input", { type: "button", className: "sub-btn", value: "edit", onClick: edit }), p.comp.type == "custom" && /* @__PURE__ */ React7.createElement("input", { type: "button", className: "sub-btn", value: "revert", onClick: revert }), /* @__PURE__ */ React7.createElement("input", { type: "button", className: "sub-btn", value: "x", onClick: (e) => p.onChange(null) }), p.comp.type == "custom" && showOpts && /* @__PURE__ */ React7.createElement("div", { style: { gridColumn: "1/-1" } }, /* @__PURE__ */ React7.createElement(ScenarionComponentSettings, { comp: p.comp, onChange: p.onChange, showOpts })));
}
function customModelJson(models, globalmods) {
  return JSON.stringify({ models, globalMods: globalmods });
}
function modeldefJsonToModel(cache, json) {
  let d = JSON.parse(json);
  assertSchema(d, customModelDefSchema);
  let models = [];
  return {
    id: json,
    info: null,
    models,
    anims: {},
    name: "custom"
  };
}
async function modelInitToModel(cache, init) {
  let [key] = init.split(":", 1);
  let id = init.slice(key.length + 1);
  if (key == "model") {
    return modelToModel(cache, +id);
  } else if (key == "item") {
    return itemToModel(cache, +id);
  } else if (key == "npc") {
    return npcBodyToModel(cache, +id);
  } else if (key == "loc") {
    return locToModel(cache, +id);
  } else if (key == "spotanim") {
    return spotAnimToModel(cache, +id);
  } else if (key == "player") {
    return playerToModel(cache, id);
  } else if (key == "custom") {
    return modeldefJsonToModel(cache, id);
  } else {
    throw new Error("unknown modelinit type");
  }
}
var SceneScenario = class extends React7.Component {
  constructor(p) {
    super(p);
    this.models = /* @__PURE__ */ new Map();
    this.idcounter = 0;
    this.mapoffset = null;
    this.mapgrid = new CombinedTileGrid([]);
    this.hadctx = false;
    this.state = {
      actions: [],
      components: {},
      addModelType: "model",
      addActionType: "anim",
      addActionTarget: -1
    };
    this.loadFromJson(p.initialId, true);
  }
  loadFromJson(str, isinit = false) {
    let newstate = parseJsonOrDefault(str, scenarioStateSchema, () => {
      if (!isinit) {
        throw new Error("invalid state json");
      }
      return { actions: [], components: {} };
    });
    let keys = Object.keys(newstate.components);
    this.idcounter = keys.length == 0 ? 0 : Math.max.apply(null, keys) + 1;
    this.hadctx = false;
    if (isinit) {
      Object.assign(this.state, newstate);
    } else {
      this.setSceneState(newstate.components, newstate.actions);
    }
  }
  componentWillUnmount() {
    for (let model of this.models.values()) {
      model.cleanup();
    }
  }
  async addComp(id) {
    if (!this.props.ctx) {
      return;
    }
    if (this.state.addModelType == "map") {
      let rect = stringToMapArea(id);
      if (!rect) {
        throw new Error("invalid map rect");
      }
      let compid = this.idcounter++;
      this.editComp(compid, {
        type: "map",
        modelkey: `${this.state.addModelType}:${id}`,
        name: `map${id}`,
        mapRect: rect
      });
    } else {
      let prim = await modelInitToModel(this.props.ctx.sceneCache, `${this.state.addModelType}:${id}`);
      let compid = this.idcounter++;
      this.editComp(compid, {
        type: "simple",
        modelkey: `${this.state.addModelType}:${id}`,
        name: `${this.state.addModelType}:${id}`,
        simpleModel: prim.models
      });
      if (Object.keys(prim.anims).length != 0) {
        this.editAction(this.state.actions.length, {
          type: "animset",
          target: compid,
          animid: prim.anims.default ?? Object.keys(prim.anims)[0],
          anims: prim.anims
        });
      }
    }
  }
  addAction() {
    let action;
    switch (this.state.addActionType) {
      case "anim":
        action = { type: "anim", target: this.state.addActionTarget, animid: 0 };
        break;
      case "delay":
        action = { type: "delay", target: -1, duration: 0 };
        break;
      case "location":
        action = { type: "location", target: this.state.addActionTarget, level: 0, x: 0, z: 0, dy: 0, rotation: 0 };
        break;
      case "visibility":
        action = { type: "visibility", target: this.state.addActionTarget, visible: true };
        break;
      case "scale":
        action = { type: "scale", target: this.state.addActionTarget, scalex: 1, scaley: 1, scalez: 1 };
        break;
      default:
        throw new Error("unknown action " + this.state.addActionType);
    }
    this.editAction(this.state.actions.length, action);
  }
  getSceneJson(newstate = this.state) {
    return JSON.stringify({ components: newstate.components, actions: newstate.actions });
  }
  setSceneState(components, actions) {
    this.setState((prev) => {
      let scenestate = {
        components: components ?? prev.components,
        actions: actions ?? prev.actions
      };
      localStorage.rsmv_lastsearch = JSON.stringify(this.getSceneJson(scenestate));
      return scenestate;
    });
  }
  ensureComp(uictx, newcomp, oldcomp) {
    let newmodel = void 0;
    if (oldcomp) {
      let oldmodel = this.models.get(oldcomp);
      if (newcomp && oldcomp.modelkey == newcomp.modelkey) {
        newmodel = oldmodel;
      } else {
        this.models.delete(oldcomp);
        oldmodel?.cleanup();
      }
    }
    if (newcomp) {
      if (!newmodel) {
        if (newcomp.type == "simple") {
          newmodel = new RSModel(uictx.sceneCache, newcomp.simpleModel, newcomp.name);
        } else if (newcomp.type == "custom") {
          let mappedmodel = newcomp.simpleModel.map((model) => ({
            ...model,
            mods: {
              replaceColors: (model.mods.replaceColors ?? []).concat(newcomp.globalMods.replaceColors),
              replaceMaterials: (model.mods.replaceMaterials ?? []).concat(newcomp.globalMods.replaceMaterials)
            }
          }));
          newmodel = new RSModel(uictx.sceneCache, mappedmodel, newcomp.name);
        } else if (newcomp.type == "map") {
          newmodel = new RSMapChunkGroup(uictx.sceneCache, newcomp.mapRect, { collision: false, invisibleLayers: false, map2d: false, skybox: true });
          newmodel.on("loaded", this.updateGrids);
          let hasmap = Object.values(this.state.components).some((q) => q.type == "map");
          if (!hasmap || !this.mapoffset) {
            this.mapoffset = {
              x: (newcomp.mapRect.x + newcomp.mapRect.xsize / 2) * rs2ChunkSize,
              z: (newcomp.mapRect.z + newcomp.mapRect.zsize / 2) * rs2ChunkSize
            };
          }
          newmodel.chunks.forEach((q) => q.rootnode.position.set(-this.mapoffset.x * tiledimensions2, 0, -this.mapoffset.z * tiledimensions2));
        } else {
          throw new Error("invalid model init");
        }
        newmodel.addToScene(uictx.renderer);
      }
      this.models.set(newcomp, newmodel);
    }
  }
  editComp(compid, newcomp) {
    if (!this.props.ctx) {
      return;
    }
    let components = { ...this.state.components };
    let oldcomp = this.state.components[compid];
    this.ensureComp(this.props.ctx, newcomp, oldcomp);
    if (newcomp) {
      components[compid] = newcomp;
    } else {
      delete components[compid];
      this.setSceneState(null, this.state.actions.filter((q) => q.target != compid));
    }
    this.setSceneState(components, null);
    if (!components[this.state.addActionTarget]) {
      let ids = Object.keys(components);
      this.setState({ addActionTarget: ids.length == 0 ? 0 : +ids[ids.length - 1] });
    }
    this.restartAnims();
  }
  editAction(index, newaction) {
    let actions = this.state.actions.slice();
    if (newaction?.type == "anim" || newaction?.type == "animset") {
      let model = this.modelIdToModel(newaction.target);
      if (model instanceof RSModel) {
        model.loadAnimation(newaction.animid);
      }
    }
    if (newaction) {
      actions[index] = newaction;
    } else {
      actions.splice(index, 1);
    }
    this.setSceneState(null, actions);
    this.restartAnims();
  }
  modelIdToModel(id) {
    let modelinfo = this.state.components[id];
    return this.models.get(modelinfo);
  }
  updateGrids() {
    let grids = [];
    for (let comp of Object.values(this.state.components)) {
      if (comp.type != "map") {
        continue;
      }
      let model = this.models.get(comp);
      let chunks = [];
      if (model instanceof RSMapChunk) {
        chunks.push(model);
      } else if (model instanceof RSMapChunkGroup) {
        chunks.push(...model.chunks);
      } else {
        continue;
      }
      for (let chunk of chunks) {
        if (!chunk.loaded) {
          continue;
        }
        grids.push({
          src: chunk.loaded.grid,
          rect: {
            x: chunk.chunkx * rs2ChunkSize,
            z: chunk.chunkz * rs2ChunkSize,
            xsize: rs2ChunkSize,
            zsize: rs2ChunkSize
          }
        });
      }
    }
    this.mapgrid = new CombinedTileGrid(grids);
    this.restartAnims();
  }
  async restartAnims() {
    await delay(1);
    let totalduration = 0;
    for (let model of this.models.values()) {
      model.mixer.setTime(0);
    }
    for (const action of this.state.actions) {
      switch (action.type) {
        case "animset":
        case "anim": {
          let model = this.modelIdToModel(action.target);
          if (model instanceof RSModel) {
            model.setAnimation(action.animid);
          }
          break;
        }
        case "location": {
          let model = this.modelIdToModel(action.target);
          let groundy = getTileHeight(this.mapgrid, action.x + (this.mapoffset?.x ?? 0), action.z + (this.mapoffset?.z ?? 0), action.level);
          model?.rootnode.position.set(action.x * tiledimensions2, groundy + action.dy * tiledimensions2, action.z * tiledimensions2);
          model?.rootnode.rotation.set(0, (action.rotation ?? 0) * Math.PI / 4, 0);
          break;
        }
        case "scale": {
          let model = this.modelIdToModel(action.target);
          model?.rootnode.scale.set(action.scalex, action.scaley, action.scalez);
          break;
        }
        case "delay": {
          totalduration += action.duration;
          await delay(action.duration);
          break;
        }
        case "visibility": {
          let model = this.modelIdToModel(action.target);
          if (model) {
            model.rootnode.visible = action.visible;
          }
          break;
        }
      }
    }
  }
  advancedIdSelect() {
    if (!this.props.ctx) {
      return;
    }
    if (this.state.addModelType == "npc") {
      selectEntity(this.props.ctx, "npcs", (id) => this.addComp("" + id), [{ path: ["name"], search: "" }]);
    } else if (this.state.addModelType == "item") {
      selectEntity(this.props.ctx, "items", (id) => this.addComp("" + id), [{ path: ["name"], search: "" }]);
    } else if (this.state.addModelType == "loc") {
      selectEntity(this.props.ctx, "objects", (id) => this.addComp("" + id), [{ path: ["name"], search: "" }]);
    }
  }
  render() {
    if (!this.hadctx && this.props.ctx) {
      this.hadctx = true;
      Object.entries(this.state.components).forEach(([key, comp]) => this.ensureComp(this.props.ctx, comp, this.state.components[key]));
      this.restartAnims();
    }
    const hasmodels = Object.keys(this.state.components).length != 0;
    const hasAdvLookup = this.state.addModelType == "item" || this.state.addModelType == "loc" || this.state.addModelType == "npc";
    return /* @__PURE__ */ React7.createElement(React7.Fragment, null, /* @__PURE__ */ React7.createElement("div", { className: "mv-sidebar-scroll" }, /* @__PURE__ */ React7.createElement("h2", null, "Models"), /* @__PURE__ */ React7.createElement("div", null, /* @__PURE__ */ React7.createElement(CopyButton, { getText: this.getSceneJson }), /* @__PURE__ */ React7.createElement(PasteButton, { onPaste: (v) => this.loadFromJson(v, false) })), /* @__PURE__ */ React7.createElement("div", { style: { display: "flex", flexDirection: "column" } }, /* @__PURE__ */ React7.createElement("select", { value: this.state.addModelType, onChange: (e) => this.setState({ addModelType: e.currentTarget.value }) }, /* @__PURE__ */ React7.createElement("option", { value: "model" }, "model"), /* @__PURE__ */ React7.createElement("option", { value: "npc" }, "npc"), /* @__PURE__ */ React7.createElement("option", { value: "spotanim" }, "spotanim"), /* @__PURE__ */ React7.createElement("option", { value: "loc" }, "location"), /* @__PURE__ */ React7.createElement("option", { value: "player" }, "player"), /* @__PURE__ */ React7.createElement("option", { value: "item" }, "item"), /* @__PURE__ */ React7.createElement("option", { value: "map" }, "map")), /* @__PURE__ */ React7.createElement("div", { style: { display: "grid", gridTemplateColumns: "minmax(0,1fr) min-content" } }, /* @__PURE__ */ React7.createElement(StringInput2, { onChange: this.addComp }), hasAdvLookup && /* @__PURE__ */ React7.createElement("input", { type: "button", className: "sub-btn", value: "Lookup", onClick: this.advancedIdSelect }))), !hasmodels && /* @__PURE__ */ React7.createElement("p", null, "Select a model type and id to add to the scene."), hasmodels && /* @__PURE__ */ React7.createElement("br", null), hasmodels && /* @__PURE__ */ React7.createElement("div", { className: "mv-inset" }, Object.entries(this.state.components).map(([id, comp]) => {
      return /* @__PURE__ */ React7.createElement(ScenarioComponentControl, { key: id, ctx: this.props.ctx, comp, onChange: (e) => this.editComp(+id, e) });
    })), /* @__PURE__ */ React7.createElement("h2", null, "Action sequence"), /* @__PURE__ */ React7.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr min-content" } }, /* @__PURE__ */ React7.createElement("select", { value: this.state.addActionType, onChange: (e) => this.setState({ addActionType: e.currentTarget.value }) }, /* @__PURE__ */ React7.createElement("option", { value: "location" }, "Location"), /* @__PURE__ */ React7.createElement("option", { value: "scale" }, "Scale"), /* @__PURE__ */ React7.createElement("option", { value: "anim" }, "Anim"), /* @__PURE__ */ React7.createElement("option", { value: "delay" }, "Delay"), /* @__PURE__ */ React7.createElement("option", { value: "visibility" }, "Visibility")), /* @__PURE__ */ React7.createElement("select", { disabled: this.state.addActionType == "delay", value: this.state.addActionType == "delay" ? -1 : this.state.addActionTarget, onChange: (e) => this.setState({ addActionTarget: +e.currentTarget.value }) }, Object.entries(this.state.components).map(([key, c]) => /* @__PURE__ */ React7.createElement("option", { key, value: key }, c.name)), this.state.addActionType == "delay" && /* @__PURE__ */ React7.createElement("option", { value: "-1" })), /* @__PURE__ */ React7.createElement("input", { type: "button", className: "sub-btn", value: "add", onClick: this.addAction })), /* @__PURE__ */ React7.createElement("div", { onClick: this.restartAnims }, "restart"), this.state.actions.length != 0 && /* @__PURE__ */ React7.createElement("br", null), this.state.actions.length != 0 && /* @__PURE__ */ React7.createElement("div", { className: "mv-inset" }, this.state.actions.map((a, i) => {
      let comp = this.state.components[a.target];
      return /* @__PURE__ */ React7.createElement(ScenarioActionControl, { key: i, comp, action: a, onChange: (e) => this.editAction(i, e) });
    }))));
  }
};
__decorateClass([
  boundMethod5
], SceneScenario.prototype, "addComp", 1);
__decorateClass([
  boundMethod5
], SceneScenario.prototype, "addAction", 1);
__decorateClass([
  boundMethod5
], SceneScenario.prototype, "getSceneJson", 1);
__decorateClass([
  boundMethod5
], SceneScenario.prototype, "updateGrids", 1);
__decorateClass([
  boundMethod5
], SceneScenario.prototype, "restartAnims", 1);
__decorateClass([
  boundMethod5
], SceneScenario.prototype, "advancedIdSelect", 1);
function hsl2hex(hsl) {
  let rgb = HSL2RGB(packedHSL2HSL(hsl));
  return `#${(rgb[0] << 16 | rgb[1] << 8 | rgb[2] << 0).toString(16).padStart(6, "0")}`;
}
function hex2hsl(hex) {
  let n = parseInt(hex.replace(/^#/, ""), 16);
  return HSL2packHSL(...RGB2HSL(n >> 16 & 255, n >> 8 & 255, n >> 0 & 255));
}
function updateItemCamera(cam, imgwidth, imgheight, centery, params) {
  const defaultcamdist = 16;
  cam.fov = Math.atan(1 / 32) / (Math.PI / 180) * 2;
  cam.aspect = imgwidth / imgheight;
  cam.updateProjectionMatrix();
  let rot = new Quaternion5().setFromEuler(new Euler3(
    -params.rotx / 2048 * 2 * Math.PI,
    params.roty / 2048 * 2 * Math.PI,
    -params.rotz / 2048 * 2 * Math.PI,
    "ZYX"
  ));
  let pos = new Vector311(
    6,
    //no clue where the 6 comes from
    0,
    4 * -params.zoom
  );
  let quatx = new Quaternion5().setFromAxisAngle(new Vector311(1, 0, 0), params.rotx / 2048 * 2 * Math.PI);
  let quaty = new Quaternion5().setFromAxisAngle(new Vector311(0, 1, 0), -params.roty / 2048 * 2 * Math.PI);
  let quatz = new Quaternion5().setFromAxisAngle(new Vector311(0, 0, 1), -params.rotz / 2048 * 2 * Math.PI);
  pos.applyQuaternion(quatx);
  pos.add(new Vector311(
    -params.translatex * 4,
    params.translatey * 4,
    -params.translatey * 4
    //yep this is y not z, i don't fucking know
  ));
  pos.applyQuaternion(quaty);
  pos.applyQuaternion(quatz);
  pos.y += centery;
  pos.divideScalar(512);
  pos.z = -pos.z;
  cam.position.copy(pos);
  cam.quaternion.copy(rot);
  cam.updateProjectionMatrix();
  cam.updateMatrixWorld(true);
  return cam;
}
var SceneMapModel = class extends React7.Component {
  constructor(p) {
    super(p);
    this.selectCleanup = [];
    this.state = {
      chunkgroups: [],
      center: { x: 0, z: 0 },
      toggles: /* @__PURE__ */ Object.create(null),
      selectionData: void 0,
      versions: [],
      extramodels: false
    };
  }
  clear() {
    this.selectCleanup.forEach((q) => q());
    this.state.chunkgroups.forEach((q) => q.models.forEach((q2) => q2.cleanup()));
    this.setState({ chunkgroups: [], toggles: /* @__PURE__ */ Object.create(null) });
  }
  viewmap() {
    showModal({ title: "Map view" }, /* @__PURE__ */ React7.createElement(Map2dView, { chunks: this.state.chunkgroups.map((q) => q.models.get(this.props.ctx.sceneCache)).filter((q) => q), gridsize: 512, mapscenes: true }));
  }
  async diffCaches(floora = 3, floorb = 3) {
    let group = this.state.chunkgroups[0];
    if (!this.props.ctx || !group) {
      return;
    }
    let arr = [...group.models.entries()];
    if (arr.length != 1 && arr.length != 2) {
      console.log("//TODO can currenly only diff with 1 or 2 caches loaded");
      return;
    }
    let [entrya, entryb] = arr.length == 1 ? [arr[0], arr[0]] : arr;
    let chunka = await entrya[1].chunkdata;
    let chunkb = await entryb[1].chunkdata;
    let cachea = entrya[0];
    let cacheb = entryb[0];
    if (!chunka.chunk || !chunkb.chunk) {
      throw new Error("unexpected");
    }
    let depsa = await cachea.engine.getDependencyGraph();
    depsa.insertMapChunk(chunka.chunk);
    let depsb = await cacheb.engine.getDependencyGraph();
    depsb.insertMapChunk(chunkb.chunk);
    let floordepsa = mapsquareFloorDependencies(chunka.grid, depsa, chunka.chunk);
    let locdepsa = mapsquareLocDependencies(chunka.grid, depsa, chunka.modeldata, chunka.chunk.mapsquarex, chunka.chunk.mapsquarez);
    let floordepsb = mapsquareFloorDependencies(chunkb.grid, depsb, chunkb.chunk);
    let locdepsb = mapsquareLocDependencies(chunkb.grid, depsb, chunkb.modeldata, chunkb.chunk.mapsquarex, chunkb.chunk.mapsquarez);
    let floordifs = compareFloorDependencies(floordepsa, floordepsb, floora, floorb);
    let locdifs = compareLocDependencies(locdepsa, locdepsb, floora, floorb);
    let floordifmesh = await mapdiffmesh(globalThis.sceneCache, floordifs, [255, 0, 0]);
    let locdifmesh = await mapdiffmesh(globalThis.sceneCache, locdifs, [0, 255, 0]);
    let diffgroup = {
      a: cachea,
      b: cacheb,
      info: {
        floordepsa,
        floordepsb,
        locdepsa,
        locdepsb
      },
      floora,
      floorb,
      visible: true,
      floormesh: {
        getSceneElements() {
          return { modelnode: !diffgroup.visible ? void 0 : floordifmesh };
        }
      },
      locsmesh: {
        getSceneElements() {
          return { modelnode: !diffgroup.visible ? void 0 : locdifmesh };
        }
      },
      remove: () => {
        group.diffs = group.diffs.filter((q) => q != diffgroup);
        this.props.ctx?.renderer.removeSceneElement(diffgroup.floormesh);
        this.props.ctx?.renderer.removeSceneElement(diffgroup.locsmesh);
        this.forceUpdate();
      }
    };
    this.props.ctx.renderer.addSceneElement(diffgroup.floormesh);
    this.props.ctx.renderer.addSceneElement(diffgroup.locsmesh);
    group.diffs.push(diffgroup);
    this.forceUpdate();
  }
  async meshSelected(e) {
    this.selectCleanup.forEach((q) => q());
    let selectionData = void 0;
    if (e) {
      this.selectCleanup = highlightModelGroup(e.vertexgroups);
      let meshdata = e.meshdata;
      if (meshdata.modeltype == "locationgroup") {
        let typedmatch = e.match;
        if (typedmatch.modeltype == "location") {
          selectionData = typedmatch;
        }
      }
      if (meshdata.modeltype == "floor") {
        let typedmatch = e.match;
        selectionData = {
          ...e.meshdata,
          x: typedmatch.x,
          z: typedmatch.z,
          subobjects: void 0,
          //remove (near) circular ref from json
          subranges: void 0,
          tile: { ...typedmatch.tile, next01: void 0, next10: void 0, next11: void 0 },
          tilenxt: typedmatch.tilenxt,
          originalcolor: typedmatch.underlaycolor
        };
      }
    }
    ;
    this.setState({ selectionData });
    this.props.ctx?.renderer.forceFrame();
  }
  componentDidMount() {
    this.props.partial.renderer?.on("select", this.meshSelected);
  }
  componentWillUnmount() {
    this.clear();
    this.props.partial.renderer?.off("select", this.meshSelected);
  }
  async addChunk(chunkx, chunkz) {
    for (let version of this.state.versions) {
      this.loadChunk(chunkx, chunkz, version.cache);
    }
    this.fixVisibility();
  }
  loadChunk(chunkx, chunkz, sceneCache) {
    this.setState((prevstate) => {
      const renderer = this.props.ctx?.renderer;
      if (!sceneCache || !renderer) {
        return;
      }
      let chunk = RSMapChunk.create(sceneCache, chunkx, chunkz, { skybox: true, map2d: this.state.extramodels, hashboxes: this.state.extramodels, minimap: this.state.extramodels });
      chunk.on("changed", () => {
        let toggles = this.state.toggles;
        let changed = false;
        let groups = /* @__PURE__ */ new Set();
        chunk.rootnode.traverse((node) => {
          if (node.userData.modelgroup) {
            groups.add(node.userData.modelgroup);
          }
        });
        [...groups].sort((a, b) => a.localeCompare(b)).forEach((q) => {
          if (typeof toggles[q] != "boolean") {
            toggles[q] = !!q.match(/^(floor|objects)\d+/);
            changed = true;
          }
        });
        let match = this.state.versions.find((q) => q.cache == sceneCache);
        chunk.setToggles(toggles, match && !match.visible);
        if (changed) {
          this.setState({ toggles });
          this.fixVisibility(toggles);
        }
      });
      let center = prevstate.center;
      if (prevstate.chunkgroups.length == 0) {
        let chunksize = sceneCache.engine.classicData ? classicChunkSize : rs2ChunkSize;
        center = {
          x: (chunkx + 0.5) * chunksize * 512,
          z: (chunkz + 0.5) * chunksize * 512
        };
      }
      let combined = chunk.rootnode;
      combined.position.add(new Vector311(-center.x, 0, -center.z));
      chunk.addToScene(renderer);
      let group = prevstate.chunkgroups.find((q) => q.chunkx == chunkx && q.chunkz == chunkz);
      let newstate = {};
      newstate.center = center;
      if (!group) {
        group = { chunkx, chunkz, models: /* @__PURE__ */ new Map(), diffs: [] };
        newstate.chunkgroups = [...prevstate.chunkgroups, group];
      }
      group.models.set(sceneCache, chunk);
      return newstate;
    });
  }
  onSubmit(searchtext) {
    localStorage.rsmv_lastsearch = JSON.stringify(searchtext);
    let rect = stringToMapArea(searchtext);
    if (!rect) {
      return;
    }
    for (let z = rect.z; z < rect.z + rect.zsize; z++) {
      for (let x = rect.x; x < rect.x + rect.xsize; x++) {
        this.addChunk(x, z);
      }
    }
  }
  fixVisibility(newtoggles = this.state.toggles) {
    this.state.chunkgroups.forEach((group) => group.models.forEach((q, key) => {
      let match = this.state.versions.find((q2) => q2.cache == key);
      q.setToggles(newtoggles, match && !match.visible);
    }));
  }
  setToggle(toggle, value) {
    this.setState((old) => {
      let newtoggles = /* @__PURE__ */ Object.create(null);
      for (let key in old.toggles) {
        newtoggles[key] = key == toggle ? value : old.toggles[key];
      }
      this.fixVisibility(newtoggles);
      return { toggles: newtoggles };
    });
  }
  selectSecondCache() {
    let onselect = async (source) => {
      frame.close();
      let cache = await openSavedCache(source, false);
      if (!cache) {
        return;
      }
      let engine = await EngineCache4.create(cache);
      let scene = await ThreejsSceneCache2.create(engine);
      for (let area of this.state.chunkgroups) {
        this.loadChunk(area.chunkx, area.chunkz, scene);
      }
      this.setState({ versions: [...this.state.versions, { cache: scene, visible: true }] });
    };
    let frame = showModal({ title: "Select a cache" }, /* @__PURE__ */ React7.createElement(CacheSelector, { onOpen: onselect, noReopen: true }));
  }
  removeCache(cache) {
    for (let group of this.state.chunkgroups) {
      let model = group.models.get(cache);
      if (!model) {
        continue;
      }
      this.props.ctx?.renderer.removeSceneElement(model);
    }
    this.setState({ versions: this.state.versions.filter((q) => q.cache != cache) });
  }
  toggleCache() {
    let currentindex = this.state.versions.findIndex((q) => q.visible);
    let newindex = (currentindex + 1) % this.state.versions.length;
    this.state.versions.forEach((q, i) => this.toggleVisible(q.cache, i == newindex));
  }
  toggleVisible(cache, visible) {
    let entry = this.state.versions.find((q) => q.cache == cache);
    if (!entry) {
      return;
    }
    entry.visible = visible;
    this.forceUpdate();
    this.fixVisibility();
  }
  static getDerivedStateFromProps(props, state) {
    if (props.ctx && !state.versions.find((q) => q.cache == props.ctx?.sceneCache)) {
      return { versions: [{ cache: props.ctx.sceneCache, visible: true }, ...state.versions] };
    }
    return null;
  }
  render() {
    this.props.ctx?.renderer.forceFrame();
    let toggles = {};
    for (let toggle of Object.keys(this.state.toggles)) {
      let m = toggle.match(/^(\D+?)(\d.*)?$/);
      if (!m) {
        throw new Error("???");
      }
      toggles[m[1]] = toggles[m[1]] ?? [];
      toggles[m[1]].push(m[2] ?? "");
    }
    let xmin = Infinity, xmax = -Infinity;
    let zmin = Infinity, zmax = -Infinity;
    for (let chunk of this.state.chunkgroups) {
      xmin = Math.min(xmin, chunk.chunkx);
      xmax = Math.max(xmax, chunk.chunkx + 1);
      zmin = Math.min(zmin, chunk.chunkz);
      zmax = Math.max(zmax, chunk.chunkz + 1);
    }
    let xsize = xmax - xmin + 2;
    let zsize = zmax - zmin + 2;
    xmin--;
    zmin--;
    let addgrid = [];
    for (let x = xmin; x < xmin + xsize; x++) {
      for (let z = zmin; z < zmin + zsize; z++) {
        let style = {
          gridColumn: "" + (x - xmin + 1),
          gridRow: "" + (zmin + zsize - z),
          border: "1px solid rgba(255,255,255,0.2)"
        };
        addgrid.push(/* @__PURE__ */ React7.createElement("div", { key: `${x}-${z}`, onClick: () => this.addChunk(x, z), style }));
      }
    }
    let initid = typeof this.props.initialId == "string" ? this.props.initialId : "50,50,1,1";
    let skysettings = this.state.chunkgroups.reduceRight((a, q) => a ?? q.models.get(this.props.ctx.sceneCache)?.loaded?.sky, void 0);
    return /* @__PURE__ */ React7.createElement(React7.Fragment, null, this.state.chunkgroups.length == 0 && /* @__PURE__ */ React7.createElement(React7.Fragment, null, /* @__PURE__ */ React7.createElement(StringInput2, { onChange: this.onSubmit, initialid: initid }), /* @__PURE__ */ React7.createElement("label", null, /* @__PURE__ */ React7.createElement("input", { type: "checkbox", checked: this.state.extramodels, onChange: (e) => this.setState({ extramodels: e.currentTarget.checked }) }), "Load extra modes"), /* @__PURE__ */ React7.createElement("p", null, "Input format: x,z[,xsize=1,[zsize=xsize]]"), /* @__PURE__ */ React7.createElement("p", null, "Coordinates are in so-called mapsquare coordinates, each mapsquare is 64x64 tiles in size. The entire RuneScape map is laid out in one plane and is 100x200 mapsquares in size.")), this.state.chunkgroups.length != 0 && /* @__PURE__ */ React7.createElement("div", { className: "mv-sidebar-scroll" }, /* @__PURE__ */ React7.createElement(Map2dView, { chunks: this.state.chunkgroups.map((q) => q.models.get(this.props.ctx.sceneCache)).filter((q) => q), addArea: this.addChunk, gridsize: 40, mapscenes: false }), /* @__PURE__ */ React7.createElement("input", { type: "button", className: "sub-btn", onClick: this.clear, value: "Clear" }), /* @__PURE__ */ React7.createElement("input", { type: "button", className: "sub-btn", onClick: this.viewmap, value: "View Map" }), /* @__PURE__ */ React7.createElement("input", { type: "button", className: "sub-btn", value: "Add other version", onClick: this.selectSecondCache }), skysettings && /* @__PURE__ */ React7.createElement("div", null, "Skybox model: ", /* @__PURE__ */ React7.createElement("span", { className: "mv-copy-text" }, skysettings.skyboxModelid), ", fog: ", /* @__PURE__ */ React7.createElement("span", { className: "mv-copy-text" }, skysettings.fogColor[0], ",", skysettings.fogColor[1], ",", skysettings.fogColor[2])), /* @__PURE__ */ React7.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(5,max-content)" } }, Object.entries(toggles).map(([base, subs]) => {
      let all = true;
      let none = true;
      subs.forEach((s) => {
        let v = this.state.toggles[base + s];
        all &&= v;
        none &&= !v;
      });
      return /* @__PURE__ */ React7.createElement(React7.Fragment, { key: base }, /* @__PURE__ */ React7.createElement("label", { style: { gridColumn: 1 } }, /* @__PURE__ */ React7.createElement("input", { type: "checkbox", checked: all, onChange: (e) => subs.forEach((s) => this.setToggle(base + s, e.currentTarget.checked)), ref: (v) => v && (v.indeterminate = !all && !none) }), base), subs.map((sub, i) => {
        let name = base + sub;
        let value = this.state.toggles[name];
        return /* @__PURE__ */ React7.createElement("label", { key: sub, style: { gridColumn: 2 + i } }, /* @__PURE__ */ React7.createElement("input", { type: "checkbox", checked: value, onChange: (e) => this.setToggle(name, e.currentTarget.checked) }), sub);
      }));
    })), (this.state.versions.length > 1 || !this.state.versions[0].visible) && "Versions", (this.state.versions.length > 1 || !this.state.versions[0].visible) && this.state.versions.map((q, i) => /* @__PURE__ */ React7.createElement("div", { key: i, style: { clear: "both" } }, /* @__PURE__ */ React7.createElement("label", { title: q.cache.engine.getCacheMeta().descr }, /* @__PURE__ */ React7.createElement("input", { type: "checkbox", checked: q.visible, onChange: (e) => this.toggleVisible(q.cache, e.currentTarget.checked) }), q.cache.engine.getCacheMeta().name), /* @__PURE__ */ React7.createElement("input", { type: "button", className: "sub-btn", value: "x", style: { float: "right" }, onClick: (e) => this.removeCache(q.cache) }))), this.state.versions.length > 1 && /* @__PURE__ */ React7.createElement("input", { type: "button", className: "sub-btn", value: "Toggle", onClick: this.toggleCache }), this.state.chunkgroups.flatMap((group, groupi) => group.diffs.map((diff, i) => {
      let metaa = diff.a.engine.getCacheMeta();
      let metab = diff.a == diff.b ? metaa : diff.b.engine.getCacheMeta();
      return /* @__PURE__ */ React7.createElement("div", { key: groupi + "-" + i, style: { clear: "both" } }, /* @__PURE__ */ React7.createElement("label", { title: diff.a == diff.b ? metaa.descr : `cache a:${metaa.descr}

${metab.descr}` }, /* @__PURE__ */ React7.createElement("input", { type: "checkbox", checked: diff.visible, onChange: (e) => {
        diff.visible = e.currentTarget.checked;
        this.props.ctx?.renderer.sceneElementsChanged();
        this.forceUpdate();
      } }), diff.a.engine.getBuildNr(), ", floor: ", diff.floora, "-", diff.b.engine.getBuildNr(), ", floor: ", diff.floorb), /* @__PURE__ */ React7.createElement("input", { type: "button", className: "sub-btn", onClick: diff.remove, style: { float: "right" }, value: "x" }));
    })), /* @__PURE__ */ React7.createElement(JsonDisplay, { obj: this.state.selectionData })));
  }
};
__decorateClass([
  boundMethod5
], SceneMapModel.prototype, "clear", 1);
__decorateClass([
  boundMethod5
], SceneMapModel.prototype, "viewmap", 1);
__decorateClass([
  boundMethod5
], SceneMapModel.prototype, "meshSelected", 1);
__decorateClass([
  boundMethod5
], SceneMapModel.prototype, "addChunk", 1);
__decorateClass([
  boundMethod5
], SceneMapModel.prototype, "onSubmit", 1);
__decorateClass([
  boundMethod5
], SceneMapModel.prototype, "selectSecondCache", 1);
__decorateClass([
  boundMethod5
], SceneMapModel.prototype, "toggleCache", 1);
var Map2dView = class extends React7.Component {
  constructor(p) {
    super(p);
    this.state = {
      cache: /* @__PURE__ */ new Map()
    };
  }
  render() {
    let xmin = Infinity, xmax = -Infinity;
    let zmin = Infinity, zmax = -Infinity;
    for (let chunk of this.props.chunks) {
      xmin = Math.min(xmin, chunk.chunkx);
      xmax = Math.max(xmax, chunk.chunkx + 1);
      zmin = Math.min(zmin, chunk.chunkz);
      zmax = Math.max(zmax, chunk.chunkz + 1);
    }
    let xsize = xmax - xmin + 2;
    let zsize = zmax - zmin + 2;
    xmin--;
    zmin--;
    let addgrid = [];
    for (let x = xmin; x < xmin + xsize; x++) {
      for (let z = zmin; z < zmin + zsize; z++) {
        let style = {
          gridColumn: "" + (x - xmin + 1),
          gridRow: "" + (zmin + zsize - z),
          border: "1px solid rgba(255,255,255,0.2)"
        };
        addgrid.push(/* @__PURE__ */ React7.createElement("div", { key: `${x}-${z}`, onClick: () => this.props.addArea?.(x, z), style }));
      }
    }
    let gridsize = this.props.gridsize;
    let pad = 20;
    return /* @__PURE__ */ React7.createElement("div", { className: "map-grid-container" }, /* @__PURE__ */ React7.createElement("div", { className: "map-grid-root", style: { gridTemplateColumns: `${pad}px repeat(${xsize - 2},${gridsize}px) ${pad}px`, gridTemplateRows: `${pad}px repeat(${zsize - 2},${gridsize}px) ${pad}px` } }, this.props.chunks.flatMap((chunk, i) => {
      let style = {
        gridColumn: `${chunk.chunkx - xmin + 1}/span ${1}`,
        gridRow: `${zsize - (chunk.chunkz - zmin)}/span ${1}`
      };
      let cached = this.state.cache.get(chunk);
      if (cached?.src) {
        style.backgroundImage = cached.src;
      } else if (!cached) {
        let prom = chunk.renderSvg(0, false);
        cached = { render: prom, src: null };
        this.state.cache.set(chunk, cached);
        prom.then((svg) => {
          cached.src = `url("data:image/svg+xml;base64,${btoa(svg)}")`;
          this.forceUpdate();
        });
      }
      addgrid[(chunk.chunkx - xmin) * zsize + (chunk.chunkz - zmin)] = null;
      return /* @__PURE__ */ React7.createElement("div", { key: i, className: classNames3("map-grid-area", { "map-grid-area-loading": !cached?.src }), style }, chunk.chunkx, ",", chunk.chunkz);
    }), addgrid));
  }
};

// rsmv/src/viewer/threejsrender.ts
globalThis.THREE = THREE6;
globalThis.logclicks = false;
globalThis.speed = 100;
function compatRequestAnimationFrame(cb) {
  if (typeof requestAnimationFrame != "undefined") {
    return requestAnimationFrame(cb);
  } else {
    return +setTimeout(cb, 50, Date.now() + 50);
  }
}
function compatCancelAnimationFrame(id) {
  if (typeof cancelAnimationFrame != "undefined") {
    return cancelAnimationFrame(id);
  } else {
    return +clearTimeout(id);
  }
}
var ThreeJsRenderer = class extends TypedEmitter {
  constructor(canvas, params) {
    super();
    this.skybox = null;
    this.queuedFrameId = 0;
    this.autoFrameMode = "forced";
    this.contextLossCount = 0;
    this.contextLossCountLastRender = 0;
    this.clock = new Clock2(true);
    this.sceneElements = /* @__PURE__ */ new Set();
    this.animationCallbacks = /* @__PURE__ */ new Set();
    this.vr360cam = null;
    this.forceAspectRatio = null;
    this.camMode = "standard";
    this.itemcam = new THREE6.PerspectiveCamera();
    globalThis.render = this;
    this.canvas = canvas;
    this.renderer = new THREE6.WebGLRenderer({
      canvas,
      alpha: true,
      powerPreference: "high-performance",
      antialias: true,
      preserveDrawingBuffer: true,
      ...params
    });
    const renderer = this.renderer;
    canvas.addEventListener("webglcontextlost", () => this.contextLossCount++);
    canvas.onmousedown = this.mousedown;
    this.camera = new THREE6.PerspectiveCamera(45, 2, 0.1, 1e3);
    this.camera.position.set(0, 10, 20);
    this.standardControls = new OrbitControls(this.camera, canvas);
    this.standardControls.target.set(0, 5, 0);
    this.standardControls.update();
    this.standardControls.addEventListener("change", this.forceFrame);
    this.topdowncam = new SkewOrthographicCamera(10, 0, 0);
    this.topdowncam.position.copy(this.camera.position);
    this.orthoControls = new OrbitControls(this.topdowncam, canvas);
    this.orthoControls.target.set(0, 5, 0);
    this.orthoControls.screenSpacePanning = false;
    this.orthoControls.update();
    this.orthoControls.addEventListener("change", this.forceFrame);
    const scene = new THREE6.Scene();
    this.scene = scene;
    scene.add(this.camera);
    scene.add(this.topdowncam);
    renderer.useLegacyLights = false;
    renderer.outputColorSpace = THREE6.SRGBColorSpace;
    const planeSize = 11;
    let floortex = makeImageData(new Uint8ClampedArray([
      128,
      128,
      128,
      255,
      192,
      192,
      192,
      255,
      192,
      192,
      192,
      255,
      128,
      128,
      128,
      255
    ]), 2, 2);
    const texture = new Texture5(floortex);
    texture.needsUpdate = true;
    texture.wrapS = THREE6.RepeatWrapping;
    texture.wrapT = THREE6.RepeatWrapping;
    texture.magFilter = THREE6.NearestFilter;
    const repeats = planeSize / 2;
    texture.repeat.set(repeats, repeats);
    const planeGeo = new THREE6.PlaneGeometry(planeSize, planeSize);
    const planeMat = new THREE6.MeshPhongMaterial({ map: texture, side: THREE6.DoubleSide });
    const floormesh = new THREE6.Mesh(planeGeo, planeMat);
    floormesh.rotation.x = Math.PI * -0.5;
    floormesh.position.y = -0.01;
    scene.add(floormesh);
    this.floormesh = floormesh;
    this.modelnode = new THREE6.Group();
    this.modelnode.scale.set(1 / 512, 1 / 512, -1 / 512);
    this.scene.add(this.modelnode);
    this.standardLights = new Group5();
    let ambientlight = new THREE6.AmbientLight(16777215, 0.7);
    var dirLight = new THREE6.DirectionalLight(16777215);
    dirLight.position.set(75, 300, -75);
    let hemilight = new THREE6.HemisphereLight(16777215, 8947780);
    ambientlight.layers.enableAll();
    dirLight.layers.enableAll();
    hemilight.layers.enableAll();
    this.standardLights.add(ambientlight);
    this.standardLights.add(dirLight);
    this.standardLights.add(hemilight);
    scene.add(this.standardLights);
    this.scene.fog = new THREE6.Fog("#FFFFFF", 1e4, 1e4);
    this.sceneElementsChanged();
  }
  getCurrent2dCamera() {
    if (this.camMode == "standard") {
      return this.getStandardCamera();
    } else if (this.camMode == "item") {
      return this.getItemCamera();
    } else if (this.camMode == "topdown") {
      return this.getTopdownCamera();
    }
    return null;
  }
  getStandardCamera() {
    return this.camera;
  }
  getVr360Camera() {
    if (!this.vr360cam) {
      this.vr360cam = new VR360Render(this.renderer, 512, 0.1, 1e3);
      this.camera.add(this.vr360cam.cubeCamera);
    }
    return this.vr360cam;
  }
  getItemCamera() {
    return this.itemcam;
  }
  getTopdownCamera() {
    return this.topdowncam;
  }
  getModelNode() {
    return this.modelnode;
  }
  addSceneElement(el) {
    this.sceneElements.add(el);
    this.sceneElementsChanged();
  }
  removeSceneElement(el) {
    this.sceneElements.delete(el);
    this.sceneElementsChanged();
  }
  sceneElementsChanged() {
    let sky = null;
    let aspect = null;
    let cammode = "standard";
    let controls = "free";
    let hideFog = false;
    let showfloor = true;
    let autoframes = "auto";
    let nodeDeleteList = new Set(this.modelnode.children);
    this.animationCallbacks.clear();
    for (let source of this.sceneElements) {
      let elgroup = source.getSceneElements();
      if (!Array.isArray(elgroup)) {
        elgroup = [elgroup];
      }
      for (let el of elgroup) {
        if (el.sky) {
          sky = el.sky;
        }
        if (el.updateAnimation) {
          this.animationCallbacks.add(el.updateAnimation);
        }
        if (el.options?.hideFog) {
          hideFog = true;
        }
        if (el.options?.hideFloor) {
          showfloor = false;
        }
        if (el.options?.camMode) {
          cammode = el.options.camMode;
        }
        if (el.options?.camControls) {
          controls = el.options.camControls;
        }
        if (el.options?.aspect) {
          aspect = el.options.aspect;
        }
        if (el.options?.autoFrames) {
          autoframes = el.options.autoFrames;
        }
        if (el.modelnode) {
          nodeDeleteList.delete(el.modelnode);
          if (el.modelnode.parent != this.modelnode) {
            this.modelnode.add(el.modelnode);
          }
        }
      }
    }
    nodeDeleteList.forEach((q) => this.modelnode.remove(q));
    this.autoFrameMode = autoframes == "auto" ? this.animationCallbacks.size == 0 ? "forced" : "continuous" : autoframes;
    this.floormesh.visible = showfloor;
    if (this.camMode == "topdown" && cammode == "standard") {
      this.camera.position.copy(this.topdowncam.position);
      this.camera.rotation.copy(this.topdowncam.rotation);
      this.standardControls.update();
    }
    if (this.camMode == "standard" && cammode == "topdown") {
      this.topdowncam.position.copy(this.camera.position);
      this.topdowncam.rotation.copy(this.camera.rotation);
      this.orthoControls.update();
    }
    this.camMode = cammode;
    this.standardControls.enabled = this.camMode != "topdown";
    this.orthoControls.enabled = this.camMode == "topdown";
    this.standardControls.screenSpacePanning = controls == "free";
    this.orthoControls.screenSpacePanning = controls == "free";
    this.forceAspectRatio = aspect;
    let fogobj = this.scene.fog;
    if (sky?.fogColor) {
      fogobj.color.setRGB(sky.fogColor[0] / 255, sky.fogColor[1] / 255, sky.fogColor[2] / 255);
    } else {
      fogobj.color.setRGB(1, 1, 1);
    }
    if (!hideFog) {
      fogobj.far = 250;
      fogobj.near = 80;
    } else {
      fogobj.far = 1e5;
      fogobj.near = 1e5;
    }
    if (sky?.skybox) {
      let scene = this.skybox?.scene ?? new THREE6.Scene();
      let camera = this.skybox?.camera ?? new PerspectiveCamera3().copy(this.camera, false);
      let obj = new THREE6.Object3D();
      obj.scale.set(1 / 512, 1 / 512, -1 / 512);
      obj.add(sky.skybox);
      scene.clear();
      scene.add(obj, camera, new THREE6.AmbientLight(16777215));
      scene.background = sky.fogColor ? fogobj.color.clone() : null;
      this.skybox = { scene, camera };
    } else {
      this.skybox = null;
    }
    this.forceFrame();
  }
  resizeRendererToDisplaySize() {
    const canvas = this.renderer.domElement;
    if (!canvas.isConnected) {
      return;
    }
    let width = canvas.clientWidth;
    let height = canvas.clientHeight;
    if (this.forceAspectRatio) {
      height = Math.min(height, Math.floor(width / this.forceAspectRatio));
      width = Math.min(width, Math.floor(height * this.forceAspectRatio));
    }
    const needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      this.renderer.setSize(width, height, false);
      this.resizeViewToRendererSize();
    }
    return needResize;
  }
  resizeViewToRendererSize() {
    let rendertarget = this.renderer.getRenderTarget();
    let width = rendertarget?.width ?? this.canvas.width;
    let height = rendertarget?.height ?? this.canvas.height;
    let camscaling = width / height * (this.topdowncam.top - this.topdowncam.bottom) / (this.topdowncam.right - this.topdowncam.left);
    this.topdowncam.left *= camscaling;
    this.topdowncam.right *= camscaling;
    this.topdowncam.updateProjectionMatrix();
  }
  async guaranteeGlCalls(glfunction) {
    let waitContext = () => {
      if (!this.renderer.getContext().isContextLost()) {
        return;
      }
      console.log("frame stalled since context is lost");
      return new Promise((resolve3) => {
        this.renderer.domElement.addEventListener("webglcontextrestored", () => {
          console.log("context restored");
          setTimeout(resolve3, 1);
        }, { once: true });
      });
    };
    for (let retry = 0; retry < 5; retry++) {
      await waitContext();
      let prerenderlosses = this.contextLossCountLastRender;
      let res = await glfunction();
      await delay(1);
      if (this.renderer.getContext().isContextLost()) {
        console.log("lost context during render " + /* @__PURE__ */ new Date());
        continue;
      } else if (prerenderlosses != this.contextLossCount) {
        console.log("lost and regained context during render " + /* @__PURE__ */ new Date());
        continue;
      }
      return res;
    }
    throw new Error("Failed to render frame after 5 retries");
  }
  render(cam) {
    compatCancelAnimationFrame(this.queuedFrameId);
    this.queuedFrameId = 0;
    let delta = this.clock.getDelta();
    delta *= (globalThis.speed ?? 100) / 100;
    this.animationCallbacks.forEach((q) => q(delta, this.clock.elapsedTime));
    this.resizeRendererToDisplaySize();
    if (cam) {
      this.renderScene(cam);
    } else if (this.camMode == "vr360") {
      let cam2 = this.getVr360Camera();
      this.renderCube(cam2);
      this.renderer.clearColor();
      cam2.render(this.renderer);
    } else {
      this.renderScene(this.getCurrent2dCamera());
    }
    if (this.autoFrameMode == "continuous") {
      this.forceFrame();
    }
  }
  renderScene(cam) {
    let size = this.renderer.getRenderTarget() ?? this.renderer.getContext().canvas ?? this.canvas;
    let aspect = size.width / size.height;
    if (cam instanceof THREE6.PerspectiveCamera && cam.aspect != aspect) {
      cam.aspect = aspect;
      cam.updateProjectionMatrix();
    }
    let oldautoclear = this.renderer.autoClear;
    if (cam == this.camera && this.skybox) {
      this.skybox.camera.matrixAutoUpdate = false;
      this.camera.updateWorldMatrix(true, true);
      this.skybox.camera.matrix.copy(this.camera.matrixWorld);
      this.skybox.camera.matrix.setPosition(0, 0, 0);
      this.skybox.camera.projectionMatrix.copy(this.camera.projectionMatrix);
      this.renderer.render(this.skybox.scene, this.skybox.camera);
      this.renderer.clearDepth();
      this.renderer.autoClear = false;
    }
    this.renderer.render(this.scene, cam);
    this.renderer.autoClear = oldautoclear;
    this.contextLossCountLastRender = this.contextLossCount;
  }
  renderCube(render) {
    render.cubeRenderTarget.clear(this.renderer, true, true, false);
    if (this.skybox) {
      render.skyCubeCamera.matrixAutoUpdate = false;
      render.cubeCamera.updateWorldMatrix(true, true);
      render.skyCubeCamera.matrix.copy(render.cubeCamera.matrixWorld);
      render.skyCubeCamera.matrix.setPosition(0, 0, 0);
      render.skyCubeCamera.updateMatrixWorld(true);
      render.skyCubeCamera.update(this.renderer, this.skybox.scene);
      render.cubeRenderTarget.clear(this.renderer, false, true, false);
    }
    render.cubeCamera.update(this.renderer, this.scene);
  }
  forceFrame() {
    if (!this.queuedFrameId && this.autoFrameMode != "never") {
      this.queuedFrameId = compatRequestAnimationFrame(() => this.render());
    }
  }
  async takeScenePicture(width = this.canvas.width, height = this.canvas.height) {
    let rendertarget = null;
    if (width != this.canvas.width || height != this.canvas.height) {
      let gl = this.renderer.getContext();
      rendertarget = new THREE6.WebGLRenderTarget(width, height, {
        minFilter: THREE6.LinearFilter,
        magFilter: THREE6.LinearFilter,
        format: THREE6.RGBAFormat,
        colorSpace: this.camMode != "vr360" ? this.renderer.outputColorSpace : THREE6.LinearSRGBColorSpace,
        samples: gl.getParameter(gl.SAMPLES)
      });
    }
    return this.guaranteeGlCalls(() => {
      let oldtarget = this.renderer.getRenderTarget();
      this.renderer.setRenderTarget(rendertarget);
      this.resizeViewToRendererSize();
      if (this.camMode != "vr360") {
        let cam = this.getCurrent2dCamera();
        this.renderScene(cam);
      } else {
        let vrcam = new VR360Render(this.renderer, width > 2e3 ? 2048 : 1024, 0.1, 1e3);
        this.camera.add(vrcam.cubeCamera);
        this.renderCube(vrcam);
        this.renderer.clearColor();
        vrcam.render(this.renderer);
        vrcam.cubeCamera.removeFromParent();
      }
      let pixels = this.getFrameBufferPixels();
      this.renderer.setRenderTarget(oldtarget);
      this.resizeViewToRendererSize();
      return pixels;
    });
  }
  getFrameBufferPixels() {
    let rendertarget = this.renderer.getRenderTarget();
    let width = rendertarget?.width ?? this.canvas.width;
    let height = rendertarget?.height ?? this.canvas.height;
    let buf = new Uint8Array(width * height * 4);
    if (rendertarget) {
      this.renderer.readRenderTargetPixels(rendertarget, 0, 0, width, height, buf);
      rendertarget.dispose();
    } else {
      let gl = this.renderer.getContext();
      gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, buf);
    }
    let r = makeImageData(buf, width, height);
    flipImage(r);
    return r;
  }
  takeMapPicture(cam, framesizex = -1, framesizey = -1, linearcolor = false, highlight = null) {
    if (framesizex != -1 && framesizey != -1) {
      this.renderer.setSize(framesizex, framesizey);
    }
    return this.guaranteeGlCalls(() => {
      let opaqueBackground = !highlight;
      let oldcolorspace = this.renderer.outputColorSpace;
      this.renderer.outputColorSpace = linearcolor ? THREE6.LinearSRGBColorSpace : THREE6.SRGBColorSpace;
      this.renderer.setClearColor(new THREE6.Color(0, 0, 0), opaqueBackground ? 255 : 0);
      this.scene.background = opaqueBackground ? new THREE6.Color(0, 0, 0) : null;
      if (!highlight) {
        this.renderScene(cam);
      } else {
        this.renderer.clearDepth();
        this.renderer.clearColor();
        let old = cam.layers.mask;
        cam.layers.set(1);
        this.renderer.render(this.scene, cam);
        cam.layers.mask = old;
      }
      let img = this.getFrameBufferPixels();
      this.renderer.outputColorSpace = oldcolorspace;
      this.renderer.setClearColor(new THREE6.Color(0, 0, 0), 0);
      this.scene.background = null;
      return img;
    });
  }
  setCameraPosition(pos) {
    this.camera.position.copy(pos);
  }
  setCameraLimits(target) {
    if (!target) {
      const box = new THREE6.Box3().setFromObject(this.modelnode);
      const boxSize = box.getSize(new THREE6.Vector3()).length();
      target = box.getCenter(new THREE6.Vector3());
    }
    this.standardControls.target.copy(target);
    this.standardControls.update();
    this.standardControls.screenSpacePanning = true;
  }
  async mousedown(e) {
    let x1 = e.screenX;
    let y1 = e.screenY;
    let cnvx = e.clientX;
    let cnvy = e.clientY;
    let onup = (e2) => {
      let d = Math.abs(e2.screenX - x1) + Math.abs(e2.screenY - y1);
      if (d < 10) {
        this.click(cnvx, cnvy);
      }
      e2.preventDefault();
    };
    window.addEventListener("mouseup", onup, { once: true });
  }
  async click(cnvx, cnvy) {
    let raycaster = new THREE6.Raycaster();
    let cnvrect = this.canvas.getBoundingClientRect();
    let mousepos = new THREE6.Vector2(
      (cnvx - cnvrect.x) / cnvrect.width * 2 - 1,
      -(cnvy - cnvrect.y) / cnvrect.height * 2 + 1
    );
    let currentcam = this.camMode == "standard" ? this.getStandardCamera() : this.camMode == "topdown" ? this.getTopdownCamera() : null;
    if (!currentcam) {
      return;
    }
    raycaster.setFromCamera(mousepos, currentcam);
    let intersects = raycaster.intersectObjects(this.scene.children);
    let firstloggable = true;
    for (let isct of intersects) {
      let obj = isct.object;
      if (!obj.visible) {
        continue;
      }
      let meshdata = obj.userData;
      if (firstloggable) {
        globalThis.model = isct.object;
        firstloggable = false;
        if (globalThis.logclicks) {
          if (isct.object instanceof Mesh9 && isct.object.geometry instanceof BufferGeometry8) {
            let indices = [isct.face.a, isct.face.b, isct.face.c];
            console.log("Click intersect");
            for (let [id, attr] of Object.entries(isct.object.geometry.attributes)) {
              let vals = [];
              for (let index of indices) {
                let val = [];
                vals.push(val);
                if (attr.itemSize >= 1) {
                  val.push(attr.getX(index));
                }
                if (attr.itemSize >= 2) {
                  val.push(attr.getY(index));
                }
                if (attr.itemSize >= 3) {
                  val.push(attr.getZ(index));
                }
                if (attr.itemSize >= 4) {
                  val.push(attr.getW(index));
                }
              }
              console.log(`${id} = ${vals.map((q) => `[${q.map((q2) => q2.toFixed(2)).join(",")}]`)}`);
            }
          }
        }
      }
      if (!(obj instanceof THREE6.Mesh) || !meshdata.isclickable) {
        continue;
      }
      let match = void 0;
      let endindex = obj.geometry.index?.count ?? obj.geometry.attributes.position.count;
      let startindex = 0;
      let clickindex = isct.faceIndex;
      if (typeof clickindex == "undefined") {
        throw new Error("???");
      }
      for (let i = 0; i < meshdata.subranges.length; i++) {
        if (clickindex * 3 < meshdata.subranges[i]) {
          endindex = meshdata.subranges[i];
          break;
        }
        startindex = meshdata.subranges[i];
        match = meshdata.subobjects[i];
      }
      if (!match) {
        continue;
      }
      let matches = [];
      if (!meshdata.searchPeers) {
        matches.push({ start: startindex, end: endindex, mesh: obj });
      } else {
        let root = obj;
        while (root.parent) {
          root = root.parent;
        }
        root.traverseVisible((obj2) => {
          let meshdata2 = obj2.userData;
          if (obj2 instanceof THREE6.Mesh && meshdata2.isclickable && meshdata2.searchPeers) {
            for (let i = 0; i < meshdata2.subobjects.length; i++) {
              if (meshdata2.subobjects[i] == match) {
                matches.push({
                  start: meshdata2.subranges[i],
                  end: meshdata2.subranges[i + 1] ?? obj2.geometry.index.count,
                  mesh: obj2
                });
              }
            }
          }
        });
      }
      this.emit("select", { obj, meshdata, match, vertexgroups: matches });
      return;
    }
    this.emit("select", null);
  }
  makeUIRenderer() {
    let scene = new THREE6.Scene();
    scene.add(new THREE6.AmbientLight(16777215, 0.7));
    let hemilight = new THREE6.HemisphereLight(16777215, 8947780);
    var dirLight = new THREE6.DirectionalLight(16777215);
    dirLight.position.set(75, 300, -75);
    let modelnode = new THREE6.Group();
    modelnode.scale.set(1 / 512, 1 / 512, -1 / 512);
    scene.add(dirLight);
    scene.add(hemilight);
    scene.add(modelnode);
    let clock = new THREE6.Clock();
    let rendertarget = null;
    let currentnode = null;
    let currentcentery = 0;
    let setmodel = (model, centery) => {
      if (currentnode?.modelnode) {
        modelnode.remove(currentnode.modelnode);
        currentnode = null;
      }
      if (model?.modelnode) {
        modelnode.add(model.modelnode);
        currentnode = model;
      }
      currentcentery = centery;
    };
    let takePicture = (width, height, params) => {
      let gl = this.renderer.getContext();
      if (!rendertarget || width != rendertarget.width || height != rendertarget.height) {
        rendertarget?.dispose();
        rendertarget = new THREE6.WebGLRenderTarget(width, height, {
          minFilter: THREE6.LinearFilter,
          magFilter: THREE6.LinearFilter,
          format: THREE6.RGBAFormat,
          colorSpace: this.renderer.outputColorSpace,
          samples: gl.getParameter(gl.SAMPLES)
        });
      }
      let delta = clock.getDelta();
      currentnode?.updateAnimation?.(delta, clock.elapsedTime);
      let oldtarget = this.renderer.getRenderTarget();
      this.renderer.setRenderTarget(rendertarget);
      let itemcam = new THREE6.PerspectiveCamera();
      updateItemCamera(itemcam, width, height, currentcentery, params);
      this.renderer.clearColor();
      this.renderer.clearDepth();
      this.renderer.render(scene, itemcam);
      let img = this.getFrameBufferPixels();
      this.renderer.setRenderTarget(oldtarget);
      return img;
    };
    let dispose = () => rendertarget?.dispose();
    return { takePicture, dispose, setmodel };
  }
  dispose() {
    this.renderer.dispose();
    disposeThreeTree(this.scene);
  }
};
__decorateClass([
  boundMethod6
], ThreeJsRenderer.prototype, "guaranteeGlCalls", 1);
__decorateClass([
  boundMethod6
], ThreeJsRenderer.prototype, "render", 1);
__decorateClass([
  boundMethod6
], ThreeJsRenderer.prototype, "forceFrame", 1);
__decorateClass([
  boundMethod6
], ThreeJsRenderer.prototype, "mousedown", 1);
function disposeThreeTree(node) {
  if (!node) {
    return;
  }
  const cleanMaterial = (material) => {
    count++;
    material.dispose();
    for (const key of Object.keys(material)) {
      const value = material[key];
      if (value && typeof value === "object" && "minFilter" in value) {
        value.dispose();
        count++;
      }
    }
  };
  let count = 0;
  node.traverse((object) => {
    if (!object.isMesh) return;
    count++;
    object.geometry.dispose();
    if (object.material.isMaterial) {
      cleanMaterial(object.material);
    } else {
      for (const material of object.material) {
        cleanMaterial(material);
      }
    }
  });
  console.log("disposed scene objects", count);
}
async function exportThreeJsGltf(node) {
  let exporter = new GLTFExporter();
  let anims = [];
  let undolist = [];
  let hiddenattributes = [
    "RA_skinIndex_bone",
    "RA_skinIndex_skin",
    "RA_skinWeight_bone",
    "RA_skinWeight_skin"
  ];
  node.traverseVisible((node2) => {
    if (node2.animations) {
      anims.push(...node2.animations.filter((q) => q.duration != 0));
    }
    if (node2 instanceof Mesh9 && node2.geometry instanceof BufferGeometry8) {
      let attributes = node2.geometry.attributes;
      let normal = node2.geometry.attributes.normal;
      if (normal && normal.array instanceof Int8Array) {
        let v = new Vector313();
        let cloned = new THREE6.BufferAttribute(new Float32Array(normal.count * 3), 3);
        for (let i = 0; i < normal.count; i++) {
          v.fromBufferAttribute(normal, i);
          v.normalize();
          cloned.setXYZ(i, v.x, v.y, v.z);
        }
        let oldnormal = attributes.normal;
        undolist.push(() => attributes.normal = oldnormal);
        node2.geometry.attributes.normal = cloned;
      }
      for (let attr of hiddenattributes) {
        if (attributes[attr]) {
          let attrname = attr;
          let oldval = attributes[attr];
          delete attributes[attr];
          undolist.push(() => attributes[attrname] = oldval);
        }
      }
    }
  });
  let res = await new Promise((resolve3, reject) => {
    exporter.parse(node, (gltf) => resolve3(gltf), reject, {
      binary: true,
      animations: anims
    });
  });
  undolist.forEach((q) => q());
  return res;
}
function exportThreeJsStl(node) {
  let exporter = new STLExporter();
  let res = exporter.parse(node, { binary: true });
  return Promise.resolve(new Uint8Array(res.buffer, res.byteOffset, res.byteLength));
}
function highlightModelGroup(vertexgroups) {
  let undos = [];
  for (let submatch of vertexgroups) {
    let color = submatch.mesh.geometry.getAttribute("color");
    if (!color) {
      continue;
    }
    let usecolor = submatch.mesh.geometry.getAttribute("color_2");
    let oldindices = [];
    let oldcols = [];
    let oldusecols = [];
    for (let i = submatch.start; i < submatch.end; i++) {
      let index = submatch.mesh.geometry.index?.getX(i) ?? i;
      oldindices.push(index);
      oldcols.push([color.getX(index), color.getY(index), color.getZ(index)]);
      if (usecolor) {
        oldusecols.push([usecolor.getX(index), usecolor.getY(index), usecolor.getZ(index), usecolor.getW(index)]);
      }
    }
    for (let i = submatch.start; i < submatch.end; i++) {
      let index = submatch.mesh.geometry.index?.getX(i) ?? i;
      oldindices.push(index);
      color.setXYZ(index, 1, 0, 0);
      if (usecolor) {
        usecolor.setXYZW(index, 1, 1, 1, 1);
      }
    }
    undos.push(() => {
      for (let i = submatch.start; i < submatch.end; i++) {
        let index = oldindices[i - submatch.start];
        color.setXYZ(index, ...oldcols[i - submatch.start]);
        color.needsUpdate = true;
        if (usecolor) {
          usecolor.setXYZW(index, ...oldusecols[i - submatch.start]);
          usecolor.needsUpdate = true;
        }
      }
    });
    color.needsUpdate = true;
    if (usecolor) {
      usecolor.needsUpdate = true;
    }
  }
  return undos;
}
export {
  ThreeJsRenderer,
  disposeThreeTree,
  exportThreeJsGltf,
  exportThreeJsStl,
  highlightModelGroup
};
//# sourceMappingURL=modelviewer.js.map
