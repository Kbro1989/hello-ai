{
  "version": 3,
  "sources": ["../../../src/constants.ts", "../../../src/rsmv/constants.ts", "../../../src/rsmv/opcode_reader.ts", "../../../src/rsmv/opdecoder.ts", "../../../src/index.ts", "../../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-VET5iV/middleware-insertion-facade.js", "../../../node_modules/wrangler/templates/middleware/common.ts", "../bundle-VET5iV/middleware-loader.entry.ts"],
  "sourceRoot": "C:\\Windows\\System32\\Pick-Of-Gods\\4.5claudecode\\hello-ai\\.wrangler\\tmp\\dev-VtCjBl",
  "sourcesContent": ["// src/constants.ts\n\n// -------------------------\n// Cloudflare Worker Bindings\n// -------------------------\nexport const KV_ASSETS = 'ASSETS';\nexport const KV_CACHE = 'CACHE_KV';\nexport const AI_BINDING = 'AI';\n\n// -------------------------\n// API Endpoints\n// -------------------------\nexport const API = {\n  GET_TYPEDEF: '/api/typedef',\n  GET_MODELS: '/api/models',\n  GET_MODEL_BY_ID: (id: string | number) => `/api/model/${id}`,\n  AI_SUGGEST_MATERIALS: '/ai/suggest-materials',\n  AI_SUGGEST_ANIMATION: '/ai/suggest-animation'\n};\n\n// -------------------------\n// Three.js Config\n// -------------------------\nexport const THREE_MODULE_URL = 'https://unpkg.com/three@0.158.0/build/three.module.js';\nexport const ORBIT_CONTROLS_URL = 'https://unpkg.com/three@0.158.0/examples/jsm/controls/OrbitControls.js';\n\n// -------------------------\n// KV Keys for data storage\n// -------------------------\nexport const KV_KEYS = {\n  TYPEDEF: 'typedef',\n  MODELS: 'models',\n  MODEL_OB3: (id: string | number) => `model_${id}.ob3`\n};\n\n// -------------------------\n// RSMV/OB3 Parser Config\n// -------------------------\nexport const PARSER_CONFIG = {\n  MAX_VERTICES: 200_000,\n  MAX_INDICES: 600_000\n};", "export const cacheMajors = {\n\tframemaps: 1,\n\tconfig: 2,\n\tinterfaces: 3,\n\tmapsquares: 5,\n\n\toldmodels: 7,\n\tsprites: 8,\n\tclientscript: 12,\n\tsounds: 14,\n\tobjects: 16,\n\tenums: 17,\n\tnpcs: 18,\n\titems: 19,\n\tsequences: 20,\n\tspotanims: 21,\n\tstructs: 22,\n\tquickchat: 24,\n\tmaterials: 26,\n\tparticles: 27,\n\tworldmap: 23,\n\tmusic: 40,\n\tmodels: 47,\n\tframes: 48,\n\n\ttexturesOldPng: 9,\n\ttexturesOldCompoundPng: 37,\n\n\ttextures2015Png: 43,\n\ttextures2015CompoundPng: 44,\n\ttextures2015Dds: 45,\n\ttextures2015CompoundPngMips: 46,\n\ttextures2015CompoundDds: 50,\n\ttextures2015PngMips: 51,\n\n\ttexturesDds: 52,\n\ttexturesPng: 53,\n\ttexturesBmp: 54,\n\ttexturesKtx: 55,\n\n\tskeletalAnims: 56,\n\n\tachievements: 57,\n\tcutscenes: 66,\n\n\tindex: 255\n} as const;\n\n//represents the largest build number that this application is aware off\n//is used as default value when a cache is considered \"current\"\n//only needs to be updated when backward incompatible code paths are added\nexport const latestBuildNumber = 940;\n\nexport const cacheMapFiles = {\n\tlocations: 0,\n\tsquares: 3,\n\tsquaresWater: 4,\n\tsquare_nxt: 5,\n\tenv: 6\n} as const;\n\nexport const cacheConfigPages = {\n\tmapunderlays: 1,\n\tidentityKit: 3,\n\tmapoverlays: 4,\n\tparams: 11,\n\tenvironments: 29,\n\tanimgroups: 32,\n\tmapscenes: 34,\n\tmaplabels: 36,\n\tdbtables: 40,\n\tdbrows: 41,\n\n\tvarplayer: 60,\n\tvarnpc: 61,\n\tvarclient: 62,\n\tvarworld: 63,\n\tvarregion: 64,\n\tvarobject: 65,\n\tvarclan: 66,\n\tvarclansettings: 67,\n\tvarcampaign: 68,\n\tvarplayergroup: 75,\n\tvarbits: 69,\n\n\t//used before 488 (feb 2008)\n\tlocs_old: 6,\n\tnpcs_old: 9,\n\titems_old: 10,\n\tspotanim_old: 13\n} as const;\n\nexport const lastLegacyBuildnr = 377;\n//unclear if there ended up being overlap with (public) rs2 since this was 12 years after rs2 release\n//first known rs2 is 254\n//TODO apparently there was some overlap with rs2 beta caches which are technically not possible to support because of this\nexport const lastClassicBuildnr = 235;\n", "import { lastLegacyBuildnr } from \"./constants\";\nimport type * as jsonschema from \"json-schema\";\nimport type { ClientscriptObfuscation } from \"./clientscript/callibrator\";\n\nfunction hexToBytes(hex: string) {\n\tfor (var bytes = [], c = 0; c < hex.length; c += 2)\n\t\tbytes.push(parseInt(hex.substr(c, 2), 16));\n\treturn new Uint8Array(bytes);\n}\n\nfunction bytesToHex(bytes: Uint8Array) {\n\tfor (var hex = [], i = 0; i < bytes.length; i++) {\n\t\thex.push((bytes[i] >>> 4).toString(16));\n\t\thex.push((bytes[i] & 0xF).toString(16));\n\t}\n\treturn hex.join(\"\");\n}\n\nexport type TypeDef = { [name: string]: unknown };\n\nconst parserFunctions: Record<string, (args: unknown[], parent: ChunkParentCallback, typedef: TypeDef) => ChunkParser> = {};\nconst hardcodes: Record<string, (args: unknown[], parent: ChunkParentCallback, typedef: TypeDef) => ChunkParser> = {};\nconst parserPrimitives: Record<string, ChunkParser> = {};\n\nconst BufferTypes = {\n\tbuffer: { constr: Uint8Array },\n\thex: { constr: Uint8Array },//used to debug into json file\n\tbyte: { constr: Int8Array },\n\tubyte: { constr: Uint8Array },\n\tshort: { constr: Int16Array },\n\tushort: { constr: Uint16Array },\n\tint: { constr: Int32Array },\n\tuint: { constr: Uint32Array },\n\tfloat: { constr: Float32Array }\n};\n\nvar debugdata: null | {\n\trootstate: unknown,\n\topcodes: {\n\top: string,\n\t\tindex: number,\n\t\tstacksize: number,\n\t\tjump?: { to: number }\n\t}[]\n} = null;\n\nexport function getDebug(trigger: boolean) {\n\tlet ret = debugdata;\n\tdebugdata = trigger ? { rootstate: null, opcodes: [] } : null;\n\treturn ret;\n}\n\ntype SharedEncoderState = {\n\tisWrite: boolean,\n\tstack: object[],\n\thiddenstack: object[],\n\tscan: number,\n\tendoffset: number,\n\tbuffer: Uint8Array,\n\tdataView: DataView,\n\targs: Record<string, unknown>\n}\n\nexport type DecodeState = SharedEncoderState & { isWrite: false };\nexport type EncodeState = SharedEncoderState & { isWrite: true };\n\nexport type ResolvedReference = {\n\tstackdepth: number,\n\tresolve(v: unknown, oldvalue: number): number\n}\n\nexport type ChunkParser = {\n\tread(state: DecodeState): any,\n\twrite(state: EncodeState, v: unknown): void,\n\tgetTypescriptType(indent: string): string,\n\tgetJsonSchema(): jsonschema.JSONSchema6Definition,\n\treadConst?(state: SharedEncoderState): any\n}\n\ntype ChunkParentCallback = (prop: string, childresolve: ResolvedReference) => ResolvedReference;\n\nasync function resolveAlias(typename: string, parent: ChunkParentCallback, typedef: TypeDef): Promise<ChunkParser> {\n\tif (!Object.hasOwn(typedef, typename)) {\n\t\tthrow new Error(`Type '${typename}' not found in typedef.json`);\n\t}\n\tlet newtype = typedef[typename];\n\tif (typeof newtype != \"string\") {\n\t\t//TODO this recursion is unchecked\n\t\treturn await buildParser(parent, newtype, typedef);\n\t} else if (Object.hasOwn(parserPrimitives, newtype)) {\n\t\treturn parserPrimitives[newtype];\n\t} else {\n\t\treturn resolveAlias(newtype, parent, typedef);\n\t}\n}\n\nexport async function buildParser(parent: ChunkParentCallback | null, chunkdef: unknown, typedef: TypeDef): Promise<ChunkParser> {\n\tparent ??= () => { throw new Error(\"reference failed to resolve\"); };\n\tawait new Promise(resolve => queueMicrotask(resolve)); // Yield here\n\tswitch (typeof chunkdef) {\n\t\tcase \"boolean\":\n\t\tcase \"number\":\n\t\t\treturn literalValueParser(chunkdef);\n\t\tcase \"string\": {\n\t\t\tif (Object.hasOwn(parserPrimitives, chunkdef)) {\n\t\t\t\treturn parserPrimitives[chunkdef];\n\t\t\t} else {\n\t\t\t\treturn await resolveAlias(chunkdef, parent, typedef); // Await here\n\t\t\t}\n\t\t}\n\t\tcase \"object\":\n\t\t\tif (chunkdef == null) {\n\t\t\t\treturn literalValueParser(null);\n\t\t\t} else if (!Array.isArray(chunkdef)) {\n\t\t\t\treturn await opcodesParser(chunkdef, parent, typedef); // Await here\n\t\t\t} else {\n\t\t\t\tif (chunkdef.length < 1) throw new Error(`'read' variables must either be a valid type-defining string, an array of type-defining strings / objects, or a valid type-defining object: ${JSON.stringify(chunkdef)}`);\n\t\t\t\tlet args = chunkdef.slice(1);\n\t\t\t\tif (parserFunctions[chunkdef[0]]) {\n\t\t\t\t\treturn await parserFunctions[chunkdef[0]](args, parent, typedef); // Await here\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tthrow new Error(`'read' variables must either be a valid type-defining string, an array of type-defining strings / objects, or a valid type-defining object: ${JSON.stringify(chunkdef)}`);\n\t}\n}\n\nasync function opcodesParser(chunkdef: {}, parent: ChunkParentCallback, typedef: TypeDef) {\n\tlet r: ChunkParser = {\n\t\tasync read(state) { // Make read async\n\t\t\tlet r: Record<string, any> = {};\n\t\t\tlet hidden: any = { $opcode: 0 };\n\t\t\tstate.stack.push(r);\n\t\t\tstate.hiddenstack.push(hidden);\n\t\t\tif (debugdata && !debugdata.rootstate) { debugdata.rootstate = r; }\n\t\t\twhile (true) {\n\t\t\t\tawait new Promise(resolve => queueMicrotask(resolve)); // Yield here\n\t\t\t\tif (state.scan == state.endoffset) {\n\t\t\t\t\tif (!hasexplicitnull) {\n\t\t\t\t\t\t// throw new Error(\"ended reading opcode struct at end of file without 0x00 opcode\");\n\t\t\t\t\t\tconsole.log(\"ended reading opcode struct at end of file without 0x00 opcode\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tlet opt = opcodetype.read(state);\n\t\t\thidden.$opcode = opt;\n\t\t\tif (!hasexplicitnull && opt == 0) { break; }\n\t\t\tlet parser = map.get(opt);\n\t\t\tif (debugdata) {\n\t\t\t\tdebugdata.opcodes.push({ op: (parser ? parser.key as string : `_0x${opt.toString(16)}_`), index: state.scan - 1, stacksize: state.stack.length });\n\t\t\t}\n\t\t\tif (!parser) { throw new Error(\"unknown chunk 0x\" + opt.toString(16).toUpperCase()); }\n\t\t\tr[parser.key] = parser.parser.read(state);\n\t\t\t}\n\t\t\tstate.stack.pop();\n\t\t\tstate.hiddenstack.pop();\n\t\t\treturn r;\n\t\t},\n\t\twrite(state, value) {\n\t\t\tif (typeof value != \"object\" || !value) { throw new Error(\"oject expected\") }\n\t\t\tstate.stack.push(value);\n\t\t\tstate.hiddenstack.push({});\n\t\t\tfor (let key in value) {\n\t\t\t\tif (key.startsWith(\"$\")) { continue; }\n\t\t\t\tlet opt = opts[key];\n\t\t\t\tif (!opt) { throw new Error(\"unknown property \" + key); }\n\t\t\t\topcodetype.write(state, opt.op);\n\t\t\t\topt.parser.write(state, value[key]);\n\t\t\t}\n\t\t\tif (!hasexplicitnull) {\n\t\t\t\topcodetype.write(state, 0);\n\t\t\t}\n\t\t\tstate.stack.pop();\n\t\t\tstate.hiddenstack.pop();\n\t\t},\n\t\tgetTypescriptType(indent) {\n\t\t\tlet r = \"{\\n\";\n\t\t\tlet newindent = indent + \"\\t\";\n\t\t\tfor (let val of map.values()) {\n\t\t\t\tr += newindent + (val.key as string) + \"?: \" + val.parser.getTypescriptType(newindent) + \" | null\\n\";\n\t\t\t}\n\t\t\tr += indent + \"}\";\n\t\t\treturn r;\n\t\t},\n\t\tgetJsonSchema() {\n\t\t\treturn {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: Object.fromEntries([...map.values()]\n\t\t\t\t\t.filter(prop => !(prop.key as string).startsWith(\"$\"))\n\t\t\t\t\t.map((prop) => {\n\t\t\t\t\t\treturn [prop.key, { oneOf: [prop.parser.getJsonSchema(), { type: \"null\" }] }];\n\t\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n\n\tlet resolveReference = function (targetprop: string, name: string, childresolve: ResolvedReference) {\n\t\tlet result: ResolvedReference = {\n\t\t\tstackdepth: childresolve.stackdepth + 1,\n\t\t\tresolve(v, oldvalue) {\n\t\t\t\tif (typeof v != \"object\" || !v) { throw new Error(\"object expected\"); }\n\t\t\t\tlet res = v[targetprop!];\n\t\t\t\treturn childresolve.resolve(res, oldvalue);\n\t\t\t}\n\t\t};\n\t\tif (name == \"$opcode\" || Object.prototype.hasOwnProperty.call(opts, name)) {\n\t\t\trefs[name] ??= [];\n\t\t\trefs[name]!.push(result);\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn buildReference(name, parent, result);\n\t\t}\n\t}\n\tlet refs: Record<string, ResolvedReference[] | undefined> = {};\n\tlet opcodetype = await buildParser(null, (chunkdef[\"$opcode\"] ?? \"unsigned byte\"), typedef);\n\tlet opts: Record<string, { op: number, parser: ChunkParser }> = {};\n\tfor (let key in chunkdef) {\n\t\tawait new Promise(resolve => queueMicrotask(resolve)); // Yield here\n\t\tif (key.startsWith(\"$\")) { continue; }\n\t\tlet op = chunkdef[key];\n\t\tif (typeof op != \"object\" || !op) { throw new Error(\"op name expected\"); }\n\t\tlet opname = op[\"name\"];\n\t\tif (typeof opname != \"string\") { throw new Error(\"op name expected\"); }\n\t\tif (opts[opname]) { throw new Error(\"duplicate opcode key \" + opname); }\n\t\topts[opname] = {\n\t\t\top: parseInt(key),\n\t\t\tparser: await buildParser(resolveReference.bind(null, key), op[\"read\"], typedef)\n\t\t};\n\t}\n\n\tlet map = new Map<number, { key: string, parser: ChunkParser }>();\n\tfor (let key in opts) {\n\t\tlet opt = opts[key];\n\t\tmap.set(opt.op, { key: key, parser: opt.parser });\n\t}\n\tlet hasexplicitnull = !!map.get(0);\n\n\treturn r;\n}\n\nasync function tuppleParser(args: unknown[], parent: ChunkParentCallback, typedef: TypeDef) {\n\tlet r: ChunkParser = {\n\t\tread(state) {\n\t\t\tlet r: any[] = [];\n\t\t\tfor (let prop of props) {\n\t\t\t\tlet v = prop.read(state);\n\t\t\t\tr.push(v);\n\t\t\t}\n\t\t\treturn r;\n\t\t},\n\t\twrite(state, value) {\n\t\t\tif (!Array.isArray(value)) { throw new Error(\"array expected\"); }\n\t\t\tfor (let [i, prop] of props.entries()) {\n\t\t\t\tprop.write(state, value[i]);\n\t\t\t}\n\t\t},\n\t\tgetTypescriptType(indent) {\n\t\t\tlet r = \"[\\n\";\n\t\t\tlet newindent = indent + \"\\t\";\n\t\t\tfor (let prop of props) { r += newindent + prop.getTypescriptType(newindent) + \",\\n\"; } \n\t\t\tr += indent + \"]\";\n\t\t\treturn r;\n\t\t},\n\t\tgetJsonSchema() {\n\t\t\treturn {\n\t\t\t\ttype: \"array\",\n\t\t\t\titems: Object.entries(props).map(([k, v]: [string, ChunkParser]) => v.getJsonSchema()),\n\t\t\t\tminItems: Object.keys(props).length,\n\t\t\t\tmaxItems: Object.keys(props).length\n\t\t\t};\n\t\t}\n\t};\n\n\tconst resolveReference = function (index: number, name: string, child: ResolvedReference) {\n\t\treturn buildReference(name, parent, {\n\t\t\tstackdepth: child.stackdepth,\n\t\t\tresolve(v, old) {\n\t\t\t\tif (!Array.isArray(v)) { throw new Error(\"Array expected\"); }\n\t\t\t\treturn child.resolve(v[index], old)\n\t\t\t}\n\t\t})\n\t}\n\n\tlet props = await Promise.all(args.map(async (d, i) => {\n\t\tawait new Promise(resolve => queueMicrotask(resolve)); // Yield here\n\t\treturn await buildParser(resolveReference.bind(null, i), d, typedef);\n\t}));\n\treturn r;\n}\n\nexport function buildReference(name: string, container: ChunkParentCallback | null, startingpoint: ResolvedReference) {\n\tif (!container) { throw new Error(\"reference \" + name + \" could not be resolved\"); }\n\treturn container(name, startingpoint);\n}\n\nfunction refgetter(refparent: ChunkParentCallback | null, propname: string, resolve: (v: unknown, old: number) => number) {\n\tlet final = buildReference(propname, refparent, { stackdepth: 0, resolve });\n\tlet depth = final.stackdepth;\n\tlet hidden = propname.startsWith(\"$\");\n\treturn {\n\t\tread(state: SharedEncoderState) {\n\t\t\tlet stack = (hidden ? state.hiddenstack : state.stack);\n\t\t\treturn stack[stack.length - depth][propname];\n\t\t},\n\t\twrite(state: SharedEncoderState, newvalue: number) {\n\t\t\tif (state.isWrite && !hidden) { throw new Error(`can update ref values in write mode when they are hidden (prefixed with $) in ${propname}`); }\n\t\t\tlet stack = (hidden ? state.hiddenstack : state.stack);\n\t\t\tstack[stack.length - depth][propname] = newvalue;\n\t\t}\n\t}\n}\n\nasync function structParser(args: unknown[], parent: ChunkParentCallback, typedef: TypeDef) {\n\tlet refs: Record<string, ResolvedReference[] | undefined> = {};\n\tlet r: ChunkParser = {\n\t\tasync read(state) { // Make read async\n\t\t\tlet r = {};\n\t\t\tlet hidden = {};\n\t\t\tstate.stack.push(r);\n\t\t\tstate.hiddenstack.push(hidden);\n\t\t\tif (debugdata && !debugdata.rootstate) { debugdata.rootstate = r; }\n\t\t\tfor (let key of keys) {\n\t\t\t\tawait new Promise(resolve => queueMicrotask(resolve)); // Yield here\n\t\t\t\tif (debugdata) { debugdata.opcodes.push({ op: key, index: state.scan, stacksize: state.stack.length }); }\n\t\t\t\tlet v = props[key].read(state);\n\t\t\t\tif (v !== undefined) {\n\t\t\t\t\tif (key[0] == \"$\") {\n\t\t\t\t\t\thidden[key] = v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr[key] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstate.stack.pop();\n\t\t\tstate.hiddenstack.pop();\n\t\t\treturn r;\n\t\t},\n\t\twrite(state, value) {\n\t\t\tif (typeof value != \"object\" || !value) { throw new Error(\"object expected\"); }\n\t\t\tlet hiddenvalue = {};\n\t\t\tstate.stack.push(value);\n\t\t\tstate.hiddenstack.push(hiddenvalue);\n\t\t\tfor (let key of keys) {\n\t\t\t\tlet propvalue = value[key as string];\n\t\t\t\tlet prop = props[key];\n\n\t\t\t\tif (key.startsWith(\"$\")) {\n\t\t\t\t\tif (prop.readConst != undefined) {\n\t\t\t\t\t\tpropvalue = prop.readConst(state);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet refarray = refs[key];\n\t\t\t\t\t\tif (!refarray) { throw new Error(\"cannot write hidden values if they are not constant or not referenced\"); }\n\t\t\t\t\t\tpropvalue ??= 0;\n\t\t\t\t\t\tfor (let ref of refarray) {\n\t\t\t\t\t\t\tpropvalue = ref.resolve(value, propvalue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\thiddenvalue[key] = propvalue;\n\t\t\t\t}\n\t\t\t\tprop.write(state, propvalue);\n\t\t\t}\n\t\t\tstate.stack.pop();\n\t\t\tstate.hiddenstack.pop();\n\t\t},\n\t\tgetTypescriptType(indent) {\n\t\t\tlet r = \"{\\n\";\n\t\t\tlet newindent = indent + \"\\t\";\n\t\t\tfor (let key of keys) {\n\t\t\t\tif (key[0] == \"$\") { continue; }\n\t\t\t\tr += newindent + key + \": \" + props[key].getTypescriptType(newindent) + \",\\n\";\n\t\t\t}\n\t\t\tr += indent + \"}\";\n\t\t\treturn r;\n\t\t},\n\t\tgetJsonSchema() {\n\t\t\treturn {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: Object.fromEntries([...Object.entries(props)]\n\t\t\t\t\t.filter(([key]) => !key.startsWith(\"$\"))\n\t\t\t\t\t.map(([key, prop]) => [key, (prop as ChunkParser).getJsonSchema()])\n\t\t\t\t),\n\t\t\t\trequired: keys.filter(k => !k.startsWith(\"$\"))\n\t\t\t}\n\t\t}\n\t}\n\n\tlet resolveReference = function (targetprop: string, name: string, childresolve: ResolvedReference) {\n\t\tlet result: ResolvedReference = {\n\t\t\tstackdepth: childresolve.stackdepth + 1,\n\t\t\tresolve(v, oldvalue) {\n\t\t\t\tif (typeof v != \"object\" || !v) { throw new Error(\"object expected\"); }\n\t\t\t\tlet res = v[targetprop!];\n\t\t\t\treturn childresolve.resolve(res, oldvalue);\n\t\t\t}\n\t\t};\n\t\tif (Object.prototype.hasOwnProperty.call(props, name)) {\n\t\t\trefs[name] ??= [];\n\t\t\trefs[name]!.push(result);\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn buildReference(name, parent, result);\n\t\t}\n\t}\n\n\tlet props = {};\n\tfor (let propdef of args) {\n\t\tawait new Promise(resolve => queueMicrotask(resolve)); // Yield here\n\t\tif (!Array.isArray(propdef) || propdef.length != 2) { throw new Error(\"each struct args should be a [name,type] pair\"); }\n\t\tif (typeof propdef[0] != \"string\") { throw new Error(\"prop name should be string\"); }\n\t\tif (props[propdef[0]]) { throw new Error(\"duplicate struct prop \" + propdef[0]); }\n\t\tprops[propdef[0]] = await buildParser(resolveReference.bind(null, propdef[0]), propdef[1], typedef);\n\t}\n\tlet keys = Object.keys(props);\n\treturn r;\n}\n\nasync function optParser(args: unknown[], parent: ChunkParentCallback, typedef: TypeDef) {\n\tlet r: ChunkParser = {\n\t\tread(state) {\n\t\t\tlet matchindex = condchecker.match(state);\n\t\t\tif (matchindex == -1) { return null; }\n\t\t\treturn type.read(state);\n\t\t},\n\t\twrite(state, value) {\n\t\t\tif (value != null) {\n\t\t\t\treturn type.write(state, value);\n\t\t\t}\n\t\t},\n\t\tgetTypescriptType(indent) {\n\t\t\treturn type.getTypescriptType(indent) + \" | null\";\n\t\t},\n\t\tgetJsonSchema() {\n\t\t\treturn {\n\t\t\t\toneOf: [\n\t\t\t\t\ttype.getJsonSchema(),\n\t\t\t\t\t{ type: \"null\" }\n\t\t\t\t]\n\t\t\t}\n\t\t}\n\t};\n\n\tlet resolveReference = function (name: string, child: ResolvedReference) {\n\t\treturn buildReference(name, parent, {\n\t\t\tstackdepth: child.stackdepth,\n\t\t\tresolve(v, old) {\n\t\t\t\treturn (v != null ? child.resolve(v, old) : old);\n\t\t\t}\n\t\t})\n\t}\n\n\tif (args.length < 2) throw new Error(`2 arguments exptected for proprety with type opt`);\n\tlet arg1 = args[0];\n\tlet condstr = \"\";\n\tif (typeof arg1 == \"string\") {\n\t\tcondstr = arg1;\n\t} else {\n\t\ttype CompareMode = \"eq\" | \"eqnot\" | \"bitflag\" | \"bitflagnot\" | \"bitor\" | \"bitand\" | \"gteq\" | \"lteq\";\n\n\t\tlet condvar: string;\n\t\tlet condvalue: number;\n\t\tlet cmpmode: CompareMode = \"eq\";\n\t\tif (Array.isArray(arg1)) {\n\t\t\tif (typeof arg1[1] != \"number\") {\n\t\t\t\tthrow new Error(\"only literal ints as condition value are supported\");\n\t\t\t}\n\t\t\tcondvar = arg1[0];\n\t\t\tcmpmode = (arg1[2] ?? \"eq\") as CompareMode;\n\t\t\tcondvalue = arg1[1];\n\t\t} else {\n\t\t\tif (typeof arg1 != \"number\") { throw new Error(\"\"); }\n\t\t\tcondvar = \"$opcode\";\n\t\t\tcondvalue = arg1;\n\t\t}\n\t\tlet condmap: Record<CompareMode, string> = {\n\t\t\tbitand: \"&=\",\n\t\t\tbitflag: \"&\",\n\t\t\tbitflagnot: \"!&\",\n\t\t\tbitor: \"&\",\n\t\t\teq: \"==\",\n\t\t\teqnot: \"!=\",\n\t\t\tgteq: \">=\",\n\t\t\tlteq: \"<=\"\n\t\t}\n\t\tlet mapped = condmap[cmpmode]\n\t\tif (cmpmode == \"bitflag\" || cmpmode == \"bitflagnot\") {\n\t\t\tcondvalue = 1 << condvalue;\n\t\t}\n\t\tcondstr = `${condvar}${mapped}${condvalue}`;\n\t}\n\tlet condchecker = conditionParser(resolveReference, [condstr], v => (v == null ? -1 : 0));\n\n\tlet type = await buildParser(resolveReference, args[1], typedef);\n\n\treturn r;\n}\n\nfunction chunkedArrayParser(args: unknown[], parent: ChunkParentCallback, typedef: TypeDef) {\n\tlet r: ChunkParser = {\n\t\tasync read(state) { // Make read async\n\t\t\tlet len = lengthtype.read(state);\n\t\t\tlet r: object[] = [];\n\t\t\tlet hiddenprops: object[] = [];\n\t\t\tfor (let chunkindex = 0; chunkindex < chunktypes.length; chunkindex++) {\n\t\t\t\tawait new Promise(resolve => queueMicrotask(resolve)); // Yield here\n\t\t\t\tlet proptype = chunktypes[chunkindex];\n\t\t\t\tif (debugdata) {\n\t\t\t\t\tdebugdata.opcodes.push({ op: Object.keys(proptype).join(), index: state.scan, stacksize: state.stack.length });\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\tlet hidden: object;\n\t\t\t\t\tlet obj: object;\n\t\t\t\t\tif (chunkindex == 0) {\n\t\t\t\t\t\tobj = {};\n\t\t\t\t\t\tr.push(obj);\n\t\t\t\t\t\thidden = {};\n\t\t\t\t\t\thiddenprops.push(hidden);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobj = r[i];\n\t\t\t\t\t\thidden = hiddenprops[i];\n\t\t\t\t\t}\n\t\t\t\t\t//TODO check if we can save speed by manually overwriting stack[length-1] instead of pop->push\n\t\t\t\t\tstate.stack.push(obj);\n\t\t\t\t\tstate.hiddenstack.push(hidden);\n\t\t\t\t\tfor (let key in proptype) {\n\t\t\t\t\t\tlet value = proptype[key].read(state);\n\t\t\t\t\t\tif (key.startsWith(\"$\")) {\n\t\t\t\t\t\t\thidden[key] = value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tobj[key] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstate.stack.pop();\n\t\t\t\t\tstate.hiddenstack.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn r;\n\t\t},\n\t\twrite(state, v) {\n\t\t\tif (!Array.isArray(v)) { throw new Error(\"array expected\"); }\n\t\t\tlengthtype.write(state, v.length);\n\n\t\t\tlet hiddenprops: object[] = [];\n\t\t\tfor (let chunkindex = 0; chunkindex < chunktypes.length; chunkindex++) {\n\t\t\t\tlet proptype = chunktypes[chunkindex];\n\t\t\t\tfor (let i = 0; i < v.length; i++) {\n\t\t\t\t\tlet entry = v[i];\n\t\t\t\t\tlet hiddenvalue = (chunkindex == 0 ? (hiddenprops[i] = {}) : hiddenprops[i]);\n\t\t\t\t\tstate.stack.push(entry);\n\t\t\t\t\tstate.hiddenstack.push(hiddenvalue);\n\t\t\t\t\tif (typeof entry != \"object\" || !entry) { throw new Error(\"object expected\"); }\n\t\t\t\t\tfor (let key in proptype) {\n\t\t\t\t\t\tlet prop = proptype[key];\n\t\t\t\t\t\tlet propvalue = entry[key];\n\t\t\t\t\t\tif (key.startsWith(\"$\")) {\n\t\t\t\t\t\t\tif (prop.readConst != undefined) {\n\t\t\t\t\t\t\t\tpropvalue = prop.readConst(state);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlet refarray = refs[key];\n\t\t\t\t\t\t\t\tif (!refarray) { throw new Error(\"cannot write hidden values if they are not constant or not referenced\"); }\n\t\t\t\t\t\t\t\tpropvalue ??= 0;\n\t\t\t\t\t\t\t\tfor (let ref of refarray) {\n\t\t\t\t\t\t\t\t\tpropvalue = ref.resolve(entry, propvalue);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thiddenvalue[key] = propvalue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\tprop.write(state, propvalue);\n\t\t\t\t\t}\n\t\t\t\t\tstate.stack.pop();\n\t\t\t\t\tstate.hiddenstack.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tgetTypescriptType(indent) {\n\t\t\tlet r = \"{\\n\";\n\t\t\tlet newindent = indent + \"\\t\";\n\t\t\tfor (let [key, prop] of Object.entries(fullobj)) {\n\t\t\t\tif (key[0] == \"$\") { continue; }\n\t\t\t\tr += newindent + key + \": \" + prop.getTypescriptType(newindent) + \",\\n\";\n\t\t\t}\n\t\t\tr += indent + \"}[]\";\n\t\t\treturn r;\n\t\t},\n\t\tgetJsonSchema() {\n\t\t\treturn {\n\t\t\t\ttype: \"array\",\n\t\t\t\titems: {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tproperties: Object.fromEntries([...Object.entries(fullobj)]\n\t\t\t\t\t\t.filter(([key]) => !key.startsWith(\"$\"))\n\t\t\t\t\t\t.map(([key, prop]) => [key, prop.getJsonSchema()])\n\t\t\t\t\t),\n\t\t\t\t\trequired: keys.filter(k => !k.startsWith(\"$\"))\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t};\n\tconst resolveLength: ChunkParentCallback = function (prop, childresolve) {\n\t\treturn buildReference(prop, parent, {\n\t\t\tstackdepth: childresolve.stackdepth,\n\t\t\tresolve(v, old) {\n\t\t\t\tif (!Array.isArray(v)) { throw new Error(\"array expected\"); }\n\t\t\t\treturn childresolve.resolve(v.length, old);\n\t\t\t}\n\t\t});\n\t}\n\n\tconst resolveReference = function (targetprop: string, name: string, childresolve: ResolvedReference) {\n\t\tlet result: ResolvedReference = {\n\t\t\tstackdepth: childresolve.stackdepth + 1,\n\t\t\tresolve(v, oldvalue) {\n\t\t\t\tif (typeof v != \"object\" || !v) { throw new Error(\"object expected\"); }\n\t\t\t\tlet res = v[targetprop!];\n\t\t\t\treturn childresolve.resolve(res, oldvalue);\n\t\t\t}\n\t\t};\n\t\tif (Object.prototype.hasOwnProperty.call(fullobj, name)) {\n\t\t\trefs[name] ??= [];\n\t\t\trefs[name]!.push(result);\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn buildReference(name, parent, result);\n\t\t}\n\t}\n\n\tlet rawchunks = args.slice(1);\n\tlet lengthtype = buildParser(resolveLength, args[0], typedef);\n\n\tlet refs: Record<string, ResolvedReference[] | undefined> = {};\n\tlet fullobj: Record<string, ChunkParser> = {};\n\tlet chunktypes: Record<string, ChunkParser>[] = [];\n\tfor (let chunk of rawchunks) {\n\t\tif (!Array.isArray(chunk)) { throw new Error(\"each argument for composed chunk should be an array\") }\n\t\tlet group: Record<string, ChunkParser> = {};\n\t\tchunktypes.push(group);\n\t\tfor (let propdef of chunk as unknown[]) {\n\t\t\tif (!Array.isArray(propdef) || propdef.length != 2 || typeof propdef[0] != \"string\") { throw new Error(\"each composedchunk should be a [name,type] pair\"); }\n\t\t\tlet p = buildParser(resolveReference.bind(null, propdef[0]), propdef[1], typedef);\n\t\t\tgroup[propdef[0]] = p;\n\t\t\tfullobj[propdef[0]] = p;\n\t\t}\n\t}\n\n\tlet keys = chunktypes.flatMap(Object.keys);\n\n\treturn r;\n}\n\nfunction bufferParserValue(value: unknown, type: typeof BufferTypes[keyof typeof BufferTypes], scalartype: keyof typeof BufferTypes) {\n\tif (typeof value == \"string\") {\n\t\tif (scalartype == \"hex\") {\n\t\t\treturn hexToBytes(value);\n\t\t} else {\n\t\t\t//accept json-ified version of our data as well\n\t\t\tlet m = value.match(/^buffer ([\\[\\w]+){([\\d,\\-\\.]*)}$/);\n\t\t\tif (!m) { throw new Error(\"invalid arraybuffer string\"); }\n\t\t\treturn new type.constr(m[2].split(\",\").map(q => +q));\n\t\t}\n\t}\n\n\tif (!(value instanceof type.constr)) { throw new Error(\"arraybuffer expected\"); }\n\treturn value;\n}\n\nasync function bufferParser(args: unknown[], parent: ChunkParentCallback, typedef: TypeDef) {\n\tlet r: ChunkParser = {\n\t\tread(state) {\n\t\t\tlet len = lengthtype.read(state);\n\t\t\tlet bytelen = len * vectorLength * type.constr.BYTES_PER_ELEMENT;\n\t\t\tlet backing = new ArrayBuffer(bytelen);\n\t\t\tif (state.scan + bytelen > state.endoffset) { throw new Error(\"trying to read outside buffer bounds\"); }\n\t\t\tlet bytes = new Uint8Array(backing);\n\t\t\tbytes.set(state.buffer.subarray(state.scan, state.scan + bytelen));\n\t\t\tstate.scan += bytelen;\n\t\t\tlet array = (scalartype == \"buffer\" ? bytes : new type.constr(backing));\n\t\t\tif (scalartype == \"hex\") { (array as any).toJSON = () => bytesToHex(bytes); }\n\t\t\telse if (state.args.keepBufferJson === true) { (array as any).toJSON = () => `buffer ${scalartype}${vectorLength != 1 ? `[${vectorLength}]` : \"\"}[${len}]`; }\n\t\t\telse { (array as any).toJSON = () => `buffer ${scalartype}${vectorLength != 1 ? `[${vectorLength}]` : \"\"}[{${[...array].join(\",\")}}]` }\n\t\t\treturn array;\n\t\t},\n\t\twrite(state, rawvalue) {\n\t\t\tlet value = bufferParserValue(rawvalue, type, scalartype);\n\t\t\tif (value.length % vectorLength != 0) { throw new Error(\"araybuffer is not integer multiple of vectorlength\"); }\n\t\t\tlengthtype.write(state, value.length / vectorLength);\n\n\t\t\tlet bytes = new Uint8Array(value.buffer, value.byteOffset, value.byteLength);\n\t\t\tstate.buffer.set(bytes, state.scan);\n\t\t\tstate.scan += bytes.byteLength;\n\t\t},\n\t\tgetTypescriptType(indent) {\n\t\t\treturn type.constr.name;\n\t\t},\n\t\tgetJsonSchema() {\n\t\t\treturn { type: \"string\" };\n\t\t}\n\t};\n\n\tconst resolveLengthReference: ChunkParentCallback = function (name, child) {\n\t\treturn buildReference(name, parent, {\n\t\t\tstackdepth: child.stackdepth,\n\t\t\tresolve(rawvalue, old) {\n\t\t\t\tlet value = bufferParserValue(rawvalue, type, scalartype);\n\t\t\t\treturn child.resolve(value.length / vectorLength, old);\n\t\t\t}\n\t\t});\n\t}\n\n\tif (args.length < 1) throw new Error(`'read' variables interpretted as an array must contain items: ${JSON.stringify(args)}`);\n\tlet typestring = args[1] ?? \"buffer\";\n\tlet lenarg = args[2] ?? 1;\n\tif (typeof typestring != \"string\" || !Object.hasOwn(BufferTypes, typestring)) { throw new Error(\"unknown buffer type \" + args[1]); }\n\tif (typeof lenarg != \"number\") { throw new Error(\"vectorlength should be a number\"); }\n\tlet vectorLength = lenarg;\n\tlet scalartype: keyof typeof BufferTypes = typestring as any;\n\n\tlet lengthtype = await buildParser(resolveLengthReference, args[0], typedef);\n\tconst type = BufferTypes[typestring];\n\treturn r;\n}\n\nasync function arrayParser(args: unknown[], parent: ChunkParentCallback, typedef: TypeDef) {\n\tlet r: ChunkParser = {\n\t\tasync read(state) { // Make read async\n\t\t\tlet len = lengthtype.read(state);\n\t\t\tlet r: any[] = [];\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tawait new Promise(resolve => queueMicrotask(resolve)); // Yield here\n\t\t\t\tr.push(subtype.read(state));\n\t\t\t}\n\t\t\treturn r;\n\t\t},\n\t\twrite(state, value) {\n\t\t\tif (!Array.isArray(value)) { throw new Error(\"array expected\"); }\n\t\t\tlengthtype.write(state, value.length);\n\t\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\t\tsubtype.write(state, value[i]);\n\t\t\t}\n\t\t},\n\t\tgetTypescriptType(indent) {\n\t\t\treturn `${subtype.getTypescriptType(indent)}[]`;\n\t\t},\n\t\tgetJsonSchema() {\n\t\t\treturn {\n\t\t\t\ttype: \"array\",\n\t\t\t\titems: subtype.getJsonSchema()\n\t\t\t}\n\t\t}\n\t};\n\tconst resolveLengthReference: ChunkParentCallback = function (name, child) {\n\t\treturn buildReference(name, parent, {\n\t\t\tstackdepth: child.stackdepth,\n\t\t\tresolve(v, old) {\n\t\t\t\tif (!Array.isArray(v)) { throw new Error(\"array expected\"); }\n\t\t\t\treturn child.resolve(v.length, old);\n\t\t\t}\n\t\t});\n\t}\n\tconst resolvePropReference = function (name, child) {\n\t\treturn buildReference(name, parent, {\n\t\t\tstackdepth: child.stackdepth,\n\t\t\tresolve(v, old) {\n\t\t\t\tif (!Array.isArray(v)) { throw new Error(\"array expected\"); }\n\t\t\t\t//possibly do this for all elements in the array if needed and allowed by performance\n\t\t\t\treturn child.resolve(v[0], old);\n\t\t\t}\n\t\t});\n\t}\n\n\n\tif (args.length < 1) throw new Error(`'read' variables interpretted as an array must contain items: ${JSON.stringify(args)}`);\n\tlet sizearg = (args.length >= 2 ? args[0] : \"variable unsigned short\");\n\tlet lengthtype = await buildParser(resolveLengthReference, sizearg, typedef);\n\tlet subtype = await buildParser(resolvePropReference, args[args.length >= 2 ? 1 : 0], typedef);\n\treturn r;\n}\n\nasync function arrayNullTerminatedParser(args: unknown[], parent: ChunkParentCallback, typedef: TypeDef) {\n\tlet r: ChunkParser = {\n\t\tasync read(state) { // Make read async\n\t\t\tlet r: any[] = [];\n\t\t\tlet ctx = { \"$opcode\": 0 };\n\t\t\tstate.hiddenstack.push(ctx);\n\t\t\tstate.stack.push({});\n\t\t\twhile (true) {\n\t\t\t\tawait new Promise(resolve => queueMicrotask(resolve)); // Yield here\n\t\t\t\tlet oldscan = state.scan;\n\t\t\t\tlet header = lengthtype.read(state);\n\t\t\t\tif (debugdata) {\n\t\t\t\t\tdebugdata.opcodes.push({ op: \"$opcode\", index: oldscan, stacksize: state.stack.length });\n\t\t\t\t}\n\t\t\t\tctx.$opcode = header;\n\t\t\t\tlet endint = endvalue.read(state);\n\t\t\t\tif (header == endint) { break; }\n\t\t\t\tr.push(subtype.read(state));\n\t\t\t}\n\t\t\tstate.hiddenstack.pop();\n\t\t\tstate.stack.pop();\n\t\t\treturn r;\n\t\t},\n\t\twrite(state, value) {\n\t\t\tif (!Array.isArray(value)) { throw new Error(\"array expected\"); }\n\t\t\t//TODO probably very wrong\n\t\t\tstate.stack.push(value);\n\t\t\tstate.hiddenstack.push({});\n\t\t\tfor (let prop of value) {\n\t\t\t\tlengthtype.write(state, 1);\n\t\t\t\tsubtype.write(state, prop);\n\t\t\t}\n\t\t\tlengthtype.write(state, 0);\n\t\t\tstate.stack.pop();\n\t\t\tstate.hiddenstack.pop();\n\t\t},\n\t\tgetTypescriptType(indent) {\n\t\t\treturn `${subtype.getTypescriptType(indent)}[]`;\n\t\t},\n\t\tgetJsonSchema() {\n\t\t\treturn {\n\t\t\t\ttype: \"array\",\n\t\t\t\titems: subtype.getJsonSchema()\n\t\t\t};\n\t\t}\n\t};\n\tconst resolveReference: ChunkParentCallback = function (name, child) {\n\t\tif (name == \"$opcode\") {\n\t\t\treturn {\n\t\t\t\tstackdepth: child.stackdepth + 1,\n\t\t\t\tresolve(v, old) { throw new Error(\"not implemented\") }\n\t\t\t}\n\t\t}\n\t\treturn buildReference(name, parent, {\n\t\t\tstackdepth: child.stackdepth + 1,\n\t\t\tresolve(v, old) {\n\t\t\t\tif (!Array.isArray(v)) { throw new Error(\"array expected\"); }\n\t\t\t\t//possibly do this for all elements in the array if needed and allowed by performance\n\t\t\t\treturn child.resolve(v[0], old);\n\t\t\t}\n\t\t})\n\t}\n\n\tif (args.length < 1) throw new Error(`'read' variables interpretted as an array must contain items: ${JSON.stringify(args)}`);\n\tlet sizearg = (args.length >= 2 ? args[0] : \"variable unsigned short\");\n\tlet endintarg = (args.length >= 3 ? args[1] : 0);\n\tlet lengthtype = await buildParser(null, sizearg, typedef);\n\tlet endvalue = await buildParser(null, endintarg, typedef);\n\tlet subtype = await buildParser(resolveReference, args[args.length - 1], typedef);\n\treturn r;\n}\n\nfunction literalValueParser(constvalue: unknown) {\n\tif (typeof constvalue != \"number\" && typeof constvalue != \"string\" && typeof constvalue != \"boolean\" && constvalue != null) {\n\t\tthrow new Error(\"only bool, number, string or null literals allowed\");\n\t}\n\tlet r: ChunkParser = {\n\t\tread(state) {\n\t\t\treturn constvalue;\n\t\t},\n\t\treadConst() {\n\t\t\treturn constvalue;\n\t\t},\n\t\twrite(state, value) {\n\t\t\tif (value != constvalue) throw new Error(`expected constant ${constvalue} was not present during write`);\n\t\t\t//this is a nop, the existence of this field implies its value\n\t\t},\n\t\tgetTypescriptType() {\n\t\t\treturn JSON.stringify(constvalue);\n\t\t},\n\t\tgetJsonSchema() {\n\t\t\treturn { const: constvalue }\n\t\t}\n\t}\n\treturn r;\n}\nfunction referenceValueParser(args: unknown[], parent: ChunkParentCallback, typedef: TypeDef) {\n\tlet read = (state: SharedEncoderState) => {\n\t\tlet value = ref.read(state);\n\t\tif (minbit != -1) {\n\t\t\tvalue = (value >> minbit) & ~((~0) << bitlength);\n\t\t}\n\t\treturn value + offset;\n\t}\n\tlet r: ChunkParser = {\n\t\tread,\n\t\treadConst: read,\n\t\twrite(state, value) {\n\t\t\t//noop, the referenced value does the writing and will get its value from this prop through refgetter\n\t\t},\n\t\tgetTypescriptType() {\n\t\t\treturn \"number\";\n\t\t},\n\t\tgetJsonSchema() {\n\t\t\treturn {\n\t\t\t\ttype: \"integer\",\n\t\t\t\tminimum: (bitlength == -1 ? undefined : 0),\n\t\t\t\tmaximum: (bitlength == -1 ? undefined : 2 ** bitlength - 1)\n\t\t\t}\n\t\t}\n\t}\n\n\tif (args.length < 1) throw new Error(`1 argument exptected for proprety with type ref`);\n\tif (typeof args[0] != \"string\") { throw new Error(\"ref propname expected\"); }\n\tlet propname = args[0];\n\tlet [minbit, bitlength] = [-1, -1];\n\tif (args[1]) {\n\t\tif (Array.isArray(args[1]) && args[1].length == 2 && typeof args[1][0] == \"number\" && typeof args[1][1] == \"number\") {\n\t\t\tminbit = args[1][0];\n\t\t\tbitlength = args[1][1];\n\t\t} else {\n\t\t\tthrow new Error(\"second argument for ref should be [minbit,bitlen] pair\");\n\t\t}\n\t}\n\tlet offset = args[2] ?? 0;\n\tif (typeof offset != \"number\") { throw new Error(\"ref offset should be a number\"); }\n\n\tlet ref = refgetter(parent, propname, (v, old) => {\n\t\tif (typeof v != \"number\") { throw new Error(\"number expected\"); }\n\t\tif (minbit != -1) {\n\t\t\tlet mask = (~(-1 << bitlength)) << minbit;\n\t\t\treturn (old & ~mask) | (v << minbit);\n\t\t} else {\n\t\t\treturn v;\n\t\t}\n\t});\n\n\treturn r;\n}\nfunction bytesRemainingParser(): ChunkParser {\n\treturn {\n\t\tread(state) {\n\t\t\treturn state.endoffset - state.scan;\n\t\t},\n\t\twrite(state, value) {\n\t\t\t//nop, value exists only in context of output\n\t\t},\n\t\tgetTypescriptType() {\n\t\t\treturn \"number\";\n\t\t},\n\t\tgetJsonSchema() {\n\t\t\treturn { type: \"integer\" };\n\t\t}\n\t}\n}\n\nfunction intAccumolatorParser(args: unknown[], parent: ChunkParentCallback, typedef: TypeDef) {\n\tlet r: ChunkParser = {\n\t\tread(state) {\n\t\t\t//TODO fix the context situation\n\t\t\tlet increment = value.read(state);\n\t\t\tlet newvalue: number;\n\t\t\tlet refvalue = ref.read(state) ?? 0;\n\t\t\tif (mode == \"add\" || mode == \"add-1\" || mode == \"postadd\") {\n\t\t\t\tnewvalue = refvalue + (increment ?? 0) + (mode == \"add-1\" ? -1 : 0);\n\t\t\t} else if (mode == \"hold\") {\n\t\t\t\tnewvalue = increment ?? refvalue;\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"unknown accumolator mode\");\n\t\t\t}\n\t\t\tref.write(state, newvalue);\n\t\t\treturn (mode == \"postadd\" ? refvalue : newvalue);\n\t\t},\n\t\twrite(state, v) {\n\t\t\tif (typeof v != \"number\") { throw new Error(\"number expected\"); }\n\n\t\t\tlet refvalue = ref.read(state) ?? 0;\n\n\t\t\tlet increment: number;\n\t\t\tif (mode == \"add\" || mode == \"add-1\") {\n\t\t\t\tincrement = v - refvalue + (mode == \"add-1\" ? 1 : 0);\n\t\t\t} else if (mode == \"hold\") {\n\t\t\t\tthrow new Error(\"writing accum intaccum hold not implemented\");\n\t\t\t} else if (mode == \"postadd\") {\n\t\t\t\tthrow new Error(\"writing accum intaccum postadd not implemented\");\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"unknown accumolator mode\");\n\t\t\t}\n\t\t\tvalue.write(state, increment);\n\t\t\tref.write(state, v);\n\t\t},\n\t\tgetTypescriptType() {\n\t\t\treturn \"number\";\n\t\t},\n\t\tgetJsonSchema() {\n\t\t\treturn { type: \"integer\" };\n\t\t}\n\t}\n\n\tif (args.length < 2) throw new Error(`2 arguments exptected for proprety with type accum`);\n\tlet refname = args[0];\n\tlet value = buildParser(parent, args[1], typedef);\n\tlet mode = args[2] ?? \"add\";\n\tif (typeof refname != \"string\") { throw new Error(\"ref name should be a string\"); }\n\n\tlet ref = refgetter(parent, refname, (v, old) => {\n\t\treturn old;\n\t});\n\n\treturn r;\n}\n\nfunction stringParser(prebytes: number[]): ChunkParser {\n\tconst encoding = \"latin1\";\n\treturn {\n\t\tasync read(state) { // Make read async\n\t\t\tlet terminator = (getClientVersion(state.args) <= lastLegacyBuildnr ? 0xA : 0);\n\t\t\tfor (let i = 0; i < prebytes.length; i++, state.scan++) {\n\t\t\t\tawait new Promise(resolve => queueMicrotask(resolve)); // Yield here\n\t\t\t\tif (state.dataView.getUint8(state.scan) != prebytes[i]) {\n\t\t\t\t\tthrow new Error(\"failed to match string header bytes\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet end = state.scan;\n\t\t\twhile (true) {\n\t\t\t\tawait new Promise(resolve => queueMicrotask(resolve)); // Yield here\n\t\t\t\tif (end == state.endoffset) {\n\t\t\t\t\tthrow new Error(\"reading string without null termination\");\n\t\t\t\t}\n\t\t\t\tif (state.dataView.getUint8(end) == terminator) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tend++;\n\t\t\t}\n\t\t\tlet outputstr = new TextDecoder(encoding).decode(state.buffer.subarray(state.scan, end));\n\t\t\tstate.scan = end + 1;\n\t\t\treturn outputstr;\n\t\t},\n\t\twrite(state, value) {\n\t\t\tif (typeof value != \"string\") throw new Error(`string expected`);\n\t\t\tlet terminator = (getClientVersion(state.args) <= lastLegacyBuildnr ? 0xA : 0);\n\t\t\tlet writebytes = [\n\t\t\t\t...prebytes,\n\t\t\t\t...new TextEncoder().encode(value),\n\t\t\t\tterminator\n\t\t\t];\n\t\t\tstate.buffer.set(writebytes, state.scan);\n\t\t\tstate.scan += writebytes.length;;\n\t\t},\n\t\tgetTypescriptType() {\n\t\t\treturn \"string\";\n\t\t},\n\t\tgetJsonSchema() {\n\t\t\treturn { type: \"string\" };\n\t\t}\n\t}\n}\n\nasync function conditionParser(parent: ChunkParentCallback, optionstrings: string[], writegetindex?: (v: unknown) => number) {\n\ttype ops = \"=\" | \"<\" | \"<=\" | \">\" | \">=\" | \"&\" | \"!&\" | \"!=\" | \"&=\";\n\ttype cond = { op: ops, value: number, varname: string, varindex: number };\n\n\tlet varmap: { name: string, parser: ReturnType<typeof refgetter> }[] = [];\n\tlet options: cond[][] = [];\n\tfor (let str of optionstrings) {\n\t\tawait new Promise(resolve => queueMicrotask(resolve)); // Yield here\n\t\tstr = str.replace(/\\s/g, \"\");\n\t\tlet parts = str.split(/&&/g);\n\t\tlet conds: cond[] = [];\n\t\tfor (let opt of parts) {\n\t\t\tlet op: ops;\n\t\t\tlet varname: string;\n\t\t\tlet value = 0;\n\t\t\tif (opt == \"default\" || opt == \"other\") {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tlet m = opt.match(/^((?<var>[\\$a-zA-Z]\\w*)?(?<op><|<=|>|>=|&|==|=|!&|&=|!=)?)?(?<version>0x[\\da-fA=F]+|-?\\d+)$/);\n\t\t\t\tif (!m) { throw new Error(\"invalid match value, expected <op><version>. For example '>10'\"); }\n\t\t\t\tvalue = parseInt(m.groups!.version);\n\t\t\t\top = (m.groups!.op ?? \"=\") as ops;\n\t\t\t\tif (op as any == \"==\") { op = \"=\"; }\n\t\t\t\tvarname = m.groups!.var ?? \"$opcode\";\n\t\t\t}\n\n\t\t\tlet varindex = varmap.findIndex(q => q.name == varname);\n\t\t\tif (varindex == -1) {\n\t\t\t\tvarindex = varmap.length;\n\n\t\t\t\tvarmap.push({\n\t\t\t\t\tname: varname,\n\t\t\t\t\tparser: refgetter(parent, varname, (v, oldvalue) => {\n\t\t\t\t\t\tif (!writegetindex) { throw new Error(\"write not implemented\"); }\n\t\t\t\t\t\tlet index = writegetindex(v);\n\n\t\t\t\t\t\tfor (let optionindex = 0; optionindex < options.length; optionindex++) {\n\t\t\t\t\t\t\tlet option = options[optionindex];\n\t\t\t\t\t\t\tfor (let con of option) {\n\t\t\t\t\t\t\t\tif (con.varindex != varindex) { continue; }\n\t\t\t\t\t\t\t\tlet state = optionindex == index;\n\t\t\t\t\t\t\t\tlet compValue = con.value;\n\t\t\t\t\t\t\t\tswitch (con.op) {\n\t\t\t\t\t\t\t\t\tcase \"=\": oldvalue = state ? compValue : oldvalue; break;\n\t\t\t\t\t\t\t\t\tcase \"!=\": oldvalue = state ? oldvalue : compValue; break;\n\t\t\t\t\t\t\t\t\tcase \"&\": oldvalue = (state ? oldvalue | compValue : oldvalue & ~compValue); break;\n\t\t\t\t\t\t\t\t\tcase \"&=\": oldvalue = (state ? oldvalue | compValue : oldvalue & ~compValue); break;\n\t\t\t\t\t\t\t\t\tcase \"!&\": oldvalue = (state ? oldvalue & ~compValue : oldvalue | compValue); break;\n\t\t\t\t\t\t\t\t\tcase \">=\": oldvalue = state ? Math.max(compValue, oldvalue) : oldvalue; break;\n\t\t\t\t\t\t\t\t\tcase \">\": oldvalue = state ? Math.max(compValue + 1, oldvalue) : oldvalue; break;\n\t\t\t\t\t\t\t\t\tcase \"<=\": oldvalue = state ? Math.min(compValue, oldvalue) : oldvalue; break;\n\t\t\t\t\t\t\t\t\tcase \"<\": oldvalue = state ? Math.min(compValue - 1, oldvalue) : oldvalue; break;\n\t\t\t\t\t\t\t\t\tdefault: throw new Error(\"unknown condition \" + con.op);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn oldvalue;\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconds.push({ op, value, varname, varindex });\n\t\t}\n\t\toptions.push(conds);\n\t}\n\n\tlet match = async (state: SharedEncoderState) => {\n\t\tlet vars = varmap.map(q => q.parser.read(state));\n\n\t\tfor (let optindex = 0; optindex < options.length; optindex++) {\n\t\t\tawait new Promise(resolve => queueMicrotask(resolve)); // Yield here\n\t\t\tlet opt = options[optindex];\n\t\t\tlet matched = true;\n\t\t\tfor (let cond of opt) {\n\t\t\t\tlet value = vars[cond.varindex];\n\t\t\t\tswitch (cond.op) {\n\t\t\t\t\tcase \"=\": matched = value == cond.value; break;\n\t\t\t\t\tcase \"!=\": matched = value != cond.value; break;\n\t\t\t\t\tcase \"<\": matched = value < cond.value; break;\n\t\t\t\t\tcase \"<=\": matched = value <= cond.value; break;\n\t\t\t\t\tcase \">\": matched = value > cond.value; break;\n\t\t\t\t\tcase \">=\": matched = value >= cond.value; break;\n\t\t\t\t\tcase \"&\": matched = (value & cond.value) != 0; break;\n\t\t\t\t\tcase \"!&\": matched = (value & cond.value) == 0; break;\n\t\t\t\t\tcase \"&=\": matched = (value & cond.value) == cond.value; break;\n\t\t\t\t\tdefault: throw new Error(\"unknown op\" + cond.op);\n\t\t\t\t}\n\t\t\t\tif (!matched) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (matched) {\n\t\t\t\treturn optindex;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\n\treturn { match };\n}\n\n\nObject.assign(hardcodes, {\n\tplayeritem: function () {\n\t\treturn {\n\t\t\tread(state) {\n\t\t\t\tlet byte0 = state.dataView.getUint8(state.scan++);\n\t\t\t\tif (byte0 == 0) { return 0; }\n\t\t\t\tlet byte1 = state.dataView.getUint8(state.scan++);\n\t\t\t\tif (byte1 == 0xff && byte0 == 0xff) { return -1; }\n\t\t\t\treturn (byte0 << 8) | byte1;\n\t\t\t},\n\t\t\twrite(state, value) {\n\t\t\t\tif (typeof value != \"number\") { throw new Error(\"number expected\"); }\n\t\t\t\tif (value == 0) {\n\t\t\t\t\tstate.dataView.setUint8(state.scan++, 0);\n\t\t\t\t} else {\n\t\t\t\t\t//replicate explicit 16bit overflow bug since that's what the game does\n\t\t\t\t\tstate.dataView.setUint16(state.scan, (value == -1 ? 0xffff : value & 0xffff));\n\t\t\t\t\tstate.scan += 2;\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetTypescriptType() { return \"number\"; },\n\t\t\tgetJsonSchema() { return { type: \"integer\", minimum: -1, maximum: 0xffff - 0x4000 - 1 }; }\n\t\t}\n\t},\n\titemvar: function (args) {\n\t\tlet type = args[0];\n\t\tif (typeof type != \"string\" || ![\"ref\", \"matcount\", \"colorcount\", \"modelcount\"].includes(type)) { throw new Error(); }\n\n\t\t//yes this is hacky af...\n\t\treturn {\n\t\t\tread(state) {\n\t\t\t\tlet activeitem = (typeof state.args.activeitem == \"number\" ? state.args.activeitem : -1);\n\t\t\t\tif (type == \"ref\") {\n\t\t\t\t\tactiveitem++;\n\t\t\t\t\tstate.args.activeitem = activeitem;\n\t\t\t\t}\n\t\t\t\tif (!Array.isArray(state.args.slots)) { throw new Error(\"\"); }\n\t\t\t\tlet ref = state.args.slots[activeitem];\n\t\t\t\tif (type == \"ref\") { return ref; }\n\t\t\t\telse if (type == \"matcount\") { return ref?.replaceMaterials?.length ?? 0; }\n\t\t\t\telse if (type == \"colorcount\") { return ref?.replaceColors?.length ?? 0; }\n\t\t\t\telse if (type == \"modelcount\") { return ref?.models.length; }\n\t\t\t\telse { throw new Error(); }\n\t\t\t},\n\t\t\twrite() {\n\t\t\t\t//noop\n\t\t\t},\n\t\t\tgetTypescriptType() { return (type == \"ref\" ? \"any\" : \"number\"); },\n\t\t\tgetJsonSchema() { return { type: (type == \"ref\" ? \"any\" : \"integer\") } }\n\t\t}\n\t},\n\tbuildnr: function (args, typedef) {\n\t\treturn {\n\t\t\treadConst(state) {\n\t\t\t\treturn getClientVersion(state.args);\n\t\t\t},\n\t\t\tread(state) {\n\t\t\t\treturn getClientVersion(state.args);\n\t\t\t},\n\t\t\twrite(state, v) {/*noop*/ },\n\t\t\tgetTypescriptType(indent) { return \"number\"; },\n\t\t\tgetJsonSchema() { return { type: \"number\" } }\n\t\t}\n\t},\n\tmatch: async function (args, parent, typedef) {\n\t\tlet r: ChunkParser = {\n\t\t\tread(state) {\n\t\t\t\tlet opcodeprop = { $opcode: 0 };\n\t\t\t\tstate.stack.push({});\n\t\t\t\tstate.hiddenstack.push(opcodeprop);\n\t\t\t\tlet value = (opvalueparser ? opvalueparser.read(state) : 0);\n\t\t\t\topcodeprop.$opcode = value;\n\t\t\t\tlet opindex = conditionparser.match(state);\n\t\t\t\tif (opindex == -1) {\n\t\t\t\t\tthrow new Error(\"no opcode matched\");\n\t\t\t\t}\n\t\t\t\tlet res = optionvalues[opindex].read(state);\n\n\t\t\t\tstate.stack.pop();\n\t\t\t\tstate.hiddenstack.pop();\n\t\t\t\treturn res;\n\t\t\t},\n\t\t\twrite(state, v) {\n\t\t\t\tlet opcodeprop = { $opcode: 0 };\n\t\t\t\tstate.stack.push({});\n\t\t\t\tstate.hiddenstack.push(opcodeprop);\n\n\t\t\t\tif (opvalueparser) {\n\t\t\t\t\t//supporting this would require finding out the type from v\n\t\t\t\t\tif (!opvalueparser.readConst) { throw new Error(\"non-const or non-reference match value not implemented in write mode\"); }\n\t\t\t\t\topcodeprop.$opcode = opvalueparser.readConst(state);\n\t\t\t\t}\n\t\t\t\tlet opindex = conditionparser.match(state);\n\t\t\t\tif (opindex == -1) { throw new Error(\"no opcode matched\"); }\n\t\t\t\toptionvalues[opindex].write(state, v);\n\n\t\t\t\tstate.stack.pop();\n\t\t\t\tstate.hiddenstack.pop();\n\t\t\t},\n\t\t\tgetTypescriptType(indent) {\n\t\t\t\treturn \"(\" + optionvalues.map(opt => opt.getTypescriptType(indent + \"\\t\")).join(\"|\") + \")\";\n\t\t\t},\n\t\t\tgetJsonSchema() {\n\t\t\t\treturn { anyOf: optionvalues.map(opt => opt.getJsonSchema()) };\n\t\t\t}\n\t\t}\n\n\t\tconst resolveReference: ChunkParentCallback = function (name, child) {\n\t\t\tlet res: ResolvedReference = {\n\t\t\t\tstackdepth: child.stackdepth + 1,\n\t\t\t\tresolve(v, old) {\n\t\t\t\t\tthrow new Error(\"write not supported\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (name == \"$opcode\") { return res; }\n\t\t\treturn buildReference(name, parent, res);\n\t\t}\n\n\t\tif (args.length == 1) { args = [null, args[0]]; }\n\t\tif (args.length != 2) { throw new Error(\"match chunks needs 2 arguments\") }\n\t\tif (typeof args[1] != \"object\") { throw new Error(\"match chunk requires 2n+2 arguments\"); }\n\n\t\tlet opvalueparser = (args[0] ? await buildParser(resolveReference, args[0], typedef) : null);\n\t\tlet conditionstrings = Object.keys(args[1] as any);\n\t\tlet optionvalues = await Promise.all(Object.values(args[1] as any).map(async q => await buildParser(resolveReference, q, typedef)));\n\t\tlet conditionparser = conditionParser(resolveReference, conditionstrings);\n\t\treturn r;\n\t},\n\tfooter: async function (args, parent, typedef) {\n\t\tif (args.length != 2) { throw new Error(\"footer requires length and subtype arguments\"); }\n\t\tlet lentype = await buildParser(parent, args[0] as any, typedef);\n\t\tlet subtype = await buildParser(parent, args[1] as any, typedef);\n\t\treturn {\n\t\t\tread(state) {\n\t\t\t\tlet len = lentype.read(state);\n\t\t\t\tlet oldscan = state.scan;\n\t\t\t\tlet footstart = state.endoffset - len;\n\t\t\t\tstate.scan = footstart;\n\t\t\t\tif (debugdata) {\n\t\t\t\t\t// debugdata.opcodes.push({ op: `footer`, index: oldscan, stacksize: state.stack.length + 1, external: { start: state.scan, len: 0 } });\n\t\t\t\t\tdebugdata.opcodes.push({ op: \"footer\", index: oldscan, stacksize: state.stack.length + 1, jump: { to: footstart } });\n\t\t\t\t}\n\t\t\t\tlet res = subtype.read(state);\n\t\t\t\tif (debugdata) {\n\t\t\t\t\tdebugdata.opcodes.push({ op: \"footer\", index: state.scan, stacksize: state.stack.length + 1, jump: { to: oldscan } });\n\t\t\t\t}\n\t\t\t\tif (state.scan != state.endoffset) { console.log(`didn't read full footer, ${state.endoffset - state.scan} bytes left`); }\n\t\t\t\tstate.scan = oldscan;\n\t\t\t\tstate.endoffset = state.endoffset - len;\n\n\t\t\t\treturn res;\n\t\t\t},\n\t\t\twrite(state, v) {\n\t\t\t\tlet oldscan = state.scan;\n\t\t\t\tsubtype.write(state, v);\n\t\t\t\tlet len = state.scan - oldscan;\n\t\t\t\tstate.buffer.copyWithin(state.endoffset - len, oldscan, state.scan);\n\t\t\t\tstate.scan = oldscan;\n\t\t\t\tstate.endoffset -= len;\n\t\t\t},\n\t\t\tgetTypescriptType(indent) {\n\t\t\t\treturn subtype.getTypescriptType(indent);\n\t\t\t},\n\t\t\tgetJsonSchema() {\n\t\t\t\treturn subtype.getJsonSchema();\n\t\t\t},\n\t\t}\n\t},\n\t\"tailed varushort\": function (args, parent, typedef) {\n\t\tconst overflowchunk = 0x7fff;\n\t\treturn {\n\t\t\tasync read(state) { // Make read async\n\t\t\t\tlet sum = 0;\n\t\t\t\twhile (true) {\n\t\t\t\t\tawait new Promise(resolve => queueMicrotask(resolve)); // Yield here\n\t\t\t\t\tlet byte0 = state.dataView.getUint8(state.scan++);\n\t\t\t\t\tlet v: number;\n\t\t\t\t\tif ((byte0 & 0x80) == 0) {\n\t\t\t\t\t\tv = byte0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet byte1 = state.dataView.getUint8(state.scan++);\n\t\t\t\t\t\tv = ((byte0 & 0x7f) << 8) | byte1;\n\t\t\t\t\t}\n\t\t\t\t\tsum += v;\n\t\t\t\t\tif (v != overflowchunk) {\n\t\t\t\t\t\treturn sum;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\twrite(state, v) {\n\t\t\t\tif (typeof v != \"number\") { throw new Error(\"number expected\"); }\n\t\t\t\twhile (v >= 0) {\n\t\t\t\t\tlet chunk = Math.min(overflowchunk, v);\n\t\t\t\t\tif (chunk < 0x80) {\n\t\t\t\t\t\tstate.dataView.setUint8(state.scan++, chunk);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate.dataView.setUint16(state.scan, chunk | 0x8000);\n\t\t\t\t\t\tstate.scan += 2;\n\t\t\t\t\t}\n\t\t\t\t\tv -= chunk;\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetTypescriptType(indent) {\n\t\t\t\treturn \"number\";\n\t\t\t},\n\t\t\tgetJsonSchema() {\n\t\t\t\treturn { type: \"number\" };\n\t\t\t}\n\t\t}\n\t},\n\t\t\"legacy_maptile\": function (args, parent, typedef) {\n\t\t\treturn {\n\t\t\t\tasync read(state) { // Make read async\n\t\t\t\t\tlet res = {\n\t\t\t\t\t\tflags: 0,\n\t\t\t\t\t\tshape: null as number | null,\n\t\t\t\t\t\toverlay: null as number | null,\n\t\t\t\t\t\tsettings: null as number | null,\n\t\t\t\t\t\tunderlay: null as number | null,\n\t\t\t\t\t\theight: null as number | null\n\t\t\t\t\t}\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tawait new Promise(resolve => queueMicrotask(resolve)); // Yield here\n\t\t\t\t\t\tlet op = state.dataView.getUint8(state.scan++);\n\t\t\t\t\t\tif (op == 0) { break; }\n\t\t\t\t\t\tif (op == 1) {\n\t\t\t\t\t\t\tres.height = state.dataView.getUint8(state.scan++);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (op >= 2 && op <= 49) {\n\t\t\t\t\t\t\tres.shape = op - 2;\n\t\t\t\t\t\t\tres.overlay = state.dataView.getUint8(state.scan);\n\t\t\t\t\t\t\tstate.scan += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (op >= 50 && op <= 81) {\n\t\t\t\t\t\t\tres.settings = op - 49;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (op >= 82) {\n\t\t\t\t\t\t\tres.underlay = op - 81;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn res;\n\t\t\t\t},\n\t\t\t\twrite(state) {\n\t\t\t\t\tthrow new Error(\"not implemented\");\n\t\t\t\t},\n\t\t\t\tgetTypescriptType(indent) {\n\t\t\t\t\tlet newindent = indent + \"\\t\";\n\t\t\t\t\treturn `{\n\t`\n\t\t\t\t\t\t+ `${newindent}flags: number,\n\t`\n\t\t\t\t\t\t+ `${newindent}shape: number | null,\n\t`\n\t\t\t\t\t\t+ `${newindent}overlay: number | null,\n\t`\n\t\t\t\t\t\t+ `${newindent}settings: number | null,\n\t`\n\t\t\t\t\t\t+ `${newindent}underlay: number | null,\n\t`\n\t\t\t\t\t\t+ `${newindent}height: number | null,\n\t`\n\t\t\t\t\t\t+ `${indent}}`;\n\t\t\t\t},\n\t\t\t\tgetJsonSchema() {\n\t\t\t\t\treturn { type: \"any\" };\n\t\t\t\t}\n\t\t\t}\n\t\t},\tscriptopt: function (args, parent, typedef) {\n\t\treturn {\n\t\t\tread(state) {\n\t\t\t\tlet cali = state.args.clientScriptDeob as ClientscriptObfuscation | undefined;\n\t\t\t\t//don't explicitly check prototype here as we would have to import the constructor\n\t\t\t\tif (!cali) {\n\t\t\t\t\tthrow new Error(\"opcode callibration not set for clientscript with obfuscated opcodes\");\n\t\t\t\t}\n\t\t\t\tif (debugdata) {\n\t\t\t\t\tdebugdata.opcodes.push({ op: \"opcode\", index: state.scan, stacksize: state.stack.length + 1 });\n\t\t\t\t}\n\t\t\t\tlet res = (cali as ClientscriptObfuscation).readOpcode(state);\n\t\t\t\treturn res;\n\t\t\t},\n\t\t\twrite(state, v) {\n\t\t\t\tlet cali = state.args.clientScriptDeob as ClientscriptObfuscation | undefined;;\n\t\t\t\tif (!cali) {\n\t\t\t\t\tthrow new Error(\"opcode callibration not set for clientscript with obfuscated opcodes\");\n\t\t\t\t}\n\t\t\t\tcali.writeOpCode(state, v);\n\t\t\t},\n\t\t\tgetJsonSchema() {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\topcode: { type: \"number\" },\n\t\t\t\t\t\timm: { type: \"number\" },\n\t\t\t\t\t\timm_obj: { oneOf: [{ type: \"number\" }, { type: \"string\" }, { type: \"null\" }] }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetTypescriptType(indent) {\n\t\t\t\tlet newindent = indent + \"\\t\";\n\t\t\t\treturn `{\n`\n\t\t\t\t\t+ `${newindent}opcode:number,\n`\n\t\t\t\t\t+ `${newindent}imm:number,\n`\n\t\t\t\t\t+ `${newindent}imm_obj:number|string|[number,number]|null,\n`\n\t\t\t\t\t+ `${indent}}`;\n\t\t\t}\n\t\t}\n\t}\n});\n\nfunction getClientVersion(args: Record<string, unknown>) {\n\tif (typeof args.clientVersion != \"number\") { throw new Error(\"client version not set\"); }\n\treturn args.clientVersion;\n}\n\nconst numberTypes: Record<string, { read: (s: DecodeState) => number, write: (s: EncodeState, v: number) => void, min: number, max: number }> = {\n\tubyte: {\n\t\tread(s) { let r = s.dataView.getUint8(s.scan); s.scan += 1; return r; },\n\t\twrite(s, v) { s.dataView.setUint8(s.scan, v); s.scan += 1; },\n\t\tmin: 0, max: 255\n\t},\n\tbyte: {\n\t\tread(s) { let r = s.dataView.getInt8(s.scan); s.scan += 1; return r; },\n\t\twrite(s, v) { s.dataView.setInt8(s.scan, v); s.scan += 1; },\n\t\tmin: -128, max: 127\n\t},\n\tushort: {\n\t\tread(s) { let r = s.dataView.getUint16(s.scan); s.scan += 2; return r; },\n\t\twrite(s, v) { s.dataView.setUint16(s.scan, v); s.scan += 2; },\n\t\tmin: 0, max: 2 ** 16 - 1\n\t},\n\tshort: {\n\t\tread(s) { let r = s.dataView.getInt16(s.scan); s.scan += 2; return r; },\n\t\twrite(s, v) { s.dataView.setInt16(s.scan, v); s.scan += 2; },\n\t\tmin: -(2 ** 15), max: 2 ** 15 - 1\n\t},\n\tuint: {\n\t\tread(s) { let r = s.dataView.getUint32(s.scan); s.scan += 4; return r; },\n\t\twrite(s, v) { s.dataView.setUint32(s.scan, v); s.scan += 4; },\n\t\tmin: 0, max: 2 ** 32 - 1\n\t},\n\tint: {\n\t\tread(s) { let r = s.dataView.getInt32(s.scan); s.scan += 4; return r; },\n\t\twrite(s, v) { s.dataView.setInt32(s.scan, v); s.scan += 4; },\n\t\tmin: -(2 ** 31), max: 2 ** 31 - 1\n\t},\n\n\tuint_le: {\n\t\tread(s) { let r = s.dataView.getUint32(s.scan, true); s.scan += 4; return r; },\n\t\twrite(s, v) { s.dataView.setUint32(s.scan, v, true); s.scan += 4; },\n\t\tmin: 0, max: 2 ** 32 - 1\n\t},\n\tushort_le: {\n\t\tread(s) { let r = s.dataView.getUint16(s.scan, true); s.scan += 2; return r; },\n\t\twrite(s, v) { s.dataView.setUint16(s.scan, v, true); s.scan += 2; },\n\t\tmin: 0, max: 2 ** 16 - 1\n\t},\n\tutribyte: {\n\t\tread(s) { let r = (s.dataView.getUint8(s.scan) << 16) | (s.dataView.getUint8(s.scan + 1) << 8) | s.dataView.getUint8(s.scan + 2); s.scan += 3; return r; },\n\t\twrite(s, v) { s.dataView.setUint8(s.scan, (v >>> 16) & 0xFF); s.dataView.setUint8(s.scan + 1, (v >>> 8) & 0xFF); s.dataView.setUint8(s.scan + 2, v & 0xFF); s.scan += 3; },\n\t\tmin: 0, max: 2 ** 24 - 1\n\t},\n\tfloat: {\n\t\tread(s) { let r = s.dataView.getFloat32(s.scan); s.scan += 4; return r; },\n\t\twrite(s, v) { s.dataView.setFloat32(s.scan, v); s.scan += 4; },\n\t\tmin: Number.MIN_VALUE, max: Number.MAX_VALUE\n\t},\n\n\tvarushort: {\n\t\tread(s) {\n\t\t\tlet firstByte = s.dataView.getUint8(s.scan++);\n\t\t\tif ((firstByte & 0x80) == 0) {\n\t\t\t\treturn firstByte;\n\t\t\t}\n\t\t\tlet secondByte = s.dataView.getUint8(s.scan++);\n\t\t\treturn ((firstByte & 0x7f) << 8) | secondByte;\n\t\t},\n\t\twrite(s, v) {\n\t\t\tif (v < 0x80) {\n\t\t\t\ts.dataView.setUint8(s.scan, v);\n\t\t\t\ts.scan += 1;\n\t\t\t} else {\n\t\t\t\ts.dataView.setUint16(s.scan, v | 0x8000);\n\t\t\t\ts.scan += 2;\n\t\t\t}\n\t\t},\n\t\tmin: 0, max: 2 ** 15 - 1\n\t},\n\tvarshort: {\n\t\tread(s) {\n\t\t\tlet firstByte = s.dataView.getUint8(s.scan++);\n\t\t\tif ((firstByte & 0x80) == 0) {\n\t\t\t\t//sign extend from 7nth bit (>> fills using 32th bit)\n\t\t\t\treturn (firstByte << (32 - 7)) >> (32 - 7);\n\t\t\t}\n\t\t\tlet secondByte = s.dataView.getUint8(s.scan++);\n\t\t\treturn ((((firstByte & 0x7f) << 8) | secondByte) << (32 - 15)) >> (32 - 15);\n\t\t},\n\t\twrite(s, v) {\n\t\t\tif (v < 0x40 && v >= -0x40) {\n\t\t\t\ts.dataView.setUint8(s.scan, v & 0x7f);\n\t\t\t\ts.scan += 1;\n\t\t\t} else {\n\t\t\t\ts.dataView.setInt16(s.scan, v | 0x8000);\n\t\t\t\ts.scan += 2;\n\t\t\t}\n\t\t},\n\t\tmin: -(2 ** 14), max: 2 ** 14 - 1\n\t},\n\tvaruint: {\n\t\tread(s) {\n\t\t\tlet firstWord = s.dataView.getUint16(s.scan);\n\t\t\ts.scan += 2;\n\t\t\tif ((firstWord & 0x8000) == 0) {\n\t\t\t\treturn firstWord;\n\t\t\t} else {\n\t\t\t\tlet secondWord = s.dataView.getUint16(s.scan);\n\t\t\t\ts.scan += 2;\n\t\t\t\treturn ((firstWord & 0x7fff) << 16) | secondWord;\n\t\t\t}\n\t\t},\n\t\twrite(s, v) {\n\t\t\tif (v < 0x8000) {\n\t\t\t\ts.dataView.setUint16(s.scan, v);\n\t\t\t\ts.scan += 2;\n\t\t\t} else {\n\t\t\t\t//unsigned right shift to cast to uint32 again\n\t\t\t\ts.dataView.setUint32(s.scan, (v | 0x80000000) >>> 0);\n\t\t\t\ts.scan += 4;\n\t\t\t}\n\t\t},\n\t\tmin: 0, max: 2 ** 31 - 1\n\t},\n\tvarnullint: {\n\t\tread(s) {\n\t\t\tlet firstWord = s.dataView.getUint16(s.scan);\n\t\t\ts.scan += 2;\n\t\t\tif (firstWord == 0x7fff) {\n\t\t\t\treturn -1;\n\t\t\t} else if ((firstWord & 0x8000) == 0) {\n\t\t\t\treturn firstWord;\n\t\t\t} else {\n\t\t\t\tlet secondWord = s.dataView.getUint16(s.scan);\n\t\t\t\ts.scan += 2;\n\t\t\t\treturn ((firstWord & 0x7fff) << 16) | secondWord;\n\t\t\t}\n\t\t},\n\t\twrite(s, v) {\n\t\t\tif (v == -1) {\n\t\t\t\ts.dataView.setUint16(s.scan, 0x7fff);\n\t\t\t\ts.scan += 2;\n\t\t\t} else if (v < 0x8000) {\n\t\t\t\ts.dataView.setUint16(s.scan, v);\n\t\t\t\ts.scan += 2;\n\t\t\t} else {\n\t\t\t\t//unsigned right shift to cast to uint32 again\n\t\t\t\ts.dataView.setUint32(s.scan, (v | 0x80000000) >>> 0);\n\t\t\t\ts.scan += 4;\n\t\t\t}\n\t\t},\n\t\tmin: -1, max: 2 ** 31 - 1\n\t},\n\tvarint: {\n\t\tread(s) {\n\t\t\tlet firstWord = s.dataView.getUint16(s.scan);\n\t\t\ts.scan += 2;\n\t\t\tif ((firstWord & 0x8000) == 0) {\n\t\t\t\t//sign extend from 7nth bit (>> fills using 32th bit)\n\t\t\t\treturn (firstWord << (32 - 15)) >> (32 - 15);\n\t\t\t}\n\t\t\tlet secondWord = s.dataView.getUint16(s.scan);\n\t\t\ts.scan += 2;\n\t\t\treturn ((((firstWord & 0x7fff) << 16) | secondWord) << (32 - 31)) >> (32 - 31);\n\t\t},\n\t\twrite(s, v) {\n\t\t\tif (v < 0x4000 && v >= -0x4000) {\n\t\t\t\t//reset bits 31-15\n\t\t\t\ts.dataView.setUint16(s.scan, v & 0x7fff);\n\t\t\t\ts.scan += 2;\n\t\t\t} else {\n\t\t\t\ts.dataView.setInt32(s.scan, v | 0x800000);\n\t\t\t\ts.scan += 4;\n\t\t\t}\n\t\t},\n\t\tmin: -(2 ** 30), max: 2 ** 30 - 1\n\t}\n}\n\nObject.assign(parserPrimitives, {\n\t...Object.fromEntries(Object.entries(numberTypes).map<[string, ChunkParser]>(([k, e]) => [k, {\n\t\tread: e.read,\n\t\twrite: (s, v) => {\n\t\t\tif (typeof v != \"number\" || v > e.max || v < e.min) { throw new Error(); }\n\t\t\te.write(s, v);\n\t\t},\n\t\tgetJsonSchema() {\n\t\t\treturn { type: \"number\", maximum: e.max, minimum: e.min };\n\t\t},\n\t\tgetTypescriptType(indent) {\n\t\t\treturn \"number\";\n\t\t}\n\t}])),\n\tbool: {\n\t\tread(s) {\n\t\t\tlet r = s.dataView.getUint8(s.scan++);\n\t\t\tif (r != 0 && r != 1) { throw new Error(\"1 or 0 expected boolean value\"); }\n\t\t\treturn r != 0;\n\t\t},\n\t\twrite(s, v) {\n\t\t\tif (typeof v != \"boolean\") { throw new Error(\"boolean expected\"); }\n\t\t\ts.dataView.setUint8(s.scan++, +v);\n\t\t},\n\t\tgetJsonSchema() {\n\t\t\treturn { type: \"boolean\" };\n\t\t},\n\t\tgetTypescriptType(indent) {\n\t\t\treturn \"boolean\";\n\t\t}\n\t},\n\tstring: stringParser([]),\n\tpaddedstring: stringParser([0]),\n});\n\nObject.assign(parserFunctions, {\n\tref: referenceValueParser,\n\taccum: intAccumolatorParser,\n\topt: optParser,\n\tchunkedarray: chunkedArrayParser,\n\tbytesleft: bytesRemainingParser,\n\tbuffer: bufferParser,\n\tnullarray: arrayNullTerminatedParser,\n\tarray: arrayParser,\n\tstruct: structParser,\n\ttuple: tuppleParser,\n\n\t...hardcodes,\n\t...parserPrimitives\n});", "import * as opcode_reader from \"./opcode_reader\";\nimport type { CacheFileSource } from \"cache\";\n\n// Removed comment-json import as it's no longer needed for direct parsing here.\n// import commentJson from \"comment-json\";\n\n// Updated imports to point to generated .js files instead of raw .json/.jsonc files.\n// The path from src/rsmv/opdecoder.ts to rsmv/generated is '../../rsmv/generated/'\n// typedef.jsonc -> typedef.js\n\n\n// cacheIndex.json -> cacheindex.js\nimport cacheIndex from \"./../../rsmv/generated/cacheindex.js\";\n\n// npcs.jsonc -> npcs.js\nimport npcs from \"./../../rsmv/generated/npcs.js\";\n// items.jsonc -> items.js\nimport items from \"./../../rsmv/generated/items.js\";\n// objects.jsonc -> objects.js\nimport objects from \"./../../rsmv/generated/objects.js\";\n\n// mapsquare_tiles.jsonc -> mapsquare_tiles.js\nimport mapsquareTiles from \"./../../rsmv/generated/mapsquare_tiles.js\";\n// mapsquare_tiles_nxt.jsonc -> mapsquare_tiles_nxt.js\nimport mapsquareTilesNxt from \"./../../rsmv/generated/mapsquare_tiles_nxt.js\";\n// mapsquare_watertiles.json -> mapsquare_watertiles.js\nimport mapsquareWaterTiles from \"./../../rsmv/generated/mapsquare_watertiles.js\";\n// mapsquare_underlays.jsonc -> mapsquare_underlays.js\nimport mapsquareUnderlays from \"./../../rsmv/generated/mapsquare_underlays.js\";\n// mapsquare_overlays.jsonc -> mapsquare_overlays.js\nimport mapsquareOverlays from \"./../../rsmv/generated/mapsquare_overlays.js\";\n// mapsquare_locations.json -> mapsquare_locations.js\nimport mapsquareLocations from \"./../../rsmv/generated/mapsquare_locations.js\";\n// mapsquare_envs.jsonc -> mapsquare_envs.js\nimport mapsquareEnvironment from \"./../../rsmv/generated/mapsquare_envs.js\";\n// mapzones.json -> mapzones.js\nimport mapZones from \"./../../rsmv/generated/mapzones.js\";\n// enums.json -> enums.js\nimport enums from \"./../../rsmv/generated/enums.js\";\n// mapscenes.json -> mapscenes.js\nimport mapscenes from \"./../../rsmv/generated/mapscenes.js\";\n// sequences.json -> sequences.js\nimport sequences from \"./../../rsmv/generated/sequences.js\";\n// framemaps.jsonc -> framemaps.js\nimport framemaps from \"./../../rsmv/generated/framemaps.js\";\n// frames.json -> frames.js\nimport frames from \"./../../rsmv/generated/frames.js\";\n// animgroupconfigs.jsonc -> animgroupconfigs.js\nimport animgroupConfigs from \"./../../rsmv/generated/animgroupconfigs.js\";\n// models.jsonc -> models.js\n\n// oldmodels.jsonc -> oldmodels.js\nimport oldmodels from \"./../../rsmv/generated/oldmodels.js\";\n// classicmodels.jsonc -> classicmodels.js\n// Updated import path to point to generated file\nimport classicmodels from \"./../../rsmv/generated/classicmodels.js\";\n// spotanims.json -> spotanims.js\n// Updated import path to point to generated file\nimport spotAnims from \"./../../rsmv/generated/spotanims.js\";\n// rootcacheindex.jsonc -> rootcacheindex.js\n// Updated import path to point to generated file\nimport rootCacheIndex from \"./../../rsmv/generated/rootcacheindex.js\";\n// skeletalanim.jsonc -> skeletalanim.js\n// Updated import path to point to generated file\nimport skeletalAnim from \"./../../rsmv/generated/skeletalanim.js\";\n// materials.jsonc -> materials.js\nimport materials from \"./../../rsmv/generated/materials.js\";\n// oldmaterials.jsonc -> oldmaterials.js\nimport oldmaterials from \"./../../rsmv/generated/oldmaterials.js\";\n// oldproctexture.jsonc -> oldproctexture.js\nimport oldproctexture from \"./../../rsmv/generated/oldproctexture.js\";\n// quickchatcategories.jsonc -> quickchatcategories.js\nimport quickchatCategories from \"./../../rsmv/generated/quickchatcategories.js\";\n// quickchatlines.jsonc -> quickchatlines.js\nimport quickchatLines from \"./../../rsmv/generated/quickchatlines.js\";\n// environments.jsonc -> environments.js\nimport environments from \"./../../rsmv/generated/environments.js\";\n// avatars.jsonc -> avatars.js\nimport avatars from \"./../../rsmv/generated/avatars.js\";\n// avataroverrides.jsonc -> avataroverrides.js\nimport avatarOverrides from \"./../../rsmv/generated/avataroverrides.js\";\n// These were previously failing with require, now updated to ESM imports\nimport identitykit from \"./../../rsmv/generated/identitykit.js\";\nimport structs from \"./../../rsmv/generated/structs.js\";\nimport params from \"./../../rsmv/generated/params.js\";\nimport particles_0 from \"./../../rsmv/generated/particles_0.js\";\nimport particles_1 from \"./../../rsmv/generated/particles_1.js\";\nimport audio from \"./../../rsmv/generated/audio.js\";\nimport proctexture from \"./../../rsmv/generated/proctexture.js\";\nimport oldproctexture from \"./../../rsmv/generated/oldproctexture.js\";\nimport maplabels from \"./../../rsmv/generated/maplabels.js\";\nimport cutscenes from \"./../../rsmv/generated/cutscenes.js\";\n\n// clientscript.jsonc -> clientscript.js\nimport clientScript from \"./../../rsmv/generated/clientscript.js\";\n// clientscriptdata.jsonc -> clientscriptdata.js\nimport clientScriptData from \"./../../rsmv/generated/clientscriptdata.js\";\n// dbtables.jsonc -> dbtables.js\nimport dbTables from \"./../../rsmv/generated/dbtables.js\";\n// dbrows.jsonc -> dbrows.js\nimport dbRows from \"./../../rsmv/generated/dbrows.js\";\n// interfaces.jsonc -> interfaces.js\nimport interfaces from \"./../../rsmv/generated/interfaces.js\";\n\n\n//alloc a large static buffer to write data to without knowing the data size\n//then copy what we need out of it\n//the buffer is reused so it saves a ton of buffer allocs\nconst scratchbuf = new Uint8Array(2 * 1024 * 1024);\nconst scratchdataview = new DataView(scratchbuf.buffer);\n\n\nlet bytesleftoverwarncount = 0;\n\nexport class FileParser<T> {\n\tprivate parserPromise: Promise<opcode_reader.ChunkParser>;\n\ttotaltime = 0;\n\n    private constructor(parserPromise: Promise<opcode_reader.ChunkParser>) {\n        this.parserPromise = parserPromise;\n    }\n\n    static async init<T>(opcodeobj: unknown, typedef: opcode_reader.TypeDef): Promise<FileParser<T>> {\n        const parser = await opcode_reader.buildParser(null, opcodeobj, typedef);\n        return new FileParser<T>(Promise.resolve(parser));\n    }\n\n\tstatic fromJson<T>(jsonObject: record): Promise<FileParser<T>> {\n\t\tlet opcodeobj = jsonObject as any;\n\t\treturn FileParser.init<T>(opcodeobj);\n\t}\n\n    async getParser(): Promise<opcode_reader.ChunkParser> {\n        return this.parserPromise;\n    }\n\n\tasync readInternal(state: opcode_reader.DecodeState) {\n\t\tlet t = performance.now();\n\t\tconst parser = await this.getParser();\n\t\tlet res = parser.read(state);\n\t\tthis.totaltime += performance.now() - t;\n\t\tif (state.scan != state.endoffset) {\n\t\t\tbytesleftoverwarncount++;\n\t\t\tif (bytesleftoverwarncount < 100) {\n\t\t\t\tconsole.log(`bytes left over after decoding file: ${state.endoffset - state.scan}`);\n\t\t\t\t// let name = `cache/bonusbytes-${Date.now()}.bin`;\n\t\t\t\t// require(\"fs\").writeFileSync(name, scanbuf.slice(scanbuf.scan));\n\t\t\t}\n\t\t\tif (bytesleftoverwarncount == 100) {\n\t\t\t\tconsole.log(\"too many bytes left over warning, no more warnings will be logged\");\n\t\t\t}\n\t\t\t// TODO remove this stupid condition, needed this to fail only in some situations\n\t\t\tif (state.buffer.byteLength < 100000) {\n\t\t\t\tthrow new Error(`bytes left over after decoding file: ${state.endoffset - state.scan}`);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tread(buffer: Uint8Array, source: CacheFileSource, args?: Record<string, any>) {\n\t\tlet state: opcode_reader.DecodeState = {\n\t\t\tisWrite: false,\n\t\t\tbuffer,\n\t\t\tdataView: new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength),\n\t\t\tstack: [],\n\t\t\thiddenstack: [],\n\t\t\tscan: 0,\n\t\t\tendoffset: buffer.byteLength,\n\t\t\targs: {\n\t\t\t\t...source.getDecodeArgs(),\n\t\t\t\t...args\n\t\t\t}\n\t\t};\n\t\treturn this.readInternal(state) as T;\n\t}\n\n\tasync write(obj: T, args?: Record<string, any>) {\n\t\tlet state: opcode_reader.EncodeState = {\n\t\t\tisWrite: true,\n\t\t\tstack: [],\n\t\t\thiddenstack: [],\n\t\t\tbuffer: scratchbuf,\n\t\t\tdataView: scratchdataview,\n\t\t\tscan: 0,\n\t\t\tendoffset: scratchbuf.byteLength,\n\t\t\targs: {\n\t\t\t\tclientVersion: 1000,//TODO\n\t\t\t\t...args\n\t\t\t}\n\t\t};\n\t\tconst parser = await this.getParser();\n\t\tparser.write(state, obj);\n\t\tif (state.scan > state.endoffset) { throw new Error(\"tried to write file larger than scratchbuffer size\"); }\n\t\t//append footer data to end of normal data\n\t\tscratchbuf.copyWithin(state.scan, state.endoffset, scratchbuf.byteLength);\n\t\tstate.scan += scratchbuf.byteLength - state.endoffset;\n\t\t//do the weird prototype slice since we need a copy, not a ref\n\t\tlet r: Uint8Array = scratchbuf.slice(0, state.scan);\n\t\t//clear it for next use\n\t\tscratchbuf.fill(0, 0, state.scan);\n\t\treturn r;\n\t}\n}\n\nglobalThis.parserTimings = () => {\n\tlet all = Object.entries(parse).map(q => ({ name: q[0], t: q[1].totaltime }));\n\tall.sort((a, b) => b.t - a.t);\n\tall.slice(0, 10).filter(q => q.t > 0.01).forEach(q => console.log(`${q.name} ${q.t.toFixed(3)}s`));\n}\n\n// Helper type alias for object literals used in 'fromJson'\ntype record = Record<string, any>;\n\nimport { Env } from '../index'; // Import Env interface\n\nlet parsePromise: Promise<ReturnType<typeof allParsers>> | null = null;\n\n\n\nexport function getParsers(env: Env): Promise<ReturnType<typeof allParsers>> {\n\n    if (parsePromise === null) {\n\n        parsePromise = (async () => {\n            // In development, fetch from local server as static assets\n            const typedefResponse = await fetch('/typedef.json');\n            const typedefContent = await typedefResponse.json();\n\n            const modelsResponse = await fetch('/models.json');\n            const modelsContent = await modelsResponse.json();\n\n            const modelsFileParser = await FileParser.init<import(\"../generated/models\").models>(modelsContent, typedefContent);\n\n            return { models: modelsFileParser };\n        })();\n\n    }\n\n    return parsePromise;\n\n}\n\n\n\n// The allParsers function is no longer needed in its original form\n\n// as its logic is now embedded within the getParsers function.\n\n// It can be removed or refactored if still needed for other purposes.\n\nfunction allParsers(): any {\n\n    return {}; // Placeholder, will be removed or refactored if needed elsewhere\n\n}", "// src/index.ts\nimport { KV_ASSETS, KV_CACHE, AI_BINDING, API, KV_KEYS } from './constants';\nimport { getParsers } from './rsmv/opdecoder';\n\nexport interface Env {\n  ASSETS: KVNamespace; // Use KVNamespace for ASSETS\n  CACHE_KV: KVNamespace;\n  AI: any; // Placeholder for AI binding\n}\n\nexport default {\n  async fetch(request: Request, env: Env): Promise<Response> {\n    const url = new URL(request.url);\n\n    // Serve index.html for the root path\n    if (url.pathname === '/') {\n      const indexHtml = await env.ASSETS.get('index.html', 'text');\n      if (indexHtml) {\n        return new Response(indexHtml, { headers: { 'Content-Type': 'text/html' } });\n      } else {\n        return new Response('Index HTML not found', { status: 404 });\n      }\n    }\n\n    // Handle API routes\n    if (url.pathname.startsWith('/api/')) {\n      const parsers = await getParsers(env);\n      if (url.pathname === API.GET_TYPEDEF) {\n        const typedefJSON = await env.CACHE_KV.get(KV_KEYS.TYPEDEF);\n        return new Response(typedefJSON || '{}', { headers: { 'Content-Type': 'application/json' } });\n      }\n      if (url.pathname === API.GET_MODELS) {\n        const modelsJSON = await env.CACHE_KV.get(KV_KEYS.MODELS);\n        return new Response(modelsJSON || '[]', { headers: { 'Content-Type': 'application/json' } });\n      }\n      if (url.pathname.startsWith('/api/model/')) {\n        const id = url.pathname.split('/').pop();\n        if (!id) return new Response('Model ID required', { status: 400 });\n        const ob3Binary = await env.CACHE_KV.get(KV_KEYS.MODEL_OB3(id), 'arrayBuffer');\n        if (!ob3Binary) return new Response('Model not found', { status: 404 });\n\n        // Parse the binary data using rsmvParse.models\n        const parsedModel = await parsers.models.read(new Uint8Array(ob3Binary));\n        return new Response(JSON.stringify(parsedModel), { headers: { 'Content-Type': 'application/json' } });\n      }\n    }\n\n    // AI Suggestion endpoints\n    if (url.pathname === API.AI_SUGGEST_MATERIALS) {\n      const body = await request.json();\n      // Placeholder: Call AI Binding to get suggestions\n      // In a real scenario, you'd pass more context about the model\n      const suggestion = await env.AI.suggestMaterials(body.modelId, body.currentMaterials);\n      return new Response(JSON.stringify(suggestion), { headers: { 'Content-Type': 'application/json' } });\n    }\n\n    if (url.pathname === API.AI_SUGGEST_ANIMATION) {\n      const body = await request.json();\n      // Placeholder: Call AI Binding to get suggestions\n      const suggestion = await env.AI.suggestAnimation(body.modelId, body.currentAnimation);\n      return new Response(JSON.stringify(suggestion), { headers: { 'Content-Type': 'application/json' } });\n    }\n\n    // Serve static assets from KV\n    // This should be the last resort if no other route matches\n    const asset = await env.ASSETS.get(url.pathname.substring(1), 'arrayBuffer');\n    if (asset) {\n      const mimeType = getMimeType(url.pathname);\n      return new Response(asset, { headers: { 'Content-Type': mimeType } });\n    }\n\n    return new Response('Not Found', { status: 404 }); // Fallback if no other route matches\n  }\n};\n\n// Helper function to determine MIME type based on file extension\nfunction getMimeType(pathname: string): string {\n  const ext = pathname.split('.').pop();\n  switch (ext) {\n    case 'html': return 'text/html';\n    case 'css': return 'text/css';\n    case 'js': return 'application/javascript';\n    case 'json': return 'application/json';\n    case 'ico': return 'image/x-icon';\n    case 'ob3': return 'application/octet-stream'; // For .ob3 model files\n    // Add more MIME types as needed\n    default: return 'application/octet-stream';\n  }\n}", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"C:\\\\Windows\\\\System32\\\\Pick-Of-Gods\\\\4.5claudecode\\\\hello-ai\\\\src\\\\index.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"C:\\\\Windows\\\\System32\\\\Pick-Of-Gods\\\\4.5claudecode\\\\hello-ai\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"C:\\\\Windows\\\\System32\\\\Pick-Of-Gods\\\\4.5claudecode\\\\hello-ai\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"C:\\\\Windows\\\\System32\\\\Pick-Of-Gods\\\\4.5claudecode\\\\hello-ai\\\\src\\\\index.ts\";\n\t\t\t\tconst MIDDLEWARE_TEST_INJECT = \"__INJECT_FOR_TESTING_WRANGLER_MIDDLEWARE__\";\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"C:\\\\Windows\\\\System32\\\\Pick-Of-Gods\\\\4.5claudecode\\\\hello-ai\\\\.wrangler\\\\tmp\\\\bundle-VET5iV\\\\middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"C:\\\\Windows\\\\System32\\\\Pick-Of-Gods\\\\4.5claudecode\\\\hello-ai\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\common.ts\";\nimport type { WorkerEntrypointConstructor } from \"C:\\\\Windows\\\\System32\\\\Pick-Of-Gods\\\\4.5claudecode\\\\hello-ai\\\\.wrangler\\\\tmp\\\\bundle-VET5iV\\\\middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"C:\\\\Windows\\\\System32\\\\Pick-Of-Gods\\\\4.5claudecode\\\\hello-ai\\\\.wrangler\\\\tmp\\\\bundle-VET5iV\\\\middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": "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",
  "names": ["r"]
}
