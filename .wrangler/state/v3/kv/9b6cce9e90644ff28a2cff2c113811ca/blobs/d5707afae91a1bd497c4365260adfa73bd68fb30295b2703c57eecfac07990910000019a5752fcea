import * as THREE from './js/three.module.js';
import { OrbitControls } from './js/OrbitControls.js';

// HSL and RGB conversion functions (copied from src/rsmv/utils.ts)
function HSL2RGBfloat(hsl) {
    var h = hsl[0];
    var s = hsl[1];
    var l = hsl[2];
    var r, g, b;

    if (s == 0) {
        r = g = b = l; // achromatic
    }
    else {
        var hue2rgb = function hue2rgb(p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        }

        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }

    return [r, g, b];
}

function HSL2RGB(hsl) {
    let rgb = HSL2RGBfloat(hsl);
    return [Math.round(rgb[0] * 255), Math.round(rgb[1] * 255), Math.round(rgb[2] * 255)];
}

function RGB2HSL(r, g, b) {
    r /= 255, g /= 255, b /= 255;
    var max = Math.max(r, g, b), min = Math.min(r, g, b);
    var h = 0;
    var s = 0;
    let l = (max + min) / 2;

    if (max != min) {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return [h, s, l];
}

function HSL2packHSL(h, s, l) {
    if (h < 0) { h += 1; }
    return (Math.round(h * 63) << 10) | (Math.round(s * 7) << 7) | (Math.round(l * 127));
}

function packedHSL2HSL(hsl) {
    var h = ((hsl >> 10) & 0x3F) / 63.0;
    var s = ((hsl >> 7) & 0x7) / 7.0;
    var l = (hsl & 0x7F) / 127.0;
    if (h > 0.5)
        h = h - 1.0;
    return [h, s, l];
}

// 1. Scene Setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xcccccc);

// Add GridHelper
const gridHelper = new THREE.GridHelper(10, 10);
scene.add(gridHelper);

// Add AxesHelper
const axesHelper = new THREE.AxesHelper(5);
scene.add(axesHelper);

// 2. Camera Setup
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 5;

// 3. Renderer Setup
const viewerContainer = document.getElementById('viewer-container');
const canvas = document.querySelector('#renderer-canvas');
const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });
renderer.setSize(viewerContainer.clientWidth, viewerContainer.clientHeight);

// 4. Camera Controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; // an animation loop is required when damping is enabled
controls.dampingFactor = 0.25;
controls.screenSpacePanning = false;
controls.maxPolarAngle = Math.PI / 2;

let currentModel = null;

// RuneScape model loading
function loadRuneScapeModel(modelData) {
    if (currentModel) {
        scene.remove(currentModel);
        // Dispose of previous model's geometry and material
        currentModel.traverse(object => {
            if (object.isMesh) {
                object.geometry.dispose();
                if (Array.isArray(object.material)) {
                    object.material.forEach(material => material.dispose());
                } else {
                    object.material.dispose();
                }
            }
        });
    }

    const modelGroup = new THREE.Group();

    modelData.meshes.forEach(meshData => {
        const geometry = new THREE.BufferGeometry();

        // Set attributes
        geometry.setAttribute('position', meshData.attributes.pos);
        if (meshData.attributes.color) {
            geometry.setAttribute('color', meshData.attributes.color);
        }
        if (meshData.attributes.normals) {
            geometry.setAttribute('normal', meshData.attributes.normals);
        }
        if (meshData.attributes.texuvs) {
            geometry.setAttribute('uv', meshData.attributes.texuvs);
        }
        // Add other attributes as needed (e.g., skinids, skinweights, boneids, boneweights)

        // Set index
        geometry.setIndex(meshData.indices);

        // Create material
        let material;
        if (meshData.attributes.color) {
            material = new THREE.MeshPhongMaterial({ vertexColors: true });
        } else {
            material = new THREE.MeshPhongMaterial({ color: 0xaaaaaa }); // Default color if no vertex colors
        }

        const mesh = new THREE.Mesh(geometry, material);
        modelGroup.add(mesh);
    });

    currentModel = modelGroup;
    scene.add(currentModel);
    console.log('RuneScape model loaded and added to scene.', currentModel);

    // Center the camera on the new model
    const box = new THREE.Box3().setFromObject(currentModel);
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z);
    const fov = camera.fov * (Math.PI / 180);
    let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
    cameraZ *= 1.5; // Add some padding

    camera.position.set(center.x, center.y, center.z + cameraZ);
    controls.target.set(center.x, center.y, center.z);
    controls.update();
}

// Color changing logic
const colorInput = document.getElementById('model-color');
colorInput.addEventListener('input', (event) => {
    const hexColor = event.target.value;
    const r = parseInt(hexColor.substring(1, 3), 16);
    const g = parseInt(hexColor.substring(3, 5), 16);
    const b = parseInt(hexColor.substring(5, 7), 16);

    if (currentModel) {
        currentModel.traverse(object => {
            if (object.isMesh && object.geometry.attributes.color) {
                const colors = object.geometry.attributes.color.array;
                const [h, s, l] = RGB2HSL(r, g, b);
                const packedHSL = HSL2packHSL(h, s, l);
                const [newR, newG, newB] = HSL2RGB(packedHSL2HSL(packedHSL));

                for (let i = 0; i < colors.length; i += 4) {
                    colors[i] = newR;
                    colors[i + 1] = newG;
                    colors[i + 2] = newB;
                    // Alpha remains unchanged
                }
                object.geometry.attributes.color.needsUpdate = true;
            } else if (object.isMesh && object.material) {
                // If no vertex colors, try to update material color
                if (Array.isArray(object.material)) {
                    object.material.forEach(material => {
                        if (material.color) {
                            material.color.set(hexColor);
                        }
                    });
                } else if (object.material.color) {
                    object.material.color.set(hexColor);
                }
            }
        });
    }
});

// Save functionality
const saveButton = document.getElementById('save-model');
saveButton.addEventListener('click', async () => {
    if (!currentModel) {
        console.warn('No model loaded to save.');
        return;
    }

    // Capture image
    const imageData = renderer.domElement.toDataURL('image/png');

    // Capture metadata
    const modelId = '123'; // Placeholder, ideally from loaded model
    const currentColor = colorInput.value;
    const metadata = {
        modelId: modelId,
        color: currentColor,
        timestamp: new Date().toISOString(),
        // Add other relevant metadata here
    };

    try {
        const response = await fetch('/api/model/save', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ imageData, metadata }),
        });

        if (response.ok) {
            console.log('Model saved successfully!');
            alert('Model saved successfully!');
        } else {
            console.error('Failed to save model:', response.statusText);
            alert('Failed to save model.');
        }
    } catch (error) {
        console.error('Error saving model:', error);
        alert('Error saving model.');
    }
});

fetch('/api/model/123') // Using a placeholder ID for now
    .then(response => response.json())
    .then(modelData => {
        loadRuneScapeModel(modelData);
    })
    .catch(error => console.error('Error fetching model:', error));

// 6. Animation Loop
function animate() {
	requestAnimationFrame(animate);

	controls.update(); // only required if controls.enableDamping is set to true

	renderer.render(scene, camera);
}
animate();

// Handle window resize
window.addEventListener('resize', () => {
    const width = viewerContainer.clientWidth;
    const height = viewerContainer.clientHeight;
	camera.aspect = width / height;
	camera.updateProjectionMatrix();
	renderer.setSize(width, height);
});

// Chat Interface Logic
const chatForm = document.getElementById('chat-form');
const chatInput = document.getElementById('chat-input');
const messagesDiv = document.getElementById('messages');

chatForm.addEventListener('submit', async (event) => {
	event.preventDefault();
	const message = chatInput.value.trim();
	if (message) {
		addMessage(message, 'user');
		chatInput.value = '';
		try {
			const response = await fetch('/api/chat', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify({ message }),
			});
			const data = await response.json();
			addMessage(data.response, 'ai');
		} catch (error) {
			console.error('Error sending message to AI:', error);
			addMessage('Error: Could not connect to AI.', 'ai');
		}
	}
});

function addMessage(text, sender) {
	const messageElement = document.createElement('div');
	messageElement.classList.add('message', sender);
	messageElement.textContent = text;
	messagesDiv.appendChild(messageElement);
	messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

import './animation/animationDemo.js';

document.addEventListener('DOMContentLoaded', () => {
    const app = document.getElementById('app');
    
    // Add version info
    const version = document.createElement('p');
    version.textContent = `Version: ${new Date().toISOString()}`;
    version.style.color = '#666';
    version.style.fontSize = '0.8em';
    app.appendChild(version);

    // Test KV connection
    fetch('/test-kv')
        .then(response => response.json())
        .then(data => {
            const status = document.createElement('pre');
            status.textContent = JSON.stringify(data, null, 2);
            app.appendChild(status);
        })
        .catch(error => console.error('Error:', error));
});
